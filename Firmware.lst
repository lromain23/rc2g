CCS PCM C Compiler, Version 4.140, 64991               09-Jan-22 13:04

               Filename:   C:\Users\luc\Projects\MBPAB IDE\RC2Gb\62_St-Joseph\Firmware.lst

               ROM used:   8090 words (99%)
                           Largest free fragment is 74
               RAM used:   165 (32%) at main() level
                           232 (45%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   714
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   348
002D:  MOVLP  00
002E:  GOTO   36F
002F:  MOVLP  00
0030:  GOTO   2EB
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #device ADC=8; 
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
163E:  MOVLB  02
163F:  MOVF   29,W
1640:  MOVWF  2D
1641:  MOVF   28,W
1642:  MOVWF  2C
1643:  MOVF   2D,W
1644:  MOVWF  7A
1645:  MOVF   2C,W
1646:  MOVWF  04
1647:  MOVF   7A,W
1648:  MOVWF  05
1649:  MOVF   00,F
164A:  BTFSC  03.2
164B:  GOTO   650
164C:  INCF   2C,F
164D:  BTFSC  03.2
164E:  INCF   2D,F
164F:  GOTO   643
....................    while(*s2 != '\0') 
....................    { 
1650:  MOVF   2B,W
1651:  MOVWF  7A
1652:  MOVF   2A,W
1653:  MOVWF  04
1654:  MOVF   7A,W
1655:  MOVWF  05
1656:  MOVF   00,F
1657:  BTFSC  03.2
1658:  GOTO   66C
....................       *s = *s2; 
1659:  MOVF   2A,W
165A:  MOVWF  04
165B:  MOVF   2B,W
165C:  MOVWF  05
165D:  MOVF   00,W
165E:  MOVWF  30
165F:  MOVF   2D,W
1660:  MOVWF  05
1661:  MOVF   2C,W
1662:  MOVWF  04
1663:  MOVF   30,W
1664:  MOVWF  00
....................       ++s; 
1665:  INCF   2C,F
1666:  BTFSC  03.2
1667:  INCF   2D,F
....................       ++s2; 
1668:  INCF   2A,F
1669:  BTFSC  03.2
166A:  INCF   2B,F
....................    } 
166B:  GOTO   650
....................  
....................    *s = '\0'; 
166C:  MOVF   2C,W
166D:  MOVWF  04
166E:  MOVF   2D,W
166F:  MOVWF  05
1670:  CLRF   00
....................    return(s1); 
1671:  MOVF   28,W
1672:  MOVWF  78
1673:  MOVF   29,W
1674:  MOVWF  79
.................... } 
1675:  MOVLB  00
1676:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0EBC:  MOVF   48,W
0EBD:  MOVWF  4C
0EBE:  MOVF   47,W
0EBF:  MOVWF  4B
0EC0:  MOVF   4C,W
0EC1:  MOVWF  7A
0EC2:  MOVF   4B,W
0EC3:  MOVWF  04
0EC4:  MOVF   7A,W
0EC5:  MOVWF  05
0EC6:  MOVF   00,F
0EC7:  BTFSC  03.2
0EC8:  GOTO   6F5
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0EC9:  MOVF   4A,W
0ECA:  MOVWF  4E
0ECB:  MOVF   49,W
0ECC:  MOVWF  4D
0ECD:  MOVF   4E,W
0ECE:  MOVWF  7A
0ECF:  MOVF   4D,W
0ED0:  MOVWF  04
0ED1:  MOVF   7A,W
0ED2:  MOVWF  05
0ED3:  MOVF   00,F
0ED4:  BTFSC  03.2
0ED5:  GOTO   6F1
....................          if (*sc1 == *sc2) 
0ED6:  MOVF   4C,W
0ED7:  MOVWF  7A
0ED8:  MOVF   4B,W
0ED9:  MOVWF  04
0EDA:  MOVF   7A,W
0EDB:  MOVWF  05
0EDC:  MOVF   00,W
0EDD:  MOVWF  4F
0EDE:  MOVF   4E,W
0EDF:  MOVWF  7A
0EE0:  MOVF   4D,W
0EE1:  MOVWF  04
0EE2:  MOVF   7A,W
0EE3:  MOVWF  05
0EE4:  MOVF   00,W
0EE5:  SUBWF  4F,W
0EE6:  BTFSS  03.2
0EE7:  GOTO   6ED
....................             return(sc1); 
0EE8:  MOVF   4B,W
0EE9:  MOVWF  78
0EEA:  MOVF   4C,W
0EEB:  MOVWF  79
0EEC:  GOTO   6F8
0EED:  INCF   4D,F
0EEE:  BTFSC  03.2
0EEF:  INCF   4E,F
0EF0:  GOTO   6CD
0EF1:  INCF   4B,F
0EF2:  BTFSC  03.2
0EF3:  INCF   4C,F
0EF4:  GOTO   6C0
....................    return(0); 
0EF5:  MOVLW  00
0EF6:  MOVWF  78
0EF7:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E55:  MOVF   48,W
0E56:  MOVWF  4C
0E57:  MOVF   47,W
0E58:  MOVWF  4B
0E59:  MOVF   4C,W
0E5A:  MOVWF  7A
0E5B:  MOVF   4B,W
0E5C:  MOVWF  04
0E5D:  MOVF   7A,W
0E5E:  MOVWF  05
0E5F:  MOVF   00,F
0E60:  BTFSC  03.2
0E61:  GOTO   693
....................       for (sc2 = s2; ; sc2++) 
0E62:  MOVF   4A,W
0E63:  MOVWF  4E
0E64:  MOVF   49,W
0E65:  MOVWF  4D
....................     if (*sc2 == '\0') 
0E66:  MOVF   4E,W
0E67:  MOVWF  7A
0E68:  MOVF   4D,W
0E69:  MOVWF  04
0E6A:  MOVF   7A,W
0E6B:  MOVWF  05
0E6C:  MOVF   00,F
0E6D:  BTFSS  03.2
0E6E:  GOTO   679
....................        return(sc1 - s1); 
0E6F:  MOVF   47,W
0E70:  SUBWF  4B,W
0E71:  MOVWF  77
0E72:  MOVF   48,W
0E73:  SUBWFC 4C,W
0E74:  MOVWF  7A
0E75:  MOVF   77,W
0E76:  MOVWF  78
0E77:  GOTO   69B
....................          else if (*sc1 == *sc2) 
0E78:  GOTO   68B
0E79:  MOVF   4C,W
0E7A:  MOVWF  7A
0E7B:  MOVF   4B,W
0E7C:  MOVWF  04
0E7D:  MOVF   7A,W
0E7E:  MOVWF  05
0E7F:  MOVF   00,W
0E80:  MOVWF  4F
0E81:  MOVF   4E,W
0E82:  MOVWF  7A
0E83:  MOVF   4D,W
0E84:  MOVWF  04
0E85:  MOVF   7A,W
0E86:  MOVWF  05
0E87:  MOVF   00,W
0E88:  SUBWF  4F,W
0E89:  BTFSC  03.2
....................             break; 
0E8A:  GOTO   68F
0E8B:  INCF   4D,F
0E8C:  BTFSC  03.2
0E8D:  INCF   4E,F
0E8E:  GOTO   666
0E8F:  INCF   4B,F
0E90:  BTFSC  03.2
0E91:  INCF   4C,F
0E92:  GOTO   659
....................    return(sc1 - s1); 
0E93:  MOVF   47,W
0E94:  SUBWF  4B,W
0E95:  MOVWF  77
0E96:  MOVF   48,W
0E97:  SUBWFC 4C,W
0E98:  MOVWF  7A
0E99:  MOVF   77,W
0E9A:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1F42:  MOVLB  00
1F43:  CLRF   26
1F44:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0E3C:  MOVLB  02
0E3D:  MOVF   3F,W
0E3E:  IORWF  40,W
0E3F:  BTFSC  03.2
0E40:  GOTO   645
0E41:  MOVF   40,W
0E42:  MOVWF  7A
0E43:  MOVF   3F,W
0E44:  GOTO   64A
0E45:  MOVLB  00
0E46:  MOVF   27,W
0E47:  MOVWF  7A
0E48:  MOVF   26,W
0E49:  MOVLB  02
0E4A:  MOVWF  43
0E4B:  MOVF   7A,W
0E4C:  MOVWF  44
....................    beg += strspn(beg, s2); 
0E4D:  MOVF   44,W
0E4E:  MOVWF  48
0E4F:  MOVF   43,W
0E50:  MOVWF  47
0E51:  MOVF   42,W
0E52:  MOVWF  4A
0E53:  MOVF   41,W
0E54:  MOVWF  49
*
0E9B:  MOVF   78,W
0E9C:  ADDWF  43,F
0E9D:  MOVLW  00
0E9E:  ADDWFC 44,F
....................    if (*beg == '\0') 
0E9F:  MOVF   44,W
0EA0:  MOVWF  7A
0EA1:  MOVF   43,W
0EA2:  MOVWF  04
0EA3:  MOVF   7A,W
0EA4:  MOVWF  05
0EA5:  MOVF   00,F
0EA6:  BTFSS  03.2
0EA7:  GOTO   6B4
....................    { 
....................       *save = ' '; 
0EA8:  MOVLB  00
0EA9:  MOVF   26,W
0EAA:  MOVWF  04
0EAB:  MOVF   27,W
0EAC:  MOVWF  05
0EAD:  MOVLW  20
0EAE:  MOVWF  00
....................       return(0); 
0EAF:  MOVLW  00
0EB0:  MOVWF  78
0EB1:  MOVWF  79
0EB2:  GOTO   719
0EB3:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0EB4:  MOVF   44,W
0EB5:  MOVWF  48
0EB6:  MOVF   43,W
0EB7:  MOVWF  47
0EB8:  MOVF   42,W
0EB9:  MOVWF  4A
0EBA:  MOVF   41,W
0EBB:  MOVWF  49
*
0EF8:  MOVF   79,W
0EF9:  MOVWF  46
0EFA:  MOVF   78,W
0EFB:  MOVWF  45
....................    if (*end != '\0') 
0EFC:  MOVF   46,W
0EFD:  MOVWF  7A
0EFE:  MOVF   45,W
0EFF:  MOVWF  04
0F00:  MOVF   7A,W
0F01:  MOVWF  05
0F02:  MOVF   00,F
0F03:  BTFSC  03.2
0F04:  GOTO   70D
....................    { 
....................       *end = '\0'; 
0F05:  MOVF   45,W
0F06:  MOVWF  04
0F07:  MOVF   46,W
0F08:  MOVWF  05
0F09:  CLRF   00
....................       end++; 
0F0A:  INCF   45,F
0F0B:  BTFSC  03.2
0F0C:  INCF   46,F
....................    } 
....................    save = end; 
0F0D:  MOVF   46,W
0F0E:  MOVLB  00
0F0F:  MOVWF  27
0F10:  MOVLB  02
0F11:  MOVF   45,W
0F12:  MOVLB  00
0F13:  MOVWF  26
....................    return(beg); 
0F14:  MOVLB  02
0F15:  MOVF   43,W
0F16:  MOVWF  78
0F17:  MOVF   44,W
0F18:  MOVWF  79
0F19:  MOVLB  00
.................... } 
0F1A:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
.................... #define BUTTON_STATES 
.................... #define POT_MAX 63 
....................  
.................... #define RS 0x01 
.................... #define LCD_READ 0x02   
.................... #define LCD_WRITE 0x00   
.................... #define E 0x04 
.................... #define BT 0x08 
.................... #define CHANGE_LINE 0x80 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
07DA:  MOVLW  20
07DB:  MOVWF  05
07DC:  MOVLW  CA
07DD:  MOVWF  04
07DE:  MOVF   00,W
07DF:  BTFSC  03.2
07E0:  GOTO   7F2
07E1:  MOVLW  02
07E2:  MOVWF  78
07E3:  MOVLW  BF
07E4:  MOVWF  77
07E5:  CLRWDT
07E6:  DECFSZ 77,F
07E7:  GOTO   7E5
07E8:  DECFSZ 78,F
07E9:  GOTO   7E3
07EA:  MOVLW  96
07EB:  MOVWF  77
07EC:  DECFSZ 77,F
07ED:  GOTO   7EC
07EE:  GOTO   7EF
07EF:  CLRWDT
07F0:  DECFSZ 00,F
07F1:  GOTO   7E1
07F2:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
0697:  MOVLB  04
0698:  BCF    15.7
0699:  MOVLB  00
069A:  BCF    11.3
069B:  MOVLB  02
069C:  MOVF   50,W
069D:  MOVLB  04
069E:  MOVWF  11
069F:  MOVLW  02
06A0:  BTFSC  15.7
06A1:  GOTO   6A9
06A2:  MOVLB  00
06A3:  BTFSS  11.3
06A4:  GOTO   6A3
06A5:  MOVLW  00
06A6:  MOVLB  04
06A7:  BTFSC  16.6
06A8:  MOVLW  01
06A9:  MOVWF  78
06AA:  MOVLB  00
06AB:  RETURN
*
0A89:  MOVLB  04
0A8A:  BCF    15.6
0A8B:  BSF    16.3
0A8C:  BTFSC  16.3
0A8D:  GOTO   28C
0A8E:  BTFSC  77.0
0A8F:  BCF    16.5
0A90:  BTFSS  77.0
0A91:  BSF    16.5
0A92:  BSF    16.4
0A93:  BTFSC  16.4
0A94:  GOTO   293
0A95:  MOVF   11,W
0A96:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02E4:  CLRWDT
02E5:  BTFSS  11.4
02E6:  GOTO   2E4
02E7:  MOVLB  03
02E8:  MOVWF  1A
02E9:  MOVLB  00
02EA:  RETURN
.................... //#use fast_io (a) 
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void process_dtmf_interrupt(void); 
.................... void init_lcd(void); 
.................... void send_tail(void); 
.................... void status_led(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
.................... void print_dfmf_info(void); 
.................... void do_delay_counters(void); 
.................... void process_buttons(void); 
.................... int1 my_stricmp(char *, char *); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN; 
.................... unsigned int Enable,Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned int TOT_Min; 
.................... unsigned int Link_TOT,LinkDurationTimer; 
.................... unsigned int COR_EMUL; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... char COR_IN_EFFECTIVE; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... // 
.................... // Button calibration states 
.................... // 
.................... #define BUTTON_IDLE 0 
.................... #define CALIB 16 
.................... #define TRIM 15  
.................... // 
.................... // Command settings 
.................... // 
.................... #define LINK_CMD 1 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define DEBOUNCE_COUNT 8 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... // Arguments 
.................... #define AUXI_EMULATE_COR0 0x01 
.................... #define AUXI_EMULATE_COR1 0x02 
.................... #define AUXI_EMULATE_COR2 0x04 
.................... #define AUXI_EMULATE_COR3 0x08 
.................... #define AUXI_EMULATE_COR4 0x10 // COR from AUX only for DTMF control (No audio feed-thru) 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x20 
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... unsigned int command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... unsigned int  LastRegisterIndex; 
.................... unsigned int  LastRegisterIndexValid; 
....................  
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
....................   int  usage : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1 ENTER_PRESSED; 
.................... int1 SELECT_PRESSED; 
.................... int  adj_value_a,adj_value_b; 
.................... char button_state; 
.................... int1       COR_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... int1       STATUS_LED; 
.................... unsigned long TOT_SecondCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1       DTMF_INTERRUPT_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... // PROTECTED -- Must be in admin mode to set value 
.................... // PUBLIC    -- Register can be set in any mode 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
.................... #define PROTECTED 1 
.................... #define PUBLIC    0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 AuxIn[0] 
.................... 	{"XI2"},	  // 19 AuxIn[1] 
.................... 	{"XI3"},	  // 20 AuxIn[2] 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"LTO"},  // 54 
....................     {"COR"},  // 55 
....................     {"CPOT"}  // 56 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
.................... #define SITE_ID_VAL  	62 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... #define ENABLE_DEFAULT 15 
.................... #define TOT_MIN 5 
.................... #define LINK_TOT 0 
.................... #define DEFAULT_GAIN 32 
.................... //#define LCD_TYPE_PI 1 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('e') 
.................... #define MORSEID5	MCHAR('h') 
....................  
.................... #define AUXOUTOP0 0 
.................... #define AUXOUTARG0 0 
.................... #define AUXOUTOP1 0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2 0 
.................... #define AUXOUTARG2 0 
....................  
.................... //#define AUXINOP0 AUXI_ENABLE 
.................... //#define AUXINARG0 AUXI_ENABLE2|AUXI_ENABLE3|AUXI_ENABLE4 
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  AUXI_EMULATE_COR 
.................... #define AUXINARG0 AUXI_EMULATE_COR_ACTIVE_LO|AUXI_EMULATE_COR4 
.................... #define AUXINOP1 AUXI_TAIL_WHEN_HI 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
.................... #define RX1_PTT 0x0F 
.................... #define RX2_PTT 0x0F 
.................... #define RX3_PTT 0x0F 
.................... #define RX4_PTT 0x0F 
....................  
.................... // Define default variables {{{ 
.................... #ifdef LCD_TYPE_PI 
....................   #define LCD_I2C_ADD 0x27 
.................... #else 
....................   #define LCD_I2C_ADD 0x60 
.................... #endif 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... #ifndef RX1_PTT 
....................   #define RX1_PTT 0x0E 
.................... #endif 
.................... #ifndef RX2_PTT 
....................   #define RX2_PTT 0x0D 
.................... #endif 
.................... #ifndef RX3_PTT 
....................   #define RX3_PTT 0x0B  
.................... #endif 
.................... #ifndef RX4_PTT 
....................   #define RX4_PTT 0x07 
.................... #endif 
.................... #ifndef DEFAULT_GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... // }}} 
....................  
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  , EEPROM,PUBLIC}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL, EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&AuxIn[0]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[1]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[2]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[0]     ,PO_AUX_OUT0     , EEPROM,PROTECTED}, 
.................... 	{&AuxOut[1]     ,PO_AUX_OUT1     , EEPROM,PROTECTED}, 
.................... 	{&AuxOut[2]     ,PO_AUX_OUT2     , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[0] ,4               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[1] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[2] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[3] ,2               , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[0]     ,RX1_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[1]     ,RX2_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[2]     ,RX3_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[3]     ,RX4_PTT         , EEPROM,PROTECTED}, 
.................... 	{&SiteID        ,SITE_ID_VAL     , EEPROM,PROTECTED}, 
.................... 	{&TXSiteID      ,0x12            , EEPROM,PROTECTED}, 
....................   {&Morse[0]      ,MORSEID0        , EEPROM,PROTECTED}, 
....................   {&Morse[1]      ,MORSEID1        , EEPROM,PROTECTED}, 
....................   {&Morse[2]      ,MORSEID2        , EEPROM,PROTECTED}, 
....................   {&Morse[3]      ,MORSEID3        , EEPROM,PROTECTED}, 
....................   {&Morse[4]      ,MORSEID4        , EEPROM,PROTECTED}, 
....................   {&Morse[5]      ,MORSEID5        , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2      , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2        , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2       , EEPROM,PROTECTED}, 
....................   {&Tail          ,TAIL_CHAR       , EEPROM,PROTECTED}, 
....................   {&TOT_Min       ,TOT_MIN         , EEPROM,PROTECTED}, 
....................   {&Link_TOT      ,LINK_TOT        , EEPROM,PROTECTED}, 
.................... 	{&COR_EMUL      ,0x00            , RAM   ,PUBLIC}, 
.................... 	{&CurrentTrimPot,0x00            , RAM   ,PROTECTED}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02EB:  BTFSS  11.5
02EC:  GOTO   342
....................     c = getc(); 
02ED:  CLRWDT
02EE:  BTFSS  11.5
02EF:  GOTO   2ED
02F0:  MOVLB  03
02F1:  MOVF   19,W
02F2:  MOVLB  02
02F3:  MOVWF  55
....................     if ( c == '\b' ) { 
02F4:  MOVF   55,W
02F5:  SUBLW  08
02F6:  BTFSS  03.2
02F7:  GOTO   320
....................       if ( sBufferIndex > 0 ) { 
02F8:  MOVF   71,F
02F9:  BTFSC  03.2
02FA:  GOTO   31A
....................         sBufferIndex--; 
02FB:  DECF   71,F
....................         sBuffer[sBufferIndex]='\0'; 
02FC:  MOVLW  50
02FD:  ADDWF  71,W
02FE:  MOVWF  04
02FF:  MOVLW  20
0300:  MOVWF  05
0301:  BTFSC  03.0
0302:  INCF   05,F
0303:  CLRF   00
....................         putc('\b'); 
0304:  MOVLW  08
0305:  MOVLB  00
0306:  CALL   2E4
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
0307:  MOVLW  1B
0308:  CALL   2E4
....................   printf("[K"); 
0309:  MOVLW  5B
030A:  CLRWDT
030B:  BTFSS  11.4
030C:  GOTO   30A
030D:  MOVLB  03
030E:  MOVWF  1A
030F:  MOVLW  4B
0310:  CLRWDT
0311:  MOVLB  00
0312:  BTFSC  11.4
0313:  GOTO   316
0314:  MOVLB  03
0315:  GOTO   310
0316:  MOVLB  03
0317:  MOVWF  1A
....................       } else { 
0318:  GOTO   31E
0319:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
031A:  MOVLW  07
031B:  MOVLB  00
031C:  CALL   2E4
031D:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
031E:  GOTO   344
031F:  MOVLB  02
0320:  MOVF   71,W
0321:  SUBLW  0F
0322:  BTFSS  03.0
0323:  GOTO   33F
....................       putc(c); // echo the character 
0324:  MOVF   55,W
0325:  MOVLB  00
0326:  CALL   2E4
....................       sBuffer[sBufferIndex++] = c; 
0327:  MOVF   71,W
0328:  INCF   71,F
0329:  ADDLW  50
032A:  MOVWF  04
032B:  MOVLW  20
032C:  MOVWF  05
032D:  BTFSC  03.0
032E:  INCF   05,F
032F:  MOVLB  02
0330:  MOVF   55,W
0331:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0332:  MOVF   55,W
0333:  SUBLW  0D
0334:  BTFSC  03.2
0335:  GOTO   33D
0336:  MOVF   55,W
0337:  SUBLW  2B
0338:  BTFSC  03.2
0339:  GOTO   33D
033A:  MOVF   55,W
033B:  SUBLW  2D
033C:  BTFSC  03.2
....................         sBufferFlag=1; 
033D:  BSF    72.0
....................       } 
....................     } else { 
033E:  GOTO   343
....................       putc('\a'); // Send alert. Avoid buffer overflow 
033F:  MOVLW  07
0340:  MOVLB  00
0341:  CALL   2E4
0342:  MOVLB  02
0343:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
0344:  MOVLB  00
0345:  BCF    11.5
0346:  MOVLP  00
0347:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   int LAST_COR_IN; 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if(IOCBF&0x0F) { // Check for interrupts on RB[3:0] only 
0348:  MOVLB  07
0349:  MOVF   16,W
034A:  ANDLW  0F
034B:  BTFSC  03.2
034C:  GOTO   35E
....................     LAST_COR_IN=COR_IN; 
034D:  MOVLB  00
034E:  MOVF   5F,W
034F:  MOVLB  02
0350:  MOVWF  55
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
0351:  MOVLB  00
0352:  MOVF   0D,W
0353:  XORWF  62,W
0354:  ANDLW  0F
0355:  MOVWF  5F
....................     if ( LAST_COR_IN != COR_IN ) { 
0356:  MOVF   5F,W
0357:  MOVLB  02
0358:  SUBWF  55,W
0359:  BTFSS  03.2
....................       COR_FLAG = 1; 
035A:  BSF    72.3
....................     } 
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
035B:  MOVLW  F0
035C:  MOVLB  07
035D:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
035E:  BTFSS  0B.0
035F:  GOTO   364
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     DTMF_INTERRUPT_FLAG = 1; 
0360:  MOVLB  01
0361:  BSF    5D.4
....................     clear_interrupt(INT_RB4_H2L); 
0362:  MOVLB  07
0363:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
0364:  BTFSS  0B.0
0365:  GOTO   36B
....................     AUX_IN_FLAG=1; 
0366:  MOVLB  01
0367:  BSF    5D.0
....................     clear_interrupt(INT_RB6|INT_RB7); 
0368:  MOVLW  3F
0369:  MOVLB  07
036A:  ANDWF  16,F
....................   } 
.................... } // }}} 
036B:  BCF    0B.0
036C:  MOVLP  00
036D:  MOVLB  00
036E:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
036F:  MOVLB  01
0370:  MOVF   30,W
0371:  IORWF  31,W
0372:  BTFSC  03.2
0373:  GOTO   379
....................     rtcc_cnt--; 
0374:  MOVF   30,W
0375:  BTFSC  03.2
0376:  DECF   31,F
0377:  DECF   30,F
....................   } else { 
0378:  GOTO   385
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
0379:  MOVLB  00
037A:  MOVF   0D,W
037B:  XORWF  62,W
037C:  ANDLW  0F
037D:  MOVWF  5F
....................     COR_FLAG=1; 
037E:  BSF    72.3
....................     SECOND_FLAG=1; 
037F:  BSF    72.4
....................     AUX_IN_FLAG=1; 
0380:  MOVLB  01
0381:  BSF    5D.0
....................     rtcc_cnt=30; 
0382:  CLRF   31
0383:  MOVLW  1E
0384:  MOVWF  30
....................   } 
....................   if (aux_timer ) { 
0385:  MOVF   32,W
0386:  IORWF  33,W
0387:  BTFSC  03.2
0388:  GOTO   38D
....................     aux_timer--; 
0389:  MOVF   32,W
038A:  BTFSC  03.2
038B:  DECF   33,F
038C:  DECF   32,F
....................   } 
.................... } // }}} 
038D:  BCF    0B.2
038E:  MOVLP  00
038F:  MOVLB  00
0390:  GOTO   020
.................... int1 warn_no_lcd = 1; 
....................  
.................... void lcd_strobe(char data) { // {{{ 
....................   i2c_write(data | E); 
....................   i2c_write(data & ~E); 
.................... } // }}} 
....................  
.................... void lcd_write(char rs, char data) { // {{{ 
....................   char lcd_word_a,lcd_word_b; 
....................   lcd_word_a = LCD_WRITE | BT | (data&0xF0); 
....................   lcd_word_b = LCD_WRITE | BT | ((data<<4)&0xF0); 
....................   if ( rs ) { 
....................     lcd_word_a |= RS; 
....................     lcd_word_b |= RS; 
....................   }  
....................   lcd_strobe(lcd_word_a); 
....................   lcd_strobe(lcd_word_b); 
.................... } // }}} 
....................  
.................... void lcd_send(char line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   i2c_start(); 
*
0973:  MOVLB  04
0974:  BSF    16.0
0975:  BTFSC  16.0
0976:  GOTO   175
....................   #ifdef LCD_TYPE_PI 
....................   ack=i2c_write(LCD_I2C_ADD << 1); 
.................... //  ack=i2c_write(line&0x03); 
.................... // Change line 
....................   switch(line&0x03) { 
....................     case 0x00: lcd_write(0,CHANGE_LINE);break; 
....................     case 0x01: lcd_write(0,CHANGE_LINE+0x40);break; 
....................     case 0x02: lcd_write(0,CHANGE_LINE+0x14);break; 
....................     case 0x03: lcd_write(0,CHANGE_LINE+0x54);break; 
....................   } 
....................   restart_wdt(); 
....................   #else 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
0977:  BCF    03.0
0978:  MOVLB  02
0979:  RLF    4A,W
097A:  ANDLW  0E
097B:  IORLW  60
097C:  MOVWF  4D
....................   ack=i2c_write(lcd_cmd); 
097D:  MOVF   4D,W
097E:  MOVWF  50
097F:  MOVLP  00
0980:  MOVLB  00
0981:  CALL   697
0982:  MOVLP  08
0983:  MOVF   78,W
0984:  MOVLB  02
0985:  BCF    4E.0
0986:  BTFSC  78.0
0987:  BSF    4E.0
....................   #endif 
....................   if ( ack!=0 ) { 
0988:  BTFSS  4E.0
0989:  GOTO   1AC
....................     if ( warn_no_lcd ) { 
098A:  MOVLB  01
098B:  BTFSS  62.1
098C:  GOTO   1AA
....................       printf("\n\rI2C : No ACK from LCD : %u",ack); 
098D:  MOVLW  00
098E:  MOVLB  02
098F:  BTFSC  4E.0
0990:  MOVLW  01
0991:  MOVWF  4F
0992:  MOVLW  91
0993:  MOVLB  03
0994:  MOVWF  11
0995:  MOVLW  03
0996:  MOVWF  12
0997:  BCF    03.0
0998:  MOVLW  1A
0999:  MOVLB  02
099A:  MOVWF  50
099B:  MOVLP  00
099C:  MOVLB  00
099D:  CALL   6AC
099E:  MOVLP  08
099F:  MOVLB  02
09A0:  MOVF   4F,W
09A1:  MOVWF  50
09A2:  MOVLW  1B
09A3:  MOVWF  51
09A4:  MOVLP  00
09A5:  MOVLB  00
09A6:  CALL   720
09A7:  MOVLP  08
....................       warn_no_lcd = 0; 
09A8:  MOVLB  01
09A9:  BCF    62.1
....................     } 
....................   } else { 
09AA:  GOTO   1AE
09AB:  MOVLB  02
....................     warn_no_lcd = 1; 
09AC:  MOVLB  01
09AD:  BSF    62.1
....................   } 
....................   while(*s) { 
09AE:  MOVLB  02
09AF:  MOVF   4C,W
09B0:  MOVWF  7A
09B1:  MOVF   4B,W
09B2:  MOVWF  04
09B3:  MOVF   7A,W
09B4:  MOVWF  05
09B5:  MOVF   00,F
09B6:  BTFSC  03.2
09B7:  GOTO   1CB
.................... #ifdef LCD_TYPE_PI 
....................     if ( *s != '\r' && *s != '\n') { 
....................       lcd_write(1,*s); 
....................     } 
....................     s++; 
.................... #else 
....................    i2c_write(*s++); 
09B8:  MOVF   4C,W
09B9:  MOVWF  7A
09BA:  MOVF   4B,W
09BB:  INCF   4B,F
09BC:  BTFSC  03.2
09BD:  INCF   4C,F
09BE:  MOVWF  04
09BF:  MOVF   7A,W
09C0:  MOVWF  05
09C1:  MOVF   00,W
09C2:  MOVWF  4F
09C3:  MOVWF  50
09C4:  MOVLP  00
09C5:  MOVLB  00
09C6:  CALL   697
09C7:  MOVLP  08
.................... #endif 
....................   } 
09C8:  MOVLB  01
09C9:  GOTO   1AE
09CA:  MOVLB  02
.................... #ifndef LCD_TYPE_PI 
....................   i2c_write(0); // EOL 
09CB:  CLRF   50
09CC:  MOVLP  00
09CD:  MOVLB  00
09CE:  CALL   697
09CF:  MOVLP  08
.................... #endif 
....................   i2c_stop(); 
09D0:  MOVLB  04
09D1:  BSF    16.2
09D2:  BTFSC  16.2
09D3:  GOTO   1D2
.................... #endif 
.................... } // }}} 
09D4:  MOVLB  00
09D5:  RETURN
.................... #ifdef BUTTON_STATES 
.................... void status_led(void) { // {{{ 
....................   char cnt_val; 
....................   STATUS_LED=0; 
*
0E0D:  MOVLB  01
0E0E:  BCF    5D.1
....................   cnt_val = rtcc_cnt>>3; 
0E0F:  RRF    31,W
0E10:  MOVWF  7A
0E11:  RRF    30,W
0E12:  MOVWF  79
0E13:  RRF    7A,F
0E14:  RRF    79,F
0E15:  RRF    7A,F
0E16:  RRF    79,F
0E17:  MOVF   79,W
0E18:  MOVWF  67
....................   if ( button_state!=0 ) { 
0E19:  MOVF   5C,F
0E1A:  BTFSC  03.2
0E1B:  GOTO   62A
....................     if ( (rtcc_cnt & 0x04) ) { 
0E1C:  MOVF   30,W
0E1D:  ANDLW  04
0E1E:  MOVWF  77
0E1F:  CLRF   7A
0E20:  MOVF   77,W
0E21:  IORWF  7A,W
0E22:  BTFSC  03.2
0E23:  GOTO   62A
....................       STATUS_LED = (cnt_val < (CurrentTrimPot+1));  
0E24:  BCF    5D.1
0E25:  MOVLW  01
0E26:  ADDWF  74,W
0E27:  SUBWF  67,W
0E28:  BTFSS  03.0
0E29:  BSF    5D.1
....................     } 
....................   }  
....................   output_bit(STATUS_LED_PIN,STATUS_LED); 
0E2A:  BTFSC  5D.1
0E2B:  GOTO   630
0E2C:  MOVLB  02
0E2D:  BCF    0C.6
0E2E:  GOTO   632
0E2F:  MOVLB  01
0E30:  MOVLB  02
0E31:  BSF    0C.6
0E32:  MOVLB  01
0E33:  BCF    0C.6
.................... } // }}} 
.................... #endif 
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
10E4:  MOVF   70,F
10E5:  BTFSC  03.2
10E6:  GOTO   148
....................     printf("\n\rProcessing Command:"); 
10E7:  MOVLW  A0
10E8:  MOVLB  03
10E9:  MOVWF  11
10EA:  MOVLW  03
10EB:  MOVWF  12
10EC:  MOVLP  00
10ED:  MOVLB  00
10EE:  CALL   4BB
10EF:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
10F0:  MOVLW  AB
10F1:  MOVLB  03
10F2:  MOVWF  11
10F3:  MOVLW  03
10F4:  MOVWF  12
10F5:  BCF    03.0
10F6:  MOVLW  0E
10F7:  MOVLB  02
10F8:  MOVWF  50
10F9:  MOVLP  00
10FA:  MOVLB  00
10FB:  CALL   6AC
10FC:  MOVLP  10
10FD:  MOVF   63,W
10FE:  MOVLB  02
10FF:  MOVWF  50
1100:  MOVLW  1B
1101:  MOVWF  51
1102:  MOVLP  00
1103:  MOVLB  00
1104:  CALL   720
1105:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
1106:  MOVLW  B4
1107:  MOVLB  03
1108:  MOVWF  11
1109:  MOVLW  03
110A:  MOVWF  12
110B:  BCF    03.0
110C:  MOVLW  0E
110D:  MOVLB  02
110E:  MOVWF  50
110F:  MOVLP  00
1110:  MOVLB  00
1111:  CALL   6AC
1112:  MOVLP  10
1113:  MOVF   70,W
1114:  MOVLB  02
1115:  MOVWF  50
1116:  MOVLW  1B
1117:  MOVWF  51
1118:  MOVLP  00
1119:  MOVLB  00
111A:  CALL   720
111B:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
111C:  MOVLW  BD
111D:  MOVLB  03
111E:  MOVWF  11
111F:  MOVLW  03
1120:  MOVWF  12
1121:  BCF    03.0
1122:  MOVLW  0E
1123:  MOVLB  02
1124:  MOVWF  50
1125:  MOVLP  00
1126:  MOVLB  00
1127:  CALL   6AC
1128:  MOVLP  10
1129:  MOVF   75,W
112A:  MOVLB  02
112B:  MOVWF  50
112C:  MOVLW  1B
112D:  MOVWF  51
112E:  MOVLP  00
112F:  MOVLB  00
1130:  CALL   720
1131:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
1132:  MOVLW  C6
1133:  MOVLB  03
1134:  MOVWF  11
1135:  MOVLW  03
1136:  MOVWF  12
1137:  BCF    03.0
1138:  MOVLW  0E
1139:  MOVLB  02
113A:  MOVWF  50
113B:  MOVLP  00
113C:  MOVLB  00
113D:  CALL   6AC
113E:  MOVLP  10
113F:  MOVF   76,W
1140:  MOVLB  02
1141:  MOVWF  50
1142:  MOVLW  1B
1143:  MOVWF  51
1144:  MOVLP  00
1145:  MOVLB  00
1146:  CALL   720
1147:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
1148:  MOVLW  02
1149:  SUBWF  70,W
114A:  ADDLW  F5
114B:  BTFSC  03.0
114C:  GOTO   55E
114D:  ADDLW  0B
114E:  GOTO   55F
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
1215:  GOTO   55E
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
1216:  RLF    75,W
1217:  MOVWF  77
1218:  RLF    77,F
1219:  MOVLW  FC
121A:  ANDWF  77,F
121B:  MOVF   77,W
121C:  MOVLB  02
121D:  MOVWF  2C
121E:  INCF   2C,W
121F:  MOVLP  00
1220:  MOVLB  00
1221:  CALL   043
1222:  MOVLP  10
1223:  MOVWF  7A
1224:  MOVLB  02
1225:  MOVF   2C,W
1226:  MOVLP  00
1227:  MOVLB  00
1228:  CALL   043
1229:  MOVLP  10
122A:  MOVLB  02
122B:  MOVWF  20
122C:  MOVF   7A,W
122D:  MOVWF  21
....................       LastRegisterIndex = argument; 
122E:  MOVF   75,W
122F:  MOVWF  7C
....................       LastRegisterIndexValid=1; 
1230:  MOVLW  01
1231:  MOVWF  7D
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
1232:  MOVLW  01
1233:  MOVWF  7A
1234:  MOVLW  8F
1235:  MOVWF  2C
1236:  MOVF   7A,W
1237:  MOVWF  2D
1238:  CLRF   2F
1239:  MOVF   75,W
123A:  MOVWF  2E
123B:  MOVF   2F,W
123C:  MOVWF  3E
123D:  MOVF   2E,W
123E:  MOVWF  3D
123F:  CLRF   40
1240:  MOVLW  06
1241:  MOVWF  3F
1242:  MOVLP  08
1243:  MOVLB  00
1244:  CALL   7A3
1245:  MOVLP  10
1246:  MOVF   78,W
1247:  MOVLB  02
1248:  ADDWF  2C,W
1249:  MOVWF  24
124A:  MOVF   79,W
124B:  ADDWFC 2D,W
124C:  MOVWF  25
....................       romstrcpy(rname,cPtr); 
124D:  MOVLW  20
124E:  MOVWF  3C
124F:  MOVLW  A6
1250:  MOVWF  3B
1251:  MOVF   25,W
1252:  MOVWF  3E
1253:  MOVF   24,W
1254:  MOVWF  3D
1255:  MOVLP  08
1256:  MOVLB  00
1257:  CALL   7BA
1258:  MOVLP  10
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
1259:  MOVLB  02
125A:  MOVF   21,W
125B:  MOVWF  7A
125C:  MOVF   20,W
125D:  MOVWF  04
125E:  MOVF   21,W
125F:  MOVWF  05
1260:  MOVF   00,W
1261:  MOVWF  2C
1262:  MOVLW  20
1263:  MOVLB  01
1264:  MOVWF  64
1265:  MOVLW  76
1266:  MOVWF  63
1267:  MOVLW  5B
1268:  MOVLB  02
1269:  MOVWF  50
126A:  MOVLP  08
126B:  MOVLB  00
126C:  CALL   0FC
126D:  MOVLP  10
126E:  MOVF   75,W
126F:  MOVLB  02
1270:  MOVWF  2D
1271:  MOVLW  01
1272:  MOVWF  2E
1273:  MOVLB  00
1274:  CALL   041
1275:  MOVLW  5D
1276:  MOVLB  02
1277:  MOVWF  50
1278:  MOVLP  08
1279:  MOVLB  00
127A:  CALL   0FC
127B:  MOVLP  10
127C:  MOVLW  20
127D:  MOVLB  02
127E:  MOVWF  50
127F:  MOVLP  08
1280:  MOVLB  00
1281:  CALL   0FC
1282:  MOVLP  10
1283:  MOVLW  20
1284:  MOVWF  05
1285:  MOVLW  A6
1286:  MOVWF  04
1287:  MOVLP  08
1288:  CALL   15E
1289:  MOVLP  10
128A:  MOVLW  20
128B:  MOVLB  02
128C:  MOVWF  50
128D:  MOVLP  08
128E:  MOVLB  00
128F:  CALL   0FC
1290:  MOVLP  10
1291:  MOVLB  02
1292:  MOVF   2C,W
1293:  MOVWF  2D
1294:  MOVLW  1B
1295:  MOVWF  2E
1296:  MOVLB  00
1297:  CALL   041
1298:  MOVLW  0A
1299:  MOVLB  02
129A:  MOVWF  50
129B:  MOVLP  08
129C:  MOVLB  00
129D:  CALL   0FC
129E:  MOVLP  10
129F:  MOVLW  0D
12A0:  MOVLB  02
12A1:  MOVWF  50
12A2:  MOVLP  08
12A3:  MOVLB  00
12A4:  CALL   0FC
12A5:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
12A6:  MOVLW  0A
12A7:  CLRWDT
12A8:  BTFSS  11.4
12A9:  GOTO   2A7
12AA:  MOVLB  03
12AB:  MOVWF  1A
12AC:  MOVLW  0D
12AD:  CLRWDT
12AE:  MOVLB  00
12AF:  BTFSC  11.4
12B0:  GOTO   2B3
12B1:  MOVLB  03
12B2:  GOTO   2AD
12B3:  MOVLB  03
12B4:  MOVWF  1A
12B5:  MOVLW  20
12B6:  MOVWF  05
12B7:  MOVLW  76
12B8:  MOVWF  04
12B9:  MOVLP  08
12BA:  MOVLB  00
12BB:  CALL   23D
12BC:  MOVLP  10
....................       lcd_send(2,LCD_str); 
12BD:  MOVLW  02
12BE:  MOVLB  02
12BF:  MOVWF  4A
12C0:  MOVLW  20
12C1:  MOVWF  4C
12C2:  MOVLW  76
12C3:  MOVWF  4B
12C4:  MOVLP  08
12C5:  MOVLB  00
12C6:  CALL   173
12C7:  MOVLP  10
....................       prompt(); 
12C8:  CALL   08A
....................       break; 
12C9:  GOTO   55E
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
12CA:  MOVLP  08
12CB:  CALL   7E3
12CC:  MOVLP  10
12CD:  MOVF   78,F
12CE:  BTFSC  03.2
12CF:  GOTO   2D3
....................         store_variables(); 
12D0:  MOVLP  00
12D1:  CALL   5AE
12D2:  MOVLP  10
....................       } 
....................       break; 
12D3:  GOTO   55E
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
12D4:  DECFSZ 76,W
12D5:  GOTO   2DA
....................         init_src=USE_EEPROM_VARS; 
12D6:  MOVLB  02
12D7:  BSF    22.0
....................       } else { 
12D8:  GOTO   2DC
12D9:  MOVLB  00
....................         init_src=USE_DEFAULT_VARS; 
12DA:  MOVLB  02
12DB:  BCF    22.0
....................       } 
....................       if ( in_admin_mode() ) { 
12DC:  MOVLP  08
12DD:  MOVLB  00
12DE:  CALL   7E3
12DF:  MOVLP  10
12E0:  MOVF   78,F
12E1:  BTFSC  03.2
12E2:  GOTO   2ED
....................         init_variables(init_src); 
12E3:  MOVLW  00
12E4:  MOVLB  02
12E5:  BTFSC  22.0
12E6:  MOVLW  01
12E7:  MOVWF  2C
12E8:  MOVWF  2D
12E9:  MOVLP  00
12EA:  MOVLB  00
12EB:  CALL   629
12EC:  MOVLP  10
....................       } 
....................       break; 
12ED:  GOTO   55E
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
12EE:  MOVF   75,W
12EF:  ANDLW  03
12F0:  MOVWF  74
....................       increment(value); 
12F1:  MOVF   76,W
12F2:  MOVLB  02
12F3:  MOVWF  2F
12F4:  MOVLB  00
12F5:  CALL   000
....................       PROMPT_FLAG=1; 
12F6:  MOVLB  01
12F7:  BSF    5D.6
....................       break; 
12F8:  MOVLB  00
12F9:  GOTO   55E
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
12FA:  MOVF   75,W
12FB:  ANDLW  03
12FC:  MOVWF  74
....................       increment(-1*value); 
12FD:  MOVLW  FF
12FE:  MOVLB  02
12FF:  MOVWF  43
1300:  MOVF   76,W
1301:  MOVWF  44
1302:  MOVLP  08
1303:  MOVLB  00
1304:  CALL   71B
1305:  MOVLP  10
1306:  MOVF   78,W
1307:  MOVLB  02
1308:  MOVWF  2C
1309:  MOVWF  2F
130A:  MOVLB  00
130B:  CALL   000
....................       PROMPT_FLAG=1; 
130C:  MOVLB  01
130D:  BSF    5D.6
....................       break; 
130E:  MOVLB  00
130F:  GOTO   55E
....................     case STATUS: 
....................       status(); 
....................       break; 
*
14D9:  MOVLB  00
14DA:  GOTO   55E
....................     case ADMIN: 
....................       switch(argument) { 
14DB:  MOVF   75,W
14DC:  XORLW  02
14DD:  BTFSC  03.2
14DE:  GOTO   4E6
14DF:  XORLW  03
14E0:  BTFSC  03.2
14E1:  GOTO   4ED
14E2:  XORLW  02
14E3:  BTFSC  03.2
14E4:  GOTO   4F5
14E5:  GOTO   4F7
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
14E6:  MOVLP  08
14E7:  CALL   7E3
14E8:  MOVLP  10
14E9:  MOVF   78,F
14EA:  BTFSS  03.2
....................             reset_cpu(); 
14EB:  RESET
....................           } 
....................           break; 
14EC:  GOTO   4FD
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
14ED:  MOVLW  01
14EE:  MOVLB  02
14EF:  MOVWF  40
14F0:  MOVLP  08
14F1:  MOVLB  00
14F2:  CALL   49F
14F3:  MOVLP  10
....................           break; 
14F4:  GOTO   4FD
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
14F5:  CALL   0A2
....................         break; 
14F6:  GOTO   4FD
....................         default: 
....................           set_admin_mode(0); 
14F7:  MOVLB  02
14F8:  CLRF   40
14F9:  MOVLP  08
14FA:  MOVLB  00
14FB:  CALL   49F
14FC:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
14FD:  GOTO   55E
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
.................... #ifdef LCD_TYPE_PI 
....................       switch(value) { 
....................         case 0 : init_lcd();break;   
....................         case 1 : lcd_write(0,0x01); 
....................       } 
.................... #else 
....................       lcd_cmd=4+(value&0x03); 
14FE:  MOVF   76,W
14FF:  ANDLW  03
1500:  ADDLW  04
1501:  MOVLB  02
1502:  MOVWF  23
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
1503:  MOVLW  20
1504:  MOVLB  01
1505:  MOVWF  64
1506:  MOVLW  76
1507:  MOVWF  63
1508:  MOVLW  CF
1509:  MOVLB  03
150A:  MOVWF  11
150B:  MOVLW  03
150C:  MOVWF  12
150D:  BCF    03.0
150E:  MOVLW  04
150F:  MOVLB  02
1510:  MOVWF  4A
1511:  MOVLP  08
1512:  MOVLB  00
1513:  CALL   10B
1514:  MOVLP  10
1515:  MOVLW  60
1516:  MOVLB  02
1517:  MOVWF  4A
1518:  MOVLW  18
1519:  MOVWF  4B
151A:  MOVLP  08
151B:  MOVLB  00
151C:  CALL   1D6
151D:  MOVLP  10
151E:  MOVLW  D2
151F:  MOVLB  03
1520:  MOVWF  11
1521:  MOVLW  03
1522:  MOVWF  12
1523:  BCF    03.0
1524:  MOVLW  08
1525:  MOVLB  02
1526:  MOVWF  4A
1527:  MOVLP  08
1528:  MOVLB  00
1529:  CALL   10B
152A:  MOVLP  10
152B:  MOVLB  02
152C:  MOVF   23,W
152D:  MOVWF  4A
152E:  MOVLW  18
152F:  MOVWF  4B
1530:  MOVLP  08
1531:  MOVLB  00
1532:  CALL   1D6
1533:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
1534:  MOVLW  0A
1535:  CLRWDT
1536:  BTFSS  11.4
1537:  GOTO   535
1538:  MOVLB  03
1539:  MOVWF  1A
153A:  MOVLW  0D
153B:  CLRWDT
153C:  MOVLB  00
153D:  BTFSC  11.4
153E:  GOTO   541
153F:  MOVLB  03
1540:  GOTO   53B
1541:  MOVLB  03
1542:  MOVWF  1A
1543:  MOVLW  20
1544:  MOVWF  05
1545:  MOVLW  76
1546:  MOVWF  04
1547:  MOVLP  08
1548:  MOVLB  00
1549:  CALL   23D
154A:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
154B:  MOVLB  02
154C:  MOVF   23,W
154D:  MOVWF  4A
154E:  MOVLW  20
154F:  MOVWF  4C
1550:  MOVLW  76
1551:  MOVWF  4B
1552:  MOVLP  08
1553:  MOVLB  00
1554:  CALL   173
1555:  MOVLP  10
.................... #endif 
....................       break; 
1556:  GOTO   55E
....................     case MORSE_SEND: 
....................       morse(value); 
1557:  MOVF   76,W
1558:  MOVLB  02
1559:  MOVWF  3F
155A:  MOVLP  08
155B:  MOVLB  00
155C:  CALL   083
155D:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
155E:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  4A
1803:  MOVLW  20
1804:  MOVWF  4C
1805:  MOVLW  50
1806:  MOVWF  4B
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   173
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVWF  75
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B62:  MOVLB  01
1B63:  CLRF   66
1B64:  CLRF   65
1B65:  MOVF   66,F
1B66:  BTFSS  03.2
1B67:  GOTO   3B6
1B68:  MOVF   65,W
1B69:  SUBLW  38
1B6A:  BTFSS  03.0
1B6B:  GOTO   3B6
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B6C:  MOVLW  01
1B6D:  MOVWF  7A
1B6E:  MOVLW  8F
1B6F:  MOVLB  02
1B70:  MOVWF  20
1B71:  MOVF   7A,W
1B72:  MOVWF  21
1B73:  MOVLB  01
1B74:  MOVF   66,W
1B75:  MOVLB  02
1B76:  MOVWF  3E
1B77:  MOVLB  01
1B78:  MOVF   65,W
1B79:  MOVLB  02
1B7A:  MOVWF  3D
1B7B:  CLRF   40
1B7C:  MOVLW  06
1B7D:  MOVWF  3F
1B7E:  MOVLP  08
1B7F:  MOVLB  00
1B80:  CALL   7A3
1B81:  MOVLP  18
1B82:  MOVF   78,W
1B83:  MOVLB  02
1B84:  ADDWF  20,W
1B85:  MOVLB  01
1B86:  MOVWF  67
1B87:  MOVF   79,W
1B88:  MOVLB  02
1B89:  ADDWFC 21,W
1B8A:  MOVLB  01
1B8B:  MOVWF  68
....................     romstrcpy(rname,cPtr); 
1B8C:  MOVLW  20
1B8D:  MOVLB  02
1B8E:  MOVWF  3C
1B8F:  MOVLW  99
1B90:  MOVWF  3B
1B91:  MOVLB  01
1B92:  MOVF   68,W
1B93:  MOVLB  02
1B94:  MOVWF  3E
1B95:  MOVLB  01
1B96:  MOVF   67,W
1B97:  MOVLB  02
1B98:  MOVWF  3D
1B99:  MOVLP  08
1B9A:  MOVLB  00
1B9B:  CALL   7BA
1B9C:  MOVLP  18
....................     if(my_stricmp(argument_name,rname)==0) { 
1B9D:  MOVLW  20
1B9E:  MOVLB  02
1B9F:  MOVWF  40
1BA0:  MOVLW  70
1BA1:  MOVWF  3F
1BA2:  MOVLW  20
1BA3:  MOVWF  42
1BA4:  MOVLW  99
1BA5:  MOVWF  41
1BA6:  MOVLP  08
1BA7:  MOVLB  00
1BA8:  CALL   77B
1BA9:  MOVLP  18
1BAA:  MOVF   78,F
1BAB:  BTFSS  03.2
1BAC:  GOTO   3B1
....................       argument=x; 
1BAD:  MOVLB  01
1BAE:  MOVF   65,W
1BAF:  MOVWF  75
1BB0:  MOVLB  00
....................     } 
....................   } 
1BB1:  MOVLB  01
1BB2:  INCF   65,F
1BB3:  BTFSC  03.2
1BB4:  INCF   66,F
1BB5:  GOTO   365
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BB6:  MOVF   75,W
1BB7:  SUBLW  FF
1BB8:  BTFSS  03.2
1BB9:  GOTO   41A
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BBA:  MOVLW  20
1BBB:  MOVLB  02
1BBC:  MOVWF  40
1BBD:  MOVLW  70
1BBE:  MOVWF  3F
1BBF:  MOVLP  08
1BC0:  MOVLB  00
1BC1:  CALL   742
1BC2:  MOVLP  18
1BC3:  MOVF   78,W
1BC4:  MOVWF  76
....................     strcpy(rname,"eeprom"); 
1BC5:  MOVLB  02
1BC6:  CLRF   20
1BC7:  CLRF   21
1BC8:  MOVLW  20
1BC9:  MOVWF  05
1BCA:  MOVLW  99
1BCB:  MOVWF  04
1BCC:  MOVF   20,W
1BCD:  ADDWF  04,F
1BCE:  MOVLW  00
1BCF:  ADDWFC 05,F
1BD0:  MOVF   21,W
1BD1:  MOVLP  00
1BD2:  MOVLB  00
1BD3:  CALL   128
1BD4:  MOVLP  18
1BD5:  MOVWF  00
1BD6:  IORLW  00
1BD7:  BTFSC  03.2
1BD8:  GOTO   3DE
1BD9:  MOVLB  02
1BDA:  INCF   21,F
1BDB:  INCF   20,F
1BDC:  GOTO   3C8
1BDD:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1BDE:  MOVLW  20
1BDF:  MOVLB  02
1BE0:  MOVWF  40
1BE1:  MOVLW  70
1BE2:  MOVWF  3F
1BE3:  MOVLW  20
1BE4:  MOVWF  42
1BE5:  MOVLW  99
1BE6:  MOVWF  41
1BE7:  MOVLP  08
1BE8:  MOVLB  00
1BE9:  CALL   77B
1BEA:  MOVLP  18
1BEB:  MOVF   78,F
1BEC:  BTFSS  03.2
1BED:  GOTO   3F0
....................       value=USE_EEPROM_VARS; 
1BEE:  MOVLW  01
1BEF:  MOVWF  76
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BF0:  MOVLB  02
1BF1:  CLRF   20
1BF2:  CLRF   21
1BF3:  MOVLW  20
1BF4:  MOVWF  05
1BF5:  MOVLW  99
1BF6:  MOVWF  04
1BF7:  MOVF   20,W
1BF8:  ADDWF  04,F
1BF9:  MOVLW  00
1BFA:  ADDWFC 05,F
1BFB:  MOVF   21,W
1BFC:  MOVLP  00
1BFD:  MOVLB  00
1BFE:  CALL   130
1BFF:  MOVLP  18
1C00:  MOVWF  00
1C01:  IORLW  00
1C02:  BTFSC  03.2
1C03:  GOTO   409
1C04:  MOVLB  02
1C05:  INCF   21,F
1C06:  INCF   20,F
1C07:  GOTO   3F3
1C08:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C09:  MOVLW  20
1C0A:  MOVLB  02
1C0B:  MOVWF  40
1C0C:  MOVLW  70
1C0D:  MOVWF  3F
1C0E:  MOVLW  20
1C0F:  MOVWF  42
1C10:  MOVLW  99
1C11:  MOVWF  41
1C12:  MOVLP  08
1C13:  MOVLB  00
1C14:  CALL   77B
1C15:  MOVLP  18
1C16:  MOVF   78,F
1C17:  BTFSC  03.2
....................       value=USE_DEFAULT_VARS; 
1C18:  CLRF   76
1C19:  MOVLB  01
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C1A:  MOVF   70,W
1C1B:  SUBLW  06
1C1C:  BTFSC  03.2
1C1D:  GOTO   422
1C1E:  MOVF   70,W
1C1F:  SUBLW  07
1C20:  BTFSS  03.2
1C21:  GOTO   426
....................     value = 1; 
1C22:  MOVLW  01
1C23:  MOVWF  76
....................     argument = CurrentTrimPot; 
1C24:  MOVF   74,W
1C25:  MOVWF  75
....................   } 
....................   rs232_mode = 1; 
1C26:  BSF    62.0
....................   execute_command(); 
1C27:  MOVLP  10
1C28:  MOVLB  00
1C29:  CALL   0E4
1C2A:  MOVLP  18
....................   rs232_mode = 0; 
1C2B:  MOVLB  01
1C2C:  BCF    62.0
.................... } // }}} 
1C2D:  MOVLP  18
1C2E:  MOVLB  00
1C2F:  GOTO   74F (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
1310:  MOVLW  1B
1311:  MOVLP  00
1312:  CALL   2E4
1313:  MOVLP  10
....................   printf("[2J"); 
1314:  MOVLW  5B
1315:  CLRWDT
1316:  BTFSS  11.4
1317:  GOTO   315
1318:  MOVLB  03
1319:  MOVWF  1A
131A:  MOVLW  32
131B:  CLRWDT
131C:  MOVLB  00
131D:  BTFSC  11.4
131E:  GOTO   321
131F:  MOVLB  03
1320:  GOTO   31B
1321:  MOVLB  03
1322:  MOVWF  1A
1323:  MOVLW  4A
1324:  CLRWDT
1325:  MOVLB  00
1326:  BTFSC  11.4
1327:  GOTO   32A
1328:  MOVLB  03
1329:  GOTO   324
132A:  MOVLB  03
132B:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
132C:  MOVLW  1B
132D:  MOVLP  00
132E:  MOVLB  00
132F:  CALL   2E4
1330:  MOVLP  10
....................   printf("[0;0H"); 
1331:  MOVLW  D8
1332:  MOVLB  03
1333:  MOVWF  11
1334:  MOVLW  03
1335:  MOVWF  12
1336:  MOVLP  00
1337:  MOVLB  00
1338:  CALL   4BB
1339:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
076F:  MOVLB  02
0770:  SWAPF  3F,W
0771:  MOVWF  41
0772:  RLF    41,F
0773:  RLF    41,F
0774:  MOVLW  C0
0775:  ANDWF  41,F
....................   tx_value=tx_value + (value & 0x3F); 
0776:  MOVF   40,W
0777:  ANDLW  3F
0778:  ADDWF  41,F
....................   i2c_start(); 
0779:  MOVLB  04
077A:  BSF    16.0
077B:  BTFSC  16.0
077C:  GOTO   77B
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
077D:  MOVLW  50
077E:  MOVLB  02
077F:  MOVWF  50
0780:  MOVLB  00
0781:  CALL   697
0782:  MOVF   78,W
0783:  MOVLB  02
0784:  BCF    42.0
0785:  BTFSC  78.0
0786:  BSF    42.0
....................   if ( ack != 0) { 
0787:  BTFSS  42.0
0788:  GOTO   7A0
....................     printf("\n\rI2C : No ACK : %u",ack); 
0789:  MOVLW  00
078A:  BTFSC  42.0
078B:  MOVLW  01
078C:  MOVWF  43
078D:  MOVLW  DB
078E:  MOVLB  03
078F:  MOVWF  11
0790:  MOVLW  03
0791:  MOVWF  12
0792:  BCF    03.0
0793:  MOVLW  11
0794:  MOVLB  02
0795:  MOVWF  50
0796:  MOVLB  00
0797:  CALL   6AC
0798:  MOVLB  02
0799:  MOVF   43,W
079A:  MOVWF  50
079B:  MOVLW  1B
079C:  MOVWF  51
079D:  MOVLB  00
079E:  CALL   720
079F:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
07A0:  MOVF   41,W
07A1:  MOVWF  50
07A2:  MOVLB  00
07A3:  CALL   697
....................   i2c_stop();   
07A4:  MOVLB  04
07A5:  BSF    16.2
07A6:  BTFSC  16.2
07A7:  GOTO   7A6
....................   printf("\n\rPot(%u)<=%u",pot,value); 
07A8:  MOVLW  E5
07A9:  MOVLB  03
07AA:  MOVWF  11
07AB:  MOVLW  03
07AC:  MOVWF  12
07AD:  BCF    03.0
07AE:  MOVLW  06
07AF:  MOVLB  02
07B0:  MOVWF  50
07B1:  MOVLB  00
07B2:  CALL   6AC
07B3:  MOVLB  02
07B4:  MOVF   3F,W
07B5:  MOVWF  50
07B6:  MOVLW  1B
07B7:  MOVWF  51
07B8:  MOVLB  00
07B9:  CALL   720
07BA:  MOVLW  29
07BB:  CLRWDT
07BC:  BTFSS  11.4
07BD:  GOTO   7BB
07BE:  MOVLB  03
07BF:  MOVWF  1A
07C0:  MOVLW  3C
07C1:  CLRWDT
07C2:  MOVLB  00
07C3:  BTFSC  11.4
07C4:  GOTO   7C7
07C5:  MOVLB  03
07C6:  GOTO   7C1
07C7:  MOVLB  03
07C8:  MOVWF  1A
07C9:  MOVLW  3D
07CA:  CLRWDT
07CB:  MOVLB  00
07CC:  BTFSC  11.4
07CD:  GOTO   7D0
07CE:  MOVLB  03
07CF:  GOTO   7CA
07D0:  MOVLB  03
07D1:  MOVWF  1A
07D2:  MOVLB  02
07D3:  MOVF   40,W
07D4:  MOVWF  50
07D5:  MOVLW  1B
07D6:  MOVWF  51
07D7:  MOVLB  00
07D8:  CALL   720
....................  
.................... } // }}} 
07D9:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
0883:  MOVLW  DB
0884:  MOVLB  02
0885:  ADDWF  3F,W
0886:  MOVWF  43
0887:  MOVLW  1F
0888:  MOVWF  44
0889:  BTFSC  03.0
088A:  INCF   44,F
088B:  MOVF   44,W
088C:  MOVLB  03
088D:  MOVWF  12
088E:  MOVLB  02
088F:  MOVF   43,W
0890:  MOVLB  03
0891:  MOVWF  11
0892:  MOVLW  20
0893:  MOVWF  05
0894:  MOVLW  C0
0895:  MOVWF  04
0896:  MOVLW  01
0897:  MOVLB  02
0898:  MOVWF  45
0899:  MOVLB  00
089A:  CALL   000
....................    
....................   PROMPT_FLAG=1; 
089B:  MOVLB  01
089C:  BSF    5D.6
....................   for(x=0;x<4;x++) { 
089D:  MOVLB  02
089E:  CLRF   41
089F:  MOVF   41,W
08A0:  SUBLW  03
08A1:  BTFSS  03.0
08A2:  GOTO   0C9
....................     do_delay=1; 
08A3:  BSF    42.0
....................     switch(mc & 0xc0) { // Check two MSB's 
08A4:  MOVF   40,W
08A5:  ANDLW  C0
08A6:  XORLW  40
08A7:  MOVLB  00
08A8:  BTFSC  03.2
08A9:  GOTO   0AE
08AA:  XORLW  C0
08AB:  BTFSC  03.2
08AC:  GOTO   0B0
08AD:  GOTO   0B2
....................       case(0x40): 
....................         dit(); 
08AE:  CALL   013
....................         break; 
08AF:  GOTO   0B5
....................       case(0x80): 
....................         dah(); 
08B0:  CALL   04B
....................         break; 
08B1:  GOTO   0B5
....................       default: 
....................         do_delay=0; 
08B2:  MOVLB  02
08B3:  BCF    42.0
....................         break; 
08B4:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
08B5:  MOVLB  02
08B6:  RLF    40,F
08B7:  RLF    40,F
08B8:  MOVLW  FC
08B9:  ANDWF  40,F
....................     if ( do_delay ) { 
08BA:  BTFSS  42.0
08BB:  GOTO   0C7
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
08BC:  MOVLB  01
08BD:  CLRF   33
08BE:  MOVLW  02
08BF:  MOVWF  32
....................       while(aux_timer) { 
08C0:  MOVF   32,W
08C1:  IORWF  33,W
08C2:  BTFSC  03.2
08C3:  GOTO   0C6
....................         delay_cycles(1); 
08C4:  NOP
....................       } 
08C5:  GOTO   0C0
08C6:  MOVLB  02
....................     } 
....................   } 
08C7:  INCF   41,F
08C8:  GOTO   09F
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
08C9:  MOVF   3F,W
08CA:  SUBLW  09
08CB:  BTFSS  03.0
08CC:  GOTO   0D8
....................     if ( c < 5 ) { 
08CD:  MOVF   3F,W
08CE:  SUBLW  04
08CF:  BTFSS  03.0
08D0:  GOTO   0D5
....................       dah(); 
08D1:  MOVLB  00
08D2:  CALL   04B
....................     } 
....................     else { 
08D3:  GOTO   0D7
08D4:  MOVLB  02
....................       dit(); 
08D5:  MOVLB  00
08D6:  CALL   013
08D7:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
08D8:  MOVLB  00
08D9:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0B4B:  MOVLW  30
0B4C:  MOVLB  02
0B4D:  MOVWF  34
0B4E:  MOVWF  35
0B4F:  MOVWF  36
0B50:  MOVWF  37
0B51:  CLRF   38
....................   char PTT_s[5]={'0','0','0','0',0}; 
0B52:  MOVWF  39
0B53:  MOVWF  3A
0B54:  MOVWF  3B
0B55:  MOVWF  3C
0B56:  CLRF   3D
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0B57:  MOVF   2E,W
0B58:  MOVLB  00
0B59:  MOVWF  6D
....................  
....................   if ( cor ) { 
0B5A:  MOVLB  02
0B5B:  MOVF   2E,F
0B5C:  BTFSC  03.2
0B5D:  GOTO   36F
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0B5E:  MOVLW  01
0B5F:  SUBWF  2E,W
0B60:  ADDLW  29
0B61:  MOVWF  04
0B62:  MOVLW  20
0B63:  MOVWF  05
0B64:  BTFSC  03.0
0B65:  INCF   05,F
0B66:  MOVF   00,W
0B67:  MOVWF  3F
0B68:  MOVLB  00
0B69:  MOVF   60,W
0B6A:  ANDWF  61,W
0B6B:  MOVLB  02
0B6C:  ANDWF  3F,W
0B6D:  MOVWF  33
....................   } else { 
0B6E:  GOTO   3B8
....................     ptt=0; 
0B6F:  CLRF   33
....................     if ( COR_DROP_FLAG ) { 
0B70:  BTFSS  72.7
0B71:  GOTO   3B8
....................       COR_DROP_FLAG=0; 
0B72:  BCF    72.7
....................       if ( ConfirmChar || TailChar ) { 
0B73:  MOVLB  00
0B74:  MOVF   6B,F
0B75:  BTFSS  03.2
0B76:  GOTO   37A
0B77:  MOVF   6A,F
0B78:  BTFSC  03.2
0B79:  GOTO   3B7
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0BB8:  MOVLW  01
0BB9:  MOVWF  32
....................   for(x=0;x<4;x++) { 
0BBA:  CLRF   2F
0BBB:  MOVF   2F,W
0BBC:  SUBLW  03
0BBD:  BTFSS  03.0
0BBE:  GOTO   423
....................     if ( !cor ) { 
0BBF:  MOVF   2E,F
0BC0:  BTFSS  03.2
0BC1:  GOTO   3C5
....................       rx_bit=0; 
0BC2:  BCF    3E.0
....................       ptt_bit=0; 
0BC3:  BCF    3E.1
....................     } else { 
0BC4:  GOTO   3D8
....................       if ( cor == (x+1) ) { 
0BC5:  MOVLW  01
0BC6:  ADDWF  2F,W
0BC7:  SUBWF  2E,W
0BC8:  BTFSS  03.2
0BC9:  GOTO   3D0
....................         rx_bit=1; 
0BCA:  BSF    3E.0
....................         CurrentCorMask=mask; 
0BCB:  MOVF   32,W
0BCC:  MOVLB  00
0BCD:  MOVWF  6C
....................       } else { 
0BCE:  GOTO   3D2
0BCF:  MOVLB  02
....................         rx_bit=0; 
0BD0:  BCF    3E.0
0BD1:  MOVLB  00
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0BD2:  MOVLB  02
0BD3:  BCF    3E.1
0BD4:  MOVF   33,W
0BD5:  ANDWF  32,W
0BD6:  BTFSS  03.2
0BD7:  BSF    3E.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0BD8:  MOVF   2F,W
0BD9:  MOVLP  00
0BDA:  MOVLB  00
0BDB:  CALL   031
0BDC:  MOVLP  08
0BDD:  MOVLB  02
0BDE:  MOVWF  3F
0BDF:  MOVLW  00
0BE0:  BTFSC  3E.0
0BE1:  MOVLW  01
0BE2:  MOVWF  77
0BE3:  MOVF   3F,W
0BE4:  MOVWF  40
0BE5:  MOVF   77,W
0BE6:  MOVWF  41
0BE7:  MOVLW  01
0BE8:  MOVWF  43
0BE9:  CLRF   42
0BEA:  MOVLB  00
0BEB:  CALL   0DA
0BEC:  MOVLB  02
0BED:  MOVF   3F,W
0BEE:  MOVWF  40
0BEF:  CLRF   41
0BF0:  CLRF   43
0BF1:  MOVLW  80
0BF2:  MOVWF  42
0BF3:  MOVLB  00
0BF4:  CALL   0DA
....................     output_bit(PTT_PIN[x],ptt_bit); 
0BF5:  MOVLB  02
0BF6:  MOVF   2F,W
0BF7:  MOVLP  00
0BF8:  MOVLB  00
0BF9:  CALL   036
0BFA:  MOVLP  08
0BFB:  MOVLB  02
0BFC:  MOVWF  3F
0BFD:  MOVLW  00
0BFE:  BTFSC  3E.1
0BFF:  MOVLW  01
0C00:  MOVWF  77
0C01:  MOVF   3F,W
0C02:  MOVWF  40
0C03:  MOVF   77,W
0C04:  MOVWF  41
0C05:  MOVLW  01
0C06:  MOVWF  43
0C07:  CLRF   42
0C08:  MOVLB  00
0C09:  CALL   0DA
0C0A:  MOVLB  02
0C0B:  MOVF   3F,W
0C0C:  MOVWF  40
0C0D:  CLRF   41
0C0E:  CLRF   43
0C0F:  MOVLW  80
0C10:  MOVWF  42
0C11:  MOVLB  00
0C12:  CALL   0DA
....................     if(ptt_bit) { 
0C13:  MOVLB  02
0C14:  BTFSS  3E.1
0C15:  GOTO   41F
....................       PTT_s[x]='1'; 
0C16:  MOVLW  B9
0C17:  ADDWF  2F,W
0C18:  MOVWF  04
0C19:  MOVLW  20
0C1A:  MOVWF  05
0C1B:  BTFSC  03.0
0C1C:  INCF   05,F
0C1D:  MOVLW  31
0C1E:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C1F:  BCF    03.0
0C20:  RLF    32,F
....................   }  
0C21:  INCF   2F,F
0C22:  GOTO   3BB
....................   if(!cor) { 
0C23:  MOVF   2E,F
0C24:  BTFSS  03.2
0C25:  GOTO   42A
....................     CurrentCorPriority=0; 
0C26:  MOVLB  00
0C27:  CLRF   6E
....................   } else { 
0C28:  GOTO   45A
0C29:  MOVLB  02
....................     CurrentCorPriority=RXPriority[cor-1]; 
0C2A:  MOVLW  01
0C2B:  SUBWF  2E,W
0C2C:  ADDLW  25
0C2D:  MOVWF  04
0C2E:  MOVLW  20
0C2F:  MOVWF  05
0C30:  BTFSC  03.0
0C31:  INCF   05,F
0C32:  MOVF   00,W
0C33:  MOVLB  00
0C34:  MOVWF  6E
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0C35:  MOVLB  02
0C36:  CLRF   30
0C37:  MOVF   30,W
0C38:  SUBLW  03
0C39:  BTFSS  03.0
0C3A:  GOTO   457
....................       pot_val=RX_GAIN[cor-1][pot]; 
0C3B:  MOVLW  01
0C3C:  SUBWF  2E,W
0C3D:  MOVWF  77
0C3E:  RLF    77,F
0C3F:  RLF    77,F
0C40:  MOVLW  FC
0C41:  ANDWF  77,F
0C42:  MOVF   77,W
0C43:  ADDWF  30,W
0C44:  ADDLW  0C
0C45:  MOVWF  04
0C46:  MOVLW  20
0C47:  MOVWF  05
0C48:  BTFSC  03.0
0C49:  INCF   05,F
0C4A:  MOVF   00,W
0C4B:  MOVWF  31
....................       set_trimpot(pot,pot_val); 
0C4C:  MOVF   30,W
0C4D:  MOVWF  3F
0C4E:  MOVF   31,W
0C4F:  MOVWF  40
0C50:  MOVLP  00
0C51:  MOVLB  00
0C52:  CALL   76F
0C53:  MOVLP  08
....................     } 
0C54:  MOVLB  02
0C55:  INCF   30,F
0C56:  GOTO   437
....................     PROMPT_FLAG=1; 
0C57:  MOVLB  01
0C58:  BSF    5D.6
0C59:  MOVLB  00
....................   } 
....................   if(cor>0) { 
0C5A:  MOVLB  02
0C5B:  MOVF   2E,F
0C5C:  BTFSC  03.2
0C5D:  GOTO   468
....................     COR_s[cor-1]='1'; 
0C5E:  MOVLW  01
0C5F:  SUBWF  2E,W
0C60:  ADDLW  B4
0C61:  MOVWF  04
0C62:  MOVLW  20
0C63:  MOVWF  05
0C64:  BTFSC  03.0
0C65:  INCF   05,F
0C66:  MOVLW  31
0C67:  MOVWF  00
....................   } 
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0C68:  MOVLW  20
0C69:  MOVLB  01
0C6A:  MOVWF  64
0C6B:  MOVLW  76
0C6C:  MOVWF  63
0C6D:  MOVLW  EC
0C6E:  MOVLB  03
0C6F:  MOVWF  11
0C70:  MOVLW  03
0C71:  MOVWF  12
0C72:  BCF    03.0
0C73:  MOVLW  04
0C74:  MOVLB  02
0C75:  MOVWF  4A
0C76:  MOVLB  00
0C77:  CALL   10B
0C78:  MOVLW  20
0C79:  MOVWF  05
0C7A:  MOVLW  B4
0C7B:  MOVWF  04
0C7C:  CALL   15E
0C7D:  MOVLW  EF
0C7E:  MOVLB  03
0C7F:  MOVWF  11
0C80:  MOVLW  03
0C81:  MOVWF  12
0C82:  BCF    03.0
0C83:  MOVLW  05
0C84:  MOVLB  02
0C85:  MOVWF  4A
0C86:  MOVLB  00
0C87:  CALL   10B
0C88:  MOVLW  20
0C89:  MOVWF  05
0C8A:  MOVLW  B9
0C8B:  MOVWF  04
0C8C:  CALL   15E
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0C8D:  MOVLW  01
0C8E:  MOVLB  02
0C8F:  MOVWF  4A
0C90:  MOVLW  20
0C91:  MOVWF  4C
0C92:  MOVLW  76
0C93:  MOVWF  4B
0C94:  MOVLB  00
0C95:  CALL   173
....................   delay_ms(50); 
0C96:  MOVLW  32
0C97:  MOVLB  02
0C98:  MOVWF  4A
0C99:  MOVLP  00
0C9A:  MOVLB  00
0C9B:  CALL   7DA
0C9C:  MOVLP  08
....................   pot_values_to_lcd(); 
0C9D:  CALL   257
.................... }// }}} 
0C9E:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1E74:  MOVF   67,W
1E75:  SUBLW  0A
1E76:  BTFSS  03.0
1E77:  GOTO   692
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1E78:  MOVLW  64
1E79:  ADDWF  67,W
1E7A:  MOVWF  04
1E7B:  MOVLW  20
1E7C:  MOVWF  05
1E7D:  BTFSC  03.0
1E7E:  INCF   05,F
1E7F:  BTFSS  00.4
1E80:  GOTO   690
1E81:  MOVLW  64
1E82:  ADDWF  67,W
1E83:  MOVWF  04
1E84:  MOVLW  20
1E85:  MOVWF  05
1E86:  BTFSC  03.0
1E87:  INCF   05,F
1E88:  MOVF   00,W
1E89:  ANDLW  0F
1E8A:  SUBLW  0C
1E8B:  BTFSC  03.2
1E8C:  GOTO   690
....................       strobe=1; 
1E8D:  MOVLW  01
1E8E:  MOVWF  68
....................      } else { 
1E8F:  GOTO   691
....................       strobe = 0; 
1E90:  CLRF   68
....................     }  
....................   } else { 
1E91:  GOTO   693
....................     strobe=0; 
1E92:  CLRF   68
....................   } 
....................   return(strobe); 
1E93:  MOVF   68,W
1E94:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
17B7:  MOVLB  01
17B8:  MOVF   67,W
17B9:  SUBWF  68,W
17BA:  BTFSS  03.0
17BB:  GOTO   7E1
17BC:  MOVF   67,W
17BD:  SUBLW  09
17BE:  BTFSS  03.0
17BF:  GOTO   7E1
....................     valid=1; 
17C0:  BSF    6B.0
....................     for(x=a;x<=b;x++) { 
17C1:  MOVF   67,W
17C2:  MOVWF  6A
17C3:  MOVF   6A,W
17C4:  SUBWF  68,W
17C5:  BTFSS  03.0
17C6:  GOTO   7E0
....................       key=(int)DTMF_ARRAY[x].Key; 
17C7:  MOVLW  64
17C8:  ADDWF  6A,W
17C9:  MOVWF  04
17CA:  MOVLW  20
17CB:  MOVWF  05
17CC:  BTFSC  03.0
17CD:  INCF   05,F
17CE:  MOVF   00,W
17CF:  ANDLW  0F
17D0:  MOVWF  69
....................       if(! DTMF_ARRAY[x].Strobe ) { 
17D1:  MOVLW  64
17D2:  ADDWF  6A,W
17D3:  MOVWF  04
17D4:  MOVLW  20
17D5:  MOVWF  05
17D6:  BTFSC  03.0
17D7:  INCF   05,F
17D8:  BTFSS  00.4
....................         valid=0; 
17D9:  BCF    6B.0
....................       } 
....................      if(key==dp) { 
17DA:  MOVF   69,W
17DB:  SUBLW  0C
17DC:  BTFSC  03.2
....................         valid=0; 
17DD:  BCF    6B.0
....................       } 
....................     } 
17DE:  INCF   6A,F
17DF:  GOTO   7C3
....................   } else { 
17E0:  GOTO   7E2
....................     valid=0; 
17E1:  BCF    6B.0
....................   } 
....................   return(valid); 
17E2:  MOVLW  00
17E3:  BTFSC  6B.0
17E4:  MOVLW  01
17E5:  MOVWF  78
.................... } // }}} 
17E6:  MOVLB  00
17E7:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   unsigned site_id; 
....................   unsigned digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 01 : Link commands 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : -- UNUSED -- 
....................   // 11 : Morse send 
....................   // 12 : Send to I2C 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   command=0; 
*
1E21:  CLRF   70
....................   if ( ValidKeyRange(0,3)) { 
1E22:  MOVLB  01
1E23:  CLRF   67
1E24:  MOVLW  03
1E25:  MOVWF  68
1E26:  MOVLP  10
1E27:  MOVLB  00
1E28:  CALL   7B7
1E29:  MOVLP  18
1E2A:  MOVF   78,F
1E2B:  BTFSC  03.2
1E2C:  GOTO   6D8
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1E2D:  MOVLB  01
1E2E:  MOVF   34,W
1E2F:  ANDLW  0F
1E30:  MOVWF  68
1E31:  MOVLB  02
1E32:  MOVWF  43
1E33:  MOVLW  0A
1E34:  MOVWF  44
1E35:  MOVLP  08
1E36:  MOVLB  00
1E37:  CALL   71B
1E38:  MOVLP  18
1E39:  MOVF   78,W
1E3A:  MOVLB  01
1E3B:  MOVWF  67
1E3C:  MOVF   35,W
1E3D:  ANDLW  0F
1E3E:  ADDWF  67,W
1E3F:  MOVWF  65
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1E40:  MOVF   36,W
1E41:  ANDLW  0F
1E42:  MOVWF  68
1E43:  MOVLB  02
1E44:  MOVWF  43
1E45:  MOVLW  0A
1E46:  MOVWF  44
1E47:  MOVLP  08
1E48:  MOVLB  00
1E49:  CALL   71B
1E4A:  MOVLP  18
1E4B:  MOVF   78,W
1E4C:  MOVLB  01
1E4D:  MOVWF  67
1E4E:  MOVF   37,W
1E4F:  ANDLW  0F
1E50:  ADDWF  67,W
1E51:  MOVWF  70
....................     if ( ValidKeyRange(4,5) ) { 
1E52:  MOVLW  04
1E53:  MOVWF  67
1E54:  MOVLW  05
1E55:  MOVWF  68
1E56:  MOVLP  10
1E57:  MOVLB  00
1E58:  CALL   7B7
1E59:  MOVLP  18
1E5A:  MOVF   78,F
1E5B:  BTFSC  03.2
1E5C:  GOTO   6B3
....................       // Admin mode {{{ 
....................       argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1E5D:  MOVLB  01
1E5E:  MOVF   38,W
1E5F:  ANDLW  0F
1E60:  MOVWF  68
1E61:  MOVLB  02
1E62:  MOVWF  43
1E63:  MOVLW  0A
1E64:  MOVWF  44
1E65:  MOVLP  08
1E66:  MOVLB  00
1E67:  CALL   71B
1E68:  MOVLP  18
1E69:  MOVF   78,W
1E6A:  MOVLB  01
1E6B:  MOVWF  67
1E6C:  MOVF   39,W
1E6D:  ANDLW  0F
1E6E:  ADDWF  67,W
1E6F:  MOVWF  75
....................       digit=6; 
1E70:  MOVLW  06
1E71:  MOVWF  66
....................       while(ValidKey(digit)) { 
1E72:  MOVF   66,W
1E73:  MOVWF  67
*
1E95:  MOVF   78,F
1E96:  BTFSC  03.2
1E97:  GOTO   6B1
....................        value = value * 10 + DTMF_ARRAY[digit].Key; 
1E98:  MOVF   76,W
1E99:  MOVLB  02
1E9A:  MOVWF  43
1E9B:  MOVLW  0A
1E9C:  MOVWF  44
1E9D:  MOVLP  08
1E9E:  MOVLB  00
1E9F:  CALL   71B
1EA0:  MOVLP  18
1EA1:  MOVF   78,W
1EA2:  MOVLB  01
1EA3:  MOVWF  67
1EA4:  MOVLW  64
1EA5:  ADDWF  66,W
1EA6:  MOVWF  04
1EA7:  MOVLW  20
1EA8:  MOVWF  05
1EA9:  BTFSC  03.0
1EAA:  INCF   05,F
1EAB:  MOVF   00,W
1EAC:  ANDLW  0F
1EAD:  ADDWF  67,W
1EAE:  MOVWF  76
....................        digit++; 
1EAF:  INCF   66,F
....................       } 
1EB0:  GOTO   672
....................       // Admin mode }}} 
....................     } else { 
1EB1:  GOTO   6C5
1EB2:  MOVLB  00
....................       // User function {{{ 
....................       // Only 4 digits were entered.  
....................       // Use 'command' value as user function. 
....................       switch(command) { 
1EB3:  MOVF   70,W
1EB4:  XORLW  0A
1EB5:  BTFSC  03.2
1EB6:  GOTO   6BB
1EB7:  XORLW  01
1EB8:  BTFSC  03.2
1EB9:  GOTO   6BF
1EBA:  GOTO   6C2
....................         // Commands 10 (disable link) and 11 (enable link) 
....................         case(10): 
....................           argument = 0; 
1EBB:  CLRF   75
....................           value = 0x0E; 
1EBC:  MOVLW  0E
1EBD:  MOVWF  76
....................   	      break; 
1EBE:  GOTO   6C2
....................         case(11): 
....................           argument = 0; 
1EBF:  CLRF   75
....................           value = 0x0F; 
1EC0:  MOVLW  0F
1EC1:  MOVWF  76
....................    		    break; 
....................       } 
....................       // Override command 
....................       command=SET_REG; 
1EC2:  MOVLW  02
1EC3:  MOVWF  70
1EC4:  MOVLB  01
....................       // User function }}} 
....................     } 
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1EC5:  MOVF   70,W
1EC6:  XORLW  04
1EC7:  MOVLB  00
1EC8:  BTFSC  03.2
1EC9:  GOTO   6CD
1ECA:  XORLW  01
1ECB:  BTFSS  03.2
1ECC:  GOTO   6CF
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1ECD:  MOVF   75,W
1ECE:  MOVWF  76
....................         break; 
....................     } 
....................     if ( site_id == SiteID ) { 
1ECF:  MOVF   63,W
1ED0:  MOVLB  01
1ED1:  SUBWF  65,W
1ED2:  BTFSS  03.2
1ED3:  GOTO   6D9
....................       execute_command(); 
1ED4:  MOVLP  10
1ED5:  MOVLB  00
1ED6:  CALL   0E4
1ED7:  MOVLP  18
1ED8:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1ED9:  MOVF   34,W
1EDA:  ANDLW  0F
1EDB:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1EDC:  BTFSS  5D.7
1EDD:  GOTO   710
1EDE:  CLRF   67
1EDF:  CLRF   68
1EE0:  MOVLP  10
1EE1:  MOVLB  00
1EE2:  CALL   7B7
1EE3:  MOVLP  18
1EE4:  MOVF   78,F
1EE5:  BTFSS  03.2
1EE6:  GOTO   6E9
1EE7:  MOVLB  01
1EE8:  GOTO   710
....................     restart_wdt(); 
1EE9:  CLRWDT
....................     switch(command) { 
1EEA:  MOVF   70,W
1EEB:  XORLW  0E
1EEC:  BTFSC  03.2
1EED:  GOTO   6F5
1EEE:  XORLW  01
1EEF:  BTFSC  03.2
1EF0:  GOTO   6FD
1EF1:  XORLW  05
1EF2:  BTFSC  03.2
1EF3:  GOTO   705
1EF4:  GOTO   70C
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1EF5:  MOVLW  01
1EF6:  ADDWF  74,W
1EF7:  ANDLW  03
1EF8:  MOVWF  74
....................         pot_values_to_lcd(); 
1EF9:  MOVLP  08
1EFA:  CALL   257
1EFB:  MOVLP  18
....................         break; 
1EFC:  GOTO   70C
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1EFD:  MOVLW  FF
1EFE:  MOVLB  02
1EFF:  MOVWF  2F
1F00:  MOVLP  10
1F01:  MOVLB  00
1F02:  CALL   000
1F03:  MOVLP  18
....................         break; 
1F04:  GOTO   70C
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1F05:  MOVLW  01
1F06:  MOVLB  02
1F07:  MOVWF  2F
1F08:  MOVLP  10
1F09:  MOVLB  00
1F0A:  CALL   000
1F0B:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1F0C:  MOVLP  08
1F0D:  CALL   7E3
1F0E:  MOVLP  18
1F0F:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1F10:  BSF    5D.5
.................... } // }}} 
1F11:  MOVLP  18
1F12:  MOVLB  00
1F13:  GOTO   77A (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask,cor_index; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
1CB0:  MOVLW  01
1CB1:  MOVLB  01
1CB2:  MOVWF  65
....................   do_update_ptt=0; 
1CB3:  CLRF   69
....................   // Allow emulated COR[4] for DTMF control (No audio feed-thru) 
....................   cor_in = COR_IN | (COR_EMUL&0x1F); 
1CB4:  MOVLB  00
1CB5:  MOVF   69,W
1CB6:  ANDLW  1F
1CB7:  IORWF  5F,W
1CB8:  MOVLB  01
1CB9:  MOVWF  68
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in&CurrentCorMask) ) { 
1CBA:  MOVLB  00
1CBB:  MOVF   6E,F
1CBC:  BTFSC  03.2
1CBD:  GOTO   4D5
1CBE:  MOVLB  01
1CBF:  MOVF   68,W
1CC0:  MOVLB  00
1CC1:  ANDWF  6C,W
1CC2:  BTFSS  03.2
1CC3:  GOTO   4D5
....................     CurrentCorPriority=0; 
1CC4:  CLRF   6E
....................     CurrentCorMask=0; 
1CC5:  CLRF   6C
....................     do_update_ptt=1; 
1CC6:  MOVLW  01
1CC7:  MOVLB  01
1CC8:  MOVWF  69
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
1CC9:  MOVF   68,W
1CCA:  MOVLB  00
1CCB:  ANDWF  60,W
1CCC:  ANDWF  61,W
1CCD:  BTFSS  03.2
1CCE:  GOTO   4D5
....................       COR_DROP_FLAG=1; 
1CCF:  BSF    72.7
....................       if ( Tail ) { 
1CD0:  MOVF   65,F
1CD1:  BTFSC  03.2
1CD2:  GOTO   4D5
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
1CD3:  MOVF   65,W
1CD4:  MOVWF  6A
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
1CD5:  MOVLB  01
1CD6:  CLRF   66
....................   for(x=0;x<4;x++) { 
1CD7:  CLRF   6A
1CD8:  MOVF   6A,W
1CD9:  SUBLW  03
1CDA:  BTFSS  03.0
1CDB:  GOTO   51C
....................     if ( cor_in & cor_mask ) { 
1CDC:  MOVF   68,W
1CDD:  ANDWF  65,W
1CDE:  BTFSC  03.2
1CDF:  GOTO   518
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
1CE0:  MOVLB  00
1CE1:  MOVF   60,W
1CE2:  ANDWF  61,W
1CE3:  MOVLB  01
1CE4:  ANDWF  65,W
1CE5:  BTFSC  03.2
1CE6:  GOTO   4F1
....................         rx_priority=RXPriority[x]; 
1CE7:  MOVLW  25
1CE8:  ADDWF  6A,W
1CE9:  MOVWF  04
1CEA:  MOVLW  20
1CEB:  MOVWF  05
1CEC:  BTFSC  03.0
1CED:  INCF   05,F
1CEE:  MOVF   00,W
1CEF:  MOVWF  67
....................       } else { 
1CF0:  GOTO   4F3
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
1CF1:  MOVLW  01
1CF2:  MOVWF  67
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1CF3:  MOVF   67,W
1CF4:  MOVLB  00
1CF5:  SUBWF  6E,W
1CF6:  BTFSC  03.0
1CF7:  GOTO   517
....................         if ( ! CurrentCorPriority ) { 
1CF8:  MOVF   6E,F
1CF9:  BTFSS  03.2
1CFA:  GOTO   4FF
....................           CurrentCorPriority = rx_priority; 
1CFB:  MOVLB  01
1CFC:  MOVF   67,W
1CFD:  MOVLB  00
1CFE:  MOVWF  6E
....................         } 
....................         cor_index=x+1; 
1CFF:  MOVLW  01
1D00:  MOVLB  01
1D01:  ADDWF  6A,W
1D02:  MOVWF  66
....................         do_update_ptt=1; 
1D03:  MOVLW  01
1D04:  MOVWF  69
....................         TOT_SecondCounter= 60 * TOT_Min; 
1D05:  MOVLW  3C
1D06:  MOVLB  02
1D07:  MOVWF  43
1D08:  MOVLB  00
1D09:  MOVF   66,W
1D0A:  MOVLB  02
1D0B:  MOVWF  44
1D0C:  MOVLP  08
1D0D:  MOVLB  00
1D0E:  CALL   71B
1D0F:  MOVLP  18
1D10:  MOVLB  01
1D11:  CLRF   61
1D12:  MOVF   78,W
1D13:  MOVWF  60
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
1D14:  MOVF   65,W
1D15:  MOVLB  00
1D16:  MOVWF  6F
1D17:  MOVLB  01
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
1D18:  BCF    03.0
1D19:  RLF    65,F
....................   } 
1D1A:  INCF   6A,F
1D1B:  GOTO   4D8
....................   if ( do_update_ptt ) { 
1D1C:  MOVF   69,F
1D1D:  BTFSC  03.2
1D1E:  GOTO   528
....................     update_ptt(cor_index); 
1D1F:  MOVF   66,W
1D20:  MOVLB  02
1D21:  MOVWF  2E
1D22:  MOVLP  08
1D23:  MOVLB  00
1D24:  CALL   34B
1D25:  MOVLP  18
....................     PROMPT_FLAG=1; 
1D26:  MOVLB  01
1D27:  BSF    5D.6
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
1D28:  MOVF   68,F
1D29:  BTFSS  03.2
1D2A:  GOTO   52F
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
1D2B:  BSF    5D.5
....................     COR_IN_EFFECTIVE=0; 
1D2C:  MOVLB  00
1D2D:  CLRF   6F
1D2E:  MOVLB  01
....................   } 
....................   // Refresh Link Time-out timer when COR is received. 
....................   // Any COR value refreshes teh link TOT timer. 
....................   if ( Link_TOT != 0 && (cor_in)!=0 ) { 
1D2F:  MOVLB  00
1D30:  MOVF   67,F
1D31:  BTFSC  03.2
1D32:  GOTO   53C
1D33:  MOVLB  01
1D34:  MOVF   68,F
1D35:  BTFSS  03.2
1D36:  GOTO   539
1D37:  MOVLB  00
1D38:  GOTO   53C
....................     LinkDurationTimer = Link_TOT; 
1D39:  MOVLB  00
1D3A:  MOVF   67,W
1D3B:  MOVWF  68
....................   } 
.................... } // }}} 
1D3C:  MOVLP  18
1D3D:  GOTO   763 (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
17E8:  MOVLB  01
17E9:  CLRF   65
17EA:  MOVF   65,W
17EB:  SUBLW  09
17EC:  BTFSS  03.0
17ED:  GOTO   7F8
....................     DTMF_ARRAY[x]=(sDTMF)0; 
17EE:  MOVLW  64
17EF:  ADDWF  65,W
17F0:  MOVWF  04
17F1:  MOVLW  20
17F2:  MOVWF  05
17F3:  BTFSC  03.0
17F4:  INCF   05,F
17F5:  CLRF   00
....................   } 
17F6:  INCF   65,F
17F7:  GOTO   7EA
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
17F8:  MOVLW  20
17F9:  MOVWF  3F
17FA:  MOVLW  64
17FB:  MOVWF  3E
.................... } // }}} 
17FC:  MOVLP  18
17FD:  MOVLB  00
17FE:  GOTO   782 (RETURN)
.................... void header (void) { // {{{ 
.................... //  putc(ESC); 
.................... //  printf("[47;34m\n\rRadio Repeater Controller - "); 
.................... //  putc(ESC); 
.................... //  printf("[47;31mVE2LRS"); 
.................... //  putc(ESC); 
.................... //  printf("[47;34m (C) 2013\n\n\r"); 
.................... //  putc(ESC); 
.................... //  printf("[40;37m"); 
.................... } // }}} 
*
0003:  RETURN
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   header(); 
*
133A:  MOVLP  00
133B:  CALL   003
133C:  MOVLP  10
....................   dtmf_in=dtmf_read(CONTROL_REG); 
133D:  MOVLW  01
133E:  MOVLB  02
133F:  MOVWF  3B
1340:  MOVLP  00
1341:  MOVLB  00
1342:  CALL   67E
1343:  MOVLP  10
1344:  MOVF   78,W
1345:  MOVLB  02
1346:  MOVWF  33
....................   aux_in = 0; 
1347:  CLRF   34
....................   for(x=0;x<RegMapNum;x++) { 
1348:  CLRF   2D
1349:  CLRF   2C
134A:  MOVF   2D,F
134B:  BTFSS  03.2
134C:  GOTO   451
134D:  MOVF   2C,W
134E:  SUBLW  38
134F:  BTFSS  03.0
1350:  GOTO   451
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
1351:  MOVLW  01
1352:  MOVWF  7A
1353:  MOVLW  8F
1354:  MOVWF  3B
1355:  MOVF   7A,W
1356:  MOVWF  3C
1357:  MOVF   2D,W
1358:  MOVWF  3E
1359:  MOVF   2C,W
135A:  MOVWF  3D
135B:  CLRF   40
135C:  MOVLW  06
135D:  MOVWF  3F
135E:  MOVLP  08
135F:  MOVLB  00
1360:  CALL   7A3
1361:  MOVLP  10
1362:  MOVF   78,W
1363:  MOVLB  02
1364:  ADDWF  3B,W
1365:  MOVWF  2F
1366:  MOVF   79,W
1367:  ADDWFC 3C,W
1368:  MOVWF  30
....................     romstrcpy(rname,cPtr); 
1369:  MOVLW  20
136A:  MOVWF  3C
136B:  MOVLW  B5
136C:  MOVWF  3B
136D:  MOVF   30,W
136E:  MOVWF  3E
136F:  MOVF   2F,W
1370:  MOVWF  3D
1371:  MOVLP  08
1372:  MOVLB  00
1373:  CALL   7BA
1374:  MOVLP  10
....................   regPtr=RegMap[x].reg_ptr; 
1375:  MOVLB  02
1376:  RLF    2C,W
1377:  MOVWF  3B
1378:  RLF    2D,W
1379:  MOVWF  3C
137A:  RLF    3B,F
137B:  RLF    3C,F
137C:  MOVLW  FC
137D:  ANDWF  3B,F
137E:  MOVF   3C,W
137F:  MOVWF  7A
1380:  MOVF   3B,W
1381:  MOVWF  3D
1382:  INCF   3B,W
1383:  MOVLP  00
1384:  MOVLB  00
1385:  CALL   043
1386:  MOVLP  10
1387:  MOVWF  7A
1388:  MOVLB  02
1389:  MOVF   3D,W
138A:  MOVLP  00
138B:  MOVLB  00
138C:  CALL   043
138D:  MOVLP  10
138E:  MOVLB  02
138F:  MOVWF  31
1390:  MOVF   7A,W
1391:  MOVWF  32
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
1392:  MOVF   32,W
1393:  MOVWF  7A
1394:  MOVF   31,W
1395:  MOVWF  04
1396:  MOVF   7A,W
1397:  MOVWF  05
1398:  MOVF   00,W
1399:  MOVWF  3B
139A:  MOVLW  5B
139B:  CLRWDT
139C:  MOVLB  00
139D:  BTFSC  11.4
139E:  GOTO   3A1
139F:  MOVLB  02
13A0:  GOTO   39B
13A1:  MOVLB  03
13A2:  MOVWF  1A
13A3:  MOVLW  0B
13A4:  MOVWF  04
13A5:  MOVLB  02
13A6:  MOVF   2D,W
13A7:  MOVWF  3D
13A8:  MOVF   2C,W
13A9:  MOVWF  3C
*
1407:  MOVLW  5D
1408:  CLRWDT
1409:  MOVLB  00
140A:  BTFSC  11.4
140B:  GOTO   40E
140C:  MOVLB  02
140D:  GOTO   408
140E:  MOVLB  03
140F:  MOVWF  1A
1410:  MOVLW  20
1411:  CLRWDT
1412:  MOVLB  00
1413:  BTFSC  11.4
1414:  GOTO   417
1415:  MOVLB  03
1416:  GOTO   411
1417:  MOVLB  03
1418:  MOVWF  1A
1419:  MOVLW  20
141A:  MOVWF  05
141B:  MOVLW  B5
141C:  MOVWF  04
141D:  MOVLP  08
141E:  MOVLB  00
141F:  CALL   23D
1420:  MOVLP  10
1421:  MOVLW  20
1422:  CLRWDT
1423:  BTFSS  11.4
1424:  GOTO   422
1425:  MOVLB  03
1426:  MOVWF  1A
1427:  MOVLB  02
1428:  MOVF   3B,W
1429:  MOVWF  50
142A:  MOVLW  1B
142B:  MOVWF  51
142C:  MOVLP  00
142D:  MOVLB  00
142E:  CALL   720
142F:  MOVLP  10
1430:  MOVLW  09
1431:  CLRWDT
1432:  BTFSS  11.4
1433:  GOTO   431
1434:  MOVLB  03
1435:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
1436:  MOVLB  02
1437:  MOVF   2C,W
1438:  ANDLW  03
1439:  MOVWF  3B
143A:  CLRF   3C
143B:  MOVF   3B,W
143C:  SUBLW  03
143D:  BTFSS  03.2
143E:  GOTO   44C
143F:  MOVF   3C,F
1440:  BTFSS  03.2
1441:  GOTO   44C
....................       putc('\n'); 
1442:  MOVLW  0A
1443:  MOVLP  00
1444:  MOVLB  00
1445:  CALL   2E4
1446:  MOVLP  10
....................       putc('\r'); 
1447:  MOVLW  0D
1448:  MOVLP  00
1449:  CALL   2E4
144A:  MOVLP  10
144B:  MOVLB  02
....................     } 
....................     restart_wdt(); 
144C:  CLRWDT
....................   } 
144D:  INCF   2C,F
144E:  BTFSC  03.2
144F:  INCF   2D,F
1450:  GOTO   34A
....................   for(y=0;y<3;y++) { 
1451:  CLRF   2E
1452:  MOVF   2E,W
1453:  SUBLW  02
1454:  BTFSS  03.0
1455:  GOTO   46C
....................     if(AuxInSW[y]==1) { 
1456:  MOVLW  1F
1457:  ADDWF  2E,W
1458:  MOVWF  04
1459:  MOVLW  20
145A:  MOVWF  05
145B:  BTFSC  03.0
145C:  INCF   05,F
145D:  DECFSZ 00,W
145E:  GOTO   46A
....................       aux_in += 2<<y; 
145F:  MOVLW  02
1460:  MOVWF  77
1461:  MOVF   2E,W
1462:  MOVWF  78
1463:  BTFSC  03.2
1464:  GOTO   468
1465:  LSLF   77,F
1466:  DECFSZ 78,F
1467:  GOTO   465
1468:  MOVF   77,W
1469:  ADDWF  34,F
....................     } 
....................   } 
146A:  INCF   2E,F
146B:  GOTO   452
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u",COR_IN,COR_EMUL,aux_in); 
146C:  MOVLW  F3
146D:  MOVLB  03
146E:  MOVWF  11
146F:  MOVLW  03
1470:  MOVWF  12
1471:  BCF    03.0
1472:  MOVLW  07
1473:  MOVLB  02
1474:  MOVWF  50
1475:  MOVLP  00
1476:  MOVLB  00
1477:  CALL   6AC
1478:  MOVLP  10
1479:  MOVF   5F,W
147A:  MOVLB  02
147B:  MOVWF  50
147C:  MOVLW  1B
147D:  MOVWF  51
147E:  MOVLP  00
147F:  MOVLB  00
1480:  CALL   720
1481:  MOVLP  10
1482:  MOVLW  F7
1483:  MOVLB  03
1484:  MOVWF  11
1485:  MOVLW  03
1486:  MOVWF  12
1487:  BSF    03.0
1488:  MOVLW  07
1489:  MOVLB  02
148A:  MOVWF  50
148B:  MOVLP  00
148C:  MOVLB  00
148D:  CALL   6AC
148E:  MOVLP  10
148F:  MOVF   69,W
1490:  MOVLB  02
1491:  MOVWF  50
1492:  MOVLW  1B
1493:  MOVWF  51
1494:  MOVLP  00
1495:  MOVLB  00
1496:  CALL   720
1497:  MOVLP  10
1498:  MOVLW  FC
1499:  MOVLB  03
149A:  MOVWF  11
149B:  MOVLW  03
149C:  MOVWF  12
149D:  BCF    03.0
149E:  MOVLW  09
149F:  MOVLB  02
14A0:  MOVWF  50
14A1:  MOVLP  00
14A2:  MOVLB  00
14A3:  CALL   6AC
14A4:  MOVLP  10
14A5:  MOVLB  02
14A6:  MOVF   34,W
14A7:  MOVWF  50
14A8:  MOVLW  1B
14A9:  MOVWF  51
14AA:  MOVLP  00
14AB:  MOVLB  00
14AC:  CALL   720
14AD:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
14AE:  MOVLW  02
14AF:  MOVLB  03
14B0:  MOVWF  11
14B1:  MOVLW  04
14B2:  MOVWF  12
14B3:  BCF    03.0
14B4:  MOVLW  10
14B5:  MOVLB  02
14B6:  MOVWF  50
14B7:  MOVLP  00
14B8:  MOVLB  00
14B9:  CALL   6AC
14BA:  MOVLP  10
14BB:  MOVLB  02
14BC:  MOVF   33,W
14BD:  MOVWF  50
14BE:  MOVLW  1B
14BF:  MOVWF  51
14C0:  MOVLP  00
14C1:  MOVLB  00
14C2:  CALL   720
14C3:  MOVLP  10
14C4:  MOVLW  0A
14C5:  CLRWDT
14C6:  BTFSS  11.4
14C7:  GOTO   4C5
14C8:  MOVLB  03
14C9:  MOVWF  1A
14CA:  MOVLW  0D
14CB:  CLRWDT
14CC:  MOVLB  00
14CD:  BTFSC  11.4
14CE:  GOTO   4D1
14CF:  MOVLB  03
14D0:  GOTO   4CB
14D1:  MOVLB  03
14D2:  MOVWF  1A
....................   pot_values_to_lcd(); 
14D3:  MOVLP  08
14D4:  MOVLB  00
14D5:  CALL   257
14D6:  MOVLP  10
....................   PROMPT_FLAG=1; 
14D7:  MOVLB  01
14D8:  BSF    5D.6
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0A57:  MOVLW  20
0A58:  MOVLB  02
0A59:  MOVWF  42
0A5A:  MOVWF  43
0A5B:  MOVWF  44
0A5C:  MOVWF  45
....................   unsigned pval[4]={0,0,0,0}; 
0A5D:  CLRF   46
0A5E:  CLRF   47
0A5F:  CLRF   48
0A60:  CLRF   49
....................   delay_ms(40); 
0A61:  MOVLW  28
0A62:  MOVWF  4A
0A63:  MOVLP  00
0A64:  MOVLB  00
0A65:  CALL   7DA
0A66:  MOVLP  08
....................   i2c_start(); 
0A67:  MOVLB  04
0A68:  BSF    16.0
0A69:  BTFSC  16.0
0A6A:  GOTO   269
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0A6B:  MOVLW  51
0A6C:  MOVLB  02
0A6D:  MOVWF  50
0A6E:  MOVLP  00
0A6F:  MOVLB  00
0A70:  CALL   697
0A71:  MOVLP  08
0A72:  MOVF   78,W
0A73:  MOVLB  02
0A74:  BCF    41.1
0A75:  BTFSC  78.0
0A76:  BSF    41.1
....................   for(x=0;x<4;x++) { 
0A77:  CLRF   3F
0A78:  MOVF   3F,W
0A79:  SUBLW  03
0A7A:  BTFSS  03.0
0A7B:  GOTO   2B5
....................     if(x==3) { 
0A7C:  MOVF   3F,W
0A7D:  SUBLW  03
0A7E:  BTFSS  03.2
0A7F:  GOTO   282
....................       ack=0; 
0A80:  BCF    41.0
....................     } else { 
0A81:  GOTO   283
....................       ack=1; 
0A82:  BSF    41.0
....................     } 
....................     pot_val=i2c_read(ack); 
0A83:  MOVLW  00
0A84:  BTFSC  41.0
0A85:  MOVLW  01
0A86:  MOVWF  4A
0A87:  MOVF   4A,W
0A88:  MOVWF  77
*
0A97:  MOVF   78,W
0A98:  MOVLB  02
0A99:  MOVWF  40
....................     pot_val=pot_val&0x3F; 
0A9A:  MOVLW  3F
0A9B:  ANDWF  40,F
....................     pval[x]=pot_val; 
0A9C:  MOVLW  C6
0A9D:  ADDWF  3F,W
0A9E:  MOVWF  04
0A9F:  MOVLW  20
0AA0:  MOVWF  05
0AA1:  BTFSC  03.0
0AA2:  INCF   05,F
0AA3:  MOVF   40,W
0AA4:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0AA5:  MOVF   74,W
0AA6:  ANDLW  03
0AA7:  SUBWF  3F,W
0AA8:  BTFSS  03.2
0AA9:  GOTO   2B3
....................       c[x] = '*'; 
0AAA:  MOVLW  C2
0AAB:  ADDWF  3F,W
0AAC:  MOVWF  04
0AAD:  MOVLW  20
0AAE:  MOVWF  05
0AAF:  BTFSC  03.0
0AB0:  INCF   05,F
0AB1:  MOVLW  2A
0AB2:  MOVWF  00
....................     } 
....................   } 
0AB3:  INCF   3F,F
0AB4:  GOTO   278
....................   i2c_stop(); 
0AB5:  MOVLB  04
0AB6:  BSF    16.2
0AB7:  BTFSC  16.2
0AB8:  GOTO   2B7
....................   delay_ms(50); 
0AB9:  MOVLW  32
0ABA:  MOVLB  02
0ABB:  MOVWF  4A
0ABC:  MOVLP  00
0ABD:  MOVLB  00
0ABE:  CALL   7DA
0ABF:  MOVLP  08
....................   if ( ack_in!=0 ) { 
0AC0:  MOVLB  02
0AC1:  BTFSS  41.1
0AC2:  GOTO   2DE
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0AC3:  MOVLW  00
0AC4:  BTFSC  41.0
0AC5:  MOVLW  01
0AC6:  MOVWF  4A
0AC7:  MOVLW  0D
0AC8:  MOVLB  03
0AC9:  MOVWF  11
0ACA:  MOVLW  04
0ACB:  MOVWF  12
0ACC:  BCF    03.0
0ACD:  MOVLW  25
0ACE:  MOVLB  02
0ACF:  MOVWF  50
0AD0:  MOVLP  00
0AD1:  MOVLB  00
0AD2:  CALL   6AC
0AD3:  MOVLP  08
0AD4:  MOVLB  02
0AD5:  MOVF   4A,W
0AD6:  MOVWF  50
0AD7:  MOVLW  1B
0AD8:  MOVWF  51
0AD9:  MOVLP  00
0ADA:  MOVLB  00
0ADB:  CALL   720
0ADC:  MOVLP  08
0ADD:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0ADE:  MOVLW  20
0ADF:  MOVLB  01
0AE0:  MOVWF  64
0AE1:  MOVLW  76
0AE2:  MOVWF  63
0AE3:  MOVLW  21
0AE4:  MOVLB  03
0AE5:  MOVWF  11
0AE6:  MOVLW  04
0AE7:  MOVWF  12
0AE8:  BCF    03.0
0AE9:  MOVLW  04
0AEA:  MOVLB  02
0AEB:  MOVWF  4A
0AEC:  MOVLB  00
0AED:  CALL   10B
0AEE:  MOVLB  02
0AEF:  MOVF   42,W
0AF0:  MOVWF  50
0AF1:  MOVLB  00
0AF2:  CALL   0FC
0AF3:  MOVLB  02
0AF4:  MOVF   46,W
0AF5:  MOVWF  4A
0AF6:  MOVLW  18
0AF7:  MOVWF  4B
0AF8:  MOVLB  00
0AF9:  CALL   1D6
0AFA:  MOVLW  20
0AFB:  MOVLB  02
0AFC:  MOVWF  50
0AFD:  MOVLB  00
0AFE:  CALL   0FC
0AFF:  MOVLB  02
0B00:  MOVF   43,W
0B01:  MOVWF  50
0B02:  MOVLB  00
0B03:  CALL   0FC
0B04:  MOVLB  02
0B05:  MOVF   47,W
0B06:  MOVWF  4A
0B07:  MOVLW  18
0B08:  MOVWF  4B
0B09:  MOVLB  00
0B0A:  CALL   1D6
0B0B:  MOVLW  20
0B0C:  MOVLB  02
0B0D:  MOVWF  50
0B0E:  MOVLB  00
0B0F:  CALL   0FC
0B10:  MOVLB  02
0B11:  MOVF   44,W
0B12:  MOVWF  50
0B13:  MOVLB  00
0B14:  CALL   0FC
0B15:  MOVLB  02
0B16:  MOVF   48,W
0B17:  MOVWF  4A
0B18:  MOVLW  18
0B19:  MOVWF  4B
0B1A:  MOVLB  00
0B1B:  CALL   1D6
0B1C:  MOVLW  20
0B1D:  MOVLB  02
0B1E:  MOVWF  50
0B1F:  MOVLB  00
0B20:  CALL   0FC
0B21:  MOVLB  02
0B22:  MOVF   45,W
0B23:  MOVWF  50
0B24:  MOVLB  00
0B25:  CALL   0FC
0B26:  MOVLB  02
0B27:  MOVF   49,W
0B28:  MOVWF  4A
0B29:  MOVLW  18
0B2A:  MOVWF  4B
0B2B:  MOVLB  00
0B2C:  CALL   1D6
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0B2D:  MOVLB  02
0B2E:  CLRF   4A
0B2F:  MOVLW  20
0B30:  MOVWF  4C
0B31:  MOVLW  76
0B32:  MOVWF  4B
0B33:  MOVLB  00
0B34:  CALL   173
....................   printf("\n\r%s",LCD_str); 
0B35:  MOVLW  0A
0B36:  CLRWDT
0B37:  BTFSS  11.4
0B38:  GOTO   336
0B39:  MOVLB  03
0B3A:  MOVWF  1A
0B3B:  MOVLW  0D
0B3C:  CLRWDT
0B3D:  MOVLB  00
0B3E:  BTFSC  11.4
0B3F:  GOTO   342
0B40:  MOVLB  03
0B41:  GOTO   33C
0B42:  MOVLB  03
0B43:  MOVWF  1A
0B44:  MOVLW  20
0B45:  MOVWF  05
0B46:  MOVLW  76
0B47:  MOVWF  04
0B48:  MOVLB  00
0B49:  CALL   23D
....................  
.................... } // }}} 
0B4A:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
108A:  MOVLB  01
108B:  BTFSS  5D.7
108C:  GOTO   098
....................     printf("\n\n\rADMIN> "); 
108D:  MOVLW  2D
108E:  MOVLB  03
108F:  MOVWF  11
1090:  MOVLW  04
1091:  MOVWF  12
1092:  MOVLP  00
1093:  MOVLB  00
1094:  CALL   4BB
1095:  MOVLP  10
....................   } else { 
1096:  GOTO   0A1
1097:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
1098:  MOVLW  33
1099:  MOVLB  03
109A:  MOVWF  11
109B:  MOVLW  04
109C:  MOVWF  12
109D:  MOVLP  00
109E:  MOVLB  00
109F:  CALL   4BB
10A0:  MOVLP  10
....................   } 
.................... } // }}} 
10A1:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
04A1:  MOVLW  10
04A2:  MOVLB  01
04A3:  MOVWF  66
....................   for (x=0;x<char_num;x++) { 
04A4:  CLRF   65
04A5:  MOVF   66,W
04A6:  SUBWF  65,W
04A7:  BTFSC  03.0
04A8:  GOTO   4B3
....................     sBuffer[x]='\0'; 
04A9:  MOVLW  50
04AA:  ADDWF  65,W
04AB:  MOVWF  04
04AC:  MOVLW  20
04AD:  MOVWF  05
04AE:  BTFSC  03.0
04AF:  INCF   05,F
04B0:  CLRF   00
....................   } 
04B1:  INCF   65,F
04B2:  GOTO   4A5
....................   sBufferIndex=0; 
04B3:  CLRF   71
....................   sBufferFlag=0;   
04B4:  BCF    72.0
....................   argument=-1; 
04B5:  MOVLW  FF
04B6:  MOVWF  75
....................   argument_name[0]='\0'; 
04B7:  CLRF   40
....................   command=0; 
04B8:  CLRF   70
.................... } // }}} 
04B9:  MOVLB  00
04BA:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
063E:  MOVLW  00
063F:  MOVLB  01
0640:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
0641:  MOVLB  02
0642:  BCF    45.0
0643:  MOVF   43,W
0644:  ANDLW  0F
0645:  ANDLW  01
0646:  BTFSS  03.2
0647:  BSF    45.0
....................   output_bit(DTMF_D0,dbit); 
0648:  BTFSC  45.0
0649:  GOTO   64C
064A:  BCF    0F.0
064B:  GOTO   64D
064C:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
064D:  BCF    45.0
064E:  MOVF   43,W
064F:  ANDLW  0F
0650:  ANDLW  02
0651:  BTFSS  03.2
0652:  BSF    45.0
....................   output_bit(DTMF_D1,dbit); 
0653:  BTFSC  45.0
0654:  GOTO   657
0655:  BCF    0F.1
0656:  GOTO   658
0657:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
0658:  BCF    45.0
0659:  MOVF   43,W
065A:  ANDLW  0F
065B:  ANDLW  04
065C:  BTFSS  03.2
065D:  BSF    45.0
....................   output_bit(DTMF_D2,dbit); 
065E:  BTFSC  45.0
065F:  GOTO   662
0660:  BCF    0F.2
0661:  GOTO   663
0662:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
0663:  BCF    45.0
0664:  MOVF   43,W
0665:  ANDLW  0F
0666:  ANDLW  08
0667:  BTFSS  03.2
0668:  BSF    45.0
....................   output_bit(DTMF_D3,dbit); 
0669:  BTFSC  45.0
066A:  GOTO   66D
066B:  BCF    0F.3
066C:  GOTO   66E
066D:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
066E:  MOVF   44,F
066F:  BTFSS  03.2
0670:  GOTO   673
0671:  BCF    0F.6
0672:  GOTO   674
0673:  BSF    0F.6
....................   delay_cycles(2); 
0674:  GOTO   675
....................   output_bit(DTMF_WEB,0); 
0675:  BCF    0F.5
....................   delay_cycles(2); 
0676:  GOTO   677
....................   output_bit(DTMF_WEB,1);   
0677:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
0678:  GOTO   679
....................   set_tris_d(0x0F); 
0679:  MOVLW  0F
067A:  MOVLB  01
067B:  MOVWF  0F
.................... } // }}} 
067C:  MOVLB  00
067D:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
067E:  MOVLW  0F
067F:  MOVLB  01
0680:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
0681:  MOVLB  02
0682:  MOVF   3B,F
0683:  BTFSS  03.2
0684:  GOTO   687
0685:  BCF    0F.6
0686:  GOTO   688
0687:  BSF    0F.6
....................   delay_cycles(1); 
0688:  NOP
....................   output_bit(DTMF_REB,0); 
0689:  BCF    0F.4
....................   delay_cycles(1); 
068A:  NOP
....................   value=input_d(); 
068B:  MOVLB  00
068C:  MOVF   0F,W
068D:  MOVLB  02
068E:  MOVWF  3C
....................   value&=0x0F; 
068F:  MOVLW  0F
0690:  ANDWF  3C,F
....................   output_bit(DTMF_REB,1); 
0691:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
0692:  NOP
....................   return(value); 
0693:  MOVF   3C,W
0694:  MOVWF  78
.................... } // }}} 
0695:  MOVLB  00
0696:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0CED:  MOVLB  02
0CEE:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0CEF:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0CF0:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0CF1:  CLRF   43
0CF2:  MOVLW  01
0CF3:  MOVWF  44
0CF4:  MOVLP  00
0CF5:  MOVLB  00
0CF6:  CALL   63E
0CF7:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0CF8:  MOVLB  02
0CF9:  CLRF   43
0CFA:  MOVLW  01
0CFB:  MOVWF  44
0CFC:  MOVLP  00
0CFD:  MOVLB  00
0CFE:  CALL   63E
0CFF:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0D00:  MOVLW  0C
0D01:  MOVLB  02
0D02:  MOVWF  43
0D03:  MOVLW  01
0D04:  MOVWF  44
0D05:  MOVLP  00
0D06:  MOVLB  00
0D07:  CALL   63E
0D08:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0D09:  MOVLW  01
0D0A:  MOVLB  02
0D0B:  MOVWF  43
0D0C:  MOVWF  44
0D0D:  MOVLP  00
0D0E:  MOVLB  00
0D0F:  CALL   63E
0D10:  MOVLP  08
....................     dtmf_read(CONTROL_REG); 
0D11:  MOVLW  01
0D12:  MOVLB  02
0D13:  MOVWF  3B
0D14:  MOVLP  00
0D15:  MOVLB  00
0D16:  CALL   67E
0D17:  MOVLP  08
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19EC:  MOVF   40,W
19ED:  MOVWF  43
19EE:  CLRF   44
19EF:  MOVLP  00
19F0:  MOVLB  00
19F1:  CALL   63E
19F2:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19F3:  MOVLW  0C
19F4:  MOVLB  02
19F5:  MOVWF  43
19F6:  MOVLW  01
19F7:  MOVWF  44
19F8:  MOVLP  00
19F9:  MOVLB  00
19FA:  CALL   63E
19FB:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
19FC:  MOVLW  01
19FD:  MOVLB  02
19FE:  MOVWF  43
19FF:  MOVWF  44
1A00:  MOVLP  00
1A01:  MOVLB  00
1A02:  CALL   63E
1A03:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A04:  MOVLW  05
1A05:  MOVLB  02
1A06:  MOVWF  43
1A07:  MOVLW  01
1A08:  MOVWF  44
1A09:  MOVLP  00
1A0A:  MOVLB  00
1A0B:  CALL   63E
1A0C:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A0D:  MOVLB  01
1A0E:  CLRF   33
1A0F:  MOVLW  10
1A10:  MOVWF  32
....................   while(aux_timer) { 
1A11:  MOVF   32,W
1A12:  IORWF  33,W
1A13:  BTFSC  03.2
1A14:  GOTO   217
....................     delay_cycles(1); 
1A15:  NOP
....................   } 
1A16:  GOTO   211
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A17:  MOVLW  04
1A18:  MOVLB  02
1A19:  MOVWF  43
1A1A:  MOVLW  01
1A1B:  MOVWF  44
1A1C:  MOVLP  00
1A1D:  MOVLB  00
1A1E:  CALL   63E
1A1F:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
0813:  MOVLW  01
0814:  MOVLB  02
0815:  MOVWF  43
0816:  CLRF   44
0817:  MOVLP  00
0818:  MOVLB  00
0819:  CALL   63E
081A:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
081B:  MOVLW  0C
081C:  MOVLB  02
081D:  MOVWF  43
081E:  MOVLW  01
081F:  MOVWF  44
0820:  MOVLP  00
0821:  MOVLB  00
0822:  CALL   63E
0823:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0824:  MOVLW  05
0825:  MOVLB  02
0826:  MOVWF  43
0827:  MOVLW  01
0828:  MOVWF  44
0829:  MOVLP  00
082A:  MOVLB  00
082B:  CALL   63E
082C:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
082D:  MOVLW  05
082E:  MOVLB  02
082F:  MOVWF  43
0830:  MOVLW  01
0831:  MOVWF  44
0832:  MOVLP  00
0833:  MOVLB  00
0834:  CALL   63E
0835:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
0836:  MOVLB  01
0837:  CLRF   33
0838:  MOVLW  02
0839:  MOVWF  32
....................   while(aux_timer) { 
083A:  MOVF   32,W
083B:  IORWF  33,W
083C:  BTFSC  03.2
083D:  GOTO   040
....................     delay_cycles(1); 
083E:  NOP
....................   } 
083F:  GOTO   03A
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0840:  MOVLW  04
0841:  MOVLB  02
0842:  MOVWF  43
0843:  MOVLW  01
0844:  MOVWF  44
0845:  MOVLP  00
0846:  MOVLB  00
0847:  CALL   63E
0848:  MOVLP  08
....................   restart_wdt(); 
0849:  CLRWDT
.................... } // }}} 
084A:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
084B:  MOVLW  01
084C:  MOVLB  02
084D:  MOVWF  43
084E:  CLRF   44
084F:  MOVLP  00
0850:  MOVLB  00
0851:  CALL   63E
0852:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0853:  MOVLW  0C
0854:  MOVLB  02
0855:  MOVWF  43
0856:  MOVLW  01
0857:  MOVWF  44
0858:  MOVLP  00
0859:  MOVLB  00
085A:  CALL   63E
085B:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
085C:  MOVLW  05
085D:  MOVLB  02
085E:  MOVWF  43
085F:  MOVLW  01
0860:  MOVWF  44
0861:  MOVLP  00
0862:  MOVLB  00
0863:  CALL   63E
0864:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0865:  MOVLW  05
0866:  MOVLB  02
0867:  MOVWF  43
0868:  MOVLW  01
0869:  MOVWF  44
086A:  MOVLP  00
086B:  MOVLB  00
086C:  CALL   63E
086D:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
086E:  MOVLB  01
086F:  CLRF   33
0870:  MOVLW  06
0871:  MOVWF  32
....................   while(aux_timer) { 
0872:  MOVF   32,W
0873:  IORWF  33,W
0874:  BTFSC  03.2
0875:  GOTO   078
....................     delay_cycles(1); 
0876:  NOP
....................   } 
0877:  GOTO   072
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0878:  MOVLW  04
0879:  MOVLB  02
087A:  MOVWF  43
087B:  MOVLW  01
087C:  MOVWF  44
087D:  MOVLP  00
087E:  MOVLB  00
087F:  CALL   63E
0880:  MOVLP  08
....................   restart_wdt(); 
0881:  CLRWDT
.................... } // }}} 
0882:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
0510:  MOVLB  02
0511:  MOVF   38,W
0512:  MOVWF  04
0513:  MOVF   39,W
0514:  MOVWF  05
0515:  MOVF   00,W
0516:  MOVWF  3B
....................   if ( tmp > 127 ) { 
0517:  MOVF   3B,W
0518:  SUBLW  7F
0519:  BTFSS  03.0
....................     tmp++; 
051A:  INCF   3B,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
051B:  BCF    03.0
051C:  RLF    3B,W
051D:  XORLW  09
051E:  ADDWF  3A,W
051F:  MOVWF  3B
....................   *cksum=tmp; 
0520:  MOVF   38,W
0521:  MOVWF  04
0522:  MOVF   39,W
0523:  MOVWF  05
0524:  MOVF   3B,W
0525:  MOVWF  00
.................... } // }}} 
0526:  MOVLB  00
0527:  RETURN
.................... void print_dtmf_info(void) { // {{{ 
....................   unsigned int x; 
....................   char dtmf; 
....................   char tmp[5]; 
....................   strcpy(LCD_str,"DTMF:"); 
*
1D90:  MOVLB  01
1D91:  CLRF   6C
1D92:  CLRF   6D
1D93:  MOVLW  20
1D94:  MOVWF  05
1D95:  MOVLW  76
1D96:  MOVWF  04
1D97:  MOVF   6C,W
1D98:  ADDWF  04,F
1D99:  MOVLW  00
1D9A:  ADDWFC 05,F
1D9B:  MOVF   6D,W
1D9C:  MOVLP  00
1D9D:  MOVLB  00
1D9E:  CALL   139
1D9F:  MOVLP  18
1DA0:  MOVWF  00
1DA1:  IORLW  00
1DA2:  BTFSC  03.2
1DA3:  GOTO   5A9
1DA4:  MOVLB  01
1DA5:  INCF   6D,F
1DA6:  INCF   6C,F
1DA7:  GOTO   593
1DA8:  MOVLB  00
....................   printf("\n\rDTMF="); 
1DA9:  MOVLW  3A
1DAA:  MOVLB  03
1DAB:  MOVWF  11
1DAC:  MOVLW  04
1DAD:  MOVWF  12
1DAE:  MOVLP  00
1DAF:  MOVLB  00
1DB0:  CALL   4BB
1DB1:  MOVLP  18
....................   for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1DB2:  MOVLB  01
1DB3:  CLRF   65
1DB4:  MOVF   65,W
1DB5:  SUBLW  09
1DB6:  BTFSS  03.0
1DB7:  GOTO   600
....................     if(DTMF_ARRAY[x].Strobe) { 
1DB8:  MOVLW  64
1DB9:  ADDWF  65,W
1DBA:  MOVWF  04
1DBB:  MOVLW  20
1DBC:  MOVWF  05
1DBD:  BTFSC  03.0
1DBE:  INCF   05,F
1DBF:  BTFSS  00.4
1DC0:  GOTO   5FD
....................       dtmf=(int)DTMF_ARRAY[x].Key; 
1DC1:  MOVLW  64
1DC2:  ADDWF  65,W
1DC3:  MOVWF  04
1DC4:  MOVLW  20
1DC5:  MOVWF  05
1DC6:  BTFSC  03.0
1DC7:  INCF   05,F
1DC8:  MOVF   00,W
1DC9:  ANDLW  0F
1DCA:  MOVWF  66
....................       sprintf(tmp,"%d ",dtmf); 
1DCB:  MOVLW  20
1DCC:  MOVWF  64
1DCD:  MOVLW  97
1DCE:  MOVWF  63
1DCF:  MOVF   66,W
1DD0:  MOVLB  02
1DD1:  MOVWF  4A
1DD2:  MOVLW  18
1DD3:  MOVWF  4B
1DD4:  MOVLP  08
1DD5:  MOVLB  00
1DD6:  CALL   1D6
1DD7:  MOVLP  18
1DD8:  MOVLW  20
1DD9:  MOVLB  02
1DDA:  MOVWF  50
1DDB:  MOVLP  08
1DDC:  MOVLB  00
1DDD:  CALL   0FC
1DDE:  MOVLP  18
....................       strcat(LCD_str,tmp); 
1DDF:  MOVLW  20
1DE0:  MOVLB  02
1DE1:  MOVWF  29
1DE2:  MOVLW  76
1DE3:  MOVWF  28
1DE4:  MOVLW  20
1DE5:  MOVWF  2B
1DE6:  MOVLW  97
1DE7:  MOVWF  2A
1DE8:  MOVLP  10
1DE9:  MOVLB  00
1DEA:  CALL   63E
1DEB:  MOVLP  18
....................       printf(" %u",dtmf); 
1DEC:  MOVLW  20
1DED:  CLRWDT
1DEE:  BTFSS  11.4
1DEF:  GOTO   5ED
1DF0:  MOVLB  03
1DF1:  MOVWF  1A
1DF2:  MOVLB  01
1DF3:  MOVF   66,W
1DF4:  MOVLB  02
1DF5:  MOVWF  50
1DF6:  MOVLW  1B
1DF7:  MOVWF  51
1DF8:  MOVLP  00
1DF9:  MOVLB  00
1DFA:  CALL   720
1DFB:  MOVLP  18
1DFC:  MOVLB  01
....................     } 
....................   restart_wdt(); 
1DFD:  CLRWDT
....................   } 
1DFE:  INCF   65,F
1DFF:  GOTO   5B4
....................   printf("\n\r"); 
1E00:  MOVLW  0A
1E01:  CLRWDT
1E02:  MOVLB  00
1E03:  BTFSC  11.4
1E04:  GOTO   607
1E05:  MOVLB  01
1E06:  GOTO   601
1E07:  MOVLB  03
1E08:  MOVWF  1A
1E09:  MOVLW  0D
1E0A:  CLRWDT
1E0B:  MOVLB  00
1E0C:  BTFSC  11.4
1E0D:  GOTO   610
1E0E:  MOVLB  03
1E0F:  GOTO   60A
1E10:  MOVLB  03
1E11:  MOVWF  1A
....................   PROMPT_FLAG=1; 
1E12:  MOVLB  01
1E13:  BSF    5D.6
....................   lcd_send(2,LCD_str); // Send DTMF on line 3 
1E14:  MOVLW  02
1E15:  MOVLB  02
1E16:  MOVWF  4A
1E17:  MOVLW  20
1E18:  MOVWF  4C
1E19:  MOVLW  76
1E1A:  MOVWF  4B
1E1B:  MOVLP  08
1E1C:  MOVLB  00
1E1D:  CALL   173
1E1E:  MOVLP  18
.................... } // }}} 
1E1F:  MOVLP  18
1E20:  GOTO   773 (RETURN)
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
*
0528:  MOVLW  01
0529:  MOVLB  02
052A:  MOVWF  32
....................   eeprom_index=0; 
052B:  CLRF   33
....................   retVal = 1; 
052C:  MOVWF  35
....................   if ( source == USE_EEPROM_VARS ) { 
052D:  DECFSZ 2E,W
052E:  GOTO   538
....................     printf("\n\rInit RAM <= EEPROM"); 
052F:  MOVLW  3E
0530:  MOVLB  03
0531:  MOVWF  11
0532:  MOVLW  04
0533:  MOVWF  12
0534:  MOVLB  00
0535:  CALL   4BB
....................   } else { 
0536:  GOTO   53F
0537:  MOVLB  02
....................     printf("\n\rInit RAM <= HW Defaults"); 
0538:  MOVLW  49
0539:  MOVLB  03
053A:  MOVWF  11
053B:  MOVLW  04
053C:  MOVWF  12
053D:  MOVLB  00
053E:  CALL   4BB
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
053F:  MOVLB  02
0540:  CLRF   2F
0541:  MOVF   2F,W
0542:  SUBLW  38
0543:  BTFSS  03.0
0544:  GOTO   59E
....................     regPtr=RegMap[x].reg_ptr; 
0545:  RLF    2F,W
0546:  MOVWF  77
0547:  RLF    77,F
0548:  MOVLW  FC
0549:  ANDWF  77,F
054A:  MOVF   77,W
054B:  MOVWF  37
054C:  INCF   37,W
054D:  MOVLB  00
054E:  CALL   043
054F:  MOVWF  7A
0550:  MOVLB  02
0551:  MOVF   37,W
0552:  MOVLB  00
0553:  CALL   043
0554:  MOVLB  02
0555:  MOVWF  30
0556:  MOVF   7A,W
0557:  MOVWF  31
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
0558:  DECFSZ 2E,W
0559:  GOTO   58A
055A:  RLF    2F,W
055B:  MOVWF  77
055C:  RLF    77,F
055D:  MOVLW  FC
055E:  ANDWF  77,F
055F:  MOVF   77,W
0560:  ADDLW  03
0561:  MOVLB  00
0562:  CALL   043
0563:  MOVWF  78
0564:  BTFSC  78.0
0565:  GOTO   568
0566:  MOVLB  02
0567:  GOTO   58A
....................       eeprom_val=read_eeprom(eeprom_index); 
0568:  MOVLB  02
0569:  MOVF   33,W
056A:  MOVLB  03
056B:  MOVWF  11
056C:  BCF    15.7
056D:  BSF    15.0
056E:  MOVF   13,W
056F:  MOVLB  02
0570:  MOVWF  36
....................       *regPtr=eeprom_val; 
0571:  MOVF   30,W
0572:  MOVWF  04
0573:  MOVF   31,W
0574:  MOVWF  05
0575:  MOVF   36,W
0576:  MOVWF  00
....................       update_checksum(&cksum,*regPtr);     
0577:  MOVF   31,W
0578:  MOVWF  7A
0579:  MOVF   30,W
057A:  MOVWF  04
057B:  MOVF   31,W
057C:  MOVWF  05
057D:  MOVF   00,W
057E:  MOVWF  37
057F:  MOVLW  20
0580:  MOVWF  39
0581:  MOVLW  B2
0582:  MOVWF  38
0583:  MOVF   37,W
0584:  MOVWF  3A
0585:  MOVLB  00
0586:  CALL   510
....................       eeprom_index++; 
0587:  MOVLB  02
0588:  INCF   33,F
....................     } else { 
0589:  GOTO   59C
....................       default_value=(int8)RegMap[x].default_value; 
058A:  RLF    2F,W
058B:  MOVWF  77
058C:  RLF    77,F
058D:  MOVLW  FC
058E:  ANDWF  77,F
058F:  MOVF   77,W
0590:  ADDLW  02
0591:  MOVLB  00
0592:  CALL   043
0593:  MOVWF  78
0594:  MOVLB  02
0595:  MOVWF  34
....................       *regPtr=default_value; 
0596:  MOVF   30,W
0597:  MOVWF  04
0598:  MOVF   31,W
0599:  MOVWF  05
059A:  MOVF   34,W
059B:  MOVWF  00
....................     } 
....................   } 
059C:  INCF   2F,F
059D:  GOTO   541
....................   if ( source == USE_EEPROM_VARS ) { 
059E:  DECFSZ 2E,W
059F:  GOTO   5AA
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
05A0:  MOVF   33,W
05A1:  MOVLB  03
05A2:  MOVWF  11
05A3:  BCF    15.7
05A4:  BSF    15.0
05A5:  MOVF   13,W
05A6:  MOVLB  02
05A7:  SUBWF  32,W
05A8:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
05A9:  CLRF   35
....................     } 
....................   } 
....................   return (retVal); 
05AA:  MOVF   35,W
05AB:  MOVWF  78
.................... } // }}} 
05AC:  MOVLB  00
05AD:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
05AE:  MOVLW  01
05AF:  MOVLB  02
05B0:  MOVWF  32
....................  
....................   eeprom_index=0; 
05B1:  CLRF   2F
....................   for(x=0;x<RegMapNum;x++) { 
05B2:  CLRF   2E
05B3:  MOVF   2E,W
05B4:  SUBLW  38
05B5:  BTFSS  03.0
05B6:  GOTO   60C
....................     regPtr=RegMap[x].reg_ptr; 
05B7:  RLF    2E,W
05B8:  MOVWF  77
05B9:  RLF    77,F
05BA:  MOVLW  FC
05BB:  ANDWF  77,F
05BC:  MOVF   77,W
05BD:  MOVWF  34
05BE:  INCF   34,W
05BF:  MOVLB  00
05C0:  CALL   043
05C1:  MOVWF  7A
05C2:  MOVLB  02
05C3:  MOVF   34,W
05C4:  MOVLB  00
05C5:  CALL   043
05C6:  MOVLB  02
05C7:  MOVWF  30
05C8:  MOVF   7A,W
05C9:  MOVWF  31
....................     if ( RegMap[x].non_volatile ) { 
05CA:  RLF    2E,W
05CB:  MOVWF  77
05CC:  RLF    77,F
05CD:  MOVLW  FC
05CE:  ANDWF  77,F
05CF:  MOVF   77,W
05D0:  ADDLW  03
05D1:  MOVLB  00
05D2:  CALL   043
05D3:  MOVWF  78
05D4:  BTFSS  78.0
05D5:  GOTO   609
....................      value=*regPtr; 
05D6:  MOVLB  02
05D7:  MOVF   30,W
05D8:  MOVWF  04
05D9:  MOVF   31,W
05DA:  MOVWF  05
05DB:  MOVF   00,W
05DC:  MOVWF  33
....................      if ( read_eeprom(eeprom_index) != value ) { 
05DD:  MOVF   2F,W
05DE:  MOVLB  03
05DF:  MOVWF  11
05E0:  BCF    15.7
05E1:  BSF    15.0
05E2:  MOVF   13,W
05E3:  MOVLB  02
05E4:  SUBWF  33,W
05E5:  BTFSC  03.2
05E6:  GOTO   5FE
....................        write_eeprom(eeprom_index,value); 
05E7:  MOVF   0B,W
05E8:  MOVWF  77
05E9:  BCF    0B.7
05EA:  MOVF   2F,W
05EB:  MOVLB  03
05EC:  MOVWF  11
05ED:  MOVLB  02
05EE:  MOVF   33,W
05EF:  MOVLB  03
05F0:  MOVWF  13
05F1:  BCF    15.7
05F2:  BSF    15.2
05F3:  MOVLW  55
05F4:  MOVWF  16
05F5:  MOVLW  AA
05F6:  MOVWF  16
05F7:  BSF    15.1
05F8:  BTFSC  15.1
05F9:  GOTO   5F8
05FA:  BCF    15.2
05FB:  MOVF   77,W
05FC:  IORWF  0B,F
05FD:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
05FE:  MOVLW  20
05FF:  MOVWF  39
0600:  MOVLW  B2
0601:  MOVWF  38
0602:  MOVF   33,W
0603:  MOVWF  3A
0604:  MOVLB  00
0605:  CALL   510
....................      eeprom_index++; 
0606:  MOVLB  02
0607:  INCF   2F,F
0608:  MOVLB  00
....................     } 
....................   } 
0609:  MOVLB  02
060A:  INCF   2E,F
060B:  GOTO   5B3
....................   write_eeprom(eeprom_index,cksum); 
060C:  MOVF   0B,W
060D:  MOVWF  77
060E:  BCF    0B.7
060F:  MOVF   2F,W
0610:  MOVLB  03
0611:  MOVWF  11
0612:  MOVLB  02
0613:  MOVF   32,W
0614:  MOVLB  03
0615:  MOVWF  13
0616:  BCF    15.7
0617:  BSF    15.2
0618:  MOVLW  55
0619:  MOVWF  16
061A:  MOVLW  AA
061B:  MOVWF  16
061C:  BSF    15.1
061D:  BTFSC  15.1
061E:  GOTO   61D
061F:  BCF    15.2
0620:  MOVF   77,W
0621:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
0622:  MOVLW  56
0623:  MOVWF  11
0624:  MOVLW  04
0625:  MOVWF  12
0626:  MOVLB  00
0627:  CALL   4BB
.................... } // }}} 
0628:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
0629:  MOVLB  02
062A:  MOVF   2D,W
062B:  MOVWF  2E
062C:  MOVLB  00
062D:  CALL   528
062E:  MOVF   78,F
062F:  BTFSS  03.2
0630:  GOTO   63D
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
0631:  MOVLW  69
0632:  MOVLB  03
0633:  MOVWF  11
0634:  MOVLW  04
0635:  MOVWF  12
0636:  MOVLB  00
0637:  CALL   4BB
....................         _init_variables(USE_DEFAULT_VARS); 
0638:  MOVLB  02
0639:  CLRF   2E
063A:  MOVLB  00
063B:  CALL   528
....................     store_variables(); 
063C:  CALL   5AE
....................     } 
.................... } // }}} 
063D:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0D2C:  MOVLB  02
0D2D:  CLRF   3F
0D2E:  CLRF   40
0D2F:  MOVLP  00
0D30:  MOVLB  00
0D31:  CALL   76F
0D32:  MOVLP  08
....................   set_trimpot(1,0); 
0D33:  MOVLW  01
0D34:  MOVLB  02
0D35:  MOVWF  3F
0D36:  CLRF   40
0D37:  MOVLP  00
0D38:  MOVLB  00
0D39:  CALL   76F
0D3A:  MOVLP  08
....................   set_trimpot(2,0); 
0D3B:  MOVLW  02
0D3C:  MOVLB  02
0D3D:  MOVWF  3F
0D3E:  CLRF   40
0D3F:  MOVLP  00
0D40:  MOVLB  00
0D41:  CALL   76F
0D42:  MOVLP  08
....................   set_trimpot(3,0); 
0D43:  MOVLW  03
0D44:  MOVLB  02
0D45:  MOVWF  3F
0D46:  CLRF   40
0D47:  MOVLP  00
0D48:  MOVLB  00
0D49:  CALL   76F
0D4A:  MOVLP  08
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0CB6:  MOVLP  00
0CB7:  CALL   4A1
0CB8:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0CB9:  MOVLB  02
0CBA:  CLRF   12
0CBB:  CLRF   11
0CBC:  CLRF   14
0CBD:  CLRF   13
....................   setup_wdt(WDT_2S); 
0CBE:  MOVLW  17
0CBF:  MOVLB  01
0CC0:  MOVWF  17
....................   COR_IN=0; 
0CC1:  MOVLB  00
0CC2:  CLRF   5F
....................   COR_DROP_FLAG=0; 
0CC3:  BCF    72.7
....................   DTMF_IN_FLAG=0; 
0CC4:  MOVLB  01
0CC5:  BCF    5D.3
....................   DTMF_INTERRUPT_FLAG=0; 
0CC6:  BCF    5D.4
....................   LastRegisterIndexValid=0; 
0CC7:  CLRF   7D
....................   LastRegisterIndex=0; 
0CC8:  CLRF   7C
....................   CurrentCorMask=0; 
0CC9:  MOVLB  00
0CCA:  CLRF   6C
....................   CurrentCorPriority=0; 
0CCB:  CLRF   6E
....................   CurrentCorIndex=0; 
0CCC:  CLRF   6D
....................   CurrentTrimPot=0; 
0CCD:  CLRF   74
....................   set_tris_b(0xFF); 
0CCE:  MOVLW  FF
0CCF:  TRIS   6
....................   set_tris_d(0x00); 
0CD0:  MOVLW  00
0CD1:  MOVLB  01
0CD2:  MOVWF  0F
....................   // 0b11111000 
....................   set_tris_e(0xF8); 
0CD3:  BCF    10.0
0CD4:  BCF    10.1
0CD5:  BCF    10.2
0CD6:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0CD7:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0CD8:  BSF    0B.3
0CD9:  MOVLW  CF
0CDA:  MOVLB  07
0CDB:  IORWF  14,F
0CDC:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0CDD:  BSF    0B.3
0CDE:  BSF    15.4
0CDF:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0CE0:  MOVLW  C0
0CE1:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0CE2:  MOVLB  02
0CE3:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0CE4:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0CE5:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0CE6:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0CE7:  MOVLW  01
0CE8:  MOVWF  2D
0CE9:  MOVLP  00
0CEA:  MOVLB  00
0CEB:  CALL   629
0CEC:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D18:  MOVLB  01
0D19:  BSF    5D.5
....................   Enable_Mask = 0x0F; 
0D1A:  MOVLW  0F
0D1B:  MOVLB  00
0D1C:  MOVWF  61
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D1D:  MOVF   62,W
0D1E:  ANDLW  0F
0D1F:  IORLW  C0
0D20:  MOVLB  04
0D21:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D22:  MOVLB  01
0D23:  BCF    15.7
....................   // }}} 
....................   header(); 
0D24:  MOVLP  00
0D25:  MOVLB  00
0D26:  CALL   003
0D27:  MOVLP  08
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D28:  MOVLW  9D
0D29:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0D2A:  MOVLW  80
0D2B:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0D4B:  MOVLB  01
0D4C:  CLRF   31
0D4D:  MOVLW  1E
0D4E:  MOVWF  30
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0D4F:  MOVF   15,W
0D50:  ANDLW  C0
0D51:  IORLW  07
0D52:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0D53:  BSF    0B.5
....................   update_ptt(0); 
0D54:  MOVLB  02
0D55:  CLRF   2E
0D56:  MOVLB  00
0D57:  CALL   34B
....................   MinuteCounter=MIN_COUNTER; 
0D58:  MOVLW  1D
0D59:  MOVLB  01
0D5A:  MOVWF  5F
....................   SecondCounter=SEC_COUNTER; 
0D5B:  MOVLW  3B
0D5C:  MOVWF  5E
....................   THIRTY_MIN_FLAG=0; 
0D5D:  BCF    72.6
....................   MINUTE_FLAG=0; 
0D5E:  BCF    72.5
....................   PROMPT_FLAG=1; 
0D5F:  BSF    5D.6
....................   TailChar=Tail; 
0D60:  MOVLB  00
0D61:  MOVF   65,W
0D62:  MOVWF  6A
....................   ConfirmChar=0; 
0D63:  CLRF   6B
....................   //AuxOut[0] = PO_AUX_OUT0; 
....................   //AuxOut[1] = PO_AUX_OUT1; 
....................   //AuxOut[2] = PO_AUX_OUT2; 
....................   AuxInSW[0] = 0; 
0D64:  CLRF   3F
....................   AuxInSW[1] = 0; 
0D65:  CLRF   40
....................   AuxInSW[2] = 0; 
0D66:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0D67:  MOVLB  01
0D68:  BCF    5D.0
....................   COR_IN_EFFECTIVE=0; 
0D69:  MOVLB  00
0D6A:  CLRF   6F
....................   set_admin_mode(0); 
0D6B:  MOVLB  02
0D6C:  CLRF   40
0D6D:  MOVLB  00
0D6E:  CALL   49F
....................   rs232_mode=0; 
0D6F:  MOVLB  01
0D70:  BCF    62.0
....................   button_state=0; 
0D71:  CLRF   5C
.................... #ifdef LCD_TYPE_PI 
....................   init_lcd(); 
.................... #endif 
....................   setup_adc(ADC_CLOCK_INTERNAL); 
0D72:  BSF    1E.4
0D73:  BSF    1E.5
0D74:  BCF    1E.6
0D75:  BCF    1E.7
0D76:  BSF    1D.0
....................   setup_adc_ports(ADJ_POT|VSS_VDD); 
0D77:  BCF    1E.0
0D78:  BCF    1E.1
0D79:  BCF    1E.2
0D7A:  MOVLW  00
0D7B:  MOVLB  03
0D7C:  MOVWF  0C
0D7D:  MOVWF  10
0D7E:  MOVLW  20
0D7F:  MOVWF  0D
0D80:  MOVLW  00
0D81:  MOVWF  0F
....................   set_adc_channel(13); 
0D82:  MOVLW  34
0D83:  MOVWF  78
0D84:  MOVLB  01
0D85:  MOVF   1D,W
0D86:  ANDLW  83
0D87:  IORWF  78,W
0D88:  MOVWF  1D
....................  
.................... //  setup_adc_ports(ADJ_POT); 
.................... //  set_adc_channel(13); 
.................... //  printf("\n\rInitialization complete"); 
.................... } // }}} 
0D89:  MOVLP  18
0D8A:  MOVLB  00
0D8B:  GOTO   747 (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180D:  MOVLB  02
180E:  BCF    28.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
180F:  CLRF   3F
1810:  CLRF   40
1811:  MOVLW  20
1812:  MOVWF  05
1813:  MOVLW  AB
1814:  MOVWF  04
1815:  MOVF   3F,W
1816:  ADDWF  04,F
1817:  MOVLW  00
1818:  ADDWFC 05,F
1819:  MOVF   40,W
181A:  MOVLP  00
181B:  MOVLB  00
181C:  CALL   140
181D:  MOVLP  18
181E:  MOVWF  00
181F:  IORLW  00
1820:  BTFSC  03.2
1821:  GOTO   027
1822:  MOVLB  02
1823:  INCF   40,F
1824:  INCF   3F,F
1825:  GOTO   011
1826:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1827:  MOVLW  20
1828:  MOVLB  02
1829:  MOVWF  40
182A:  MOVLW  50
182B:  MOVWF  3F
182C:  MOVLW  20
182D:  MOVWF  42
182E:  MOVLW  AB
182F:  MOVWF  41
1830:  MOVLP  08
1831:  MOVLB  00
1832:  CALL   63C
1833:  MOVLP  18
1834:  MOVF   79,W
1835:  MOVLB  02
1836:  MOVWF  2A
1837:  MOVF   78,W
1838:  MOVWF  29
....................   if (sptr!=0) {; 
1839:  MOVF   29,F
183A:  BTFSS  03.2
183B:  GOTO   03F
183C:  MOVF   2A,F
183D:  BTFSC  03.2
183E:  GOTO   059
....................     strcpy(verb,sptr); 
183F:  MOVF   2A,W
1840:  MOVWF  42
1841:  MOVF   29,W
1842:  MOVWF  41
1843:  MOVLW  20
1844:  MOVWF  40
1845:  MOVLW  A0
1846:  MOVWF  3F
1847:  MOVF   42,W
1848:  MOVWF  05
1849:  MOVF   41,W
184A:  MOVWF  04
184B:  MOVF   00,W
184C:  MOVWF  43
184D:  MOVF   40,W
184E:  MOVWF  05
184F:  MOVF   3F,W
1850:  MOVWF  04
1851:  MOVF   43,W
1852:  MOVWF  00
1853:  MOVF   00,F
1854:  BTFSC  03.2
1855:  GOTO   059
1856:  INCF   3F,F
1857:  INCF   41,F
1858:  GOTO   047
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
1859:  CLRF   40
185A:  CLRF   3F
185B:  MOVLW  20
185C:  MOVWF  42
185D:  MOVLW  AB
185E:  MOVWF  41
185F:  MOVLP  08
1860:  MOVLB  00
1861:  CALL   63C
1862:  MOVLP  18
1863:  MOVF   79,W
1864:  MOVLB  02
1865:  MOVWF  2A
1866:  MOVF   78,W
1867:  MOVWF  29
....................   if (sptr!=0) {; 
1868:  MOVF   29,F
1869:  BTFSS  03.2
186A:  GOTO   06E
186B:  MOVF   2A,F
186C:  BTFSC  03.2
186D:  GOTO   088
....................     strcpy(argument_name,sptr); 
186E:  MOVF   2A,W
186F:  MOVWF  42
1870:  MOVF   29,W
1871:  MOVWF  41
1872:  MOVLW  20
1873:  MOVWF  40
1874:  MOVLW  70
1875:  MOVWF  3F
1876:  MOVF   42,W
1877:  MOVWF  05
1878:  MOVF   41,W
1879:  MOVWF  04
187A:  MOVF   00,W
187B:  MOVWF  43
187C:  MOVF   40,W
187D:  MOVWF  05
187E:  MOVF   3F,W
187F:  MOVWF  04
1880:  MOVF   43,W
1881:  MOVWF  00
1882:  MOVF   00,F
1883:  BTFSC  03.2
1884:  GOTO   088
1885:  INCF   3F,F
1886:  INCF   41,F
1887:  GOTO   076
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1888:  CLRF   40
1889:  CLRF   3F
188A:  MOVLW  20
188B:  MOVWF  42
188C:  MOVLW  AB
188D:  MOVWF  41
188E:  MOVLP  08
188F:  MOVLB  00
1890:  CALL   63C
1891:  MOVLP  18
1892:  MOVF   79,W
1893:  MOVLB  02
1894:  MOVWF  2A
1895:  MOVF   78,W
1896:  MOVWF  29
....................   if (sptr!=0) {; 
1897:  MOVF   29,F
1898:  BTFSS  03.2
1899:  GOTO   09D
189A:  MOVF   2A,F
189B:  BTFSC  03.2
189C:  GOTO   0C3
....................     strcpy(match_val,sptr); 
189D:  MOVF   2A,W
189E:  MOVWF  42
189F:  MOVF   29,W
18A0:  MOVWF  41
18A1:  MOVLW  20
18A2:  MOVWF  40
18A3:  MOVLW  B3
18A4:  MOVWF  3F
18A5:  MOVF   42,W
18A6:  MOVWF  05
18A7:  MOVF   41,W
18A8:  MOVWF  04
18A9:  MOVF   00,W
18AA:  MOVWF  43
18AB:  MOVF   40,W
18AC:  MOVWF  05
18AD:  MOVF   3F,W
18AE:  MOVWF  04
18AF:  MOVF   43,W
18B0:  MOVWF  00
18B1:  MOVF   00,F
18B2:  BTFSC  03.2
18B3:  GOTO   0B7
18B4:  INCF   3F,F
18B5:  INCF   41,F
18B6:  GOTO   0A5
....................     value = str_to_decimal(match_val); 
18B7:  MOVLW  20
18B8:  MOVWF  40
18B9:  MOVLW  B3
18BA:  MOVWF  3F
18BB:  MOVLP  08
18BC:  MOVLB  00
18BD:  CALL   742
18BE:  MOVLP  18
18BF:  MOVF   78,W
18C0:  MOVWF  76
....................   } else { 
18C1:  GOTO   0C6
18C2:  MOVLB  02
....................     value = 0; 
18C3:  CLRF   76
....................     do_get_var = 1; 
18C4:  BSF    28.0
18C5:  MOVLB  00
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18C6:  MOVLB  02
18C7:  CLRF   3F
18C8:  CLRF   40
18C9:  MOVLW  20
18CA:  MOVWF  05
18CB:  MOVLW  B7
18CC:  MOVWF  04
18CD:  MOVF   3F,W
18CE:  ADDWF  04,F
18CF:  MOVLW  00
18D0:  ADDWFC 05,F
18D1:  MOVF   40,W
18D2:  MOVLP  00
18D3:  MOVLB  00
18D4:  CALL   146
18D5:  MOVLP  18
18D6:  MOVWF  00
18D7:  IORLW  00
18D8:  BTFSC  03.2
18D9:  GOTO   0DF
18DA:  MOVLB  02
18DB:  INCF   40,F
18DC:  INCF   3F,F
18DD:  GOTO   0C9
18DE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
18DF:  MOVLW  20
18E0:  MOVLB  02
18E1:  MOVWF  40
18E2:  MOVLW  B7
18E3:  MOVWF  3F
18E4:  MOVLW  20
18E5:  MOVWF  42
18E6:  MOVLW  A0
18E7:  MOVWF  41
18E8:  MOVLP  08
18E9:  MOVLB  00
18EA:  CALL   77B
18EB:  MOVLP  18
18EC:  MOVF   78,F
18ED:  BTFSS  03.2
18EE:  GOTO   0F8
....................     if ( do_get_var ) { 
18EF:  MOVLB  02
18F0:  BTFSS  28.0
18F1:  GOTO   0F5
....................       command=GET_REG; 
18F2:  MOVLW  03
18F3:  MOVWF  70
....................     } else { 
18F4:  GOTO   0F7
....................       command=SET_REG; 
18F5:  MOVLW  02
18F6:  MOVWF  70
18F7:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18F8:  MOVLB  02
18F9:  CLRF   3F
18FA:  CLRF   40
18FB:  MOVLW  20
18FC:  MOVWF  05
18FD:  MOVLW  B7
18FE:  MOVWF  04
18FF:  MOVF   3F,W
1900:  ADDWF  04,F
1901:  MOVLW  00
1902:  ADDWFC 05,F
1903:  MOVF   40,W
1904:  MOVLP  00
1905:  MOVLB  00
1906:  CALL   14B
1907:  MOVLP  18
1908:  MOVWF  00
1909:  IORLW  00
190A:  BTFSC  03.2
190B:  GOTO   111
190C:  MOVLB  02
190D:  INCF   40,F
190E:  INCF   3F,F
190F:  GOTO   0FB
1910:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1911:  MOVLW  20
1912:  MOVLB  02
1913:  MOVWF  40
1914:  MOVLW  B7
1915:  MOVWF  3F
1916:  MOVLW  20
1917:  MOVWF  42
1918:  MOVLW  A0
1919:  MOVWF  41
191A:  MOVLP  08
191B:  MOVLB  00
191C:  CALL   77B
191D:  MOVLP  18
191E:  MOVF   78,F
191F:  BTFSS  03.2
1920:  GOTO   123
....................       command=SAVE_SETTINGS; 
1921:  MOVLW  04
1922:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1923:  MOVLB  02
1924:  CLRF   3F
1925:  CLRF   40
1926:  MOVLW  20
1927:  MOVWF  05
1928:  MOVLW  B7
1929:  MOVWF  04
192A:  MOVF   3F,W
192B:  ADDWF  04,F
192C:  MOVLW  00
192D:  ADDWFC 05,F
192E:  MOVF   40,W
192F:  MOVLP  00
1930:  MOVLB  00
1931:  CALL   151
1932:  MOVLP  18
1933:  MOVWF  00
1934:  IORLW  00
1935:  BTFSC  03.2
1936:  GOTO   13C
1937:  MOVLB  02
1938:  INCF   40,F
1939:  INCF   3F,F
193A:  GOTO   126
193B:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
193C:  MOVLW  20
193D:  MOVLB  02
193E:  MOVWF  40
193F:  MOVLW  B7
1940:  MOVWF  3F
1941:  MOVLW  20
1942:  MOVWF  42
1943:  MOVLW  A0
1944:  MOVWF  41
1945:  MOVLP  08
1946:  MOVLB  00
1947:  CALL   77B
1948:  MOVLP  18
1949:  MOVF   78,F
194A:  BTFSS  03.2
194B:  GOTO   14E
....................       command=RESTORE_SETTINGS; 
194C:  MOVLW  05
194D:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
194E:  MOVLB  02
194F:  CLRF   3F
1950:  CLRF   40
1951:  MOVLW  20
1952:  MOVWF  05
1953:  MOVLW  B7
1954:  MOVWF  04
1955:  MOVF   3F,W
1956:  ADDWF  04,F
1957:  MOVLW  00
1958:  ADDWFC 05,F
1959:  MOVF   40,W
195A:  MOVLP  00
195B:  MOVLB  00
195C:  CALL   15A
195D:  MOVLP  18
195E:  MOVWF  00
195F:  IORLW  00
1960:  BTFSC  03.2
1961:  GOTO   167
1962:  MOVLB  02
1963:  INCF   40,F
1964:  INCF   3F,F
1965:  GOTO   151
1966:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1967:  MOVLW  20
1968:  MOVLB  02
1969:  MOVWF  40
196A:  MOVLW  B7
196B:  MOVWF  3F
196C:  MOVLW  20
196D:  MOVWF  42
196E:  MOVLW  A0
196F:  MOVWF  41
1970:  MOVLP  08
1971:  MOVLB  00
1972:  CALL   77B
1973:  MOVLP  18
1974:  MOVF   78,F
1975:  BTFSS  03.2
1976:  GOTO   179
....................     command=STATUS; 
1977:  MOVLW  08
1978:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
1979:  MOVLB  02
197A:  CLRF   3F
197B:  CLRF   40
197C:  MOVLW  20
197D:  MOVWF  05
197E:  MOVLW  B7
197F:  MOVWF  04
1980:  MOVF   3F,W
1981:  ADDWF  04,F
1982:  MOVLW  00
1983:  ADDWFC 05,F
1984:  MOVF   40,W
1985:  MOVLP  00
1986:  MOVLB  00
1987:  CALL   162
1988:  MOVLP  18
1989:  MOVWF  00
198A:  IORLW  00
198B:  BTFSC  03.2
198C:  GOTO   192
198D:  MOVLB  02
198E:  INCF   40,F
198F:  INCF   3F,F
1990:  GOTO   17C
1991:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1992:  MOVLW  20
1993:  MOVLB  02
1994:  MOVWF  40
1995:  MOVLW  B7
1996:  MOVWF  3F
1997:  MOVLW  20
1998:  MOVWF  42
1999:  MOVLW  A0
199A:  MOVWF  41
199B:  MOVLP  08
199C:  MOVLB  00
199D:  CALL   77B
199E:  MOVLP  18
199F:  MOVF   78,F
19A0:  BTFSS  03.2
19A1:  GOTO   1A6
....................     command=ADMIN; 
19A2:  MOVLW  09
19A3:  MOVWF  70
....................     argument=REBOOT; 
19A4:  MOVLW  02
19A5:  MOVWF  75
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19A6:  MOVLB  02
19A7:  CLRF   3F
19A8:  CLRF   40
19A9:  MOVLW  20
19AA:  MOVWF  05
19AB:  MOVLW  B7
19AC:  MOVWF  04
19AD:  MOVF   3F,W
19AE:  ADDWF  04,F
19AF:  MOVLW  00
19B0:  ADDWFC 05,F
19B1:  MOVF   40,W
19B2:  MOVLP  00
19B3:  MOVLB  00
19B4:  CALL   16A
19B5:  MOVLP  18
19B6:  MOVWF  00
19B7:  IORLW  00
19B8:  BTFSC  03.2
19B9:  GOTO   1BF
19BA:  MOVLB  02
19BB:  INCF   40,F
19BC:  INCF   3F,F
19BD:  GOTO   1A9
19BE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19BF:  MOVLW  20
19C0:  MOVLB  02
19C1:  MOVWF  40
19C2:  MOVLW  B7
19C3:  MOVWF  3F
19C4:  MOVLW  20
19C5:  MOVWF  42
19C6:  MOVLW  A0
19C7:  MOVWF  41
19C8:  MOVLP  08
19C9:  MOVLB  00
19CA:  CALL   77B
19CB:  MOVLP  18
19CC:  MOVF   78,F
19CD:  BTFSS  03.2
19CE:  GOTO   220
....................     //command=DTMF_SEND; 
....................     command=0; 
19CF:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D0:  MOVLW  20
19D1:  MOVLB  02
19D2:  MOVWF  40
19D3:  MOVLW  70
19D4:  MOVWF  3F
19D5:  MOVLP  08
19D6:  MOVLB  00
19D7:  CALL   742
19D8:  MOVLP  18
19D9:  MOVF   78,W
19DA:  MOVWF  76
....................     if ( value == d0 ) { 
19DB:  MOVF   76,W
19DC:  SUBLW  0A
19DD:  BTFSS  03.2
19DE:  GOTO   1E1
....................       value = dd; 
19DF:  CLRF   76
....................     } else if (value == dd) { 
19E0:  GOTO   1E6
19E1:  MOVF   76,F
19E2:  BTFSS  03.2
19E3:  GOTO   1E6
....................       value = d0; 
19E4:  MOVLW  0A
19E5:  MOVWF  76
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19E6:  MOVF   76,W
19E7:  ANDLW  0F
19E8:  MOVLB  02
19E9:  MOVWF  3F
19EA:  MOVF   3F,W
19EB:  MOVWF  40
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A20:  MOVLB  02
1A21:  CLRF   3F
1A22:  CLRF   40
1A23:  MOVLW  20
1A24:  MOVWF  05
1A25:  MOVLW  B7
1A26:  MOVWF  04
1A27:  MOVF   3F,W
1A28:  ADDWF  04,F
1A29:  MOVLW  00
1A2A:  ADDWFC 05,F
1A2B:  MOVF   40,W
1A2C:  MOVLP  00
1A2D:  MOVLB  00
1A2E:  CALL   16D
1A2F:  MOVLP  18
1A30:  MOVWF  00
1A31:  IORLW  00
1A32:  BTFSC  03.2
1A33:  GOTO   239
1A34:  MOVLB  02
1A35:  INCF   40,F
1A36:  INCF   3F,F
1A37:  GOTO   223
1A38:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A39:  MOVLW  20
1A3A:  MOVLB  02
1A3B:  MOVWF  40
1A3C:  MOVLW  B7
1A3D:  MOVWF  3F
1A3E:  MOVLW  20
1A3F:  MOVWF  42
1A40:  MOVLW  A0
1A41:  MOVWF  41
1A42:  MOVLP  08
1A43:  MOVLB  00
1A44:  CALL   77B
1A45:  MOVLP  18
1A46:  MOVF   78,F
1A47:  BTFSS  03.2
1A48:  GOTO   24B
....................     command=I2C_SEND; 
1A49:  MOVLW  0C
1A4A:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A4B:  MOVLB  02
1A4C:  CLRF   3F
1A4D:  CLRF   40
1A4E:  MOVLW  20
1A4F:  MOVWF  05
1A50:  MOVLW  B7
1A51:  MOVWF  04
1A52:  MOVF   3F,W
1A53:  ADDWF  04,F
1A54:  MOVLW  00
1A55:  ADDWFC 05,F
1A56:  MOVF   40,W
1A57:  MOVLP  00
1A58:  MOVLB  00
1A59:  CALL   172
1A5A:  MOVLP  18
1A5B:  MOVWF  00
1A5C:  IORLW  00
1A5D:  BTFSC  03.2
1A5E:  GOTO   264
1A5F:  MOVLB  02
1A60:  INCF   40,F
1A61:  INCF   3F,F
1A62:  GOTO   24E
1A63:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A64:  MOVLW  20
1A65:  MOVLB  02
1A66:  MOVWF  40
1A67:  MOVLW  B7
1A68:  MOVWF  3F
1A69:  MOVLW  20
1A6A:  MOVWF  42
1A6B:  MOVLW  A0
1A6C:  MOVWF  41
1A6D:  MOVLP  08
1A6E:  MOVLB  00
1A6F:  CALL   77B
1A70:  MOVLP  18
1A71:  MOVF   78,F
1A72:  BTFSS  03.2
1A73:  GOTO   28B
....................     value = str_to_decimal(argument_name); 
1A74:  MOVLW  20
1A75:  MOVLB  02
1A76:  MOVWF  40
1A77:  MOVLW  70
1A78:  MOVWF  3F
1A79:  MOVLP  08
1A7A:  MOVLB  00
1A7B:  CALL   742
1A7C:  MOVLP  18
1A7D:  MOVF   78,W
1A7E:  MOVWF  76
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A7F:  MOVF   76,W
1A80:  SUBLW  24
1A81:  BTFSS  03.0
1A82:  GOTO   287
....................       argument = 0; 
1A83:  CLRF   75
....................       command  = MORSE_SEND; 
1A84:  MOVLW  0B
1A85:  MOVWF  70
....................     } else { 
1A86:  GOTO   28B
....................       command  = ADMIN; 
1A87:  MOVLW  09
1A88:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A89:  MOVLW  03
1A8A:  MOVWF  75
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A8B:  MOVLB  02
1A8C:  CLRF   3F
1A8D:  CLRF   40
1A8E:  MOVLW  20
1A8F:  MOVWF  05
1A90:  MOVLW  B7
1A91:  MOVWF  04
1A92:  MOVF   3F,W
1A93:  ADDWF  04,F
1A94:  MOVLW  00
1A95:  ADDWFC 05,F
1A96:  MOVF   40,W
1A97:  MOVLP  00
1A98:  MOVLB  00
1A99:  CALL   179
1A9A:  MOVLP  18
1A9B:  MOVWF  00
1A9C:  IORLW  00
1A9D:  BTFSC  03.2
1A9E:  GOTO   2A4
1A9F:  MOVLB  02
1AA0:  INCF   40,F
1AA1:  INCF   3F,F
1AA2:  GOTO   28E
1AA3:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AA4:  MOVLW  20
1AA5:  MOVLB  02
1AA6:  MOVWF  40
1AA7:  MOVLW  B7
1AA8:  MOVWF  3F
1AA9:  MOVLW  20
1AAA:  MOVWF  42
1AAB:  MOVLW  A0
1AAC:  MOVWF  41
1AAD:  MOVLP  08
1AAE:  MOVLB  00
1AAF:  CALL   77B
1AB0:  MOVLP  18
1AB1:  MOVF   78,F
1AB2:  BTFSS  03.2
1AB3:  GOTO   2B6
....................     command=INCREMENT_REG; 
1AB4:  MOVLW  06
1AB5:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1AB6:  MOVLB  02
1AB7:  CLRF   3F
1AB8:  CLRF   40
1AB9:  MOVLW  20
1ABA:  MOVWF  05
1ABB:  MOVLW  B7
1ABC:  MOVWF  04
1ABD:  MOVF   3F,W
1ABE:  ADDWF  04,F
1ABF:  MOVLW  00
1AC0:  ADDWFC 05,F
1AC1:  MOVF   40,W
1AC2:  MOVLP  00
1AC3:  MOVLB  00
1AC4:  CALL   17C
1AC5:  MOVLP  18
1AC6:  MOVWF  00
1AC7:  IORLW  00
1AC8:  BTFSC  03.2
1AC9:  GOTO   2CF
1ACA:  MOVLB  02
1ACB:  INCF   40,F
1ACC:  INCF   3F,F
1ACD:  GOTO   2B9
1ACE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1ACF:  MOVLW  20
1AD0:  MOVLB  02
1AD1:  MOVWF  40
1AD2:  MOVLW  B7
1AD3:  MOVWF  3F
1AD4:  MOVLW  20
1AD5:  MOVWF  42
1AD6:  MOVLW  A0
1AD7:  MOVWF  41
1AD8:  MOVLP  08
1AD9:  MOVLB  00
1ADA:  CALL   77B
1ADB:  MOVLP  18
1ADC:  MOVF   78,F
1ADD:  BTFSS  03.2
1ADE:  GOTO   2E1
....................     command=DECREMENT_REG; 
1ADF:  MOVLW  07
1AE0:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AE1:  MOVLB  02
1AE2:  CLRF   3F
1AE3:  CLRF   40
1AE4:  MOVLW  20
1AE5:  MOVWF  05
1AE6:  MOVLW  B7
1AE7:  MOVWF  04
1AE8:  MOVF   3F,W
1AE9:  ADDWF  04,F
1AEA:  MOVLW  00
1AEB:  ADDWFC 05,F
1AEC:  MOVF   40,W
1AED:  MOVLP  00
1AEE:  MOVLB  00
1AEF:  CALL   17F
1AF0:  MOVLP  18
1AF1:  MOVWF  00
1AF2:  IORLW  00
1AF3:  BTFSC  03.2
1AF4:  GOTO   2FA
1AF5:  MOVLB  02
1AF6:  INCF   40,F
1AF7:  INCF   3F,F
1AF8:  GOTO   2E4
1AF9:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AFA:  MOVLW  20
1AFB:  MOVLB  02
1AFC:  MOVWF  40
1AFD:  MOVLW  B7
1AFE:  MOVWF  3F
1AFF:  MOVLW  20
1B00:  MOVWF  42
1B01:  MOVLW  A0
1B02:  MOVWF  41
1B03:  MOVLP  08
1B04:  MOVLB  00
1B05:  CALL   77B
1B06:  MOVLP  18
1B07:  MOVF   78,F
1B08:  BTFSS  03.2
1B09:  GOTO   329
....................     command=SET_REG; 
1B0A:  MOVLW  02
1B0B:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B0C:  MOVLW  01
1B0D:  ADDWF  74,W
1B0E:  ANDLW  03
1B0F:  MOVWF  76
....................     strcpy(argument_name,"CPOT"); 
1B10:  MOVLB  02
1B11:  CLRF   3F
1B12:  CLRF   40
1B13:  MOVLW  20
1B14:  MOVWF  05
1B15:  MOVLW  70
1B16:  MOVWF  04
1B17:  MOVF   3F,W
1B18:  ADDWF  04,F
1B19:  MOVLW  00
1B1A:  ADDWFC 05,F
1B1B:  MOVF   40,W
1B1C:  MOVLP  00
1B1D:  MOVLB  00
1B1E:  CALL   182
1B1F:  MOVLP  18
1B20:  MOVWF  00
1B21:  IORLW  00
1B22:  BTFSC  03.2
1B23:  GOTO   329
1B24:  MOVLB  02
1B25:  INCF   40,F
1B26:  INCF   3F,F
1B27:  GOTO   313
1B28:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B29:  MOVLB  02
1B2A:  CLRF   3F
1B2B:  CLRF   40
1B2C:  MOVLW  20
1B2D:  MOVWF  05
1B2E:  MOVLW  B7
1B2F:  MOVWF  04
1B30:  MOVF   3F,W
1B31:  ADDWF  04,F
1B32:  MOVLW  00
1B33:  ADDWFC 05,F
1B34:  MOVF   40,W
1B35:  MOVLP  00
1B36:  MOVLB  00
1B37:  CALL   188
1B38:  MOVLP  18
1B39:  MOVWF  00
1B3A:  IORLW  00
1B3B:  BTFSC  03.2
1B3C:  GOTO   342
1B3D:  MOVLB  02
1B3E:  INCF   40,F
1B3F:  INCF   3F,F
1B40:  GOTO   32C
1B41:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B42:  MOVLW  20
1B43:  MOVLB  02
1B44:  MOVWF  40
1B45:  MOVLW  B7
1B46:  MOVWF  3F
1B47:  MOVLW  20
1B48:  MOVWF  42
1B49:  MOVLW  A0
1B4A:  MOVWF  41
1B4B:  MOVLP  08
1B4C:  MOVLB  00
1B4D:  CALL   77B
1B4E:  MOVLP  18
1B4F:  MOVF   78,F
1B50:  BTFSS  03.2
1B51:  GOTO   362
....................     AdminMode = ~AdminMode; 
1B52:  MOVLW  80
1B53:  MOVLB  01
1B54:  XORWF  5D,F
....................     set_admin_mode(AdminMode); 
1B55:  MOVLW  00
1B56:  BTFSC  5D.7
1B57:  MOVLW  01
1B58:  MOVLB  02
1B59:  MOVWF  3F
1B5A:  MOVWF  40
1B5B:  MOVLP  08
1B5C:  MOVLB  00
1B5D:  CALL   49F
1B5E:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B5F:  MOVLB  01
1B60:  BSF    5D.6
1B61:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
114F:  MOVF   76,W
1150:  SUBLW  FF
1151:  BTFSS  03.2
1152:  GOTO   179
....................     printf ("\n\r%s %u",argument,value); 
1153:  MOVLW  0A
1154:  CLRWDT
1155:  BTFSS  11.4
1156:  GOTO   154
1157:  MOVLB  03
1158:  MOVWF  1A
1159:  MOVLW  0D
115A:  CLRWDT
115B:  MOVLB  00
115C:  BTFSC  11.4
115D:  GOTO   160
115E:  MOVLB  03
115F:  GOTO   15A
1160:  MOVLB  03
1161:  MOVWF  1A
1162:  CLRF   05
1163:  MOVF   75,W
1164:  MOVWF  04
1165:  MOVLP  08
1166:  MOVLB  00
1167:  CALL   23D
1168:  MOVLP  10
1169:  MOVLW  20
116A:  CLRWDT
116B:  BTFSS  11.4
116C:  GOTO   16A
116D:  MOVLB  03
116E:  MOVWF  1A
116F:  MOVF   76,W
1170:  MOVLB  02
1171:  MOVWF  50
1172:  MOVLW  1B
1173:  MOVWF  51
1174:  MOVLP  00
1175:  MOVLB  00
1176:  CALL   720
1177:  MOVLP  10
....................   } else { 
1178:  GOTO   215
....................     pObj=RegMap[argument].reg_ptr; 
1179:  RLF    75,W
117A:  MOVWF  77
117B:  RLF    77,F
117C:  MOVLW  FC
117D:  ANDWF  77,F
117E:  MOVF   77,W
117F:  MOVLB  02
1180:  MOVWF  2F
1181:  INCF   2F,W
1182:  MOVLP  00
1183:  MOVLB  00
1184:  CALL   043
1185:  MOVLP  10
1186:  MOVWF  7A
1187:  MOVLB  02
1188:  MOVF   2F,W
1189:  MOVLP  00
118A:  MOVLB  00
118B:  CALL   043
118C:  MOVLP  10
118D:  MOVLB  02
118E:  MOVWF  2C
118F:  MOVF   7A,W
1190:  MOVWF  2D
....................     // Consider allowing some registers to be updated outside AdminMode. 
....................     // Example : AuxOut registers, Enable 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
1191:  MOVLP  08
1192:  MOVLB  00
1193:  CALL   7E3
1194:  MOVLP  10
1195:  MOVF   78,F
1196:  BTFSS  03.2
1197:  GOTO   1A5
1198:  RLF    75,W
1199:  MOVWF  77
119A:  RLF    77,F
119B:  MOVLW  FC
119C:  ANDWF  77,F
119D:  MOVF   77,W
119E:  ADDLW  03
119F:  MOVLP  00
11A0:  CALL   043
11A1:  MOVLP  10
11A2:  MOVWF  78
11A3:  BTFSC  78.1
11A4:  GOTO   1AD
....................       *pObj=value; 
11A5:  MOVLB  02
11A6:  MOVF   2C,W
11A7:  MOVWF  04
11A8:  MOVF   2D,W
11A9:  MOVWF  05
11AA:  MOVF   76,W
11AB:  MOVWF  00
11AC:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
11AD:  MOVLB  02
11AE:  MOVF   2C,W
11AF:  MOVWF  04
11B0:  MOVF   2D,W
11B1:  MOVWF  05
11B2:  MOVF   00,W
11B3:  MOVWF  2E
....................     LastRegisterIndex = argument; 
11B4:  MOVF   75,W
11B5:  MOVWF  7C
....................     LastRegisterIndexValid=1; 
11B6:  MOVLW  01
11B7:  MOVWF  7D
....................     printf ("\n\rSetting %s(%u) to %u",argument_name,argument,lVar); 
11B8:  MOVLW  82
11B9:  MOVLB  03
11BA:  MOVWF  11
11BB:  MOVLW  04
11BC:  MOVWF  12
11BD:  BCF    03.0
11BE:  MOVLW  0A
11BF:  MOVLB  02
11C0:  MOVWF  50
11C1:  MOVLP  00
11C2:  MOVLB  00
11C3:  CALL   6AC
11C4:  MOVLP  10
11C5:  MOVLW  20
11C6:  MOVWF  05
11C7:  MOVLW  70
11C8:  MOVWF  04
11C9:  MOVLP  08
11CA:  CALL   23D
11CB:  MOVLP  10
11CC:  MOVLW  28
11CD:  CLRWDT
11CE:  BTFSS  11.4
11CF:  GOTO   1CD
11D0:  MOVLB  03
11D1:  MOVWF  1A
11D2:  MOVF   75,W
11D3:  MOVLB  02
11D4:  MOVWF  50
11D5:  MOVLW  1B
11D6:  MOVWF  51
11D7:  MOVLP  00
11D8:  MOVLB  00
11D9:  CALL   720
11DA:  MOVLP  10
11DB:  MOVLW  89
11DC:  MOVLB  03
11DD:  MOVWF  11
11DE:  MOVLW  04
11DF:  MOVWF  12
11E0:  BSF    03.0
11E1:  MOVLW  05
11E2:  MOVLB  02
11E3:  MOVWF  50
11E4:  MOVLP  00
11E5:  MOVLB  00
11E6:  CALL   6AC
11E7:  MOVLP  10
11E8:  MOVLB  02
11E9:  MOVF   2E,W
11EA:  MOVWF  50
11EB:  MOVLW  1B
11EC:  MOVWF  51
11ED:  MOVLP  00
11EE:  MOVLB  00
11EF:  CALL   720
11F0:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
11F1:  MOVLB  02
11F2:  MOVF   2D,W
11F3:  SUBLW  1F
11F4:  BTFSC  03.0
11F5:  GOTO   207
11F6:  XORLW  FF
11F7:  BTFSS  03.2
11F8:  GOTO   1FD
11F9:  MOVF   2C,W
11FA:  SUBLW  0B
11FB:  BTFSC  03.0
11FC:  GOTO   207
11FD:  MOVF   2D,W
11FE:  SUBLW  20
11FF:  BTFSS  03.0
1200:  GOTO   207
1201:  BTFSS  03.2
1202:  GOTO   20E
1203:  MOVF   2C,W
1204:  SUBLW  1B
1205:  BTFSC  03.0
1206:  GOTO   20E
1207:  MOVF   2C,W
1208:  SUBLW  74
1209:  BTFSS  03.2
120A:  GOTO   212
120B:  MOVF   2D,F
120C:  BTFSS  03.2
120D:  GOTO   212
....................       increment(0); // Increment is done in this function. Only update trim pot. 
120E:  CLRF   2F
120F:  MOVLB  00
1210:  CALL   000
1211:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
1212:  MOVLB  01
1213:  BSF    5D.6
1214:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
1000:  MOVF   74,W
1001:  ANDLW  03
1002:  MOVLB  02
1003:  MOVWF  33
....................   if ( CurrentCorIndex ) { 
1004:  MOVLB  00
1005:  MOVF   6D,F
1006:  BTFSC  03.2
1007:  GOTO   03D
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
1008:  MOVLW  01
1009:  SUBWF  6D,W
100A:  MOVWF  77
100B:  RLF    77,F
100C:  RLF    77,F
100D:  MOVLW  FC
100E:  ANDWF  77,F
100F:  MOVF   77,W
1010:  MOVLB  02
1011:  ADDWF  33,W
1012:  ADDLW  0C
1013:  MOVWF  30
1014:  MOVLW  20
1015:  MOVWF  31
1016:  BTFSC  03.0
1017:  INCF   31,F
....................     value = *pot_ptr; 
1018:  MOVF   30,W
1019:  MOVWF  04
101A:  MOVF   31,W
101B:  MOVWF  05
101C:  MOVF   00,W
101D:  MOVWF  32
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
101E:  MOVF   30,W
101F:  MOVWF  04
1020:  MOVF   31,W
1021:  MOVWF  05
1022:  MOVF   2F,W
1023:  ADDWF  32,W
1024:  MOVWF  00
....................     if ( in_admin_mode() ) { 
1025:  MOVLP  08
1026:  MOVLB  00
1027:  CALL   7E3
1028:  MOVLP  10
1029:  MOVF   78,F
102A:  BTFSC  03.2
102B:  GOTO   03D
....................       set_trimpot(CPotPtr,*pot_ptr); 
102C:  MOVLB  02
102D:  MOVF   31,W
102E:  MOVWF  7A
102F:  MOVF   30,W
1030:  MOVWF  04
1031:  MOVF   31,W
1032:  MOVWF  05
1033:  MOVF   00,W
1034:  MOVWF  34
1035:  MOVF   33,W
1036:  MOVWF  3F
1037:  MOVF   34,W
1038:  MOVWF  40
1039:  MOVLP  00
103A:  MOVLB  00
103B:  CALL   76F
103C:  MOVLP  10
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
103D:  MOVLP  08
103E:  CALL   257
103F:  MOVLP  10
.................... } // }}} 
1040:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
0FBA:  MOVLB  02
0FBB:  CLRF   3F
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
0FBC:  MOVF   3F,W
0FBD:  SUBLW  05
0FBE:  BTFSS  03.0
0FBF:  GOTO   7E1
....................     dest[c]=src[c]; 
0FC0:  MOVF   3F,W
0FC1:  ADDWF  3B,W
0FC2:  MOVWF  78
0FC3:  MOVLW  00
0FC4:  ADDWFC 3C,W
0FC5:  MOVWF  7A
0FC6:  MOVF   78,W
0FC7:  MOVWF  40
0FC8:  MOVF   7A,W
0FC9:  MOVWF  41
0FCA:  MOVF   3F,W
0FCB:  ADDWF  3D,W
0FCC:  MOVWF  78
0FCD:  MOVLW  00
0FCE:  ADDWFC 3E,W
0FCF:  MOVWF  7A
0FD0:  MOVF   78,W
0FD1:  MOVLB  03
0FD2:  MOVWF  11
0FD3:  MOVF   7A,W
0FD4:  MOVWF  12
0FD5:  MOVLB  02
0FD6:  MOVF   41,W
0FD7:  MOVWF  05
0FD8:  MOVF   40,W
0FD9:  MOVWF  04
0FDA:  MOVLW  01
0FDB:  MOVWF  45
0FDC:  MOVLB  00
0FDD:  CALL   000
....................   c++; 
0FDE:  MOVLB  02
0FDF:  INCF   3F,F
....................   } 
0FE0:  GOTO   7BC
.................... } // }}} 
0FE1:  MOVLB  00
0FE2:  RETURN
.................... void ExecAuxOutOp(int op,int arg,int ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
16B2:  MOVF   29,W
16B3:  ANDLW  0F
16B4:  MOVWF  2B
....................   uarg = (arg & 0xF0) >> 4; 
16B5:  MOVF   29,W
16B6:  ANDLW  F0
16B7:  MOVWF  77
16B8:  SWAPF  77,W
16B9:  MOVWF  2C
16BA:  MOVLW  0F
16BB:  ANDWF  2C,F
....................   switch(op) { 
16BC:  MOVF   28,W
16BD:  XORLW  01
16BE:  MOVLB  00
16BF:  BTFSC  03.2
16C0:  GOTO   6C5
16C1:  XORLW  03
16C2:  BTFSC  03.2
16C3:  GOTO   6DA
16C4:  GOTO   6F3
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       AuxOut[ID] = ((COR_IN_EFFECTIVE ^ uarg) & larg) != 0; 
16C5:  MOVLW  22
16C6:  MOVLB  02
16C7:  ADDWF  2A,W
16C8:  MOVWF  04
16C9:  MOVLW  20
16CA:  MOVWF  05
16CB:  BTFSC  03.0
16CC:  INCF   05,F
16CD:  MOVLB  00
16CE:  MOVF   6F,W
16CF:  MOVLB  02
16D0:  XORWF  2C,W
16D1:  ANDWF  2B,W
16D2:  BTFSS  03.2
16D3:  GOTO   6D6
16D4:  MOVLW  00
16D5:  GOTO   6D7
16D6:  MOVLW  01
16D7:  MOVWF  00
....................     break; 
16D8:  MOVLB  00
16D9:  GOTO   6F3
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
16DA:  MOVLW  22
16DB:  MOVLB  02
16DC:  ADDWF  2A,W
16DD:  MOVWF  04
16DE:  MOVLW  20
16DF:  MOVWF  05
16E0:  BTFSC  03.0
16E1:  INCF   05,F
16E2:  MOVF   2B,W
16E3:  ANDLW  1F
16E4:  MOVWF  2F
16E5:  MOVF   7A,W
16E6:  MOVWF  30
16E7:  MOVF   2C,W
16E8:  XORWF  2F,F
16E9:  BTFSS  03.2
16EA:  GOTO   6F0
16EB:  MOVF   30,F
16EC:  BTFSS  03.2
16ED:  GOTO   6F0
16EE:  MOVLW  00
16EF:  GOTO   6F1
16F0:  MOVLW  01
16F1:  MOVWF  00
....................     break; 
16F2:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0F42:  MOVLB  02
0F43:  CLRF   41
0F44:  CLRF   42
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0F45:  MOVF   41,W
0F46:  ADDWF  3F,W
0F47:  MOVWF  04
0F48:  MOVLW  00
0F49:  ADDWFC 40,W
0F4A:  MOVWF  05
0F4B:  MOVF   00,F
0F4C:  BTFSC  03.2
0F4D:  GOTO   777
0F4E:  MOVF   41,W
0F4F:  ADDWF  3F,W
0F50:  MOVWF  04
0F51:  MOVLW  00
0F52:  ADDWFC 40,W
0F53:  MOVWF  05
0F54:  MOVF   00,W
0F55:  SUBLW  2F
0F56:  BTFSC  03.0
0F57:  GOTO   777
0F58:  MOVF   41,W
0F59:  ADDWF  3F,W
0F5A:  MOVWF  04
0F5B:  MOVLW  00
0F5C:  ADDWFC 40,W
0F5D:  MOVWF  05
0F5E:  MOVF   00,W
0F5F:  SUBLW  39
0F60:  BTFSS  03.0
0F61:  GOTO   777
....................     value = (value * 10) + (str[x]-'0'); 
0F62:  MOVF   42,W
0F63:  MOVWF  43
0F64:  MOVLW  0A
0F65:  MOVWF  44
0F66:  MOVLB  00
0F67:  CALL   71B
0F68:  MOVF   78,W
0F69:  MOVLB  02
0F6A:  MOVWF  43
0F6B:  MOVF   41,W
0F6C:  ADDWF  3F,W
0F6D:  MOVWF  04
0F6E:  MOVLW  00
0F6F:  ADDWFC 40,W
0F70:  MOVWF  05
0F71:  MOVLW  30
0F72:  SUBWF  00,W
0F73:  ADDWF  43,W
0F74:  MOVWF  42
....................     x++; 
0F75:  INCF   41,F
....................   } 
0F76:  GOTO   745
....................   return(value); 
0F77:  MOVF   42,W
0F78:  MOVWF  78
.................... } // }}} 
0F79:  MOVLB  00
0F7A:  RETURN
.................... void ExecAuxInOp(int op,int arg,int ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
15D2:  MOVLB  02
15D3:  BCF    2B.0
15D4:  MOVLW  1F
15D5:  ADDWF  2A,W
15D6:  MOVWF  04
15D7:  MOVLW  20
15D8:  MOVWF  05
15D9:  BTFSC  03.0
15DA:  INCF   05,F
15DB:  MOVF   00,F
15DC:  BTFSS  03.2
15DD:  BSF    2B.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   // Include arg[4] for COR4 emulation 
....................   larg = arg & 0x1F; 
15DE:  MOVF   29,W
15DF:  ANDLW  1F
15E0:  MOVWF  2C
....................   uarg = (arg & 0xF0) >> 4; 
15E1:  MOVF   29,W
15E2:  ANDLW  F0
15E3:  MOVWF  77
15E4:  SWAPF  77,W
15E5:  MOVWF  2D
15E6:  MOVLW  0F
15E7:  ANDWF  2D,F
....................   switch(op) { 
15E8:  MOVLW  01
15E9:  SUBWF  28,W
15EA:  ADDLW  FC
15EB:  BTFSC  03.0
15EC:  GOTO   633
15ED:  ADDLW  04
15EE:  MOVLB  00
15EF:  GOTO   636
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
15F0:  MOVLB  02
15F1:  BTFSS  2B.0
15F2:  GOTO   5F8
....................         Enable_Mask &= arg; 
15F3:  MOVF   29,W
15F4:  MOVLB  00
15F5:  ANDWF  61,F
....................       } else { // AuxIn is not enabled 
15F6:  GOTO   5FD
15F7:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
15F8:  MOVF   29,W
15F9:  XORLW  FF
15FA:  ANDLW  0F
15FB:  MOVLB  00
15FC:  IORWF  61,F
....................       } 
....................       break; 
15FD:  MOVLB  02
15FE:  GOTO   633
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
15FF:  MOVLB  02
1600:  BTFSS  2B.0
1601:  GOTO   608
....................         COR_DROP_FLAG=1; 
1602:  BSF    72.7
....................         TailChar=arg; 
1603:  MOVF   29,W
1604:  MOVLB  00
1605:  MOVWF  6A
....................       } else { 
1606:  GOTO   60A
1607:  MOVLB  02
....................         TailChar=0; 
1608:  MOVLB  00
1609:  CLRF   6A
....................       } 
....................     break; 
160A:  MOVLB  02
160B:  GOTO   633
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
160C:  MOVLB  02
160D:  BTFSC  2B.0
160E:  GOTO   615
....................         COR_DROP_FLAG=1; 
160F:  BSF    72.7
....................         TailChar=arg; 
1610:  MOVF   29,W
1611:  MOVLB  00
1612:  MOVWF  6A
....................       } else { 
1613:  GOTO   617
1614:  MOVLB  02
....................         TailChar=0; 
1615:  MOVLB  00
1616:  CLRF   6A
....................       } 
....................     break; 
1617:  MOVLB  02
1618:  GOTO   633
....................     case AUXI_EMULATE_COR: 
....................       if ( (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0 ) { 
1619:  MOVLB  02
161A:  MOVF   29,W
161B:  ANDLW  20
161C:  BTFSC  03.2
161D:  GOTO   622
....................         tmp_bit = ~in_bit; 
161E:  BCF    2B.1
161F:  BTFSS  2B.0
1620:  BSF    2B.1
....................       } else { 
1621:  GOTO   625
....................         tmp_bit = in_bit; 
1622:  BCF    2B.1
1623:  BTFSC  2B.0
1624:  BSF    2B.1
....................       } 
....................       if ( tmp_bit ) { 
1625:  BTFSS  2B.1
1626:  GOTO   62C
....................         COR_EMUL |= larg; 
1627:  MOVF   2C,W
1628:  MOVLB  00
1629:  IORWF  69,F
....................       } else { 
162A:  GOTO   630
162B:  MOVLB  02
....................         COR_EMUL &= ~larg; 
162C:  MOVF   2C,W
162D:  XORLW  FF
162E:  MOVLB  00
162F:  ANDWF  69,F
....................       } 
....................     break; 
1630:  MOVLB  02
1631:  GOTO   633
1632:  MOVLB  02
....................   } 
.................... } // }}} 
1633:  MOVLP  10
1634:  MOVLB  00
1635:  GOTO   764 (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
1588:  MOVLB  01
1589:  CLRF   65
158A:  MOVF   65,W
158B:  SUBLW  02
158C:  BTFSS  03.0
158D:  GOTO   5CF
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = (input(AUX_IN_PIN[x])!=0) || (AuxIn[x]!=0); 
158E:  MOVLW  1F
158F:  ADDWF  65,W
1590:  MOVWF  78
1591:  MOVLW  20
1592:  MOVWF  7A
1593:  BTFSC  03.0
1594:  INCF   7A,F
1595:  MOVF   78,W
1596:  MOVWF  66
1597:  MOVF   7A,W
1598:  MOVWF  67
1599:  MOVF   65,W
159A:  MOVLP  00
159B:  MOVLB  00
159C:  CALL   03F
159D:  MOVLP  10
159E:  MOVLB  01
159F:  MOVWF  68
15A0:  MOVLB  02
15A1:  MOVWF  40
15A2:  MOVLW  01
15A3:  MOVWF  41
15A4:  CLRF   43
15A5:  MOVLW  80
15A6:  MOVWF  42
15A7:  MOVLP  08
15A8:  MOVLB  00
15A9:  CALL   0DA
15AA:  MOVLP  10
15AB:  MOVLB  01
15AC:  MOVF   68,W
15AD:  MOVWF  69
15AE:  CLRF   6B
15AF:  CLRF   6A
15B0:  MOVLB  00
15B1:  GOTO   56E
15B2:  BTFSC  78.0
15B3:  GOTO   5C4
15B4:  MOVLW  1C
15B5:  MOVLB  01
15B6:  ADDWF  65,W
15B7:  MOVWF  04
15B8:  MOVLW  20
15B9:  MOVWF  05
15BA:  BTFSC  03.0
15BB:  INCF   05,F
15BC:  MOVF   00,F
15BD:  BTFSC  03.2
15BE:  GOTO   5C1
15BF:  MOVLB  00
15C0:  GOTO   5C4
15C1:  MOVLW  00
15C2:  GOTO   5C6
15C3:  MOVLB  00
15C4:  MOVLW  01
15C5:  MOVLB  01
15C6:  MOVWF  69
15C7:  MOVF   67,W
15C8:  MOVWF  05
15C9:  MOVF   66,W
15CA:  MOVWF  04
15CB:  MOVF   69,W
15CC:  MOVWF  00
....................   } 
15CD:  INCF   65,F
15CE:  GOTO   58A
.................... } // }}} 
15CF:  MOVLP  18
15D0:  MOVLB  00
15D1:  GOTO   75A (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
1677:  MOVLW  30
1678:  MOVLB  01
1679:  MOVWF  68
167A:  MOVWF  69
167B:  MOVWF  6A
167C:  CLRF   6B
....................   char AuxOut_s[4]={'0','0','0',0}; 
167D:  MOVWF  6C
167E:  MOVWF  6D
167F:  MOVWF  6E
1680:  CLRF   6F
....................   char ADM[]=" ADMIN"; 
1681:  MOVLW  20
1682:  MOVLB  02
1683:  MOVWF  20
1684:  MOVLW  41
1685:  MOVWF  21
1686:  MOVLW  44
1687:  MOVWF  22
1688:  MOVLW  4D
1689:  MOVWF  23
168A:  MOVLW  49
168B:  MOVWF  24
168C:  MOVLW  4E
168D:  MOVWF  25
168E:  CLRF   26
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
168F:  MOVLB  01
1690:  CLRF   65
1691:  MOVF   65,W
1692:  SUBLW  02
1693:  BTFSS  03.0
1694:  GOTO   767
....................     AuxOp = AuxOutOp[x]; 
1695:  MOVLW  33
1696:  ADDWF  65,W
1697:  MOVWF  04
1698:  MOVLW  20
1699:  MOVWF  05
169A:  BTFSC  03.0
169B:  INCF   05,F
169C:  MOVF   00,W
169D:  MOVWF  66
....................     AuxArg = AuxOutArg[x]; 
169E:  MOVLW  36
169F:  ADDWF  65,W
16A0:  MOVWF  04
16A1:  MOVLW  20
16A2:  MOVWF  05
16A3:  BTFSC  03.0
16A4:  INCF   05,F
16A5:  MOVF   00,W
16A6:  MOVWF  67
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
16A7:  MOVF   66,W
16A8:  MOVLB  02
16A9:  MOVWF  28
16AA:  MOVLB  01
16AB:  MOVF   67,W
16AC:  MOVLB  02
16AD:  MOVWF  29
16AE:  MOVLB  01
16AF:  MOVF   65,W
16B0:  MOVLB  02
16B1:  MOVWF  2A
....................     out_bit = (AuxOut[x])==0; 
*
16F3:  MOVLB  02
16F4:  BCF    27.0
16F5:  MOVLW  22
16F6:  MOVLB  01
16F7:  ADDWF  65,W
16F8:  MOVWF  04
16F9:  MOVLW  20
16FA:  MOVWF  05
16FB:  BTFSC  03.0
16FC:  INCF   05,F
16FD:  MOVF   00,F
16FE:  BTFSS  03.2
16FF:  GOTO   703
1700:  MOVLB  02
1701:  BSF    27.0
1702:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
1703:  MOVF   65,W
1704:  MOVLP  00
1705:  MOVLB  00
1706:  CALL   03B
1707:  MOVLP  10
1708:  MOVLB  02
1709:  MOVWF  28
170A:  MOVLW  00
170B:  BTFSC  27.0
170C:  MOVLW  01
170D:  MOVWF  77
170E:  MOVF   28,W
170F:  MOVWF  40
1710:  MOVF   77,W
1711:  MOVWF  41
1712:  MOVLW  01
1713:  MOVWF  43
1714:  CLRF   42
1715:  MOVLP  08
1716:  MOVLB  00
1717:  CALL   0DA
1718:  MOVLP  10
1719:  MOVLB  02
171A:  MOVF   28,W
171B:  MOVWF  40
171C:  CLRF   41
171D:  CLRF   43
171E:  MOVLW  80
171F:  MOVWF  42
1720:  MOVLP  08
1721:  MOVLB  00
1722:  CALL   0DA
1723:  MOVLP  10
....................     if(out_bit==0) { 
1724:  MOVLB  02
1725:  BTFSC  27.0
1726:  GOTO   732
....................       AuxOut_s[x]='1'; 
1727:  MOVLW  9C
1728:  MOVLB  01
1729:  ADDWF  65,W
172A:  MOVWF  04
172B:  MOVLW  20
172C:  MOVWF  05
172D:  BTFSC  03.0
172E:  INCF   05,F
172F:  MOVLW  31
1730:  MOVWF  00
1731:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
1732:  MOVLW  39
1733:  MOVLB  01
1734:  ADDWF  65,W
1735:  MOVWF  04
1736:  MOVLW  20
1737:  MOVWF  05
1738:  BTFSC  03.0
1739:  INCF   05,F
173A:  MOVF   00,W
173B:  MOVWF  66
....................     AuxArg = AuxInArg[x]; 
173C:  MOVLW  3C
173D:  ADDWF  65,W
173E:  MOVWF  04
173F:  MOVLW  20
1740:  MOVWF  05
1741:  BTFSC  03.0
1742:  INCF   05,F
1743:  MOVF   00,W
1744:  MOVWF  67
....................     if(AuxInSW[x]==1) { 
1745:  MOVLW  1F
1746:  ADDWF  65,W
1747:  MOVWF  04
1748:  MOVLW  20
1749:  MOVWF  05
174A:  BTFSC  03.0
174B:  INCF   05,F
174C:  DECFSZ 00,W
174D:  GOTO   757
....................       AuxIn_s[x]='1'; 
174E:  MOVLW  98
174F:  ADDWF  65,W
1750:  MOVWF  04
1751:  MOVLW  20
1752:  MOVWF  05
1753:  BTFSC  03.0
1754:  INCF   05,F
1755:  MOVLW  31
1756:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
1757:  MOVF   66,W
1758:  MOVLB  02
1759:  MOVWF  28
175A:  MOVLB  01
175B:  MOVF   67,W
175C:  MOVLB  02
175D:  MOVWF  29
175E:  MOVLB  01
175F:  MOVF   65,W
1760:  MOVLB  02
1761:  MOVWF  2A
1762:  MOVLB  00
1763:  GOTO   5D2
....................     // }}} 
....................   } 
1764:  MOVLB  01
1765:  INCF   65,F
1766:  GOTO   691
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
1767:  MOVLW  20
1768:  MOVWF  64
1769:  MOVLW  76
176A:  MOVWF  63
176B:  MOVLW  49
176C:  MOVLB  02
176D:  MOVWF  50
176E:  MOVLP  08
176F:  MOVLB  00
1770:  CALL   0FC
1771:  MOVLP  10
1772:  MOVLW  3A
1773:  MOVLB  02
1774:  MOVWF  50
1775:  MOVLP  08
1776:  MOVLB  00
1777:  CALL   0FC
1778:  MOVLP  10
1779:  MOVLW  20
177A:  MOVWF  05
177B:  MOVLW  98
177C:  MOVWF  04
177D:  MOVLP  08
177E:  CALL   15E
177F:  MOVLP  10
1780:  MOVLW  20
1781:  MOVLB  02
1782:  MOVWF  50
1783:  MOVLP  08
1784:  MOVLB  00
1785:  CALL   0FC
1786:  MOVLP  10
1787:  MOVLW  4F
1788:  MOVLB  02
1789:  MOVWF  50
178A:  MOVLP  08
178B:  MOVLB  00
178C:  CALL   0FC
178D:  MOVLP  10
178E:  MOVLW  3A
178F:  MOVLB  02
1790:  MOVWF  50
1791:  MOVLP  08
1792:  MOVLB  00
1793:  CALL   0FC
1794:  MOVLP  10
1795:  MOVLW  20
1796:  MOVWF  05
1797:  MOVLW  9C
1798:  MOVWF  04
1799:  MOVLP  08
179A:  CALL   15E
179B:  MOVLP  10
....................   if ( AdminMode ) { 
179C:  MOVLB  01
179D:  BTFSS  5D.7
179E:  GOTO   7AB
....................     strcat(LCD_str,ADM); 
179F:  MOVLW  20
17A0:  MOVLB  02
17A1:  MOVWF  29
17A2:  MOVLW  76
17A3:  MOVWF  28
17A4:  MOVLW  20
17A5:  MOVWF  2B
17A6:  MOVLW  A0
17A7:  MOVWF  2A
17A8:  MOVLB  00
17A9:  CALL   63E
17AA:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
17AB:  MOVLW  03
17AC:  MOVLB  02
17AD:  MOVWF  4A
17AE:  MOVLW  20
17AF:  MOVWF  4C
17B0:  MOVLW  76
17B1:  MOVWF  4B
17B2:  MOVLP  08
17B3:  MOVLB  00
17B4:  CALL   173
17B5:  MOVLP  10
.................... } // }}} 
17B6:  RETURN
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
10A2:  MOVLW  01
10A3:  MOVLB  02
10A4:  MOVWF  2E
10A5:  MOVLP  08
10A6:  MOVLB  00
10A7:  CALL   34B
10A8:  MOVLP  10
....................   delay_ms(1000); 
10A9:  MOVLW  04
10AA:  MOVLB  02
10AB:  MOVWF  2E
10AC:  MOVLW  FA
10AD:  MOVWF  4A
10AE:  MOVLP  00
10AF:  MOVLB  00
10B0:  CALL   7DA
10B1:  MOVLP  10
10B2:  MOVLB  02
10B3:  DECFSZ 2E,F
10B4:  GOTO   0AC
....................   for(x=0;x<6;x++) { 
10B5:  CLRF   2C
10B6:  MOVF   2C,W
10B7:  SUBLW  05
10B8:  BTFSS  03.0
10B9:  GOTO   0D6
....................     mchar=Morse[x]; 
10BA:  MOVLW  2D
10BB:  ADDWF  2C,W
10BC:  MOVWF  04
10BD:  MOVLW  20
10BE:  MOVWF  05
10BF:  BTFSC  03.0
10C0:  INCF   05,F
10C1:  MOVF   00,W
10C2:  MOVWF  2D
....................     morse(mchar); 
10C3:  MOVF   2D,W
10C4:  MOVWF  3F
10C5:  MOVLP  08
10C6:  MOVLB  00
10C7:  CALL   083
10C8:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
10C9:  MOVLB  01
10CA:  CLRF   33
10CB:  MOVLW  06
10CC:  MOVWF  32
....................     while(aux_timer) { 
10CD:  MOVF   32,W
10CE:  IORWF  33,W
10CF:  BTFSC  03.2
10D0:  GOTO   0D3
....................       delay_cycles(1); 
10D1:  NOP
....................     } 
10D2:  GOTO   0CD
....................   } 
10D3:  MOVLB  02
10D4:  INCF   2C,F
10D5:  GOTO   0B6
....................   delay_ms(1000); 
10D6:  MOVLW  04
10D7:  MOVWF  2E
10D8:  MOVLW  FA
10D9:  MOVWF  4A
10DA:  MOVLP  00
10DB:  MOVLB  00
10DC:  CALL   7DA
10DD:  MOVLP  10
10DE:  MOVLB  02
10DF:  DECFSZ 2E,F
10E0:  GOTO   0D8
....................   COR_FLAG=1; 
10E1:  BSF    72.3
.................... } // }}} 
10E2:  MOVLB  00
10E3:  RETURN
.................... void main (void) { // {{{ 
*
1F14:  CLRF   05
1F15:  CLRF   04
1F16:  MOVLW  1F
1F17:  ANDWF  03,F
1F18:  MOVLW  72
1F19:  MOVLB  01
1F1A:  MOVWF  19
1F1B:  BSF    0E.3
1F1C:  BSF    0E.4
1F1D:  MOVLB  04
1F1E:  BCF    17.0
1F1F:  BCF    17.1
1F20:  BCF    17.3
1F21:  MOVLW  13
1F22:  MOVWF  12
1F23:  MOVLW  28
1F24:  MOVWF  15
1F25:  BSF    14.7
1F26:  BCF    14.6
1F27:  MOVLW  0C
1F28:  MOVLB  03
1F29:  MOVWF  1B
1F2A:  MOVLW  A2
1F2B:  MOVWF  1E
1F2C:  MOVLW  90
1F2D:  MOVWF  1D
1F2E:  MOVLB  01
1F2F:  BSF    62.1
1F30:  CLRF   64
1F31:  CLRF   63
1F32:  MOVLB  0F
1F33:  CLRF   11
1F34:  CLRF   12
1F35:  CLRF   18
1F36:  CLRF   19
1F37:  CLRF   1A
1F38:  MOVLB  03
1F39:  CLRF   0C
1F3A:  CLRF   0D
1F3B:  CLRF   0F
1F3C:  CLRF   10
1F3D:  MOVLB  02
1F3E:  CLRF   12
1F3F:  CLRF   11
1F40:  CLRF   14
1F41:  CLRF   13
....................   initialize(); 
*
1F45:  MOVLP  08
1F46:  GOTO   4B6
1F47:  MOVLP  18
.................... #ignore_warnings 203 
....................   while(1) { // {{{ 
.................... #ignore_warnings none 
....................     restart_wdt(); 
1F48:  CLRWDT
....................   process_buttons(); 
1F49:  MOVLP  08
1F4A:  GOTO   58C
1F4B:  MOVLP  18
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "\r" or "+" or "-" is received. 
....................     if ( sBufferFlag ) { 
1F4C:  BTFSS  72.0
1F4D:  GOTO   753
....................       process_sBuffer(); 
1F4E:  GOTO   000
....................       clear_sBuffer(); 
1F4F:  MOVLP  00
1F50:  CALL   4A1
1F51:  MOVLP  18
....................       sBufferFlag=0; 
1F52:  BCF    72.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1F53:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1F54:  MOVLB  01
1F55:  BTFSS  5D.0
1F56:  GOTO   75D
....................       update_aux_in(); 
1F57:  MOVLP  10
1F58:  MOVLB  00
1F59:  GOTO   588
1F5A:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1F5B:  MOVLB  01
1F5C:  BCF    5D.0
....................     } 
....................     do_delay_counters(); 
1F5D:  MOVLB  00
1F5E:  GOTO   430
....................     restart_wdt(); 
1F5F:  CLRWDT
....................     if ( COR_FLAG ) { 
1F60:  BTFSS  72.3
1F61:  GOTO   768
....................       process_cor(); 
1F62:  GOTO   4B0
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       update_aux_out();  
1F63:  MOVLP  10
1F64:  CALL   677
1F65:  MOVLP  18
....................       COR_FLAG=0; 
1F66:  BCF    72.3
....................       restart_wdt(); 
1F67:  CLRWDT
....................     } 
....................     if ( DTMF_INTERRUPT_FLAG ) { 
1F68:  MOVLB  01
1F69:  BTFSS  5D.4
1F6A:  GOTO   76F
....................       // Extract data from DTMF device 
....................       process_dtmf_interrupt(); 
1F6B:  MOVLB  00
1F6C:  GOTO   53E
....................       DTMF_INTERRUPT_FLAG=0; 
1F6D:  MOVLB  01
1F6E:  BCF    5D.4
....................     } 
....................     if ( DTMF_IN_FLAG ) { 
1F6F:  BTFSS  5D.3
1F70:  GOTO   776
....................       print_dtmf_info(); 
1F71:  MOVLB  00
1F72:  GOTO   590
....................       DTMF_IN_FLAG=0; 
1F73:  MOVLB  01
1F74:  BCF    5D.3
....................       restart_wdt(); 
1F75:  CLRWDT
....................     } 
....................     if ( DTMF_FLAG ) { 
1F76:  BTFSS  5D.2
1F77:  GOTO   77D
....................       process_dtmf(); 
1F78:  MOVLB  00
1F79:  GOTO   621
....................       DTMF_FLAG=0; 
1F7A:  MOVLB  01
1F7B:  BCF    5D.2
....................     restart_wdt(); 
1F7C:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1F7D:  BTFSS  5D.5
1F7E:  GOTO   785
....................       clear_dtmf_array(); 
1F7F:  MOVLP  10
1F80:  MOVLB  00
1F81:  GOTO   7E8
1F82:  MOVLP  18
....................       CLEAR_DTMF_FLAG=0; 
1F83:  MOVLB  01
1F84:  BCF    5D.5
....................     } 
....................     if ( PROMPT_FLAG ) { 
1F85:  BTFSS  5D.6
1F86:  GOTO   78E
....................       prompt(); 
1F87:  MOVLP  10
1F88:  MOVLB  00
1F89:  CALL   08A
1F8A:  MOVLP  18
....................       PROMPT_FLAG=0; 
1F8B:  MOVLB  01
1F8C:  BCF    5D.6
....................     restart_wdt(); 
1F8D:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1F8E:  MOVLB  00
1F8F:  GOTO   748
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0B7A:  CLRWDT
*
1F90:  SLEEP
....................   delay_ms(1000); 
*
0B7B:  MOVLW  04
0B7C:  MOVLB  02
0B7D:  MOVWF  3F
0B7E:  MOVLW  FA
0B7F:  MOVWF  4A
0B80:  MOVLP  00
0B81:  MOVLB  00
0B82:  CALL   7DA
0B83:  MOVLP  08
0B84:  MOVLB  02
0B85:  DECFSZ 3F,F
0B86:  GOTO   37E
....................   if ( ConfirmChar!=0 ) { 
0B87:  MOVLB  00
0B88:  MOVF   6B,F
0B89:  BTFSC  03.2
0B8A:  GOTO   39F
....................     morse(ConfirmChar); 
0B8B:  MOVF   6B,W
0B8C:  MOVLB  02
0B8D:  MOVWF  3F
0B8E:  MOVLB  00
0B8F:  CALL   083
....................     ConfirmChar=0; 
0B90:  CLRF   6B
....................     restart_wdt(); 
0B91:  CLRWDT
....................     delay_ms(500); 
0B92:  MOVLW  02
0B93:  MOVLB  02
0B94:  MOVWF  3F
0B95:  MOVLW  FA
0B96:  MOVWF  4A
0B97:  MOVLP  00
0B98:  MOVLB  00
0B99:  CALL   7DA
0B9A:  MOVLP  08
0B9B:  MOVLB  02
0B9C:  DECFSZ 3F,F
0B9D:  GOTO   395
0B9E:  MOVLB  00
....................   } 
....................   if (TailChar != 0) { 
0B9F:  MOVF   6A,F
0BA0:  BTFSC  03.2
0BA1:  GOTO   3B6
....................     morse(TailChar); 
0BA2:  MOVF   6A,W
0BA3:  MOVLB  02
0BA4:  MOVWF  3F
0BA5:  MOVLB  00
0BA6:  CALL   083
....................     TailChar=0; 
0BA7:  CLRF   6A
....................     restart_wdt(); 
0BA8:  CLRWDT
....................     delay_ms(500); 
0BA9:  MOVLW  02
0BAA:  MOVLB  02
0BAB:  MOVWF  3F
0BAC:  MOVLW  FA
0BAD:  MOVWF  4A
0BAE:  MOVLP  00
0BAF:  MOVLB  00
0BB0:  CALL   7DA
0BB1:  MOVLP  08
0BB2:  MOVLB  02
0BB3:  DECFSZ 3F,F
0BB4:  GOTO   3AC
0BB5:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0BB6:  CLRWDT
0BB7:  MOVLB  02
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
0FE3:  MOVLB  01
0FE4:  BTFSS  5D.7
0FE5:  GOTO   7E8
....................     admin_timer = ADMIN_TIMEOUT; 
0FE6:  MOVLW  FF
0FE7:  MOVWF  73
....................   } 
....................   return(AdminMode||rs232_mode); 
0FE8:  BTFSC  5D.7
0FE9:  GOTO   7EE
0FEA:  BTFSC  62.0
0FEB:  GOTO   7EE
0FEC:  MOVLW  00
0FED:  GOTO   7EF
0FEE:  MOVLW  01
0FEF:  MOVWF  78
.................... } // }}} 
0FF0:  MOVLB  00
0FF1:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0C9F:  MOVLB  01
0CA0:  BCF    5D.7
0CA1:  MOVLB  02
0CA2:  MOVF   40,F
0CA3:  BTFSC  03.2
0CA4:  GOTO   4A8
0CA5:  MOVLB  01
0CA6:  BSF    5D.7
0CA7:  MOVLB  02
....................   if (AdminMode) { 
0CA8:  MOVLB  01
0CA9:  BTFSS  5D.7
0CAA:  GOTO   4B2
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0CAB:  MOVLW  0A
0CAC:  MOVLB  00
0CAD:  MOVWF  6B
....................     admin_timer = ADMIN_TIMEOUT; 
0CAE:  MOVLW  FF
0CAF:  MOVWF  73
....................   } else { 
0CB0:  GOTO   4B5
0CB1:  MOVLB  01
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0CB2:  MOVLW  18
0CB3:  MOVLB  00
0CB4:  MOVWF  6B
....................   }  
.................... } // }}} 
0CB5:  RETURN
.................... // string matchnig function with case insensitive match. 
.................... int1 my_stricmp(char *s1,char *s2) { // {{{ 
*
0F7B:  MOVLB  02
0F7C:  CLRF   43
....................   unsigned int x=0; 
....................   const char AMASK=0xDF; 
....................   while((AMASK&s1[x])==(AMASK&s2[x])) { 
0F7D:  MOVF   43,W
0F7E:  ADDWF  3F,W
0F7F:  MOVWF  04
0F80:  MOVLW  00
0F81:  ADDWFC 40,W
0F82:  MOVWF  05
0F83:  MOVF   00,W
0F84:  ANDLW  DF
0F85:  MOVWF  44
0F86:  MOVF   43,W
0F87:  ADDWF  41,W
0F88:  MOVWF  04
0F89:  MOVLW  00
0F8A:  ADDWFC 42,W
0F8B:  MOVWF  05
0F8C:  MOVF   00,W
0F8D:  ANDLW  DF
0F8E:  SUBWF  44,W
0F8F:  BTFSS  03.2
0F90:  GOTO   79F
....................     if(s1[x]==0) { 
0F91:  MOVF   43,W
0F92:  ADDWF  3F,W
0F93:  MOVWF  04
0F94:  MOVLW  00
0F95:  ADDWFC 40,W
0F96:  MOVWF  05
0F97:  MOVF   00,F
0F98:  BTFSS  03.2
0F99:  GOTO   79D
....................       return 0; 
0F9A:  MOVLW  00
0F9B:  MOVWF  78
0F9C:  GOTO   7A1
....................     } 
....................     x++; 
0F9D:  INCF   43,F
....................   } 
0F9E:  GOTO   77D
....................   // Strings don't match. Return 1. 
....................   return 1; 
0F9F:  MOVLW  01
0FA0:  MOVWF  78
.................... } // }}} 
0FA1:  MOVLB  00
0FA2:  RETURN
.................... // Fetches data from MC8888 device upon interrupt 
.................... void process_dtmf_interrupt(void) { // {{{ 
....................   int value,dtmf_status; 
....................   dtmf_status = dtmf_read(CONTROL_REG); 
*
1D3E:  MOVLW  01
1D3F:  MOVLB  02
1D40:  MOVWF  3B
1D41:  MOVLP  00
1D42:  MOVLB  00
1D43:  CALL   67E
1D44:  MOVLP  18
1D45:  MOVF   78,W
1D46:  MOVLB  01
1D47:  MOVWF  66
....................   if ( dtmf_status & DTMF_BUFFER_FULL) { 
1D48:  BTFSS  66.2
1D49:  GOTO   58D
....................     value=dtmf_read(DATA_REG); 
1D4A:  MOVLB  02
1D4B:  CLRF   3B
1D4C:  MOVLP  00
1D4D:  MOVLB  00
1D4E:  CALL   67E
1D4F:  MOVLP  18
1D50:  MOVF   78,W
1D51:  MOVLB  01
1D52:  MOVWF  65
....................     DTMF_IN_FLAG=1; 
1D53:  BSF    5D.3
....................     if ( value == dd ) { 
1D54:  MOVF   65,F
1D55:  BTFSS  03.2
1D56:  GOTO   55A
....................       value=d0; 
1D57:  MOVLW  0A
1D58:  MOVWF  65
....................     } else if ( value == d0 ) { 
1D59:  GOTO   55E
1D5A:  MOVF   65,W
1D5B:  SUBLW  0A
1D5C:  BTFSC  03.2
....................       value=dd; 
1D5D:  CLRF   65
....................     } 
....................     if ( value == ds ) { 
1D5E:  MOVF   65,W
1D5F:  SUBLW  0B
1D60:  BTFSC  03.2
....................       CLEAR_DTMF_FLAG=1; 
1D61:  BSF    5D.5
....................     } 
....................     // Check for '#' 
....................     if ( value == dp ) { 
1D62:  MOVF   65,W
1D63:  SUBLW  0C
1D64:  BTFSS  03.2
1D65:  GOTO   56E
....................       DTMF_FLAG = 1; 
1D66:  BSF    5D.2
....................       DTMF_ptr->Last=1; 
1D67:  MOVF   3E,W
1D68:  MOVWF  04
1D69:  MOVF   3F,W
1D6A:  MOVWF  05
1D6B:  ADDFSR 00,FSR0
1D6C:  BSF    00.5
....................     } else { 
1D6D:  GOTO   58D
....................       if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
1D6E:  MOVF   3F,W
1D6F:  SUBLW  20
1D70:  BTFSS  03.0
1D71:  GOTO   58D
1D72:  BTFSS  03.2
1D73:  GOTO   578
1D74:  MOVF   3E,W
1D75:  SUBLW  6D
1D76:  BTFSS  03.0
1D77:  GOTO   58D
....................         DTMF_ptr->Key=value; 
1D78:  MOVF   3E,W
1D79:  MOVWF  04
1D7A:  MOVF   3F,W
1D7B:  MOVWF  05
1D7C:  ADDFSR 00,FSR0
1D7D:  MOVF   65,W
1D7E:  ANDLW  0F
1D7F:  MOVWF  77
1D80:  MOVLW  F0
1D81:  ANDWF  00,W
1D82:  IORWF  77,W
1D83:  MOVWF  00
....................         DTMF_ptr->Strobe=1; 
1D84:  MOVF   3E,W
1D85:  MOVWF  04
1D86:  MOVF   3F,W
1D87:  MOVWF  05
1D88:  ADDFSR 00,FSR0
1D89:  BSF    00.4
....................         DTMF_ptr++; 
1D8A:  INCF   3E,F
1D8B:  BTFSC  03.2
1D8C:  INCF   3F,F
....................       } 
....................     } 
....................   } 
.................... } // }}} 
1D8D:  MOVLP  18
1D8E:  MOVLB  00
1D8F:  GOTO   76D (RETURN)
.................... void init_lcd(void) { // {{{ 
.................... #define INIT 0x18 
.................... #define MODE_SET 0x1C 
.................... #define ENABLE 0x04 
....................   i2c_start(); 
....................   i2c_write(LCD_I2C_ADD<<1); 
....................   // Function set 
....................   // Initialize in 8-bit mode first for 3 clock cycles 
....................   lcd_strobe(0x30);lcd_strobe(0x30);lcd_strobe(0x30); 
....................   // Init 4-bit interface mode 
....................   lcd_strobe(0x20); 
....................   lcd_write(0,0x2C); 
....................   // Display On/Off, Cursor off 
....................   lcd_write(0,0x0C); 
....................   // Display clear 
....................   lcd_write(0,0x01); 
....................   // Entry mode set 
....................   lcd_write(0,0x04); 
....................   i2c_stop(); 
.................... } // }}} 
.................... void do_delay_counters(void) { 
....................   // Second Flag {{{ 
....................   if ( SECOND_FLAG ) { 
*
1C30:  BTFSS  72.4
1C31:  GOTO   474
....................     update_aux_out(); 
1C32:  MOVLP  10
1C33:  CALL   677
1C34:  MOVLP  18
....................     // Time Out PTT {{{ 
....................     if ( TOT_SecondCounter || TOT_Min == 0) { 
1C35:  MOVLB  01
1C36:  MOVF   60,W
1C37:  IORWF  61,W
1C38:  BTFSS  03.2
1C39:  GOTO   43F
1C3A:  MOVLB  00
1C3B:  MOVF   66,F
1C3C:  BTFSS  03.2
1C3D:  GOTO   445
1C3E:  MOVLB  01
....................       TOT_SecondCounter--; 
1C3F:  MOVF   60,W
1C40:  BTFSC  03.2
1C41:  DECF   61,F
1C42:  DECF   60,F
....................     } else if ( COR_IN != 0x00 ) { 
1C43:  GOTO   459
1C44:  MOVLB  00
1C45:  MOVF   5F,F
1C46:  BTFSC  03.2
1C47:  GOTO   45A
....................       update_ptt(0); 
1C48:  MOVLB  02
1C49:  CLRF   2E
1C4A:  MOVLP  08
1C4B:  MOVLB  00
1C4C:  CALL   34B
1C4D:  MOVLP  18
....................       printf("\n\r# PTT Timeout!\n"); 
1C4E:  MOVLW  8E
1C4F:  MOVLB  03
1C50:  MOVWF  11
1C51:  MOVLW  04
1C52:  MOVWF  12
1C53:  MOVLP  00
1C54:  MOVLB  00
1C55:  CALL   4BB
1C56:  MOVLP  18
....................       PROMPT_FLAG=1; 
1C57:  MOVLB  01
1C58:  BSF    5D.6
1C59:  MOVLB  00
....................     } 
....................     // }}} 
....................     // Admin mode timeout {{{ 
....................     if ( admin_timer ) { 
1C5A:  MOVF   73,F
1C5B:  BTFSC  03.2
1C5C:  GOTO   45F
....................       admin_timer--; 
1C5D:  DECF   73,F
....................     } else { 
1C5E:  GOTO   468
....................       // Exit admin mode. 
....................       if ( AdminMode ) { 
1C5F:  MOVLB  01
1C60:  BTFSS  5D.7
1C61:  GOTO   469
....................         set_admin_mode(0); 
1C62:  MOVLB  02
1C63:  CLRF   40
1C64:  MOVLP  08
1C65:  MOVLB  00
1C66:  CALL   49F
1C67:  MOVLP  18
1C68:  MOVLB  01
....................       } 
....................     } 
....................     // }}} 
....................     restart_wdt(); 
1C69:  CLRWDT
....................     if ( SecondCounter ) { 
1C6A:  MOVF   5E,F
1C6B:  BTFSC  03.2
1C6C:  GOTO   46F
....................       SecondCounter--; 
1C6D:  DECF   5E,F
....................     } else { 
1C6E:  GOTO   472
....................       SecondCounter=SEC_COUNTER; 
1C6F:  MOVLW  3B
1C70:  MOVWF  5E
....................       MINUTE_FLAG = 1; 
1C71:  BSF    72.5
....................     } 
....................     SECOND_FLAG=0; 
1C72:  BCF    72.4
1C73:  MOVLB  00
....................   } 
....................   // Second Flag }}} 
....................   // Minute flag {{{ 
....................   if ( MINUTE_FLAG ) { 
1C74:  BTFSS  72.5
1C75:  GOTO   493
....................     if ( MinuteCounter ) { 
1C76:  MOVLB  01
1C77:  MOVF   5F,F
1C78:  BTFSC  03.2
1C79:  GOTO   47C
....................       MinuteCounter--; 
1C7A:  DECF   5F,F
....................     } else { 
1C7B:  GOTO   47F
....................       THIRTY_MIN_FLAG=1; 
1C7C:  BSF    72.6
....................       MinuteCounter = MIN_COUNTER; 
1C7D:  MOVLW  1D
1C7E:  MOVWF  5F
....................     } 
....................     MINUTE_FLAG = 0; 
1C7F:  BCF    72.5
....................     // Link timeout timer {{{ 
....................     if ( Link_TOT != 0 ) { 
1C80:  MOVLB  00
1C81:  MOVF   67,F
1C82:  BTFSC  03.2
1C83:  GOTO   493
....................       if ( LinkDurationTimer ) { 
1C84:  MOVF   68,F
1C85:  BTFSC  03.2
1C86:  GOTO   489
....................         LinkDurationTimer--; 
1C87:  DECF   68,F
....................       } else { 
1C88:  GOTO   493
....................         // Disable Link 
....................         printf("\n\r# Link Timeout!\n"); 
1C89:  MOVLW  97
1C8A:  MOVLB  03
1C8B:  MOVWF  11
1C8C:  MOVLW  04
1C8D:  MOVWF  12
1C8E:  MOVLP  00
1C8F:  MOVLB  00
1C90:  CALL   4BB
1C91:  MOVLP  18
....................         Enable&=0xFE; 
1C92:  BCF    60.0
....................       } 
....................     } 
....................     // Link timeout timer }}} 
....................   } 
....................   // Minute flag }}} 
....................   if ( THIRTY_MIN_FLAG ) { // {{{ 
1C93:  BTFSS  72.6
1C94:  GOTO   4AE
....................     if ( (TXSiteID&0x03) !=0 ) { 
1C95:  MOVF   64,W
1C96:  ANDLW  03
1C97:  BTFSC  03.2
1C98:  GOTO   4AD
....................       // Transmit Site ID every 30 mins when: 
....................       // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................       // E = Transmit every 30 mins 
....................       // M = Transmit only if EnableMask is off 
....................       if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
1C99:  MOVF   64,W
1C9A:  ANDLW  01
1C9B:  BTFSS  03.2
1C9C:  GOTO   4AA
1C9D:  MOVF   64,W
1C9E:  ANDLW  02
1C9F:  BTFSC  03.2
1CA0:  GOTO   4AD
1CA1:  SWAPF  64,W
1CA2:  MOVWF  77
1CA3:  MOVLW  0F
1CA4:  ANDWF  77,F
1CA5:  MOVF   77,W
1CA6:  ANDLW  0F
1CA7:  ANDWF  60,W
1CA8:  BTFSS  03.2
1CA9:  GOTO   4AD
....................         send_morse_id(); 
1CAA:  MOVLP  10
1CAB:  CALL   0A2
1CAC:  MOVLP  18
....................       } 
....................     } 
....................     THIRTY_MIN_FLAG=0; 
1CAD:  BCF    72.6
....................   } // }}} 
.................... } 
1CAE:  MOVLP  18
1CAF:  GOTO   75F (RETURN)
.................... void process_buttons(void) { // {{{ 
.................... #ifdef BUTTON_STATES 
....................   char enter_b,select_b; 
....................   // Process Enter / select buttons {{{ 
....................   if ( input(ENTER_BUTTON)==0 ) { 
*
0D8C:  MOVLB  01
0D8D:  BSF    0C.7
0D8E:  MOVLB  00
0D8F:  BTFSC  0C.7
0D90:  GOTO   59D
....................     ENTER_PRESSED = (enter_b == DEBOUNCE_COUNT); 
0D91:  BCF    72.1
0D92:  MOVLB  01
0D93:  MOVF   65,W
0D94:  SUBLW  08
0D95:  BTFSC  03.2
0D96:  BSF    72.1
....................     if ( enter_b < DEBOUNCE_COUNT+ 1 ) { 
0D97:  MOVF   65,W
0D98:  SUBLW  08
0D99:  BTFSC  03.0
....................       enter_b++;  
0D9A:  INCF   65,F
....................     } 
....................   } else { 
0D9B:  GOTO   5A0
0D9C:  MOVLB  00
....................     enter_b = 0; 
0D9D:  MOVLB  01
0D9E:  CLRF   65
....................     ENTER_PRESSED = 0; 
0D9F:  BCF    72.1
....................   } 
....................   if ( input(SELECT_BUTTON)==0 ) { 
0DA0:  MOVLB  00
0DA1:  BTFSC  10.3
0DA2:  GOTO   5AF
....................     SELECT_PRESSED = (select_b == DEBOUNCE_COUNT); 
0DA3:  BCF    72.2
0DA4:  MOVLB  01
0DA5:  MOVF   66,W
0DA6:  SUBLW  08
0DA7:  BTFSC  03.2
0DA8:  BSF    72.2
....................     if ( select_b < DEBOUNCE_COUNT + 1 ) { 
0DA9:  MOVF   66,W
0DAA:  SUBLW  08
0DAB:  BTFSC  03.0
....................       select_b++; 
0DAC:  INCF   66,F
....................     } 
....................   } else { 
0DAD:  GOTO   5B2
0DAE:  MOVLB  00
....................     select_b = 0; 
0DAF:  MOVLB  01
0DB0:  CLRF   66
....................     SELECT_PRESSED = 0; 
0DB1:  BCF    72.2
....................   } 
....................   // Define Button States 
....................   // IDLE + ENTER --> TRIM 
....................   // TRIM + ENTER --> Exit 
....................   // TRIM + SELECT --> NextPot 
....................   switch (button_state) { 
0DB2:  MOVF   5C,W
0DB3:  XORLW  00
0DB4:  MOVLB  00
0DB5:  BTFSC  03.2
0DB6:  GOTO   5BE
0DB7:  XORLW  10
0DB8:  BTFSC  03.2
0DB9:  GOTO   5C5
0DBA:  XORLW  1F
0DBB:  BTFSC  03.2
0DBC:  GOTO   5D5
0DBD:  GOTO   636
....................     case BUTTON_IDLE:   
....................       if ( ENTER_PRESSED == 1 ) { 
0DBE:  BTFSS  72.1
0DBF:  GOTO   5C4
....................         button_state=CALIB; 
0DC0:  MOVLW  10
0DC1:  MOVLB  01
0DC2:  MOVWF  5C
0DC3:  MOVLB  00
....................       } 
....................     break; 
0DC4:  GOTO   639
....................     case CALIB: 
....................       adj_value_a = read_adc() >> 2; 
0DC5:  MOVLB  01
0DC6:  BSF    1D.1
0DC7:  BTFSC  1D.1
0DC8:  GOTO   5C7
0DC9:  RRF    1C,W
0DCA:  MOVWF  7E
0DCB:  RRF    7E,F
0DCC:  MOVLW  3F
0DCD:  ANDWF  7E,F
....................       adj_value_b = adj_value_a; 
0DCE:  MOVF   7E,W
0DCF:  MOVWF  5B
....................       button_state=TRIM; 
0DD0:  MOVLW  0F
0DD1:  MOVWF  5C
....................       pot_values_to_lcd(); 
0DD2:  MOVLB  00
0DD3:  CALL   257
....................       break; 
0DD4:  GOTO   639
....................     case TRIM: 
....................        if ( ((COR_IN|COR_EMUL)&0x0F) != 0 ) { 
0DD5:  MOVF   5F,W
0DD6:  IORWF  69,W
0DD7:  ANDLW  0F
0DD8:  BTFSC  03.2
0DD9:  GOTO   5FC
....................          adj_value_a = read_adc() >> 2; 
0DDA:  MOVLB  01
0DDB:  BSF    1D.1
0DDC:  BTFSC  1D.1
0DDD:  GOTO   5DC
0DDE:  RRF    1C,W
0DDF:  MOVWF  7E
0DE0:  RRF    7E,F
0DE1:  MOVLW  3F
0DE2:  ANDWF  7E,F
....................          if ( adj_value_a != adj_value_b ) { 
0DE3:  MOVF   5B,W
0DE4:  SUBWF  7E,W
0DE5:  BTFSC  03.2
0DE6:  GOTO   5F9
....................            rs232_mode = 1; 
0DE7:  BSF    62.0
....................            set_trimpot(CurrentTrimPot, 63-adj_value_a); 
0DE8:  MOVF   7E,W
0DE9:  SUBLW  3F
0DEA:  MOVWF  67
0DEB:  MOVF   74,W
0DEC:  MOVLB  02
0DED:  MOVWF  3F
0DEE:  MOVLB  01
0DEF:  MOVF   67,W
0DF0:  MOVLB  02
0DF1:  MOVWF  40
0DF2:  MOVLP  00
0DF3:  MOVLB  00
0DF4:  CALL   76F
0DF5:  MOVLP  08
....................            pot_values_to_lcd(); 
0DF6:  CALL   257
....................            rs232_mode = 0; 
0DF7:  MOVLB  01
0DF8:  BCF    62.0
....................          } 
....................          adj_value_b = adj_value_a; 
0DF9:  MOVF   7E,W
0DFA:  MOVWF  5B
0DFB:  MOVLB  00
.................... 	     } 
....................        if ( SELECT_PRESSED == 1 ) { 
0DFC:  BTFSS  72.2
0DFD:  GOTO   603
....................          CurrentTrimPot = (CurrentTrimPot + 1 ) & 0x03; 
0DFE:  MOVLW  01
0DFF:  ADDWF  74,W
0E00:  ANDLW  03
0E01:  MOVWF  74
....................          pot_values_to_lcd(); 
0E02:  CALL   257
....................        } 
....................        if ( ENTER_PRESSED == 1 ) { 
0E03:  BTFSS  72.1
0E04:  GOTO   60D
....................          // Hold SELECT and press ENTER to store settings in EEPROM 
....................          if ( input(SELECT_BUTTON)==0 ) { 
0E05:  BTFSC  10.3
0E06:  GOTO   60A
....................            store_variables(); 
0E07:  MOVLP  00
0E08:  CALL   5AE
0E09:  MOVLP  08
....................          } 
....................          button_state = BUTTON_IDLE; 
0E0A:  MOVLB  01
0E0B:  CLRF   5C
0E0C:  MOVLB  00
.................... 	     }  
....................        status_led(); 
....................     break; 
*
0E34:  MOVLB  00
0E35:  GOTO   639
....................     default: 
....................   		button_state = BUTTON_IDLE; 
0E36:  MOVLB  01
0E37:  CLRF   5C
....................     break; 
0E38:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0E39:  CLRWDT
....................   // }}} 
.................... #endif 
.................... } // }}} 
0E3A:  MOVLP  18
0E3B:  GOTO   74B (RETURN)

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
