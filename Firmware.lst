CCS PCM C Compiler, Version 4.140, 64991               04-Jan-24 17:17

               Filename:   C:\Users\m3n2bn\Projects\MBPAB IDE\RC2Ga\52_Buckingham\Firmware.lst

               ROM used:   7935 words (97%)
                           Largest free fragment is 225
               RAM used:   163 (32%) at main() level
                           229 (45%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   682
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   348
002D:  MOVLP  00
002E:  GOTO   37A
002F:  MOVLP  00
0030:  GOTO   2EB
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
15AC:  MOVLB  02
15AD:  MOVF   27,W
15AE:  MOVWF  2B
15AF:  MOVF   26,W
15B0:  MOVWF  2A
15B1:  MOVF   2B,W
15B2:  MOVWF  7A
15B3:  MOVF   2A,W
15B4:  MOVWF  04
15B5:  MOVF   7A,W
15B6:  MOVWF  05
15B7:  MOVF   00,F
15B8:  BTFSC  03.2
15B9:  GOTO   5BE
15BA:  INCF   2A,F
15BB:  BTFSC  03.2
15BC:  INCF   2B,F
15BD:  GOTO   5B1
....................    while(*s2 != '\0') 
....................    { 
15BE:  MOVF   29,W
15BF:  MOVWF  7A
15C0:  MOVF   28,W
15C1:  MOVWF  04
15C2:  MOVF   7A,W
15C3:  MOVWF  05
15C4:  MOVF   00,F
15C5:  BTFSC  03.2
15C6:  GOTO   5DA
....................       *s = *s2; 
15C7:  MOVF   28,W
15C8:  MOVWF  04
15C9:  MOVF   29,W
15CA:  MOVWF  05
15CB:  MOVF   00,W
15CC:  MOVWF  2E
15CD:  MOVF   2B,W
15CE:  MOVWF  05
15CF:  MOVF   2A,W
15D0:  MOVWF  04
15D1:  MOVF   2E,W
15D2:  MOVWF  00
....................       ++s; 
15D3:  INCF   2A,F
15D4:  BTFSC  03.2
15D5:  INCF   2B,F
....................       ++s2; 
15D6:  INCF   28,F
15D7:  BTFSC  03.2
15D8:  INCF   29,F
....................    } 
15D9:  GOTO   5BE
....................  
....................    *s = '\0'; 
15DA:  MOVF   2A,W
15DB:  MOVWF  04
15DC:  MOVF   2B,W
15DD:  MOVWF  05
15DE:  CLRF   00
....................    return(s1); 
15DF:  MOVF   26,W
15E0:  MOVWF  78
15E1:  MOVF   27,W
15E2:  MOVWF  79
.................... } 
15E3:  MOVLB  00
15E4:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E02:  MOVF   45,W
0E03:  MOVWF  49
0E04:  MOVF   44,W
0E05:  MOVWF  48
0E06:  MOVF   49,W
0E07:  MOVWF  7A
0E08:  MOVF   48,W
0E09:  MOVWF  04
0E0A:  MOVF   7A,W
0E0B:  MOVWF  05
0E0C:  MOVF   00,F
0E0D:  BTFSC  03.2
0E0E:  GOTO   63B
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0E0F:  MOVF   47,W
0E10:  MOVWF  4B
0E11:  MOVF   46,W
0E12:  MOVWF  4A
0E13:  MOVF   4B,W
0E14:  MOVWF  7A
0E15:  MOVF   4A,W
0E16:  MOVWF  04
0E17:  MOVF   7A,W
0E18:  MOVWF  05
0E19:  MOVF   00,F
0E1A:  BTFSC  03.2
0E1B:  GOTO   637
....................          if (*sc1 == *sc2) 
0E1C:  MOVF   49,W
0E1D:  MOVWF  7A
0E1E:  MOVF   48,W
0E1F:  MOVWF  04
0E20:  MOVF   7A,W
0E21:  MOVWF  05
0E22:  MOVF   00,W
0E23:  MOVWF  4C
0E24:  MOVF   4B,W
0E25:  MOVWF  7A
0E26:  MOVF   4A,W
0E27:  MOVWF  04
0E28:  MOVF   7A,W
0E29:  MOVWF  05
0E2A:  MOVF   00,W
0E2B:  SUBWF  4C,W
0E2C:  BTFSS  03.2
0E2D:  GOTO   633
....................             return(sc1); 
0E2E:  MOVF   48,W
0E2F:  MOVWF  78
0E30:  MOVF   49,W
0E31:  MOVWF  79
0E32:  GOTO   63E
0E33:  INCF   4A,F
0E34:  BTFSC  03.2
0E35:  INCF   4B,F
0E36:  GOTO   613
0E37:  INCF   48,F
0E38:  BTFSC  03.2
0E39:  INCF   49,F
0E3A:  GOTO   606
....................    return(0); 
0E3B:  MOVLW  00
0E3C:  MOVWF  78
0E3D:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0D9B:  MOVF   45,W
0D9C:  MOVWF  49
0D9D:  MOVF   44,W
0D9E:  MOVWF  48
0D9F:  MOVF   49,W
0DA0:  MOVWF  7A
0DA1:  MOVF   48,W
0DA2:  MOVWF  04
0DA3:  MOVF   7A,W
0DA4:  MOVWF  05
0DA5:  MOVF   00,F
0DA6:  BTFSC  03.2
0DA7:  GOTO   5D9
....................       for (sc2 = s2; ; sc2++) 
0DA8:  MOVF   47,W
0DA9:  MOVWF  4B
0DAA:  MOVF   46,W
0DAB:  MOVWF  4A
....................     if (*sc2 == '\0') 
0DAC:  MOVF   4B,W
0DAD:  MOVWF  7A
0DAE:  MOVF   4A,W
0DAF:  MOVWF  04
0DB0:  MOVF   7A,W
0DB1:  MOVWF  05
0DB2:  MOVF   00,F
0DB3:  BTFSS  03.2
0DB4:  GOTO   5BF
....................        return(sc1 - s1); 
0DB5:  MOVF   44,W
0DB6:  SUBWF  48,W
0DB7:  MOVWF  77
0DB8:  MOVF   45,W
0DB9:  SUBWFC 49,W
0DBA:  MOVWF  7A
0DBB:  MOVF   77,W
0DBC:  MOVWF  78
0DBD:  GOTO   5E1
....................          else if (*sc1 == *sc2) 
0DBE:  GOTO   5D1
0DBF:  MOVF   49,W
0DC0:  MOVWF  7A
0DC1:  MOVF   48,W
0DC2:  MOVWF  04
0DC3:  MOVF   7A,W
0DC4:  MOVWF  05
0DC5:  MOVF   00,W
0DC6:  MOVWF  4C
0DC7:  MOVF   4B,W
0DC8:  MOVWF  7A
0DC9:  MOVF   4A,W
0DCA:  MOVWF  04
0DCB:  MOVF   7A,W
0DCC:  MOVWF  05
0DCD:  MOVF   00,W
0DCE:  SUBWF  4C,W
0DCF:  BTFSC  03.2
....................             break; 
0DD0:  GOTO   5D5
0DD1:  INCF   4A,F
0DD2:  BTFSC  03.2
0DD3:  INCF   4B,F
0DD4:  GOTO   5AC
0DD5:  INCF   48,F
0DD6:  BTFSC  03.2
0DD7:  INCF   49,F
0DD8:  GOTO   59F
....................    return(sc1 - s1); 
0DD9:  MOVF   44,W
0DDA:  SUBWF  48,W
0DDB:  MOVWF  77
0DDC:  MOVF   45,W
0DDD:  SUBWFC 49,W
0DDE:  MOVWF  7A
0DDF:  MOVF   77,W
0DE0:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1EB0:  MOVLB  00
1EB1:  CLRF   26
1EB2:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0D82:  MOVLB  02
0D83:  MOVF   3C,W
0D84:  IORWF  3D,W
0D85:  BTFSC  03.2
0D86:  GOTO   58B
0D87:  MOVF   3D,W
0D88:  MOVWF  7A
0D89:  MOVF   3C,W
0D8A:  GOTO   590
0D8B:  MOVLB  00
0D8C:  MOVF   27,W
0D8D:  MOVWF  7A
0D8E:  MOVF   26,W
0D8F:  MOVLB  02
0D90:  MOVWF  40
0D91:  MOVF   7A,W
0D92:  MOVWF  41
....................    beg += strspn(beg, s2); 
0D93:  MOVF   41,W
0D94:  MOVWF  45
0D95:  MOVF   40,W
0D96:  MOVWF  44
0D97:  MOVF   3F,W
0D98:  MOVWF  47
0D99:  MOVF   3E,W
0D9A:  MOVWF  46
*
0DE1:  MOVF   78,W
0DE2:  ADDWF  40,F
0DE3:  MOVLW  00
0DE4:  ADDWFC 41,F
....................    if (*beg == '\0') 
0DE5:  MOVF   41,W
0DE6:  MOVWF  7A
0DE7:  MOVF   40,W
0DE8:  MOVWF  04
0DE9:  MOVF   7A,W
0DEA:  MOVWF  05
0DEB:  MOVF   00,F
0DEC:  BTFSS  03.2
0DED:  GOTO   5FA
....................    { 
....................       *save = ' '; 
0DEE:  MOVLB  00
0DEF:  MOVF   26,W
0DF0:  MOVWF  04
0DF1:  MOVF   27,W
0DF2:  MOVWF  05
0DF3:  MOVLW  20
0DF4:  MOVWF  00
....................       return(0); 
0DF5:  MOVLW  00
0DF6:  MOVWF  78
0DF7:  MOVWF  79
0DF8:  GOTO   65F
0DF9:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0DFA:  MOVF   41,W
0DFB:  MOVWF  45
0DFC:  MOVF   40,W
0DFD:  MOVWF  44
0DFE:  MOVF   3F,W
0DFF:  MOVWF  47
0E00:  MOVF   3E,W
0E01:  MOVWF  46
*
0E3E:  MOVF   79,W
0E3F:  MOVWF  43
0E40:  MOVF   78,W
0E41:  MOVWF  42
....................    if (*end != '\0') 
0E42:  MOVF   43,W
0E43:  MOVWF  7A
0E44:  MOVF   42,W
0E45:  MOVWF  04
0E46:  MOVF   7A,W
0E47:  MOVWF  05
0E48:  MOVF   00,F
0E49:  BTFSC  03.2
0E4A:  GOTO   653
....................    { 
....................       *end = '\0'; 
0E4B:  MOVF   42,W
0E4C:  MOVWF  04
0E4D:  MOVF   43,W
0E4E:  MOVWF  05
0E4F:  CLRF   00
....................       end++; 
0E50:  INCF   42,F
0E51:  BTFSC  03.2
0E52:  INCF   43,F
....................    } 
....................    save = end; 
0E53:  MOVF   43,W
0E54:  MOVLB  00
0E55:  MOVWF  27
0E56:  MOVLB  02
0E57:  MOVF   42,W
0E58:  MOVLB  00
0E59:  MOVWF  26
....................    return(beg); 
0E5A:  MOVLB  02
0E5B:  MOVF   40,W
0E5C:  MOVWF  78
0E5D:  MOVF   41,W
0E5E:  MOVWF  79
0E5F:  MOVLB  00
.................... } 
0E60:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
....................  
.................... #define POT_MAX 63 
....................  
.................... #define RS 0x01 
.................... #define LCD_READ 0x02   
.................... #define LCD_WRITE 0x00   
.................... #define E 0x04 
.................... #define BT 0x08 
.................... #define CHANGE_LINE 0x80 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
0800:  MOVLW  20
0801:  MOVWF  05
0802:  MOVLW  C7
0803:  MOVWF  04
0804:  MOVF   00,W
0805:  BTFSC  03.2
0806:  GOTO   018
0807:  MOVLW  02
0808:  MOVWF  78
0809:  MOVLW  BF
080A:  MOVWF  77
080B:  CLRWDT
080C:  DECFSZ 77,F
080D:  GOTO   00B
080E:  DECFSZ 78,F
080F:  GOTO   009
0810:  MOVLW  96
0811:  MOVWF  77
0812:  DECFSZ 77,F
0813:  GOTO   012
0814:  GOTO   015
0815:  CLRWDT
0816:  DECFSZ 00,F
0817:  GOTO   007
0818:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
06B3:  MOVLB  04
06B4:  BCF    15.7
06B5:  MOVLB  00
06B6:  BCF    11.3
06B7:  MOVLB  02
06B8:  MOVF   4D,W
06B9:  MOVLB  04
06BA:  MOVWF  11
06BB:  MOVLW  02
06BC:  BTFSC  15.7
06BD:  GOTO   6C5
06BE:  MOVLB  00
06BF:  BTFSS  11.3
06C0:  GOTO   6BF
06C1:  MOVLW  00
06C2:  MOVLB  04
06C3:  BTFSC  16.6
06C4:  MOVLW  01
06C5:  MOVWF  78
06C6:  MOVLB  00
06C7:  RETURN
*
0AA0:  MOVLB  04
0AA1:  BCF    15.6
0AA2:  BSF    16.3
0AA3:  BTFSC  16.3
0AA4:  GOTO   2A3
0AA5:  BTFSC  77.0
0AA6:  BCF    16.5
0AA7:  BTFSS  77.0
0AA8:  BSF    16.5
0AA9:  BSF    16.4
0AAA:  BTFSC  16.4
0AAB:  GOTO   2AA
0AAC:  MOVF   11,W
0AAD:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02E4:  CLRWDT
02E5:  BTFSS  11.4
02E6:  GOTO   2E4
02E7:  MOVLB  03
02E8:  MOVWF  1A
02E9:  MOVLB  00
02EA:  RETURN
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void process_dtmf_interrupt(void); 
.................... void init_lcd(void); 
.................... void send_tail(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
.................... void print_dfmf_info(void); 
.................... void do_delay_counters(void); 
.................... int1 my_stricmp(char *, char *); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN; 
.................... unsigned int Enable; 
.................... unsigned int Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned int TOT_Min; 
.................... unsigned int TOT_FLAG_Mask; 
.................... unsigned int Link_TOT,LinkDurationTimer; 
.................... unsigned int COR_EMUL; 
.................... unsigned int COR_AUX; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... char COR_IN_EFFECTIVE; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... #define LINK_CMD 1 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... #define AUXI_EMULATE_COR1 0x01 
.................... #define AUXI_EMULATE_COR2 0x02 
.................... #define AUXI_EMULATE_COR3 0x04 
.................... #define AUXI_EMULATE_COR4 0x08 
.................... #define AUXI_EMULATE_COR5 0x10 // COR from AUX only for DTMF control (No audio feed-thru) 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x20 
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... unsigned int command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... unsigned int  LastRegisterIndex; 
.................... unsigned int  LastRegisterIndexValid; 
....................  
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
....................   int  usage : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1       COR_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... unsigned long TOT_SecondCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1       DTMF_INTERRUPT_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... // PROTECTED -- Must be in admin mode to set value 
.................... // PUBLIC    -- Register can be set in any mode 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
.................... #define PROTECTED 1 
.................... #define PUBLIC    0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 
.................... 	{"XI2"},	  // 19 
.................... 	{"XI3"},	  // 20 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"LTO"},  // 54 
....................     {"COR"},  // 55 
....................     {"CPOT"}  // 56 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
....................  
.................... #define SITE_ID_VAL  	52 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... #define ENABLE_DEFAULT 0xEF 
.................... #define TOT_MIN 1 
.................... #define LINK_TOT 0 
.................... #define DEFAULT_GAIN 32 
.................... //#define LCD_TYPE_PI 1 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('e') 
.................... #define MORSEID5	MCHAR('h') 
....................  
.................... #define AUXOUTOP0  AUX_OUT_FOLLOW_COR 
.................... #define AUXOUTARG0 AUX_OUT_FOLLOW_COR1 | AUX_OUT_FOLLOW_COR_INVERT1 
.................... #define AUXOUTOP1  0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2  0 
.................... #define AUXOUTARG2 0 
....................  
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  AUXI_EMULATE_COR 
.................... #define AUXINARG0 AUXI_EMULATE_COR1 | AUXI_EMULATE_COR_ACTIVE_LO 
.................... #define AUXINOP1  AUXI_TAIL_WHEN_HI 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
.................... #define RX1_PTT 0x0E 
.................... #define RX2_PTT 0x0D 
.................... #define RX3_PTT 0x0B 
.................... #define RX4_PTT 0x07 
....................  
.................... // Define default variables {{{ 
.................... #ifdef LCD_TYPE_PI 
....................   #define LCD_I2C_ADD 0x27 
.................... #else 
....................   #define LCD_I2C_ADD 0x60 
.................... #endif 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... #ifndef RX1_PTT 
....................   #define RX1_PTT 0x0E 
.................... #endif 
.................... #ifndef RX2_PTT 
....................   #define RX2_PTT 0x0D 
.................... #endif 
.................... #ifndef RX3_PTT 
....................   #define RX3_PTT 0x0B  
.................... #endif 
.................... #ifndef RX4_PTT 
....................   #define RX4_PTT 0x07 
.................... #endif 
.................... #ifndef DEFAULT_GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  , EEPROM,PUBLIC}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL, EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&AuxIn[0]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[1]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[2]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[0]     ,PO_AUX_OUT0     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[1]     ,PO_AUX_OUT1     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[2]     ,PO_AUX_OUT2     , EEPROM,PUBLIC}, 
.................... 	{&RXPriority[0] ,4               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[1] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[2] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[3] ,2               , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[0]     ,RX1_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[1]     ,RX2_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[2]     ,RX3_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[3]     ,RX4_PTT         , EEPROM,PROTECTED}, 
.................... 	{&SiteID        ,SITE_ID_VAL     , EEPROM,PROTECTED}, 
.................... 	{&TXSiteID      ,0x12            , EEPROM,PROTECTED}, 
....................   {&Morse[0]      ,MORSEID0        , EEPROM,PROTECTED}, 
....................   {&Morse[1]      ,MORSEID1        , EEPROM,PROTECTED}, 
....................   {&Morse[2]      ,MORSEID2        , EEPROM,PROTECTED}, 
....................   {&Morse[3]      ,MORSEID3        , EEPROM,PROTECTED}, 
....................   {&Morse[4]      ,MORSEID4        , EEPROM,PROTECTED}, 
....................   {&Morse[5]      ,MORSEID5        , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2      , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2        , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2       , EEPROM,PROTECTED}, 
....................   {&Tail          ,TAIL_CHAR       , EEPROM,PROTECTED}, 
....................   {&TOT_Min       ,TOT_MIN         , EEPROM,PROTECTED}, 
....................   {&Link_TOT      ,LINK_TOT        , EEPROM,PROTECTED}, 
.................... 	{&COR_EMUL      ,0x00            , RAM   ,PUBLIC}, 
.................... 	{&CurrentTrimPot,0x00            , RAM   ,PROTECTED}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02EB:  BTFSS  11.5
02EC:  GOTO   342
....................     c = getc(); 
02ED:  CLRWDT
02EE:  BTFSS  11.5
02EF:  GOTO   2ED
02F0:  MOVLB  03
02F1:  MOVF   19,W
02F2:  MOVLB  02
02F3:  MOVWF  52
....................     if ( c == '\b' ) { 
02F4:  MOVF   52,W
02F5:  SUBLW  08
02F6:  BTFSS  03.2
02F7:  GOTO   320
....................       if ( sBufferIndex > 0 ) { 
02F8:  MOVF   73,F
02F9:  BTFSC  03.2
02FA:  GOTO   31A
....................         sBufferIndex--; 
02FB:  DECF   73,F
....................         sBuffer[sBufferIndex]='\0'; 
02FC:  MOVLW  50
02FD:  ADDWF  73,W
02FE:  MOVWF  04
02FF:  MOVLW  20
0300:  MOVWF  05
0301:  BTFSC  03.0
0302:  INCF   05,F
0303:  CLRF   00
....................         putc('\b'); 
0304:  MOVLW  08
0305:  MOVLB  00
0306:  CALL   2E4
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
0307:  MOVLW  1B
0308:  CALL   2E4
....................   printf("[K"); 
0309:  MOVLW  5B
030A:  CLRWDT
030B:  BTFSS  11.4
030C:  GOTO   30A
030D:  MOVLB  03
030E:  MOVWF  1A
030F:  MOVLW  4B
0310:  CLRWDT
0311:  MOVLB  00
0312:  BTFSC  11.4
0313:  GOTO   316
0314:  MOVLB  03
0315:  GOTO   310
0316:  MOVLB  03
0317:  MOVWF  1A
....................       } else { 
0318:  GOTO   31E
0319:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
031A:  MOVLW  07
031B:  MOVLB  00
031C:  CALL   2E4
031D:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
031E:  GOTO   344
031F:  MOVLB  02
0320:  MOVF   73,W
0321:  SUBLW  0F
0322:  BTFSS  03.0
0323:  GOTO   33F
....................       putc(c); // echo the character 
0324:  MOVF   52,W
0325:  MOVLB  00
0326:  CALL   2E4
....................       sBuffer[sBufferIndex++] = c; 
0327:  MOVF   73,W
0328:  INCF   73,F
0329:  ADDLW  50
032A:  MOVWF  04
032B:  MOVLW  20
032C:  MOVWF  05
032D:  BTFSC  03.0
032E:  INCF   05,F
032F:  MOVLB  02
0330:  MOVF   52,W
0331:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0332:  MOVF   52,W
0333:  SUBLW  0D
0334:  BTFSC  03.2
0335:  GOTO   33D
0336:  MOVF   52,W
0337:  SUBLW  2B
0338:  BTFSC  03.2
0339:  GOTO   33D
033A:  MOVF   52,W
033B:  SUBLW  2D
033C:  BTFSC  03.2
....................         sBufferFlag=1; 
033D:  BSF    74.0
....................       } 
....................     } else { 
033E:  GOTO   343
....................       putc('\a'); // Send alert. Avoid buffer overflow 
033F:  MOVLW  07
0340:  MOVLB  00
0341:  CALL   2E4
0342:  MOVLB  02
0343:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
0344:  MOVLB  00
0345:  BCF    11.5
0346:  MOVLP  00
0347:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   int LAST_COR_IN; 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if(IOCBF&0x0F) { // Check for interrupts on RB[3:0] only 
0348:  MOVLB  07
0349:  MOVF   16,W
034A:  ANDLW  0F
034B:  BTFSC  03.2
034C:  GOTO   36B
....................     LAST_COR_IN=COR_IN; 
034D:  MOVLB  00
034E:  MOVF   5F,W
034F:  MOVLB  02
0350:  MOVWF  52
....................     COR_IN= ((input_b() ^ Polarity)&0x0F) | (COR_EMUL & 0x1F) | (COR_AUX&0x0F); 
0351:  MOVLB  00
0352:  MOVF   0D,W
0353:  XORWF  62,W
0354:  ANDLW  0F
0355:  MOVLB  02
0356:  MOVWF  53
0357:  MOVLB  00
0358:  MOVF   6A,W
0359:  ANDLW  1F
035A:  MOVLB  02
035B:  IORWF  53,F
035C:  MOVLB  00
035D:  MOVF   6B,W
035E:  ANDLW  0F
035F:  MOVLB  02
0360:  IORWF  53,W
0361:  MOVLB  00
0362:  MOVWF  5F
....................     if ( LAST_COR_IN != COR_IN ) { 
0363:  MOVF   5F,W
0364:  MOVLB  02
0365:  SUBWF  52,W
0366:  BTFSS  03.2
....................       COR_FLAG = 1; 
0367:  BSF    74.1
....................     } 
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
0368:  MOVLW  F0
0369:  MOVLB  07
036A:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
036B:  BTFSS  0B.0
036C:  GOTO   371
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     DTMF_INTERRUPT_FLAG = 1; 
036D:  MOVLB  01
036E:  BSF    60.1
....................     clear_interrupt(INT_RB4_H2L); 
036F:  MOVLB  07
0370:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
0371:  BTFSS  0B.0
0372:  GOTO   376
....................     AUX_IN_FLAG=1; 
0373:  BSF    74.6
....................     clear_interrupt(INT_RB6|INT_RB7); 
0374:  MOVLW  3F
0375:  ANDWF  16,F
....................   } 
.................... } // }}} 
0376:  BCF    0B.0
0377:  MOVLP  00
0378:  MOVLB  00
0379:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
037A:  MOVLB  01
037B:  MOVF   30,W
037C:  IORWF  31,W
037D:  BTFSC  03.2
037E:  GOTO   384
....................     rtcc_cnt--; 
037F:  MOVF   30,W
0380:  BTFSC  03.2
0381:  DECF   31,F
0382:  DECF   30,F
....................   } else { 
0383:  GOTO   39D
....................     COR_IN= ((input_b() ^ Polarity)&0x0F) | (COR_EMUL & 0x1F) | (COR_AUX&0x0F); 
0384:  MOVLB  00
0385:  MOVF   0D,W
0386:  XORWF  62,W
0387:  ANDLW  0F
0388:  MOVLB  02
0389:  MOVWF  52
038A:  MOVLB  00
038B:  MOVF   6A,W
038C:  ANDLW  1F
038D:  MOVLB  02
038E:  IORWF  52,F
038F:  MOVLB  00
0390:  MOVF   6B,W
0391:  ANDLW  0F
0392:  MOVLB  02
0393:  IORWF  52,W
0394:  MOVLB  00
0395:  MOVWF  5F
....................     COR_FLAG=1; 
0396:  BSF    74.1
....................     SECOND_FLAG=1; 
0397:  BSF    74.2
....................     AUX_IN_FLAG=1; 
0398:  BSF    74.6
....................     rtcc_cnt=30; 
0399:  MOVLB  01
039A:  CLRF   31
039B:  MOVLW  1E
039C:  MOVWF  30
....................   } 
....................   if (aux_timer ) { 
039D:  MOVF   32,W
039E:  IORWF  33,W
039F:  BTFSC  03.2
03A0:  GOTO   3A5
....................     aux_timer--; 
03A1:  MOVF   32,W
03A2:  BTFSC  03.2
03A3:  DECF   33,F
03A4:  DECF   32,F
....................   } 
.................... } // }}} 
03A5:  BCF    0B.2
03A6:  MOVLP  00
03A7:  MOVLB  00
03A8:  GOTO   020
.................... int1 warn_no_lcd = 1; 
....................  
.................... void lcd_strobe(char data) { // {{{ 
....................   i2c_write(data | E); 
....................   i2c_write(data & ~E); 
.................... } // }}} 
....................  
.................... void lcd_write(char rs, char data) { // {{{ 
....................   char lcd_word_a,lcd_word_b; 
....................   lcd_word_a = LCD_WRITE | BT | (data&0xF0); 
....................   lcd_word_b = LCD_WRITE | BT | ((data<<4)&0xF0); 
....................   if ( rs ) { 
....................     lcd_word_a |= RS; 
....................     lcd_word_b |= RS; 
....................   }  
....................   lcd_strobe(lcd_word_a); 
....................   lcd_strobe(lcd_word_b); 
.................... } // }}} 
....................  
.................... void lcd_send(char line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   i2c_start(); 
*
098C:  MOVLB  04
098D:  BSF    16.0
098E:  BTFSC  16.0
098F:  GOTO   18E
....................   #ifdef LCD_TYPE_PI 
....................   ack=i2c_write(LCD_I2C_ADD << 1); 
.................... //  ack=i2c_write(line&0x03); 
.................... // Change line 
....................   switch(line&0x03) { 
....................     case 0x00: lcd_write(0,CHANGE_LINE);break; 
....................     case 0x01: lcd_write(0,CHANGE_LINE+0x40);break; 
....................     case 0x02: lcd_write(0,CHANGE_LINE+0x14);break; 
....................     case 0x03: lcd_write(0,CHANGE_LINE+0x54);break; 
....................   } 
....................   restart_wdt(); 
....................   #else 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
0990:  BCF    03.0
0991:  MOVLB  02
0992:  RLF    47,W
0993:  ANDLW  0E
0994:  IORLW  60
0995:  MOVWF  4A
....................   ack=i2c_write(lcd_cmd); 
0996:  MOVF   4A,W
0997:  MOVWF  4D
0998:  MOVLP  00
0999:  MOVLB  00
099A:  CALL   6B3
099B:  MOVLP  08
099C:  MOVF   78,W
099D:  MOVLB  02
099E:  BCF    4B.0
099F:  BTFSC  78.0
09A0:  BSF    4B.0
....................   #endif 
....................   if ( ack!=0 ) { 
09A1:  BTFSS  4B.0
09A2:  GOTO   1C5
....................     if ( warn_no_lcd ) { 
09A3:  MOVLB  01
09A4:  BTFSS  60.6
09A5:  GOTO   1C3
....................       printf("\n\rI2C : No ACK from LCD : %u",ack); 
09A6:  MOVLW  00
09A7:  MOVLB  02
09A8:  BTFSC  4B.0
09A9:  MOVLW  01
09AA:  MOVWF  4C
09AB:  MOVLW  A9
09AC:  MOVLB  03
09AD:  MOVWF  11
09AE:  MOVLW  03
09AF:  MOVWF  12
09B0:  BCF    03.0
09B1:  MOVLW  1A
09B2:  MOVLB  02
09B3:  MOVWF  4D
09B4:  MOVLP  00
09B5:  MOVLB  00
09B6:  CALL   6C8
09B7:  MOVLP  08
09B8:  MOVLB  02
09B9:  MOVF   4C,W
09BA:  MOVWF  4D
09BB:  MOVLW  1B
09BC:  MOVWF  4E
09BD:  MOVLP  00
09BE:  MOVLB  00
09BF:  CALL   73C
09C0:  MOVLP  08
....................       warn_no_lcd = 0; 
09C1:  MOVLB  01
09C2:  BCF    60.6
....................     } 
....................   } else { 
09C3:  GOTO   1C7
09C4:  MOVLB  02
....................     warn_no_lcd = 1; 
09C5:  MOVLB  01
09C6:  BSF    60.6
....................   } 
....................   while(*s) { 
09C7:  MOVLB  02
09C8:  MOVF   49,W
09C9:  MOVWF  7A
09CA:  MOVF   48,W
09CB:  MOVWF  04
09CC:  MOVF   7A,W
09CD:  MOVWF  05
09CE:  MOVF   00,F
09CF:  BTFSC  03.2
09D0:  GOTO   1E4
.................... #ifdef LCD_TYPE_PI 
....................     if ( *s != '\r' && *s != '\n') { 
....................       lcd_write(1,*s); 
....................     } 
....................     s++; 
.................... #else 
....................    i2c_write(*s++); 
09D1:  MOVF   49,W
09D2:  MOVWF  7A
09D3:  MOVF   48,W
09D4:  INCF   48,F
09D5:  BTFSC  03.2
09D6:  INCF   49,F
09D7:  MOVWF  04
09D8:  MOVF   7A,W
09D9:  MOVWF  05
09DA:  MOVF   00,W
09DB:  MOVWF  4C
09DC:  MOVWF  4D
09DD:  MOVLP  00
09DE:  MOVLB  00
09DF:  CALL   6B3
09E0:  MOVLP  08
.................... #endif 
....................   } 
09E1:  MOVLB  01
09E2:  GOTO   1C7
09E3:  MOVLB  02
.................... #ifndef LCD_TYPE_PI 
....................   i2c_write(0); // EOL 
09E4:  CLRF   4D
09E5:  MOVLP  00
09E6:  MOVLB  00
09E7:  CALL   6B3
09E8:  MOVLP  08
.................... #endif 
....................   i2c_stop(); 
09E9:  MOVLB  04
09EA:  BSF    16.2
09EB:  BTFSC  16.2
09EC:  GOTO   1EB
.................... #endif 
.................... } // }}} 
09ED:  MOVLB  00
09EE:  RETURN
....................  
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
1042:  MOVF   70,F
1043:  BTFSC  03.2
1044:  GOTO   0A6
....................     printf("\n\rProcessing Command:"); 
1045:  MOVLW  B8
1046:  MOVLB  03
1047:  MOVWF  11
1048:  MOVLW  03
1049:  MOVWF  12
104A:  MOVLP  00
104B:  MOVLB  00
104C:  CALL   4D7
104D:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
104E:  MOVLW  C3
104F:  MOVLB  03
1050:  MOVWF  11
1051:  MOVLW  03
1052:  MOVWF  12
1053:  BCF    03.0
1054:  MOVLW  0E
1055:  MOVLB  02
1056:  MOVWF  4D
1057:  MOVLP  00
1058:  MOVLB  00
1059:  CALL   6C8
105A:  MOVLP  10
105B:  MOVF   63,W
105C:  MOVLB  02
105D:  MOVWF  4D
105E:  MOVLW  1B
105F:  MOVWF  4E
1060:  MOVLP  00
1061:  MOVLB  00
1062:  CALL   73C
1063:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
1064:  MOVLW  CC
1065:  MOVLB  03
1066:  MOVWF  11
1067:  MOVLW  03
1068:  MOVWF  12
1069:  BCF    03.0
106A:  MOVLW  0E
106B:  MOVLB  02
106C:  MOVWF  4D
106D:  MOVLP  00
106E:  MOVLB  00
106F:  CALL   6C8
1070:  MOVLP  10
1071:  MOVF   70,W
1072:  MOVLB  02
1073:  MOVWF  4D
1074:  MOVLW  1B
1075:  MOVWF  4E
1076:  MOVLP  00
1077:  MOVLB  00
1078:  CALL   73C
1079:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
107A:  MOVLW  D5
107B:  MOVLB  03
107C:  MOVWF  11
107D:  MOVLW  03
107E:  MOVWF  12
107F:  BCF    03.0
1080:  MOVLW  0E
1081:  MOVLB  02
1082:  MOVWF  4D
1083:  MOVLP  00
1084:  MOVLB  00
1085:  CALL   6C8
1086:  MOVLP  10
1087:  MOVF   7C,W
1088:  MOVLB  02
1089:  MOVWF  4D
108A:  MOVLW  1B
108B:  MOVWF  4E
108C:  MOVLP  00
108D:  MOVLB  00
108E:  CALL   73C
108F:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
1090:  MOVLW  DE
1091:  MOVLB  03
1092:  MOVWF  11
1093:  MOVLW  03
1094:  MOVWF  12
1095:  BCF    03.0
1096:  MOVLW  0E
1097:  MOVLB  02
1098:  MOVWF  4D
1099:  MOVLP  00
109A:  MOVLB  00
109B:  CALL   6C8
109C:  MOVLP  10
109D:  MOVF   7D,W
109E:  MOVLB  02
109F:  MOVWF  4D
10A0:  MOVLW  1B
10A1:  MOVWF  4E
10A2:  MOVLP  00
10A3:  MOVLB  00
10A4:  CALL   73C
10A5:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
10A6:  MOVLW  02
10A7:  SUBWF  70,W
10A8:  ADDLW  F5
10A9:  BTFSC  03.0
10AA:  GOTO   4E2
10AB:  ADDLW  0B
10AC:  GOTO   4E3
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
1176:  GOTO   4E2
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
1177:  RLF    7C,W
1178:  MOVWF  77
1179:  RLF    77,F
117A:  MOVLW  FC
117B:  ANDWF  77,F
117C:  MOVF   77,W
117D:  MOVLB  02
117E:  MOVWF  29
117F:  INCF   29,W
1180:  MOVLP  00
1181:  MOVLB  00
1182:  CALL   043
1183:  MOVLP  10
1184:  MOVWF  7A
1185:  MOVLB  02
1186:  MOVF   29,W
1187:  MOVLP  00
1188:  MOVLB  00
1189:  CALL   043
118A:  MOVLP  10
118B:  MOVLB  01
118C:  MOVWF  6D
118D:  MOVF   7A,W
118E:  MOVWF  6E
....................       LastRegisterIndex = argument; 
118F:  MOVF   7C,W
1190:  MOVWF  7E
....................       LastRegisterIndexValid=1; 
1191:  MOVLW  01
1192:  MOVWF  5B
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
1193:  MOVLW  01
1194:  MOVWF  7A
1195:  MOVLW  8F
1196:  MOVLB  02
1197:  MOVWF  29
1198:  MOVF   7A,W
1199:  MOVWF  2A
119A:  CLRF   2C
119B:  MOVF   7C,W
119C:  MOVWF  2B
119D:  MOVF   2C,W
119E:  MOVWF  3B
119F:  MOVF   2B,W
11A0:  MOVWF  3A
11A1:  CLRF   3D
11A2:  MOVLW  06
11A3:  MOVWF  3C
11A4:  MOVLP  08
11A5:  MOVLB  00
11A6:  CALL   6E9
11A7:  MOVLP  10
11A8:  MOVF   78,W
11A9:  MOVLB  02
11AA:  ADDWF  29,W
11AB:  MOVWF  21
11AC:  MOVF   79,W
11AD:  ADDWFC 2A,W
11AE:  MOVWF  22
....................       romstrcpy(rname,cPtr); 
11AF:  MOVLW  20
11B0:  MOVWF  39
11B1:  MOVLW  A3
11B2:  MOVWF  38
11B3:  MOVF   22,W
11B4:  MOVWF  3B
11B5:  MOVF   21,W
11B6:  MOVWF  3A
11B7:  MOVLP  08
11B8:  MOVLB  00
11B9:  CALL   700
11BA:  MOVLP  10
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
11BB:  MOVLB  01
11BC:  MOVF   6E,W
11BD:  MOVWF  7A
11BE:  MOVF   6D,W
11BF:  MOVWF  04
11C0:  MOVF   6E,W
11C1:  MOVWF  05
11C2:  MOVF   00,W
11C3:  MOVLB  02
11C4:  MOVWF  29
11C5:  MOVLW  20
11C6:  MOVLB  01
11C7:  MOVWF  62
11C8:  MOVLW  76
11C9:  MOVWF  61
11CA:  MOVLW  5B
11CB:  MOVLB  02
11CC:  MOVWF  4D
11CD:  MOVLP  08
11CE:  MOVLB  00
11CF:  CALL   115
11D0:  MOVLP  10
11D1:  MOVF   7C,W
11D2:  MOVLB  02
11D3:  MOVWF  2A
11D4:  MOVLW  01
11D5:  MOVWF  2B
11D6:  MOVLP  08
11D7:  MOVLB  00
11D8:  CALL   779
11D9:  MOVLP  10
11DA:  MOVLW  5D
11DB:  MOVLB  02
11DC:  MOVWF  4D
11DD:  MOVLP  08
11DE:  MOVLB  00
11DF:  CALL   115
11E0:  MOVLP  10
11E1:  MOVLW  20
11E2:  MOVLB  02
11E3:  MOVWF  4D
11E4:  MOVLP  08
11E5:  MOVLB  00
11E6:  CALL   115
11E7:  MOVLP  10
11E8:  MOVLW  20
11E9:  MOVWF  05
11EA:  MOVLW  A3
11EB:  MOVWF  04
11EC:  MOVLP  08
11ED:  CALL   177
11EE:  MOVLP  10
11EF:  MOVLW  20
11F0:  MOVLB  02
11F1:  MOVWF  4D
11F2:  MOVLP  08
11F3:  MOVLB  00
11F4:  CALL   115
11F5:  MOVLP  10
11F6:  MOVLB  02
11F7:  MOVF   29,W
11F8:  MOVWF  2A
11F9:  MOVLW  1B
11FA:  MOVWF  2B
11FB:  MOVLP  08
11FC:  MOVLB  00
11FD:  CALL   779
11FE:  MOVLP  10
11FF:  MOVLW  0A
1200:  MOVLB  02
1201:  MOVWF  4D
1202:  MOVLP  08
1203:  MOVLB  00
1204:  CALL   115
1205:  MOVLP  10
1206:  MOVLW  0D
1207:  MOVLB  02
1208:  MOVWF  4D
1209:  MOVLP  08
120A:  MOVLB  00
120B:  CALL   115
120C:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
120D:  MOVLW  0A
120E:  CLRWDT
120F:  BTFSS  11.4
1210:  GOTO   20E
1211:  MOVLB  03
1212:  MOVWF  1A
1213:  MOVLW  0D
1214:  CLRWDT
1215:  MOVLB  00
1216:  BTFSC  11.4
1217:  GOTO   21A
1218:  MOVLB  03
1219:  GOTO   214
121A:  MOVLB  03
121B:  MOVWF  1A
121C:  MOVLW  20
121D:  MOVWF  05
121E:  MOVLW  76
121F:  MOVWF  04
1220:  MOVLP  08
1221:  MOVLB  00
1222:  CALL   256
1223:  MOVLP  10
....................       lcd_send(2,LCD_str); 
1224:  MOVLW  02
1225:  MOVLB  02
1226:  MOVWF  47
1227:  MOVLW  20
1228:  MOVWF  49
1229:  MOVLW  76
122A:  MOVWF  48
122B:  MOVLP  08
122C:  MOVLB  00
122D:  CALL   18C
122E:  MOVLP  10
....................       prompt(); 
122F:  MOVLP  08
1230:  CALL   7BC
1231:  MOVLP  10
....................       break; 
1232:  GOTO   4E2
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
1233:  MOVLP  08
1234:  CALL   729
1235:  MOVLP  10
1236:  MOVF   78,F
1237:  BTFSC  03.2
1238:  GOTO   23C
....................         store_variables(); 
1239:  MOVLP  00
123A:  CALL   5CA
123B:  MOVLP  10
....................       } 
....................       break; 
123C:  GOTO   4E2
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
123D:  DECFSZ 7D,W
123E:  GOTO   243
....................         init_src=USE_EEPROM_VARS; 
123F:  MOVLB  01
1240:  BSF    6F.0
....................       } else { 
1241:  GOTO   245
1242:  MOVLB  00
....................         init_src=USE_DEFAULT_VARS; 
1243:  MOVLB  01
1244:  BCF    6F.0
....................       } 
....................       if ( in_admin_mode() ) { 
1245:  MOVLP  08
1246:  MOVLB  00
1247:  CALL   729
1248:  MOVLP  10
1249:  MOVF   78,F
124A:  BTFSC  03.2
124B:  GOTO   257
....................         init_variables(init_src); 
124C:  MOVLW  00
124D:  MOVLB  01
124E:  BTFSC  6F.0
124F:  MOVLW  01
1250:  MOVLB  02
1251:  MOVWF  29
1252:  MOVWF  2A
1253:  MOVLP  00
1254:  MOVLB  00
1255:  CALL   645
1256:  MOVLP  10
....................       } 
....................       break; 
1257:  GOTO   4E2
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1258:  MOVF   7C,W
1259:  ANDLW  03
125A:  MOVWF  76
....................       increment(value); 
125B:  MOVF   7D,W
125C:  MOVLB  02
125D:  MOVWF  2C
125E:  MOVLP  08
125F:  MOVLB  00
1260:  CALL   738
1261:  MOVLP  10
....................       PROMPT_FLAG=1; 
1262:  MOVLB  01
1263:  BSF    60.3
....................       break; 
1264:  MOVLB  00
1265:  GOTO   4E2
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1266:  MOVF   7C,W
1267:  ANDLW  03
1268:  MOVWF  76
....................       increment(-1*value); 
1269:  MOVLW  FF
126A:  MOVLB  02
126B:  MOVWF  40
126C:  MOVF   7D,W
126D:  MOVWF  41
126E:  MOVLP  08
126F:  MOVLB  00
1270:  CALL   661
1271:  MOVLP  10
1272:  MOVF   78,W
1273:  MOVLB  02
1274:  MOVWF  29
1275:  MOVWF  2C
1276:  MOVLP  08
1277:  MOVLB  00
1278:  CALL   738
1279:  MOVLP  10
....................       PROMPT_FLAG=1; 
127A:  MOVLB  01
127B:  BSF    60.3
....................       break; 
127C:  MOVLB  00
127D:  GOTO   4E2
....................     case STATUS: 
....................       status(); 
....................       break; 
*
145D:  MOVLB  00
145E:  GOTO   4E2
....................     case ADMIN: 
....................       switch(argument) { 
145F:  MOVF   7C,W
1460:  XORLW  02
1461:  BTFSC  03.2
1462:  GOTO   46A
1463:  XORLW  03
1464:  BTFSC  03.2
1465:  GOTO   471
1466:  XORLW  02
1467:  BTFSC  03.2
1468:  GOTO   479
1469:  GOTO   47B
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
146A:  MOVLP  08
146B:  CALL   729
146C:  MOVLP  10
146D:  MOVF   78,F
146E:  BTFSS  03.2
....................             reset_cpu(); 
146F:  RESET
....................           } 
....................           break; 
1470:  GOTO   481
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
1471:  MOVLW  01
1472:  MOVLB  02
1473:  MOVWF  3D
1474:  MOVLP  08
1475:  MOVLB  00
1476:  CALL   4A9
1477:  MOVLP  10
....................           break; 
1478:  GOTO   481
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
1479:  CALL   000
....................         break; 
147A:  GOTO   481
....................         default: 
....................           set_admin_mode(0); 
147B:  MOVLB  02
147C:  CLRF   3D
147D:  MOVLP  08
147E:  MOVLB  00
147F:  CALL   4A9
1480:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
1481:  GOTO   4E2
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
.................... #ifdef LCD_TYPE_PI 
....................       switch(value) { 
....................         case 0 : init_lcd();break;   
....................         case 1 : lcd_write(0,0x01); 
....................       } 
.................... #else 
....................       lcd_cmd=4+(value&0x03); 
1482:  MOVF   7D,W
1483:  ANDLW  03
1484:  ADDLW  04
1485:  MOVLB  02
1486:  MOVWF  20
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
1487:  MOVLW  20
1488:  MOVLB  01
1489:  MOVWF  62
148A:  MOVLW  76
148B:  MOVWF  61
148C:  MOVLW  E7
148D:  MOVLB  03
148E:  MOVWF  11
148F:  MOVLW  03
1490:  MOVWF  12
1491:  BCF    03.0
1492:  MOVLW  04
1493:  MOVLB  02
1494:  MOVWF  47
1495:  MOVLP  08
1496:  MOVLB  00
1497:  CALL   124
1498:  MOVLP  10
1499:  MOVLW  60
149A:  MOVLB  02
149B:  MOVWF  47
149C:  MOVLW  18
149D:  MOVWF  48
149E:  MOVLP  08
149F:  MOVLB  00
14A0:  CALL   1EF
14A1:  MOVLP  10
14A2:  MOVLW  EA
14A3:  MOVLB  03
14A4:  MOVWF  11
14A5:  MOVLW  03
14A6:  MOVWF  12
14A7:  BCF    03.0
14A8:  MOVLW  08
14A9:  MOVLB  02
14AA:  MOVWF  47
14AB:  MOVLP  08
14AC:  MOVLB  00
14AD:  CALL   124
14AE:  MOVLP  10
14AF:  MOVLB  02
14B0:  MOVF   20,W
14B1:  MOVWF  47
14B2:  MOVLW  18
14B3:  MOVWF  48
14B4:  MOVLP  08
14B5:  MOVLB  00
14B6:  CALL   1EF
14B7:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
14B8:  MOVLW  0A
14B9:  CLRWDT
14BA:  BTFSS  11.4
14BB:  GOTO   4B9
14BC:  MOVLB  03
14BD:  MOVWF  1A
14BE:  MOVLW  0D
14BF:  CLRWDT
14C0:  MOVLB  00
14C1:  BTFSC  11.4
14C2:  GOTO   4C5
14C3:  MOVLB  03
14C4:  GOTO   4BF
14C5:  MOVLB  03
14C6:  MOVWF  1A
14C7:  MOVLW  20
14C8:  MOVWF  05
14C9:  MOVLW  76
14CA:  MOVWF  04
14CB:  MOVLP  08
14CC:  MOVLB  00
14CD:  CALL   256
14CE:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
14CF:  MOVLB  02
14D0:  MOVF   20,W
14D1:  MOVWF  47
14D2:  MOVLW  20
14D3:  MOVWF  49
14D4:  MOVLW  76
14D5:  MOVWF  48
14D6:  MOVLP  08
14D7:  MOVLB  00
14D8:  CALL   18C
14D9:  MOVLP  10
.................... #endif 
....................       break; 
14DA:  GOTO   4E2
....................     case MORSE_SEND: 
....................       morse(value); 
14DB:  MOVF   7D,W
14DC:  MOVLB  02
14DD:  MOVWF  3C
14DE:  MOVLP  08
14DF:  MOVLB  00
14E0:  CALL   09C
14E1:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
14E2:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  47
1803:  MOVLW  20
1804:  MOVWF  49
1805:  MOVLW  50
1806:  MOVWF  48
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   18C
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVWF  7C
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B62:  MOVLB  01
1B63:  CLRF   64
1B64:  CLRF   63
1B65:  MOVF   64,F
1B66:  BTFSS  03.2
1B67:  GOTO   3B1
1B68:  MOVF   63,W
1B69:  SUBLW  38
1B6A:  BTFSS  03.0
1B6B:  GOTO   3B1
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B6C:  MOVLW  01
1B6D:  MOVWF  7A
1B6E:  MOVLW  8F
1B6F:  MOVWF  6D
1B70:  MOVF   7A,W
1B71:  MOVWF  6E
1B72:  MOVF   64,W
1B73:  MOVLB  02
1B74:  MOVWF  3B
1B75:  MOVLB  01
1B76:  MOVF   63,W
1B77:  MOVLB  02
1B78:  MOVWF  3A
1B79:  CLRF   3D
1B7A:  MOVLW  06
1B7B:  MOVWF  3C
1B7C:  MOVLP  08
1B7D:  MOVLB  00
1B7E:  CALL   6E9
1B7F:  MOVLP  18
1B80:  MOVF   78,W
1B81:  MOVLB  01
1B82:  ADDWF  6D,W
1B83:  MOVWF  65
1B84:  MOVF   79,W
1B85:  ADDWFC 6E,W
1B86:  MOVWF  66
....................     romstrcpy(rname,cPtr); 
1B87:  MOVLW  20
1B88:  MOVLB  02
1B89:  MOVWF  39
1B8A:  MOVLW  97
1B8B:  MOVWF  38
1B8C:  MOVLB  01
1B8D:  MOVF   66,W
1B8E:  MOVLB  02
1B8F:  MOVWF  3B
1B90:  MOVLB  01
1B91:  MOVF   65,W
1B92:  MOVLB  02
1B93:  MOVWF  3A
1B94:  MOVLP  08
1B95:  MOVLB  00
1B96:  CALL   700
1B97:  MOVLP  18
....................     if(my_stricmp(argument_name,rname)==0) { 
1B98:  MOVLW  20
1B99:  MOVLB  02
1B9A:  MOVWF  3D
1B9B:  MOVLW  70
1B9C:  MOVWF  3C
1B9D:  MOVLW  20
1B9E:  MOVWF  3F
1B9F:  MOVLW  97
1BA0:  MOVWF  3E
1BA1:  MOVLP  08
1BA2:  MOVLB  00
1BA3:  CALL   6C1
1BA4:  MOVLP  18
1BA5:  MOVF   78,F
1BA6:  BTFSS  03.2
1BA7:  GOTO   3AC
....................       argument=x; 
1BA8:  MOVLB  01
1BA9:  MOVF   63,W
1BAA:  MOVWF  7C
1BAB:  MOVLB  00
....................     } 
....................   } 
1BAC:  MOVLB  01
1BAD:  INCF   63,F
1BAE:  BTFSC  03.2
1BAF:  INCF   64,F
1BB0:  GOTO   365
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BB1:  MOVF   7C,W
1BB2:  SUBLW  FF
1BB3:  BTFSS  03.2
1BB4:  GOTO   415
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BB5:  MOVLW  20
1BB6:  MOVLB  02
1BB7:  MOVWF  3D
1BB8:  MOVLW  70
1BB9:  MOVWF  3C
1BBA:  MOVLP  08
1BBB:  MOVLB  00
1BBC:  CALL   688
1BBD:  MOVLP  18
1BBE:  MOVF   78,W
1BBF:  MOVWF  7D
....................     strcpy(rname,"eeprom"); 
1BC0:  MOVLB  01
1BC1:  CLRF   6D
1BC2:  CLRF   6E
1BC3:  MOVLW  20
1BC4:  MOVWF  05
1BC5:  MOVLW  97
1BC6:  MOVWF  04
1BC7:  MOVF   6D,W
1BC8:  ADDWF  04,F
1BC9:  MOVLW  00
1BCA:  ADDWFC 05,F
1BCB:  MOVF   6E,W
1BCC:  MOVLP  00
1BCD:  MOVLB  00
1BCE:  CALL   128
1BCF:  MOVLP  18
1BD0:  MOVWF  00
1BD1:  IORLW  00
1BD2:  BTFSC  03.2
1BD3:  GOTO   3D9
1BD4:  MOVLB  01
1BD5:  INCF   6E,F
1BD6:  INCF   6D,F
1BD7:  GOTO   3C3
1BD8:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1BD9:  MOVLW  20
1BDA:  MOVLB  02
1BDB:  MOVWF  3D
1BDC:  MOVLW  70
1BDD:  MOVWF  3C
1BDE:  MOVLW  20
1BDF:  MOVWF  3F
1BE0:  MOVLW  97
1BE1:  MOVWF  3E
1BE2:  MOVLP  08
1BE3:  MOVLB  00
1BE4:  CALL   6C1
1BE5:  MOVLP  18
1BE6:  MOVF   78,F
1BE7:  BTFSS  03.2
1BE8:  GOTO   3EB
....................       value=USE_EEPROM_VARS; 
1BE9:  MOVLW  01
1BEA:  MOVWF  7D
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BEB:  MOVLB  01
1BEC:  CLRF   6D
1BED:  CLRF   6E
1BEE:  MOVLW  20
1BEF:  MOVWF  05
1BF0:  MOVLW  97
1BF1:  MOVWF  04
1BF2:  MOVF   6D,W
1BF3:  ADDWF  04,F
1BF4:  MOVLW  00
1BF5:  ADDWFC 05,F
1BF6:  MOVF   6E,W
1BF7:  MOVLP  00
1BF8:  MOVLB  00
1BF9:  CALL   130
1BFA:  MOVLP  18
1BFB:  MOVWF  00
1BFC:  IORLW  00
1BFD:  BTFSC  03.2
1BFE:  GOTO   404
1BFF:  MOVLB  01
1C00:  INCF   6E,F
1C01:  INCF   6D,F
1C02:  GOTO   3EE
1C03:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C04:  MOVLW  20
1C05:  MOVLB  02
1C06:  MOVWF  3D
1C07:  MOVLW  70
1C08:  MOVWF  3C
1C09:  MOVLW  20
1C0A:  MOVWF  3F
1C0B:  MOVLW  97
1C0C:  MOVWF  3E
1C0D:  MOVLP  08
1C0E:  MOVLB  00
1C0F:  CALL   6C1
1C10:  MOVLP  18
1C11:  MOVF   78,F
1C12:  BTFSC  03.2
....................       value=USE_DEFAULT_VARS; 
1C13:  CLRF   7D
1C14:  MOVLB  01
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C15:  MOVF   70,W
1C16:  SUBLW  06
1C17:  BTFSC  03.2
1C18:  GOTO   41D
1C19:  MOVF   70,W
1C1A:  SUBLW  07
1C1B:  BTFSS  03.2
1C1C:  GOTO   421
....................     value = 1; 
1C1D:  MOVLW  01
1C1E:  MOVWF  7D
....................     argument = CurrentTrimPot; 
1C1F:  MOVF   76,W
1C20:  MOVWF  7C
....................   } 
....................   rs232_mode = 1; 
1C21:  BSF    60.5
....................   execute_command(); 
1C22:  MOVLP  10
1C23:  MOVLB  00
1C24:  CALL   042
1C25:  MOVLP  18
....................   rs232_mode = 0; 
1C26:  MOVLB  01
1C27:  BCF    60.5
.................... } // }}} 
1C28:  MOVLP  18
1C29:  MOVLB  00
1C2A:  GOTO   6BA (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
127E:  MOVLW  1B
127F:  MOVLP  00
1280:  CALL   2E4
1281:  MOVLP  10
....................   printf("[2J"); 
1282:  MOVLW  5B
1283:  CLRWDT
1284:  BTFSS  11.4
1285:  GOTO   283
1286:  MOVLB  03
1287:  MOVWF  1A
1288:  MOVLW  32
1289:  CLRWDT
128A:  MOVLB  00
128B:  BTFSC  11.4
128C:  GOTO   28F
128D:  MOVLB  03
128E:  GOTO   289
128F:  MOVLB  03
1290:  MOVWF  1A
1291:  MOVLW  4A
1292:  CLRWDT
1293:  MOVLB  00
1294:  BTFSC  11.4
1295:  GOTO   298
1296:  MOVLB  03
1297:  GOTO   292
1298:  MOVLB  03
1299:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
129A:  MOVLW  1B
129B:  MOVLP  00
129C:  MOVLB  00
129D:  CALL   2E4
129E:  MOVLP  10
....................   printf("[0;0H"); 
129F:  MOVLW  F0
12A0:  MOVLB  03
12A1:  MOVWF  11
12A2:  MOVLW  03
12A3:  MOVWF  12
12A4:  MOVLP  00
12A5:  MOVLB  00
12A6:  CALL   4D7
12A7:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
078B:  MOVLB  02
078C:  SWAPF  3C,W
078D:  MOVWF  3E
078E:  RLF    3E,F
078F:  RLF    3E,F
0790:  MOVLW  C0
0791:  ANDWF  3E,F
....................   tx_value=tx_value + (value & 0x3F); 
0792:  MOVF   3D,W
0793:  ANDLW  3F
0794:  ADDWF  3E,F
....................   i2c_start(); 
0795:  MOVLB  04
0796:  BSF    16.0
0797:  BTFSC  16.0
0798:  GOTO   797
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
0799:  MOVLW  50
079A:  MOVLB  02
079B:  MOVWF  4D
079C:  MOVLB  00
079D:  CALL   6B3
079E:  MOVF   78,W
079F:  MOVLB  02
07A0:  BCF    3F.0
07A1:  BTFSC  78.0
07A2:  BSF    3F.0
....................   if ( ack != 0) { 
07A3:  BTFSS  3F.0
07A4:  GOTO   7BC
....................     printf("\n\rI2C : No ACK : %u",ack); 
07A5:  MOVLW  00
07A6:  BTFSC  3F.0
07A7:  MOVLW  01
07A8:  MOVWF  40
07A9:  MOVLW  F3
07AA:  MOVLB  03
07AB:  MOVWF  11
07AC:  MOVLW  03
07AD:  MOVWF  12
07AE:  BCF    03.0
07AF:  MOVLW  11
07B0:  MOVLB  02
07B1:  MOVWF  4D
07B2:  MOVLB  00
07B3:  CALL   6C8
07B4:  MOVLB  02
07B5:  MOVF   40,W
07B6:  MOVWF  4D
07B7:  MOVLW  1B
07B8:  MOVWF  4E
07B9:  MOVLB  00
07BA:  CALL   73C
07BB:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
07BC:  MOVF   3E,W
07BD:  MOVWF  4D
07BE:  MOVLB  00
07BF:  CALL   6B3
....................   i2c_stop();   
07C0:  MOVLB  04
07C1:  BSF    16.2
07C2:  BTFSC  16.2
07C3:  GOTO   7C2
....................   printf("\n\rPot(%u)<=%u",pot,value); 
07C4:  MOVLW  FD
07C5:  MOVLB  03
07C6:  MOVWF  11
07C7:  MOVLW  03
07C8:  MOVWF  12
07C9:  BCF    03.0
07CA:  MOVLW  06
07CB:  MOVLB  02
07CC:  MOVWF  4D
07CD:  MOVLB  00
07CE:  CALL   6C8
07CF:  MOVLB  02
07D0:  MOVF   3C,W
07D1:  MOVWF  4D
07D2:  MOVLW  1B
07D3:  MOVWF  4E
07D4:  MOVLB  00
07D5:  CALL   73C
07D6:  MOVLW  29
07D7:  CLRWDT
07D8:  BTFSS  11.4
07D9:  GOTO   7D7
07DA:  MOVLB  03
07DB:  MOVWF  1A
07DC:  MOVLW  3C
07DD:  CLRWDT
07DE:  MOVLB  00
07DF:  BTFSC  11.4
07E0:  GOTO   7E3
07E1:  MOVLB  03
07E2:  GOTO   7DD
07E3:  MOVLB  03
07E4:  MOVWF  1A
07E5:  MOVLW  3D
07E6:  CLRWDT
07E7:  MOVLB  00
07E8:  BTFSC  11.4
07E9:  GOTO   7EC
07EA:  MOVLB  03
07EB:  GOTO   7E6
07EC:  MOVLB  03
07ED:  MOVWF  1A
07EE:  MOVLB  02
07EF:  MOVF   3D,W
07F0:  MOVWF  4D
07F1:  MOVLW  1B
07F2:  MOVWF  4E
07F3:  MOVLB  00
07F4:  CALL   73C
....................  
.................... } // }}} 
07F5:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
089C:  MOVLW  DB
089D:  MOVLB  02
089E:  ADDWF  3C,W
089F:  MOVWF  40
08A0:  MOVLW  1F
08A1:  MOVWF  41
08A2:  BTFSC  03.0
08A3:  INCF   41,F
08A4:  MOVF   41,W
08A5:  MOVLB  03
08A6:  MOVWF  12
08A7:  MOVLB  02
08A8:  MOVF   40,W
08A9:  MOVLB  03
08AA:  MOVWF  11
08AB:  MOVLW  20
08AC:  MOVWF  05
08AD:  MOVLW  BD
08AE:  MOVWF  04
08AF:  MOVLW  01
08B0:  MOVLB  02
08B1:  MOVWF  42
08B2:  MOVLB  00
08B3:  CALL   019
....................    
....................   PROMPT_FLAG=1; 
08B4:  MOVLB  01
08B5:  BSF    60.3
....................   for(x=0;x<4;x++) { 
08B6:  MOVLB  02
08B7:  CLRF   3E
08B8:  MOVF   3E,W
08B9:  SUBLW  03
08BA:  BTFSS  03.0
08BB:  GOTO   0E2
....................     do_delay=1; 
08BC:  BSF    3F.0
....................     switch(mc & 0xc0) { // Check two MSB's 
08BD:  MOVF   3D,W
08BE:  ANDLW  C0
08BF:  XORLW  40
08C0:  MOVLB  00
08C1:  BTFSC  03.2
08C2:  GOTO   0C7
08C3:  XORLW  C0
08C4:  BTFSC  03.2
08C5:  GOTO   0C9
08C6:  GOTO   0CB
....................       case(0x40): 
....................         dit(); 
08C7:  CALL   02C
....................         break; 
08C8:  GOTO   0CE
....................       case(0x80): 
....................         dah(); 
08C9:  CALL   064
....................         break; 
08CA:  GOTO   0CE
....................       default: 
....................         do_delay=0; 
08CB:  MOVLB  02
08CC:  BCF    3F.0
....................         break; 
08CD:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
08CE:  MOVLB  02
08CF:  RLF    3D,F
08D0:  RLF    3D,F
08D1:  MOVLW  FC
08D2:  ANDWF  3D,F
....................     if ( do_delay ) { 
08D3:  BTFSS  3F.0
08D4:  GOTO   0E0
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
08D5:  MOVLB  01
08D6:  CLRF   33
08D7:  MOVLW  02
08D8:  MOVWF  32
....................       while(aux_timer) { 
08D9:  MOVF   32,W
08DA:  IORWF  33,W
08DB:  BTFSC  03.2
08DC:  GOTO   0DF
....................         delay_cycles(1); 
08DD:  NOP
....................       } 
08DE:  GOTO   0D9
08DF:  MOVLB  02
....................     } 
....................   } 
08E0:  INCF   3E,F
08E1:  GOTO   0B8
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
08E2:  MOVF   3C,W
08E3:  SUBLW  09
08E4:  BTFSS  03.0
08E5:  GOTO   0F1
....................     if ( c < 5 ) { 
08E6:  MOVF   3C,W
08E7:  SUBLW  04
08E8:  BTFSS  03.0
08E9:  GOTO   0EE
....................       dah(); 
08EA:  MOVLB  00
08EB:  CALL   064
....................     } 
....................     else { 
08EC:  GOTO   0F0
08ED:  MOVLB  02
....................       dit(); 
08EE:  MOVLB  00
08EF:  CALL   02C
08F0:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
08F1:  MOVLB  00
08F2:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0B60:  MOVLW  30
0B61:  MOVLB  02
0B62:  MOVWF  31
0B63:  MOVWF  32
0B64:  MOVWF  33
0B65:  MOVWF  34
0B66:  CLRF   35
....................   char PTT_s[5]={'0','0','0','0',0}; 
0B67:  MOVWF  36
0B68:  MOVWF  37
0B69:  MOVWF  38
0B6A:  MOVWF  39
0B6B:  CLRF   3A
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0B6C:  MOVF   2B,W
0B6D:  MOVLB  00
0B6E:  MOVWF  6F
....................  
....................   if ( cor ) { 
0B6F:  MOVLB  02
0B70:  MOVF   2B,F
0B71:  BTFSC  03.2
0B72:  GOTO   384
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0B73:  MOVLW  01
0B74:  SUBWF  2B,W
0B75:  ADDLW  29
0B76:  MOVWF  04
0B77:  MOVLW  20
0B78:  MOVWF  05
0B79:  BTFSC  03.0
0B7A:  INCF   05,F
0B7B:  MOVF   00,W
0B7C:  MOVWF  3C
0B7D:  MOVLB  00
0B7E:  MOVF   60,W
0B7F:  ANDWF  61,W
0B80:  MOVLB  02
0B81:  ANDWF  3C,W
0B82:  MOVWF  30
....................   } else { 
0B83:  GOTO   3C7
....................     ptt=0; 
0B84:  CLRF   30
....................     //COR_EMUL=0; 
....................     if ( COR_DROP_FLAG ) { 
0B85:  BTFSS  74.5
0B86:  GOTO   3C7
....................       COR_DROP_FLAG=0; 
0B87:  BCF    74.5
....................       if ( ConfirmChar || TailChar ) { 
0B88:  MOVLB  00
0B89:  MOVF   6D,F
0B8A:  BTFSS  03.2
0B8B:  GOTO   38F
0B8C:  MOVF   6C,F
0B8D:  BTFSC  03.2
0B8E:  GOTO   3C6
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0BC7:  MOVLW  01
0BC8:  MOVWF  2F
....................   for(x=0;x<4;x++) { 
0BC9:  CLRF   2C
0BCA:  MOVF   2C,W
0BCB:  SUBLW  03
0BCC:  BTFSS  03.0
0BCD:  GOTO   432
....................     if ( !cor ) { 
0BCE:  MOVF   2B,F
0BCF:  BTFSS  03.2
0BD0:  GOTO   3D4
....................       rx_bit=0; 
0BD1:  BCF    3B.0
....................       ptt_bit=0; 
0BD2:  BCF    3B.1
....................     } else { 
0BD3:  GOTO   3E7
....................       if ( cor == (x+1) ) { 
0BD4:  MOVLW  01
0BD5:  ADDWF  2C,W
0BD6:  SUBWF  2B,W
0BD7:  BTFSS  03.2
0BD8:  GOTO   3DF
....................         rx_bit=1; 
0BD9:  BSF    3B.0
....................         CurrentCorMask=mask; 
0BDA:  MOVF   2F,W
0BDB:  MOVLB  00
0BDC:  MOVWF  6E
....................       } else { 
0BDD:  GOTO   3E1
0BDE:  MOVLB  02
....................         rx_bit=0; 
0BDF:  BCF    3B.0
0BE0:  MOVLB  00
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0BE1:  MOVLB  02
0BE2:  BCF    3B.1
0BE3:  MOVF   30,W
0BE4:  ANDWF  2F,W
0BE5:  BTFSS  03.2
0BE6:  BSF    3B.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0BE7:  MOVF   2C,W
0BE8:  MOVLP  00
0BE9:  MOVLB  00
0BEA:  CALL   031
0BEB:  MOVLP  08
0BEC:  MOVLB  02
0BED:  MOVWF  3C
0BEE:  MOVLW  00
0BEF:  BTFSC  3B.0
0BF0:  MOVLW  01
0BF1:  MOVWF  77
0BF2:  MOVF   3C,W
0BF3:  MOVWF  3D
0BF4:  MOVF   77,W
0BF5:  MOVWF  3E
0BF6:  MOVLW  01
0BF7:  MOVWF  40
0BF8:  CLRF   3F
0BF9:  MOVLB  00
0BFA:  CALL   0F3
0BFB:  MOVLB  02
0BFC:  MOVF   3C,W
0BFD:  MOVWF  3D
0BFE:  CLRF   3E
0BFF:  CLRF   40
0C00:  MOVLW  80
0C01:  MOVWF  3F
0C02:  MOVLB  00
0C03:  CALL   0F3
....................     output_bit(PTT_PIN[x],ptt_bit); 
0C04:  MOVLB  02
0C05:  MOVF   2C,W
0C06:  MOVLP  00
0C07:  MOVLB  00
0C08:  CALL   036
0C09:  MOVLP  08
0C0A:  MOVLB  02
0C0B:  MOVWF  3C
0C0C:  MOVLW  00
0C0D:  BTFSC  3B.1
0C0E:  MOVLW  01
0C0F:  MOVWF  77
0C10:  MOVF   3C,W
0C11:  MOVWF  3D
0C12:  MOVF   77,W
0C13:  MOVWF  3E
0C14:  MOVLW  01
0C15:  MOVWF  40
0C16:  CLRF   3F
0C17:  MOVLB  00
0C18:  CALL   0F3
0C19:  MOVLB  02
0C1A:  MOVF   3C,W
0C1B:  MOVWF  3D
0C1C:  CLRF   3E
0C1D:  CLRF   40
0C1E:  MOVLW  80
0C1F:  MOVWF  3F
0C20:  MOVLB  00
0C21:  CALL   0F3
....................     if(ptt_bit) { 
0C22:  MOVLB  02
0C23:  BTFSS  3B.1
0C24:  GOTO   42E
....................       PTT_s[x]='1'; 
0C25:  MOVLW  B6
0C26:  ADDWF  2C,W
0C27:  MOVWF  04
0C28:  MOVLW  20
0C29:  MOVWF  05
0C2A:  BTFSC  03.0
0C2B:  INCF   05,F
0C2C:  MOVLW  31
0C2D:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C2E:  BCF    03.0
0C2F:  RLF    2F,F
....................   }  
0C30:  INCF   2C,F
0C31:  GOTO   3CA
....................   if(!cor) { 
0C32:  MOVF   2B,F
0C33:  BTFSS  03.2
0C34:  GOTO   437
....................     CurrentCorPriority=0; 
0C35:  CLRF   71
....................   } else { 
0C36:  GOTO   465
....................     CurrentCorPriority=RXPriority[cor-1]; 
0C37:  MOVLW  01
0C38:  SUBWF  2B,W
0C39:  ADDLW  25
0C3A:  MOVWF  04
0C3B:  MOVLW  20
0C3C:  MOVWF  05
0C3D:  BTFSC  03.0
0C3E:  INCF   05,F
0C3F:  MOVF   00,W
0C40:  MOVWF  71
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0C41:  CLRF   2D
0C42:  MOVF   2D,W
0C43:  SUBLW  03
0C44:  BTFSS  03.0
0C45:  GOTO   462
....................       pot_val=RX_GAIN[cor-1][pot]; 
0C46:  MOVLW  01
0C47:  SUBWF  2B,W
0C48:  MOVWF  77
0C49:  RLF    77,F
0C4A:  RLF    77,F
0C4B:  MOVLW  FC
0C4C:  ANDWF  77,F
0C4D:  MOVF   77,W
0C4E:  ADDWF  2D,W
0C4F:  ADDLW  0C
0C50:  MOVWF  04
0C51:  MOVLW  20
0C52:  MOVWF  05
0C53:  BTFSC  03.0
0C54:  INCF   05,F
0C55:  MOVF   00,W
0C56:  MOVWF  2E
....................       set_trimpot(pot,pot_val); 
0C57:  MOVF   2D,W
0C58:  MOVWF  3C
0C59:  MOVF   2E,W
0C5A:  MOVWF  3D
0C5B:  MOVLP  00
0C5C:  MOVLB  00
0C5D:  CALL   78B
0C5E:  MOVLP  08
....................     } 
0C5F:  MOVLB  02
0C60:  INCF   2D,F
0C61:  GOTO   442
....................     PROMPT_FLAG=1; 
0C62:  MOVLB  01
0C63:  BSF    60.3
0C64:  MOVLB  02
....................   } 
....................   if(cor>0) { 
0C65:  MOVF   2B,F
0C66:  BTFSC  03.2
0C67:  GOTO   4A7
....................     COR_s[cor-1]='1'; 
0C68:  MOVLW  01
0C69:  SUBWF  2B,W
0C6A:  ADDLW  B1
0C6B:  MOVWF  04
0C6C:  MOVLW  20
0C6D:  MOVWF  05
0C6E:  BTFSC  03.0
0C6F:  INCF   05,F
0C70:  MOVLW  31
0C71:  MOVWF  00
....................     sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0C72:  MOVLW  20
0C73:  MOVLB  01
0C74:  MOVWF  62
0C75:  MOVLW  76
0C76:  MOVWF  61
0C77:  MOVLW  04
0C78:  MOVLB  03
0C79:  MOVWF  11
0C7A:  MOVLW  04
0C7B:  MOVWF  12
0C7C:  BCF    03.0
0C7D:  MOVLW  04
0C7E:  MOVLB  02
0C7F:  MOVWF  47
0C80:  MOVLB  00
0C81:  CALL   124
0C82:  MOVLW  20
0C83:  MOVWF  05
0C84:  MOVLW  B1
0C85:  MOVWF  04
0C86:  CALL   177
0C87:  MOVLW  07
0C88:  MOVLB  03
0C89:  MOVWF  11
0C8A:  MOVLW  04
0C8B:  MOVWF  12
0C8C:  BCF    03.0
0C8D:  MOVLW  05
0C8E:  MOVLB  02
0C8F:  MOVWF  47
0C90:  MOVLB  00
0C91:  CALL   124
0C92:  MOVLW  20
0C93:  MOVWF  05
0C94:  MOVLW  B6
0C95:  MOVWF  04
0C96:  CALL   177
....................     lcd_send(1,LCD_str); // COR/PTT on line 1 
0C97:  MOVLW  01
0C98:  MOVLB  02
0C99:  MOVWF  47
0C9A:  MOVLW  20
0C9B:  MOVWF  49
0C9C:  MOVLW  76
0C9D:  MOVWF  48
0C9E:  MOVLB  00
0C9F:  CALL   18C
....................     delay_ms(50); 
0CA0:  MOVLW  32
0CA1:  MOVLB  02
0CA2:  MOVWF  47
0CA3:  MOVLB  00
0CA4:  CALL   000
....................     pot_values_to_lcd(); 
0CA5:  CALL   270
0CA6:  MOVLB  02
....................   } 
.................... }// }}} 
0CA7:  MOVLB  00
0CA8:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1DCD:  MOVF   65,W
1DCE:  SUBLW  0A
1DCF:  BTFSS  03.0
1DD0:  GOTO   5EB
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1DD1:  MOVLW  64
1DD2:  ADDWF  65,W
1DD3:  MOVWF  04
1DD4:  MOVLW  20
1DD5:  MOVWF  05
1DD6:  BTFSC  03.0
1DD7:  INCF   05,F
1DD8:  BTFSS  00.4
1DD9:  GOTO   5E9
1DDA:  MOVLW  64
1DDB:  ADDWF  65,W
1DDC:  MOVWF  04
1DDD:  MOVLW  20
1DDE:  MOVWF  05
1DDF:  BTFSC  03.0
1DE0:  INCF   05,F
1DE1:  MOVF   00,W
1DE2:  ANDLW  0F
1DE3:  SUBLW  0C
1DE4:  BTFSC  03.2
1DE5:  GOTO   5E9
....................       strobe=1; 
1DE6:  MOVLW  01
1DE7:  MOVWF  66
....................      } else { 
1DE8:  GOTO   5EA
....................       strobe = 0; 
1DE9:  CLRF   66
....................     }  
....................   } else { 
1DEA:  GOTO   5EC
....................     strobe=0; 
1DEB:  CLRF   66
....................   } 
....................   return(strobe); 
1DEC:  MOVF   66,W
1DED:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
1D4C:  MOVLB  01
1D4D:  MOVF   65,W
1D4E:  SUBWF  66,W
1D4F:  BTFSS  03.0
1D50:  GOTO   576
1D51:  MOVF   65,W
1D52:  SUBLW  09
1D53:  BTFSS  03.0
1D54:  GOTO   576
....................     valid=1; 
1D55:  BSF    69.0
....................     for(x=a;x<=b;x++) { 
1D56:  MOVF   65,W
1D57:  MOVWF  68
1D58:  MOVF   68,W
1D59:  SUBWF  66,W
1D5A:  BTFSS  03.0
1D5B:  GOTO   575
....................       key=(int)DTMF_ARRAY[x].Key; 
1D5C:  MOVLW  64
1D5D:  ADDWF  68,W
1D5E:  MOVWF  04
1D5F:  MOVLW  20
1D60:  MOVWF  05
1D61:  BTFSC  03.0
1D62:  INCF   05,F
1D63:  MOVF   00,W
1D64:  ANDLW  0F
1D65:  MOVWF  67
....................       if(! DTMF_ARRAY[x].Strobe ) { 
1D66:  MOVLW  64
1D67:  ADDWF  68,W
1D68:  MOVWF  04
1D69:  MOVLW  20
1D6A:  MOVWF  05
1D6B:  BTFSC  03.0
1D6C:  INCF   05,F
1D6D:  BTFSS  00.4
....................         valid=0; 
1D6E:  BCF    69.0
....................       } 
....................      if(key==dp) { 
1D6F:  MOVF   67,W
1D70:  SUBLW  0C
1D71:  BTFSC  03.2
....................         valid=0; 
1D72:  BCF    69.0
....................       } 
....................     } 
1D73:  INCF   68,F
1D74:  GOTO   558
....................   } else { 
1D75:  GOTO   577
....................     valid=0; 
1D76:  BCF    69.0
....................   } 
....................   return(valid); 
1D77:  MOVLW  00
1D78:  BTFSC  69.0
1D79:  MOVLW  01
1D7A:  MOVWF  78
.................... } // }}} 
1D7B:  MOVLB  00
1D7C:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   unsigned site_id; 
....................   unsigned digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 01 : Link commands 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : -- UNUSED -- 
....................   // 11 : Morse send 
....................   // 12 : Send to I2C 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   // -- User Functions -- 
....................   // Disable AuxOut0        : 51 02 21 0 #  
....................   // Disable AuxOut0 (!Arg) : 51 02 21 #  
....................   // Enable  AuxOut1        : 51 02 22 1 # 
....................   command=0; 
1D7D:  CLRF   70
....................   value=0; 
1D7E:  CLRF   7D
....................   if ( ValidKeyRange(0,3)) { 
1D7F:  MOVLB  01
1D80:  CLRF   65
1D81:  MOVLW  03
1D82:  MOVWF  66
1D83:  MOVLB  00
1D84:  CALL   54C
1D85:  MOVF   78,F
1D86:  BTFSC  03.2
1D87:  GOTO   631
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1D88:  MOVLB  01
1D89:  MOVF   34,W
1D8A:  ANDLW  0F
1D8B:  MOVWF  66
1D8C:  MOVLB  02
1D8D:  MOVWF  40
1D8E:  MOVLW  0A
1D8F:  MOVWF  41
1D90:  MOVLP  08
1D91:  MOVLB  00
1D92:  CALL   661
1D93:  MOVLP  18
1D94:  MOVF   78,W
1D95:  MOVLB  01
1D96:  MOVWF  65
1D97:  MOVF   35,W
1D98:  ANDLW  0F
1D99:  ADDWF  65,W
1D9A:  MOVWF  63
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1D9B:  MOVF   36,W
1D9C:  ANDLW  0F
1D9D:  MOVWF  66
1D9E:  MOVLB  02
1D9F:  MOVWF  40
1DA0:  MOVLW  0A
1DA1:  MOVWF  41
1DA2:  MOVLP  08
1DA3:  MOVLB  00
1DA4:  CALL   661
1DA5:  MOVLP  18
1DA6:  MOVF   78,W
1DA7:  MOVLB  01
1DA8:  MOVWF  65
1DA9:  MOVF   37,W
1DAA:  ANDLW  0F
1DAB:  ADDWF  65,W
1DAC:  MOVWF  70
....................     if ( ValidKeyRange(4,5) ) { 
1DAD:  MOVLW  04
1DAE:  MOVWF  65
1DAF:  MOVLW  05
1DB0:  MOVWF  66
1DB1:  MOVLB  00
1DB2:  CALL   54C
1DB3:  MOVF   78,F
1DB4:  BTFSC  03.2
1DB5:  GOTO   60C
....................       // Admin mode {{{ 
....................       argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1DB6:  MOVLB  01
1DB7:  MOVF   38,W
1DB8:  ANDLW  0F
1DB9:  MOVWF  66
1DBA:  MOVLB  02
1DBB:  MOVWF  40
1DBC:  MOVLW  0A
1DBD:  MOVWF  41
1DBE:  MOVLP  08
1DBF:  MOVLB  00
1DC0:  CALL   661
1DC1:  MOVLP  18
1DC2:  MOVF   78,W
1DC3:  MOVLB  01
1DC4:  MOVWF  65
1DC5:  MOVF   39,W
1DC6:  ANDLW  0F
1DC7:  ADDWF  65,W
1DC8:  MOVWF  7C
....................       digit=6; 
1DC9:  MOVLW  06
1DCA:  MOVWF  64
....................       while(ValidKey(digit)) { 
1DCB:  MOVF   64,W
1DCC:  MOVWF  65
*
1DEE:  MOVF   78,F
1DEF:  BTFSC  03.2
1DF0:  GOTO   60A
....................        value = value * 10 + DTMF_ARRAY[digit].Key; 
1DF1:  MOVF   7D,W
1DF2:  MOVLB  02
1DF3:  MOVWF  40
1DF4:  MOVLW  0A
1DF5:  MOVWF  41
1DF6:  MOVLP  08
1DF7:  MOVLB  00
1DF8:  CALL   661
1DF9:  MOVLP  18
1DFA:  MOVF   78,W
1DFB:  MOVLB  01
1DFC:  MOVWF  65
1DFD:  MOVLW  64
1DFE:  ADDWF  64,W
1DFF:  MOVWF  04
1E00:  MOVLW  20
1E01:  MOVWF  05
1E02:  BTFSC  03.0
1E03:  INCF   05,F
1E04:  MOVF   00,W
1E05:  ANDLW  0F
1E06:  ADDWF  65,W
1E07:  MOVWF  7D
....................        digit++; 
1E08:  INCF   64,F
....................       } 
1E09:  GOTO   5CB
....................       // Admin mode }}} 
....................     } else { 
1E0A:  GOTO   61E
1E0B:  MOVLB  00
....................       // User function {{{ 
....................       // Only 4 digits were entered.  
....................       // Use 'command' value as user function. 
....................       switch(command) { 
1E0C:  MOVF   70,W
1E0D:  XORLW  0A
1E0E:  BTFSC  03.2
1E0F:  GOTO   614
1E10:  XORLW  01
1E11:  BTFSC  03.2
1E12:  GOTO   618
1E13:  GOTO   61B
....................         // Commands 10 (disable link) and 11 (enable link) 
....................         case(10): 
....................           argument = 0; 
1E14:  CLRF   7C
....................           value = 0x0E; 
1E15:  MOVLW  0E
1E16:  MOVWF  7D
....................   	      break; 
1E17:  GOTO   61B
....................         case(11): 
....................           argument = 0; 
1E18:  CLRF   7C
....................           value = 0x0F; 
1E19:  MOVLW  0F
1E1A:  MOVWF  7D
....................    		    break; 
....................       } 
....................       // Override command 
....................       command=SET_REG; 
1E1B:  MOVLW  02
1E1C:  MOVWF  70
1E1D:  MOVLB  01
....................       // User function }}} 
....................     } 
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1E1E:  MOVF   70,W
1E1F:  XORLW  04
1E20:  MOVLB  00
1E21:  BTFSC  03.2
1E22:  GOTO   626
1E23:  XORLW  01
1E24:  BTFSS  03.2
1E25:  GOTO   628
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1E26:  MOVF   7C,W
1E27:  MOVWF  7D
....................         break; 
....................     } 
....................     if ( site_id == SiteID ) { 
1E28:  MOVF   63,W
1E29:  MOVLB  01
1E2A:  SUBWF  63,W
1E2B:  BTFSS  03.2
1E2C:  GOTO   632
....................       execute_command(); 
1E2D:  MOVLP  10
1E2E:  MOVLB  00
1E2F:  CALL   042
1E30:  MOVLP  18
1E31:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1E32:  MOVF   34,W
1E33:  ANDLW  0F
1E34:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1E35:  BTFSS  60.4
1E36:  GOTO   667
1E37:  CLRF   65
1E38:  CLRF   66
1E39:  MOVLB  00
1E3A:  CALL   54C
1E3B:  MOVF   78,F
1E3C:  BTFSS  03.2
1E3D:  GOTO   640
1E3E:  MOVLB  01
1E3F:  GOTO   667
....................     restart_wdt(); 
1E40:  CLRWDT
....................     switch(command) { 
1E41:  MOVF   70,W
1E42:  XORLW  0E
1E43:  BTFSC  03.2
1E44:  GOTO   64C
1E45:  XORLW  01
1E46:  BTFSC  03.2
1E47:  GOTO   654
1E48:  XORLW  05
1E49:  BTFSC  03.2
1E4A:  GOTO   65C
1E4B:  GOTO   663
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1E4C:  MOVLW  01
1E4D:  ADDWF  76,W
1E4E:  ANDLW  03
1E4F:  MOVWF  76
....................         pot_values_to_lcd(); 
1E50:  MOVLP  08
1E51:  CALL   270
1E52:  MOVLP  18
....................         break; 
1E53:  GOTO   663
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1E54:  MOVLW  FF
1E55:  MOVLB  02
1E56:  MOVWF  2C
1E57:  MOVLP  08
1E58:  MOVLB  00
1E59:  CALL   738
1E5A:  MOVLP  18
....................         break; 
1E5B:  GOTO   663
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1E5C:  MOVLW  01
1E5D:  MOVLB  02
1E5E:  MOVWF  2C
1E5F:  MOVLP  08
1E60:  MOVLB  00
1E61:  CALL   738
1E62:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1E63:  MOVLP  08
1E64:  CALL   729
1E65:  MOVLP  18
1E66:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1E67:  BSF    60.2
.................... } // }}} 
1E68:  MOVLP  18
1E69:  MOVLB  00
1E6A:  GOTO   6E5 (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int cor_index; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
1C2B:  MOVLW  01
1C2C:  MOVLB  01
1C2D:  MOVWF  63
....................   do_update_ptt=0; 
1C2E:  CLRF   66
....................   // Allow emulated COR[4] for DTMF control (No audio feed-thru) 
....................   cor_in = COR_IN ; 
1C2F:  MOVLB  00
1C30:  MOVF   5F,W
1C31:  MOVLB  01
1C32:  MOVWF  65
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in & CurrentCorMask) ) { 
1C33:  MOVF   71,F
1C34:  BTFSC  03.2
1C35:  GOTO   44F
1C36:  MOVF   65,W
1C37:  MOVLB  00
1C38:  ANDWF  6E,W
1C39:  BTFSC  03.2
1C3A:  GOTO   43D
1C3B:  MOVLB  01
1C3C:  GOTO   44F
....................     CurrentCorPriority=0; 
1C3D:  CLRF   71
....................     CurrentCorMask=0; 
1C3E:  CLRF   6E
....................     do_update_ptt=1; 
1C3F:  MOVLW  01
1C40:  MOVLB  01
1C41:  MOVWF  66
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
1C42:  MOVF   65,W
1C43:  MOVLB  00
1C44:  ANDWF  60,W
1C45:  ANDWF  61,W
1C46:  BTFSS  03.2
1C47:  GOTO   44E
....................       COR_DROP_FLAG=1; 
1C48:  BSF    74.5
....................       if ( Tail ) { 
1C49:  MOVF   65,F
1C4A:  BTFSC  03.2
1C4B:  GOTO   44E
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
1C4C:  MOVF   65,W
1C4D:  MOVWF  6C
1C4E:  MOVLB  01
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
1C4F:  CLRF   67
....................   for(x=0;x<4;x++) { 
1C50:  CLRF   68
1C51:  MOVF   68,W
1C52:  SUBLW  03
1C53:  BTFSS  03.0
1C54:  GOTO   498
....................     if ( cor_in & cor_mask & (~TOT_FLAG_Mask) ) { 
1C55:  MOVF   65,W
1C56:  ANDWF  63,W
1C57:  MOVWF  69
1C58:  MOVLB  00
1C59:  MOVF   67,W
1C5A:  XORLW  FF
1C5B:  MOVLB  01
1C5C:  ANDWF  69,W
1C5D:  BTFSC  03.2
1C5E:  GOTO   494
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
1C5F:  MOVLB  00
1C60:  MOVF   60,W
1C61:  ANDWF  61,W
1C62:  MOVLB  01
1C63:  ANDWF  63,W
1C64:  BTFSC  03.2
1C65:  GOTO   470
....................         rx_priority=RXPriority[x]; 
1C66:  MOVLW  25
1C67:  ADDWF  68,W
1C68:  MOVWF  04
1C69:  MOVLW  20
1C6A:  MOVWF  05
1C6B:  BTFSC  03.0
1C6C:  INCF   05,F
1C6D:  MOVF   00,W
1C6E:  MOVWF  64
....................       } else { 
1C6F:  GOTO   472
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
1C70:  MOVLW  01
1C71:  MOVWF  64
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1C72:  MOVF   64,W
1C73:  SUBWF  71,W
1C74:  BTFSC  03.0
1C75:  GOTO   494
....................         if ( ! CurrentCorPriority ) { 
1C76:  MOVF   71,F
1C77:  BTFSS  03.2
1C78:  GOTO   47B
....................           CurrentCorPriority = rx_priority; 
1C79:  MOVF   64,W
1C7A:  MOVWF  71
....................         } 
....................         cor_index=x+1; 
1C7B:  MOVLW  01
1C7C:  ADDWF  68,W
1C7D:  MOVWF  67
....................         do_update_ptt=1; 
1C7E:  MOVLW  01
1C7F:  MOVWF  66
....................         TOT_SecondCounter= 60 * TOT_Min; 
1C80:  MOVLW  3C
1C81:  MOVLB  02
1C82:  MOVWF  40
1C83:  MOVLB  00
1C84:  MOVF   66,W
1C85:  MOVLB  02
1C86:  MOVWF  41
1C87:  MOVLP  08
1C88:  MOVLB  00
1C89:  CALL   661
1C8A:  MOVLP  18
1C8B:  MOVLB  01
1C8C:  CLRF   5F
1C8D:  MOVF   78,W
1C8E:  MOVWF  5E
.................... 	TOT_FLAG_Mask=0; 
1C8F:  MOVLB  00
1C90:  CLRF   67
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
1C91:  MOVLB  01
1C92:  MOVF   63,W
1C93:  MOVWF  72
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
1C94:  BCF    03.0
1C95:  RLF    63,F
....................   } 
1C96:  INCF   68,F
1C97:  GOTO   451
....................   if ( do_update_ptt ) { 
1C98:  MOVF   66,F
1C99:  BTFSC  03.2
1C9A:  GOTO   4A4
....................     update_ptt(cor_index); 
1C9B:  MOVF   67,W
1C9C:  MOVLB  02
1C9D:  MOVWF  2B
1C9E:  MOVLP  08
1C9F:  MOVLB  00
1CA0:  CALL   360
1CA1:  MOVLP  18
....................     PROMPT_FLAG=1; 
1CA2:  MOVLB  01
1CA3:  BSF    60.3
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
1CA4:  MOVF   65,F
1CA5:  BTFSS  03.2
1CA6:  GOTO   4AC
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
1CA7:  BSF    60.2
....................     COR_IN_EFFECTIVE=0; 
1CA8:  CLRF   72
....................     TOT_FLAG_Mask=0; 
1CA9:  MOVLB  00
1CAA:  CLRF   67
1CAB:  MOVLB  01
....................   } 
....................   // Refresh Link Time-out timer when COR is received. 
....................   // Any COR value refreshes the link TOT timer. 
....................   if ( Link_TOT != 0 && (cor_in)!=0 ) { 
1CAC:  MOVLB  00
1CAD:  MOVF   68,F
1CAE:  BTFSC  03.2
1CAF:  GOTO   4B9
1CB0:  MOVLB  01
1CB1:  MOVF   65,F
1CB2:  BTFSS  03.2
1CB3:  GOTO   4B6
1CB4:  MOVLB  00
1CB5:  GOTO   4B9
....................     LinkDurationTimer = Link_TOT; 
1CB6:  MOVLB  00
1CB7:  MOVF   68,W
1CB8:  MOVWF  69
....................   } 
.................... } // }}} 
1CB9:  MOVLP  18
1CBA:  GOTO   6CC (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
1E6B:  MOVLB  01
1E6C:  CLRF   63
1E6D:  MOVF   63,W
1E6E:  SUBLW  09
1E6F:  BTFSS  03.0
1E70:  GOTO   67B
....................     DTMF_ARRAY[x]=(sDTMF)0; 
1E71:  MOVLW  64
1E72:  ADDWF  63,W
1E73:  MOVWF  04
1E74:  MOVLW  20
1E75:  MOVWF  05
1E76:  BTFSC  03.0
1E77:  INCF   05,F
1E78:  CLRF   00
....................   } 
1E79:  INCF   63,F
1E7A:  GOTO   66D
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
1E7B:  MOVLW  20
1E7C:  MOVWF  3F
1E7D:  MOVLW  64
1E7E:  MOVWF  3E
.................... } // }}} 
1E7F:  MOVLP  18
1E80:  MOVLB  00
1E81:  GOTO   6EC (RETURN)
.................... void header (void) { // {{{ 
.................... } // }}} 
*
0003:  RETURN
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   header(); 
*
12A8:  MOVLP  00
12A9:  CALL   003
12AA:  MOVLP  10
....................   dtmf_in=dtmf_read(CONTROL_REG); 
12AB:  MOVLW  01
12AC:  MOVLB  02
12AD:  MOVWF  38
12AE:  MOVLP  00
12AF:  MOVLB  00
12B0:  CALL   69A
12B1:  MOVLP  10
12B2:  MOVF   78,W
12B3:  MOVLB  02
12B4:  MOVWF  30
....................   aux_in = 0; 
12B5:  CLRF   31
....................   for(x=0;x<RegMapNum;x++) { 
12B6:  CLRF   2A
12B7:  CLRF   29
12B8:  MOVF   2A,F
12B9:  BTFSS  03.2
12BA:  GOTO   3BF
12BB:  MOVF   29,W
12BC:  SUBLW  38
12BD:  BTFSS  03.0
12BE:  GOTO   3BF
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
12BF:  MOVLW  01
12C0:  MOVWF  7A
12C1:  MOVLW  8F
12C2:  MOVWF  38
12C3:  MOVF   7A,W
12C4:  MOVWF  39
12C5:  MOVF   2A,W
12C6:  MOVWF  3B
12C7:  MOVF   29,W
12C8:  MOVWF  3A
12C9:  CLRF   3D
12CA:  MOVLW  06
12CB:  MOVWF  3C
12CC:  MOVLP  08
12CD:  MOVLB  00
12CE:  CALL   6E9
12CF:  MOVLP  10
12D0:  MOVF   78,W
12D1:  MOVLB  02
12D2:  ADDWF  38,W
12D3:  MOVWF  2C
12D4:  MOVF   79,W
12D5:  ADDWFC 39,W
12D6:  MOVWF  2D
....................     romstrcpy(rname,cPtr); 
12D7:  MOVLW  20
12D8:  MOVWF  39
12D9:  MOVLW  B2
12DA:  MOVWF  38
12DB:  MOVF   2D,W
12DC:  MOVWF  3B
12DD:  MOVF   2C,W
12DE:  MOVWF  3A
12DF:  MOVLP  08
12E0:  MOVLB  00
12E1:  CALL   700
12E2:  MOVLP  10
....................   regPtr=RegMap[x].reg_ptr; 
12E3:  MOVLB  02
12E4:  RLF    29,W
12E5:  MOVWF  38
12E6:  RLF    2A,W
12E7:  MOVWF  39
12E8:  RLF    38,F
12E9:  RLF    39,F
12EA:  MOVLW  FC
12EB:  ANDWF  38,F
12EC:  MOVF   39,W
12ED:  MOVWF  7A
12EE:  MOVF   38,W
12EF:  MOVWF  3A
12F0:  INCF   38,W
12F1:  MOVLP  00
12F2:  MOVLB  00
12F3:  CALL   043
12F4:  MOVLP  10
12F5:  MOVWF  7A
12F6:  MOVLB  02
12F7:  MOVF   3A,W
12F8:  MOVLP  00
12F9:  MOVLB  00
12FA:  CALL   043
12FB:  MOVLP  10
12FC:  MOVLB  02
12FD:  MOVWF  2E
12FE:  MOVF   7A,W
12FF:  MOVWF  2F
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
1300:  MOVF   2F,W
1301:  MOVWF  7A
1302:  MOVF   2E,W
1303:  MOVWF  04
1304:  MOVF   7A,W
1305:  MOVWF  05
1306:  MOVF   00,W
1307:  MOVWF  38
1308:  MOVLW  5B
1309:  CLRWDT
130A:  MOVLB  00
130B:  BTFSC  11.4
130C:  GOTO   30F
130D:  MOVLB  02
130E:  GOTO   309
130F:  MOVLB  03
1310:  MOVWF  1A
1311:  MOVLW  0B
1312:  MOVWF  04
1313:  MOVLB  02
1314:  MOVF   2A,W
1315:  MOVWF  3A
1316:  MOVF   29,W
1317:  MOVWF  39
*
1375:  MOVLW  5D
1376:  CLRWDT
1377:  MOVLB  00
1378:  BTFSC  11.4
1379:  GOTO   37C
137A:  MOVLB  02
137B:  GOTO   376
137C:  MOVLB  03
137D:  MOVWF  1A
137E:  MOVLW  20
137F:  CLRWDT
1380:  MOVLB  00
1381:  BTFSC  11.4
1382:  GOTO   385
1383:  MOVLB  03
1384:  GOTO   37F
1385:  MOVLB  03
1386:  MOVWF  1A
1387:  MOVLW  20
1388:  MOVWF  05
1389:  MOVLW  B2
138A:  MOVWF  04
138B:  MOVLP  08
138C:  MOVLB  00
138D:  CALL   256
138E:  MOVLP  10
138F:  MOVLW  20
1390:  CLRWDT
1391:  BTFSS  11.4
1392:  GOTO   390
1393:  MOVLB  03
1394:  MOVWF  1A
1395:  MOVLB  02
1396:  MOVF   38,W
1397:  MOVWF  4D
1398:  MOVLW  1B
1399:  MOVWF  4E
139A:  MOVLP  00
139B:  MOVLB  00
139C:  CALL   73C
139D:  MOVLP  10
139E:  MOVLW  09
139F:  CLRWDT
13A0:  BTFSS  11.4
13A1:  GOTO   39F
13A2:  MOVLB  03
13A3:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
13A4:  MOVLB  02
13A5:  MOVF   29,W
13A6:  ANDLW  03
13A7:  MOVWF  38
13A8:  CLRF   39
13A9:  MOVF   38,W
13AA:  SUBLW  03
13AB:  BTFSS  03.2
13AC:  GOTO   3BA
13AD:  MOVF   39,F
13AE:  BTFSS  03.2
13AF:  GOTO   3BA
....................       putc('\n'); 
13B0:  MOVLW  0A
13B1:  MOVLP  00
13B2:  MOVLB  00
13B3:  CALL   2E4
13B4:  MOVLP  10
....................       putc('\r'); 
13B5:  MOVLW  0D
13B6:  MOVLP  00
13B7:  CALL   2E4
13B8:  MOVLP  10
13B9:  MOVLB  02
....................     } 
....................     restart_wdt(); 
13BA:  CLRWDT
....................   } 
13BB:  INCF   29,F
13BC:  BTFSC  03.2
13BD:  INCF   2A,F
13BE:  GOTO   2B8
....................   for(y=0;y<3;y++) { 
13BF:  CLRF   2B
13C0:  MOVF   2B,W
13C1:  SUBLW  02
13C2:  BTFSS  03.0
13C3:  GOTO   3DA
....................     if(AuxInSW[y]==1) { 
13C4:  MOVLW  1F
13C5:  ADDWF  2B,W
13C6:  MOVWF  04
13C7:  MOVLW  20
13C8:  MOVWF  05
13C9:  BTFSC  03.0
13CA:  INCF   05,F
13CB:  DECFSZ 00,W
13CC:  GOTO   3D8
....................       aux_in += (1<<y); 
13CD:  MOVLW  01
13CE:  MOVWF  77
13CF:  MOVF   2B,W
13D0:  MOVWF  78
13D1:  BTFSC  03.2
13D2:  GOTO   3D6
13D3:  LSLF   77,F
13D4:  DECFSZ 78,F
13D5:  GOTO   3D3
13D6:  MOVF   77,W
13D7:  ADDWF  31,F
....................     } 
....................   } 
13D8:  INCF   2B,F
13D9:  GOTO   3C0
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u TOT:%u",COR_IN,COR_EMUL,aux_in,TOT_FLAG_Mask); 
13DA:  MOVLW  0B
13DB:  MOVLB  03
13DC:  MOVWF  11
13DD:  MOVLW  04
13DE:  MOVWF  12
13DF:  BCF    03.0
13E0:  MOVLW  07
13E1:  MOVLB  02
13E2:  MOVWF  4D
13E3:  MOVLP  00
13E4:  MOVLB  00
13E5:  CALL   6C8
13E6:  MOVLP  10
13E7:  MOVF   5F,W
13E8:  MOVLB  02
13E9:  MOVWF  4D
13EA:  MOVLW  1B
13EB:  MOVWF  4E
13EC:  MOVLP  00
13ED:  MOVLB  00
13EE:  CALL   73C
13EF:  MOVLP  10
13F0:  MOVLW  0F
13F1:  MOVLB  03
13F2:  MOVWF  11
13F3:  MOVLW  04
13F4:  MOVWF  12
13F5:  BSF    03.0
13F6:  MOVLW  07
13F7:  MOVLB  02
13F8:  MOVWF  4D
13F9:  MOVLP  00
13FA:  MOVLB  00
13FB:  CALL   6C8
13FC:  MOVLP  10
13FD:  MOVF   6A,W
13FE:  MOVLB  02
13FF:  MOVWF  4D
1400:  MOVLW  1B
1401:  MOVWF  4E
1402:  MOVLP  00
1403:  MOVLB  00
1404:  CALL   73C
1405:  MOVLP  10
1406:  MOVLW  14
1407:  MOVLB  03
1408:  MOVWF  11
1409:  MOVLW  04
140A:  MOVWF  12
140B:  BCF    03.0
140C:  MOVLW  09
140D:  MOVLB  02
140E:  MOVWF  4D
140F:  MOVLP  00
1410:  MOVLB  00
1411:  CALL   6C8
1412:  MOVLP  10
1413:  MOVLB  02
1414:  MOVF   31,W
1415:  MOVWF  4D
1416:  MOVLW  1B
1417:  MOVWF  4E
1418:  MOVLP  00
1419:  MOVLB  00
141A:  CALL   73C
141B:  MOVLP  10
141C:  MOVLW  19
141D:  MOVLB  03
141E:  MOVWF  11
141F:  MOVLW  04
1420:  MOVWF  12
1421:  BSF    03.0
1422:  MOVLW  05
1423:  MOVLB  02
1424:  MOVWF  4D
1425:  MOVLP  00
1426:  MOVLB  00
1427:  CALL   6C8
1428:  MOVLP  10
1429:  MOVF   67,W
142A:  MOVLB  02
142B:  MOVWF  4D
142C:  MOVLW  1B
142D:  MOVWF  4E
142E:  MOVLP  00
142F:  MOVLB  00
1430:  CALL   73C
1431:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
1432:  MOVLW  1E
1433:  MOVLB  03
1434:  MOVWF  11
1435:  MOVLW  04
1436:  MOVWF  12
1437:  BCF    03.0
1438:  MOVLW  10
1439:  MOVLB  02
143A:  MOVWF  4D
143B:  MOVLP  00
143C:  MOVLB  00
143D:  CALL   6C8
143E:  MOVLP  10
143F:  MOVLB  02
1440:  MOVF   30,W
1441:  MOVWF  4D
1442:  MOVLW  1B
1443:  MOVWF  4E
1444:  MOVLP  00
1445:  MOVLB  00
1446:  CALL   73C
1447:  MOVLP  10
1448:  MOVLW  0A
1449:  CLRWDT
144A:  BTFSS  11.4
144B:  GOTO   449
144C:  MOVLB  03
144D:  MOVWF  1A
144E:  MOVLW  0D
144F:  CLRWDT
1450:  MOVLB  00
1451:  BTFSC  11.4
1452:  GOTO   455
1453:  MOVLB  03
1454:  GOTO   44F
1455:  MOVLB  03
1456:  MOVWF  1A
....................   pot_values_to_lcd(); 
1457:  MOVLP  08
1458:  MOVLB  00
1459:  CALL   270
145A:  MOVLP  10
....................   PROMPT_FLAG=1; 
145B:  MOVLB  01
145C:  BSF    60.3
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0A70:  MOVLW  20
0A71:  MOVLB  02
0A72:  MOVWF  3F
0A73:  MOVWF  40
0A74:  MOVWF  41
0A75:  MOVWF  42
....................   unsigned pval[4]={0,0,0,0}; 
0A76:  CLRF   43
0A77:  CLRF   44
0A78:  CLRF   45
0A79:  CLRF   46
....................   delay_ms(40); 
0A7A:  MOVLW  28
0A7B:  MOVWF  47
0A7C:  MOVLB  00
0A7D:  CALL   000
....................   i2c_start(); 
0A7E:  MOVLB  04
0A7F:  BSF    16.0
0A80:  BTFSC  16.0
0A81:  GOTO   280
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0A82:  MOVLW  51
0A83:  MOVLB  02
0A84:  MOVWF  4D
0A85:  MOVLP  00
0A86:  MOVLB  00
0A87:  CALL   6B3
0A88:  MOVLP  08
0A89:  MOVF   78,W
0A8A:  MOVLB  02
0A8B:  BCF    3E.1
0A8C:  BTFSC  78.0
0A8D:  BSF    3E.1
....................   for(x=0;x<4;x++) { 
0A8E:  CLRF   3C
0A8F:  MOVF   3C,W
0A90:  SUBLW  03
0A91:  BTFSS  03.0
0A92:  GOTO   2CC
....................     if(x==3) { 
0A93:  MOVF   3C,W
0A94:  SUBLW  03
0A95:  BTFSS  03.2
0A96:  GOTO   299
....................       ack=0; 
0A97:  BCF    3E.0
....................     } else { 
0A98:  GOTO   29A
....................       ack=1; 
0A99:  BSF    3E.0
....................     } 
....................     pot_val=i2c_read(ack); 
0A9A:  MOVLW  00
0A9B:  BTFSC  3E.0
0A9C:  MOVLW  01
0A9D:  MOVWF  47
0A9E:  MOVF   47,W
0A9F:  MOVWF  77
*
0AAE:  MOVF   78,W
0AAF:  MOVLB  02
0AB0:  MOVWF  3D
....................     pot_val=pot_val&0x3F; 
0AB1:  MOVLW  3F
0AB2:  ANDWF  3D,F
....................     pval[x]=pot_val; 
0AB3:  MOVLW  C3
0AB4:  ADDWF  3C,W
0AB5:  MOVWF  04
0AB6:  MOVLW  20
0AB7:  MOVWF  05
0AB8:  BTFSC  03.0
0AB9:  INCF   05,F
0ABA:  MOVF   3D,W
0ABB:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0ABC:  MOVF   76,W
0ABD:  ANDLW  03
0ABE:  SUBWF  3C,W
0ABF:  BTFSS  03.2
0AC0:  GOTO   2CA
....................       c[x] = '*'; 
0AC1:  MOVLW  BF
0AC2:  ADDWF  3C,W
0AC3:  MOVWF  04
0AC4:  MOVLW  20
0AC5:  MOVWF  05
0AC6:  BTFSC  03.0
0AC7:  INCF   05,F
0AC8:  MOVLW  2A
0AC9:  MOVWF  00
....................     } 
....................   } 
0ACA:  INCF   3C,F
0ACB:  GOTO   28F
....................   i2c_stop(); 
0ACC:  MOVLB  04
0ACD:  BSF    16.2
0ACE:  BTFSC  16.2
0ACF:  GOTO   2CE
....................   delay_ms(50); 
0AD0:  MOVLW  32
0AD1:  MOVLB  02
0AD2:  MOVWF  47
0AD3:  MOVLB  00
0AD4:  CALL   000
....................   if ( ack_in!=0 ) { 
0AD5:  MOVLB  02
0AD6:  BTFSS  3E.1
0AD7:  GOTO   2F3
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0AD8:  MOVLW  00
0AD9:  BTFSC  3E.0
0ADA:  MOVLW  01
0ADB:  MOVWF  47
0ADC:  MOVLW  29
0ADD:  MOVLB  03
0ADE:  MOVWF  11
0ADF:  MOVLW  04
0AE0:  MOVWF  12
0AE1:  BCF    03.0
0AE2:  MOVLW  25
0AE3:  MOVLB  02
0AE4:  MOVWF  4D
0AE5:  MOVLP  00
0AE6:  MOVLB  00
0AE7:  CALL   6C8
0AE8:  MOVLP  08
0AE9:  MOVLB  02
0AEA:  MOVF   47,W
0AEB:  MOVWF  4D
0AEC:  MOVLW  1B
0AED:  MOVWF  4E
0AEE:  MOVLP  00
0AEF:  MOVLB  00
0AF0:  CALL   73C
0AF1:  MOVLP  08
0AF2:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0AF3:  MOVLW  20
0AF4:  MOVLB  01
0AF5:  MOVWF  62
0AF6:  MOVLW  76
0AF7:  MOVWF  61
0AF8:  MOVLW  3D
0AF9:  MOVLB  03
0AFA:  MOVWF  11
0AFB:  MOVLW  04
0AFC:  MOVWF  12
0AFD:  BCF    03.0
0AFE:  MOVLW  04
0AFF:  MOVLB  02
0B00:  MOVWF  47
0B01:  MOVLB  00
0B02:  CALL   124
0B03:  MOVLB  02
0B04:  MOVF   3F,W
0B05:  MOVWF  4D
0B06:  MOVLB  00
0B07:  CALL   115
0B08:  MOVLB  02
0B09:  MOVF   43,W
0B0A:  MOVWF  47
0B0B:  MOVLW  18
0B0C:  MOVWF  48
0B0D:  MOVLB  00
0B0E:  CALL   1EF
0B0F:  MOVLW  20
0B10:  MOVLB  02
0B11:  MOVWF  4D
0B12:  MOVLB  00
0B13:  CALL   115
0B14:  MOVLB  02
0B15:  MOVF   40,W
0B16:  MOVWF  4D
0B17:  MOVLB  00
0B18:  CALL   115
0B19:  MOVLB  02
0B1A:  MOVF   44,W
0B1B:  MOVWF  47
0B1C:  MOVLW  18
0B1D:  MOVWF  48
0B1E:  MOVLB  00
0B1F:  CALL   1EF
0B20:  MOVLW  20
0B21:  MOVLB  02
0B22:  MOVWF  4D
0B23:  MOVLB  00
0B24:  CALL   115
0B25:  MOVLB  02
0B26:  MOVF   41,W
0B27:  MOVWF  4D
0B28:  MOVLB  00
0B29:  CALL   115
0B2A:  MOVLB  02
0B2B:  MOVF   45,W
0B2C:  MOVWF  47
0B2D:  MOVLW  18
0B2E:  MOVWF  48
0B2F:  MOVLB  00
0B30:  CALL   1EF
0B31:  MOVLW  20
0B32:  MOVLB  02
0B33:  MOVWF  4D
0B34:  MOVLB  00
0B35:  CALL   115
0B36:  MOVLB  02
0B37:  MOVF   42,W
0B38:  MOVWF  4D
0B39:  MOVLB  00
0B3A:  CALL   115
0B3B:  MOVLB  02
0B3C:  MOVF   46,W
0B3D:  MOVWF  47
0B3E:  MOVLW  18
0B3F:  MOVWF  48
0B40:  MOVLB  00
0B41:  CALL   1EF
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0B42:  MOVLB  02
0B43:  CLRF   47
0B44:  MOVLW  20
0B45:  MOVWF  49
0B46:  MOVLW  76
0B47:  MOVWF  48
0B48:  MOVLB  00
0B49:  CALL   18C
....................   printf("\n\r%s",LCD_str); 
0B4A:  MOVLW  0A
0B4B:  CLRWDT
0B4C:  BTFSS  11.4
0B4D:  GOTO   34B
0B4E:  MOVLB  03
0B4F:  MOVWF  1A
0B50:  MOVLW  0D
0B51:  CLRWDT
0B52:  MOVLB  00
0B53:  BTFSC  11.4
0B54:  GOTO   357
0B55:  MOVLB  03
0B56:  GOTO   351
0B57:  MOVLB  03
0B58:  MOVWF  1A
0B59:  MOVLW  20
0B5A:  MOVWF  05
0B5B:  MOVLW  76
0B5C:  MOVWF  04
0B5D:  MOVLB  00
0B5E:  CALL   256
....................  
.................... } // }}} 
0B5F:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
0FBC:  MOVLB  01
0FBD:  BTFSS  60.4
0FBE:  GOTO   7CA
....................     printf("\n\n\rADMIN> "); 
0FBF:  MOVLW  49
0FC0:  MOVLB  03
0FC1:  MOVWF  11
0FC2:  MOVLW  04
0FC3:  MOVWF  12
0FC4:  MOVLP  00
0FC5:  MOVLB  00
0FC6:  CALL   4D7
0FC7:  MOVLP  08
....................   } else { 
0FC8:  GOTO   7D3
0FC9:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
0FCA:  MOVLW  4F
0FCB:  MOVLB  03
0FCC:  MOVWF  11
0FCD:  MOVLW  04
0FCE:  MOVWF  12
0FCF:  MOVLP  00
0FD0:  MOVLB  00
0FD1:  CALL   4D7
0FD2:  MOVLP  08
....................   } 
.................... } // }}} 
0FD3:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
04BD:  MOVLW  10
04BE:  MOVLB  01
04BF:  MOVWF  64
....................   for (x=0;x<char_num;x++) { 
04C0:  CLRF   63
04C1:  MOVF   64,W
04C2:  SUBWF  63,W
04C3:  BTFSC  03.0
04C4:  GOTO   4CF
....................     sBuffer[x]='\0'; 
04C5:  MOVLW  50
04C6:  ADDWF  63,W
04C7:  MOVWF  04
04C8:  MOVLW  20
04C9:  MOVWF  05
04CA:  BTFSC  03.0
04CB:  INCF   05,F
04CC:  CLRF   00
....................   } 
04CD:  INCF   63,F
04CE:  GOTO   4C1
....................   sBufferIndex=0; 
04CF:  CLRF   73
....................   sBufferFlag=0;   
04D0:  BCF    74.0
....................   argument=-1; 
04D1:  MOVLW  FF
04D2:  MOVWF  7C
....................   argument_name[0]='\0'; 
04D3:  CLRF   40
....................   command=0; 
04D4:  CLRF   70
.................... } // }}} 
04D5:  MOVLB  00
04D6:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
065A:  MOVLW  00
065B:  MOVLB  01
065C:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
065D:  MOVLB  02
065E:  BCF    42.0
065F:  MOVF   40,W
0660:  ANDLW  0F
0661:  ANDLW  01
0662:  BTFSS  03.2
0663:  BSF    42.0
....................   output_bit(DTMF_D0,dbit); 
0664:  BTFSC  42.0
0665:  GOTO   668
0666:  BCF    0F.0
0667:  GOTO   669
0668:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
0669:  BCF    42.0
066A:  MOVF   40,W
066B:  ANDLW  0F
066C:  ANDLW  02
066D:  BTFSS  03.2
066E:  BSF    42.0
....................   output_bit(DTMF_D1,dbit); 
066F:  BTFSC  42.0
0670:  GOTO   673
0671:  BCF    0F.1
0672:  GOTO   674
0673:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
0674:  BCF    42.0
0675:  MOVF   40,W
0676:  ANDLW  0F
0677:  ANDLW  04
0678:  BTFSS  03.2
0679:  BSF    42.0
....................   output_bit(DTMF_D2,dbit); 
067A:  BTFSC  42.0
067B:  GOTO   67E
067C:  BCF    0F.2
067D:  GOTO   67F
067E:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
067F:  BCF    42.0
0680:  MOVF   40,W
0681:  ANDLW  0F
0682:  ANDLW  08
0683:  BTFSS  03.2
0684:  BSF    42.0
....................   output_bit(DTMF_D3,dbit); 
0685:  BTFSC  42.0
0686:  GOTO   689
0687:  BCF    0F.3
0688:  GOTO   68A
0689:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
068A:  MOVF   41,F
068B:  BTFSS  03.2
068C:  GOTO   68F
068D:  BCF    0F.6
068E:  GOTO   690
068F:  BSF    0F.6
....................   delay_cycles(2); 
0690:  GOTO   691
....................   output_bit(DTMF_WEB,0); 
0691:  BCF    0F.5
....................   delay_cycles(2); 
0692:  GOTO   693
....................   output_bit(DTMF_WEB,1);   
0693:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
0694:  GOTO   695
....................   set_tris_d(0x0F); 
0695:  MOVLW  0F
0696:  MOVLB  01
0697:  MOVWF  0F
.................... } // }}} 
0698:  MOVLB  00
0699:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
069A:  MOVLW  0F
069B:  MOVLB  01
069C:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
069D:  MOVLB  02
069E:  MOVF   38,F
069F:  BTFSS  03.2
06A0:  GOTO   6A3
06A1:  BCF    0F.6
06A2:  GOTO   6A4
06A3:  BSF    0F.6
....................   delay_cycles(1); 
06A4:  NOP
....................   output_bit(DTMF_REB,0); 
06A5:  BCF    0F.4
....................   delay_cycles(1); 
06A6:  NOP
....................   value=input_d(); 
06A7:  MOVLB  00
06A8:  MOVF   0F,W
06A9:  MOVLB  02
06AA:  MOVWF  39
....................   value&=0x0F; 
06AB:  MOVLW  0F
06AC:  ANDWF  39,F
....................   output_bit(DTMF_REB,1); 
06AD:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
06AE:  NOP
....................   return(value); 
06AF:  MOVF   39,W
06B0:  MOVWF  78
.................... } // }}} 
06B1:  MOVLB  00
06B2:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0CFD:  MOVLB  02
0CFE:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0CFF:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0D00:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0D01:  CLRF   40
0D02:  MOVLW  01
0D03:  MOVWF  41
0D04:  MOVLP  00
0D05:  MOVLB  00
0D06:  CALL   65A
0D07:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0D08:  MOVLB  02
0D09:  CLRF   40
0D0A:  MOVLW  01
0D0B:  MOVWF  41
0D0C:  MOVLP  00
0D0D:  MOVLB  00
0D0E:  CALL   65A
0D0F:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0D10:  MOVLW  0C
0D11:  MOVLB  02
0D12:  MOVWF  40
0D13:  MOVLW  01
0D14:  MOVWF  41
0D15:  MOVLP  00
0D16:  MOVLB  00
0D17:  CALL   65A
0D18:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0D19:  MOVLW  01
0D1A:  MOVLB  02
0D1B:  MOVWF  40
0D1C:  MOVWF  41
0D1D:  MOVLP  00
0D1E:  MOVLB  00
0D1F:  CALL   65A
0D20:  MOVLP  08
....................     dtmf_read(CONTROL_REG); 
0D21:  MOVLW  01
0D22:  MOVLB  02
0D23:  MOVWF  38
0D24:  MOVLP  00
0D25:  MOVLB  00
0D26:  CALL   69A
0D27:  MOVLP  08
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19EC:  MOVF   3D,W
19ED:  MOVWF  40
19EE:  CLRF   41
19EF:  MOVLP  00
19F0:  MOVLB  00
19F1:  CALL   65A
19F2:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19F3:  MOVLW  0C
19F4:  MOVLB  02
19F5:  MOVWF  40
19F6:  MOVLW  01
19F7:  MOVWF  41
19F8:  MOVLP  00
19F9:  MOVLB  00
19FA:  CALL   65A
19FB:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
19FC:  MOVLW  01
19FD:  MOVLB  02
19FE:  MOVWF  40
19FF:  MOVWF  41
1A00:  MOVLP  00
1A01:  MOVLB  00
1A02:  CALL   65A
1A03:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A04:  MOVLW  05
1A05:  MOVLB  02
1A06:  MOVWF  40
1A07:  MOVLW  01
1A08:  MOVWF  41
1A09:  MOVLP  00
1A0A:  MOVLB  00
1A0B:  CALL   65A
1A0C:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A0D:  MOVLB  01
1A0E:  CLRF   33
1A0F:  MOVLW  10
1A10:  MOVWF  32
....................   while(aux_timer) { 
1A11:  MOVF   32,W
1A12:  IORWF  33,W
1A13:  BTFSC  03.2
1A14:  GOTO   217
....................     delay_cycles(1); 
1A15:  NOP
....................   } 
1A16:  GOTO   211
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A17:  MOVLW  04
1A18:  MOVLB  02
1A19:  MOVWF  40
1A1A:  MOVLW  01
1A1B:  MOVWF  41
1A1C:  MOVLP  00
1A1D:  MOVLB  00
1A1E:  CALL   65A
1A1F:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
082C:  MOVLW  01
082D:  MOVLB  02
082E:  MOVWF  40
082F:  CLRF   41
0830:  MOVLP  00
0831:  MOVLB  00
0832:  CALL   65A
0833:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0834:  MOVLW  0C
0835:  MOVLB  02
0836:  MOVWF  40
0837:  MOVLW  01
0838:  MOVWF  41
0839:  MOVLP  00
083A:  MOVLB  00
083B:  CALL   65A
083C:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
083D:  MOVLW  05
083E:  MOVLB  02
083F:  MOVWF  40
0840:  MOVLW  01
0841:  MOVWF  41
0842:  MOVLP  00
0843:  MOVLB  00
0844:  CALL   65A
0845:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0846:  MOVLW  05
0847:  MOVLB  02
0848:  MOVWF  40
0849:  MOVLW  01
084A:  MOVWF  41
084B:  MOVLP  00
084C:  MOVLB  00
084D:  CALL   65A
084E:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
084F:  MOVLB  01
0850:  CLRF   33
0851:  MOVLW  02
0852:  MOVWF  32
....................   while(aux_timer) { 
0853:  MOVF   32,W
0854:  IORWF  33,W
0855:  BTFSC  03.2
0856:  GOTO   059
....................     delay_cycles(1); 
0857:  NOP
....................   } 
0858:  GOTO   053
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0859:  MOVLW  04
085A:  MOVLB  02
085B:  MOVWF  40
085C:  MOVLW  01
085D:  MOVWF  41
085E:  MOVLP  00
085F:  MOVLB  00
0860:  CALL   65A
0861:  MOVLP  08
....................   restart_wdt(); 
0862:  CLRWDT
.................... } // }}} 
0863:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
0864:  MOVLW  01
0865:  MOVLB  02
0866:  MOVWF  40
0867:  CLRF   41
0868:  MOVLP  00
0869:  MOVLB  00
086A:  CALL   65A
086B:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
086C:  MOVLW  0C
086D:  MOVLB  02
086E:  MOVWF  40
086F:  MOVLW  01
0870:  MOVWF  41
0871:  MOVLP  00
0872:  MOVLB  00
0873:  CALL   65A
0874:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0875:  MOVLW  05
0876:  MOVLB  02
0877:  MOVWF  40
0878:  MOVLW  01
0879:  MOVWF  41
087A:  MOVLP  00
087B:  MOVLB  00
087C:  CALL   65A
087D:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
087E:  MOVLW  05
087F:  MOVLB  02
0880:  MOVWF  40
0881:  MOVLW  01
0882:  MOVWF  41
0883:  MOVLP  00
0884:  MOVLB  00
0885:  CALL   65A
0886:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
0887:  MOVLB  01
0888:  CLRF   33
0889:  MOVLW  06
088A:  MOVWF  32
....................   while(aux_timer) { 
088B:  MOVF   32,W
088C:  IORWF  33,W
088D:  BTFSC  03.2
088E:  GOTO   091
....................     delay_cycles(1); 
088F:  NOP
....................   } 
0890:  GOTO   08B
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0891:  MOVLW  04
0892:  MOVLB  02
0893:  MOVWF  40
0894:  MOVLW  01
0895:  MOVWF  41
0896:  MOVLP  00
0897:  MOVLB  00
0898:  CALL   65A
0899:  MOVLP  08
....................   restart_wdt(); 
089A:  CLRWDT
.................... } // }}} 
089B:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
052C:  MOVLB  02
052D:  MOVF   35,W
052E:  MOVWF  04
052F:  MOVF   36,W
0530:  MOVWF  05
0531:  MOVF   00,W
0532:  MOVWF  38
....................   if ( tmp > 127 ) { 
0533:  MOVF   38,W
0534:  SUBLW  7F
0535:  BTFSS  03.0
....................     tmp++; 
0536:  INCF   38,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
0537:  BCF    03.0
0538:  RLF    38,W
0539:  XORLW  09
053A:  ADDWF  37,W
053B:  MOVWF  38
....................   *cksum=tmp; 
053C:  MOVF   35,W
053D:  MOVWF  04
053E:  MOVF   36,W
053F:  MOVWF  05
0540:  MOVF   38,W
0541:  MOVWF  00
.................... } // }}} 
0542:  MOVLB  00
0543:  RETURN
.................... void print_dtmf_info(void) { // {{{ 
....................   unsigned int x; 
....................   char dtmf; 
....................   char tmp[5]; 
....................   strcpy(LCD_str,"DTMF:"); 
*
1CBB:  MOVLB  01
1CBC:  CLRF   6A
1CBD:  CLRF   6B
1CBE:  MOVLW  20
1CBF:  MOVWF  05
1CC0:  MOVLW  76
1CC1:  MOVWF  04
1CC2:  MOVF   6A,W
1CC3:  ADDWF  04,F
1CC4:  MOVLW  00
1CC5:  ADDWFC 05,F
1CC6:  MOVF   6B,W
1CC7:  MOVLP  00
1CC8:  MOVLB  00
1CC9:  CALL   139
1CCA:  MOVLP  18
1CCB:  MOVWF  00
1CCC:  IORLW  00
1CCD:  BTFSC  03.2
1CCE:  GOTO   4D4
1CCF:  MOVLB  01
1CD0:  INCF   6B,F
1CD1:  INCF   6A,F
1CD2:  GOTO   4BE
1CD3:  MOVLB  00
....................   printf("\n\rDTMF="); 
1CD4:  MOVLW  56
1CD5:  MOVLB  03
1CD6:  MOVWF  11
1CD7:  MOVLW  04
1CD8:  MOVWF  12
1CD9:  MOVLP  00
1CDA:  MOVLB  00
1CDB:  CALL   4D7
1CDC:  MOVLP  18
....................   for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1CDD:  MOVLB  01
1CDE:  CLRF   63
1CDF:  MOVF   63,W
1CE0:  SUBLW  09
1CE1:  BTFSS  03.0
1CE2:  GOTO   52B
....................     if(DTMF_ARRAY[x].Strobe) { 
1CE3:  MOVLW  64
1CE4:  ADDWF  63,W
1CE5:  MOVWF  04
1CE6:  MOVLW  20
1CE7:  MOVWF  05
1CE8:  BTFSC  03.0
1CE9:  INCF   05,F
1CEA:  BTFSS  00.4
1CEB:  GOTO   528
....................       dtmf=(int)DTMF_ARRAY[x].Key; 
1CEC:  MOVLW  64
1CED:  ADDWF  63,W
1CEE:  MOVWF  04
1CEF:  MOVLW  20
1CF0:  MOVWF  05
1CF1:  BTFSC  03.0
1CF2:  INCF   05,F
1CF3:  MOVF   00,W
1CF4:  ANDLW  0F
1CF5:  MOVWF  64
....................       sprintf(tmp,"%d ",dtmf); 
1CF6:  MOVLW  20
1CF7:  MOVWF  62
1CF8:  MOVLW  95
1CF9:  MOVWF  61
1CFA:  MOVF   64,W
1CFB:  MOVLB  02
1CFC:  MOVWF  47
1CFD:  MOVLW  18
1CFE:  MOVWF  48
1CFF:  MOVLP  08
1D00:  MOVLB  00
1D01:  CALL   1EF
1D02:  MOVLP  18
1D03:  MOVLW  20
1D04:  MOVLB  02
1D05:  MOVWF  4D
1D06:  MOVLP  08
1D07:  MOVLB  00
1D08:  CALL   115
1D09:  MOVLP  18
....................       strcat(LCD_str,tmp); 
1D0A:  MOVLW  20
1D0B:  MOVLB  02
1D0C:  MOVWF  27
1D0D:  MOVLW  76
1D0E:  MOVWF  26
1D0F:  MOVLW  20
1D10:  MOVWF  29
1D11:  MOVLW  95
1D12:  MOVWF  28
1D13:  MOVLP  10
1D14:  MOVLB  00
1D15:  CALL   5AC
1D16:  MOVLP  18
....................       printf(" %u",dtmf); 
1D17:  MOVLW  20
1D18:  CLRWDT
1D19:  BTFSS  11.4
1D1A:  GOTO   518
1D1B:  MOVLB  03
1D1C:  MOVWF  1A
1D1D:  MOVLB  01
1D1E:  MOVF   64,W
1D1F:  MOVLB  02
1D20:  MOVWF  4D
1D21:  MOVLW  1B
1D22:  MOVWF  4E
1D23:  MOVLP  00
1D24:  MOVLB  00
1D25:  CALL   73C
1D26:  MOVLP  18
1D27:  MOVLB  01
....................     } 
....................   restart_wdt(); 
1D28:  CLRWDT
....................   } 
1D29:  INCF   63,F
1D2A:  GOTO   4DF
....................   printf("\n\r"); 
1D2B:  MOVLW  0A
1D2C:  CLRWDT
1D2D:  MOVLB  00
1D2E:  BTFSC  11.4
1D2F:  GOTO   532
1D30:  MOVLB  01
1D31:  GOTO   52C
1D32:  MOVLB  03
1D33:  MOVWF  1A
1D34:  MOVLW  0D
1D35:  CLRWDT
1D36:  MOVLB  00
1D37:  BTFSC  11.4
1D38:  GOTO   53B
1D39:  MOVLB  03
1D3A:  GOTO   535
1D3B:  MOVLB  03
1D3C:  MOVWF  1A
....................   PROMPT_FLAG=1; 
1D3D:  MOVLB  01
1D3E:  BSF    60.3
....................   lcd_send(2,LCD_str); // Send DTMF on line 3 
1D3F:  MOVLW  02
1D40:  MOVLB  02
1D41:  MOVWF  47
1D42:  MOVLW  20
1D43:  MOVWF  49
1D44:  MOVLW  76
1D45:  MOVWF  48
1D46:  MOVLP  08
1D47:  MOVLB  00
1D48:  CALL   18C
1D49:  MOVLP  18
.................... } // }}} 
1D4A:  MOVLP  18
1D4B:  GOTO   6DE (RETURN)
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
*
0544:  MOVLW  01
0545:  MOVLB  02
0546:  MOVWF  2F
....................   eeprom_index=0; 
0547:  CLRF   30
....................   retVal = 1; 
0548:  MOVWF  32
....................   if ( source == USE_EEPROM_VARS ) { 
0549:  DECFSZ 2B,W
054A:  GOTO   554
....................     printf("\n\rInit RAM <= EEPROM"); 
054B:  MOVLW  5A
054C:  MOVLB  03
054D:  MOVWF  11
054E:  MOVLW  04
054F:  MOVWF  12
0550:  MOVLB  00
0551:  CALL   4D7
....................   } else { 
0552:  GOTO   55B
0553:  MOVLB  02
....................     printf("\n\rInit RAM <= HW Defaults"); 
0554:  MOVLW  65
0555:  MOVLB  03
0556:  MOVWF  11
0557:  MOVLW  04
0558:  MOVWF  12
0559:  MOVLB  00
055A:  CALL   4D7
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
055B:  MOVLB  02
055C:  CLRF   2C
055D:  MOVF   2C,W
055E:  SUBLW  38
055F:  BTFSS  03.0
0560:  GOTO   5BA
....................     regPtr=RegMap[x].reg_ptr; 
0561:  RLF    2C,W
0562:  MOVWF  77
0563:  RLF    77,F
0564:  MOVLW  FC
0565:  ANDWF  77,F
0566:  MOVF   77,W
0567:  MOVWF  34
0568:  INCF   34,W
0569:  MOVLB  00
056A:  CALL   043
056B:  MOVWF  7A
056C:  MOVLB  02
056D:  MOVF   34,W
056E:  MOVLB  00
056F:  CALL   043
0570:  MOVLB  02
0571:  MOVWF  2D
0572:  MOVF   7A,W
0573:  MOVWF  2E
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
0574:  DECFSZ 2B,W
0575:  GOTO   5A6
0576:  RLF    2C,W
0577:  MOVWF  77
0578:  RLF    77,F
0579:  MOVLW  FC
057A:  ANDWF  77,F
057B:  MOVF   77,W
057C:  ADDLW  03
057D:  MOVLB  00
057E:  CALL   043
057F:  MOVWF  78
0580:  BTFSC  78.0
0581:  GOTO   584
0582:  MOVLB  02
0583:  GOTO   5A6
....................       eeprom_val=read_eeprom(eeprom_index); 
0584:  MOVLB  02
0585:  MOVF   30,W
0586:  MOVLB  03
0587:  MOVWF  11
0588:  BCF    15.7
0589:  BSF    15.0
058A:  MOVF   13,W
058B:  MOVLB  02
058C:  MOVWF  33
....................       *regPtr=eeprom_val; 
058D:  MOVF   2D,W
058E:  MOVWF  04
058F:  MOVF   2E,W
0590:  MOVWF  05
0591:  MOVF   33,W
0592:  MOVWF  00
....................       update_checksum(&cksum,*regPtr);     
0593:  MOVF   2E,W
0594:  MOVWF  7A
0595:  MOVF   2D,W
0596:  MOVWF  04
0597:  MOVF   2E,W
0598:  MOVWF  05
0599:  MOVF   00,W
059A:  MOVWF  34
059B:  MOVLW  20
059C:  MOVWF  36
059D:  MOVLW  AF
059E:  MOVWF  35
059F:  MOVF   34,W
05A0:  MOVWF  37
05A1:  MOVLB  00
05A2:  CALL   52C
....................       eeprom_index++; 
05A3:  MOVLB  02
05A4:  INCF   30,F
....................     } else { 
05A5:  GOTO   5B8
....................       default_value=(int8)RegMap[x].default_value; 
05A6:  RLF    2C,W
05A7:  MOVWF  77
05A8:  RLF    77,F
05A9:  MOVLW  FC
05AA:  ANDWF  77,F
05AB:  MOVF   77,W
05AC:  ADDLW  02
05AD:  MOVLB  00
05AE:  CALL   043
05AF:  MOVWF  78
05B0:  MOVLB  02
05B1:  MOVWF  31
....................       *regPtr=default_value; 
05B2:  MOVF   2D,W
05B3:  MOVWF  04
05B4:  MOVF   2E,W
05B5:  MOVWF  05
05B6:  MOVF   31,W
05B7:  MOVWF  00
....................     } 
....................   } 
05B8:  INCF   2C,F
05B9:  GOTO   55D
....................   if ( source == USE_EEPROM_VARS ) { 
05BA:  DECFSZ 2B,W
05BB:  GOTO   5C6
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
05BC:  MOVF   30,W
05BD:  MOVLB  03
05BE:  MOVWF  11
05BF:  BCF    15.7
05C0:  BSF    15.0
05C1:  MOVF   13,W
05C2:  MOVLB  02
05C3:  SUBWF  2F,W
05C4:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
05C5:  CLRF   32
....................     } 
....................   } 
....................   return (retVal); 
05C6:  MOVF   32,W
05C7:  MOVWF  78
.................... } // }}} 
05C8:  MOVLB  00
05C9:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
05CA:  MOVLW  01
05CB:  MOVLB  02
05CC:  MOVWF  2F
....................  
....................   eeprom_index=0; 
05CD:  CLRF   2C
....................   for(x=0;x<RegMapNum;x++) { 
05CE:  CLRF   2B
05CF:  MOVF   2B,W
05D0:  SUBLW  38
05D1:  BTFSS  03.0
05D2:  GOTO   628
....................     regPtr=RegMap[x].reg_ptr; 
05D3:  RLF    2B,W
05D4:  MOVWF  77
05D5:  RLF    77,F
05D6:  MOVLW  FC
05D7:  ANDWF  77,F
05D8:  MOVF   77,W
05D9:  MOVWF  31
05DA:  INCF   31,W
05DB:  MOVLB  00
05DC:  CALL   043
05DD:  MOVWF  7A
05DE:  MOVLB  02
05DF:  MOVF   31,W
05E0:  MOVLB  00
05E1:  CALL   043
05E2:  MOVLB  02
05E3:  MOVWF  2D
05E4:  MOVF   7A,W
05E5:  MOVWF  2E
....................     if ( RegMap[x].non_volatile ) { 
05E6:  RLF    2B,W
05E7:  MOVWF  77
05E8:  RLF    77,F
05E9:  MOVLW  FC
05EA:  ANDWF  77,F
05EB:  MOVF   77,W
05EC:  ADDLW  03
05ED:  MOVLB  00
05EE:  CALL   043
05EF:  MOVWF  78
05F0:  BTFSS  78.0
05F1:  GOTO   625
....................      value=*regPtr; 
05F2:  MOVLB  02
05F3:  MOVF   2D,W
05F4:  MOVWF  04
05F5:  MOVF   2E,W
05F6:  MOVWF  05
05F7:  MOVF   00,W
05F8:  MOVWF  30
....................      if ( read_eeprom(eeprom_index) != value ) { 
05F9:  MOVF   2C,W
05FA:  MOVLB  03
05FB:  MOVWF  11
05FC:  BCF    15.7
05FD:  BSF    15.0
05FE:  MOVF   13,W
05FF:  MOVLB  02
0600:  SUBWF  30,W
0601:  BTFSC  03.2
0602:  GOTO   61A
....................        write_eeprom(eeprom_index,value); 
0603:  MOVF   0B,W
0604:  MOVWF  77
0605:  BCF    0B.7
0606:  MOVF   2C,W
0607:  MOVLB  03
0608:  MOVWF  11
0609:  MOVLB  02
060A:  MOVF   30,W
060B:  MOVLB  03
060C:  MOVWF  13
060D:  BCF    15.7
060E:  BSF    15.2
060F:  MOVLW  55
0610:  MOVWF  16
0611:  MOVLW  AA
0612:  MOVWF  16
0613:  BSF    15.1
0614:  BTFSC  15.1
0615:  GOTO   614
0616:  BCF    15.2
0617:  MOVF   77,W
0618:  IORWF  0B,F
0619:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
061A:  MOVLW  20
061B:  MOVWF  36
061C:  MOVLW  AF
061D:  MOVWF  35
061E:  MOVF   30,W
061F:  MOVWF  37
0620:  MOVLB  00
0621:  CALL   52C
....................      eeprom_index++; 
0622:  MOVLB  02
0623:  INCF   2C,F
0624:  MOVLB  00
....................     } 
....................   } 
0625:  MOVLB  02
0626:  INCF   2B,F
0627:  GOTO   5CF
....................   write_eeprom(eeprom_index,cksum); 
0628:  MOVF   0B,W
0629:  MOVWF  77
062A:  BCF    0B.7
062B:  MOVF   2C,W
062C:  MOVLB  03
062D:  MOVWF  11
062E:  MOVLB  02
062F:  MOVF   2F,W
0630:  MOVLB  03
0631:  MOVWF  13
0632:  BCF    15.7
0633:  BSF    15.2
0634:  MOVLW  55
0635:  MOVWF  16
0636:  MOVLW  AA
0637:  MOVWF  16
0638:  BSF    15.1
0639:  BTFSC  15.1
063A:  GOTO   639
063B:  BCF    15.2
063C:  MOVF   77,W
063D:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
063E:  MOVLW  72
063F:  MOVWF  11
0640:  MOVLW  04
0641:  MOVWF  12
0642:  MOVLB  00
0643:  CALL   4D7
.................... } // }}} 
0644:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
0645:  MOVLB  02
0646:  MOVF   2A,W
0647:  MOVWF  2B
0648:  MOVLB  00
0649:  CALL   544
064A:  MOVF   78,F
064B:  BTFSS  03.2
064C:  GOTO   659
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
064D:  MOVLW  85
064E:  MOVLB  03
064F:  MOVWF  11
0650:  MOVLW  04
0651:  MOVWF  12
0652:  MOVLB  00
0653:  CALL   4D7
....................         _init_variables(USE_DEFAULT_VARS); 
0654:  MOVLB  02
0655:  CLRF   2B
0656:  MOVLB  00
0657:  CALL   544
....................     store_variables(); 
0658:  CALL   5CA
....................     } 
.................... } // }}} 
0659:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0D3C:  MOVLB  02
0D3D:  CLRF   3C
0D3E:  CLRF   3D
0D3F:  MOVLP  00
0D40:  MOVLB  00
0D41:  CALL   78B
0D42:  MOVLP  08
....................   set_trimpot(1,0); 
0D43:  MOVLW  01
0D44:  MOVLB  02
0D45:  MOVWF  3C
0D46:  CLRF   3D
0D47:  MOVLP  00
0D48:  MOVLB  00
0D49:  CALL   78B
0D4A:  MOVLP  08
....................   set_trimpot(2,0); 
0D4B:  MOVLW  02
0D4C:  MOVLB  02
0D4D:  MOVWF  3C
0D4E:  CLRF   3D
0D4F:  MOVLP  00
0D50:  MOVLB  00
0D51:  CALL   78B
0D52:  MOVLP  08
....................   set_trimpot(3,0); 
0D53:  MOVLW  03
0D54:  MOVLB  02
0D55:  MOVWF  3C
0D56:  CLRF   3D
0D57:  MOVLP  00
0D58:  MOVLB  00
0D59:  CALL   78B
0D5A:  MOVLP  08
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0CC0:  MOVLP  00
0CC1:  CALL   4BD
0CC2:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0CC3:  MOVLB  02
0CC4:  CLRF   12
0CC5:  CLRF   11
0CC6:  CLRF   14
0CC7:  CLRF   13
....................   setup_wdt(WDT_2S); 
0CC8:  MOVLW  17
0CC9:  MOVLB  01
0CCA:  MOVWF  17
....................   COR_IN=0; 
0CCB:  MOVLB  00
0CCC:  CLRF   5F
....................   COR_EMUL=0; 
0CCD:  CLRF   6A
....................   COR_AUX=0; 
0CCE:  CLRF   6B
....................   COR_DROP_FLAG=0; 
0CCF:  BCF    74.5
....................   DTMF_IN_FLAG=0; 
0CD0:  MOVLB  01
0CD1:  BCF    60.0
....................   DTMF_INTERRUPT_FLAG=0; 
0CD2:  BCF    60.1
....................   TOT_FLAG_Mask=0; 
0CD3:  MOVLB  00
0CD4:  CLRF   67
....................   LastRegisterIndexValid=0; 
0CD5:  MOVLB  01
0CD6:  CLRF   5B
....................   LastRegisterIndex=0; 
0CD7:  CLRF   7E
....................   CurrentCorMask=0; 
0CD8:  MOVLB  00
0CD9:  CLRF   6E
....................   CurrentCorPriority=0; 
0CDA:  CLRF   71
....................   CurrentCorIndex=0; 
0CDB:  CLRF   6F
....................   CurrentTrimPot=0; 
0CDC:  CLRF   76
....................   setup_adc(NO_ANALOGS); 
0CDD:  MOVLB  01
0CDE:  BCF    1D.0
....................   set_tris_b(0xFF); 
0CDF:  MOVLW  FF
0CE0:  TRIS   6
....................   set_tris_d(0x00); 
0CE1:  MOVLW  00
0CE2:  MOVWF  0F
....................   set_tris_e(0xF8); 
0CE3:  BCF    10.0
0CE4:  BCF    10.1
0CE5:  BCF    10.2
0CE6:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0CE7:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0CE8:  BSF    0B.3
0CE9:  MOVLW  CF
0CEA:  MOVLB  07
0CEB:  IORWF  14,F
0CEC:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0CED:  BSF    0B.3
0CEE:  BSF    15.4
0CEF:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0CF0:  MOVLW  C0
0CF1:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0CF2:  MOVLB  02
0CF3:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0CF4:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0CF5:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0CF6:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0CF7:  MOVLW  01
0CF8:  MOVWF  2A
0CF9:  MOVLP  00
0CFA:  MOVLB  00
0CFB:  CALL   645
0CFC:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D28:  MOVLB  01
0D29:  BSF    60.2
....................   Enable_Mask = 0x0F; 
0D2A:  MOVLW  0F
0D2B:  MOVLB  00
0D2C:  MOVWF  61
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D2D:  MOVF   62,W
0D2E:  ANDLW  0F
0D2F:  IORLW  C0
0D30:  MOVLB  04
0D31:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D32:  MOVLB  01
0D33:  BCF    15.7
....................   // }}} 
....................   header(); 
0D34:  MOVLP  00
0D35:  MOVLB  00
0D36:  CALL   003
0D37:  MOVLP  08
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D38:  MOVLW  9D
0D39:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0D3A:  MOVLW  80
0D3B:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0D5B:  MOVLB  01
0D5C:  CLRF   31
0D5D:  MOVLW  1E
0D5E:  MOVWF  30
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0D5F:  MOVF   15,W
0D60:  ANDLW  C0
0D61:  IORLW  07
0D62:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0D63:  BSF    0B.5
....................   update_ptt(0); 
0D64:  MOVLB  02
0D65:  CLRF   2B
0D66:  MOVLB  00
0D67:  CALL   360
....................   MinuteCounter=MIN_COUNTER; 
0D68:  MOVLW  1D
0D69:  MOVLB  01
0D6A:  MOVWF  5D
....................   SecondCounter=SEC_COUNTER; 
0D6B:  MOVLW  3B
0D6C:  MOVWF  5C
....................   THIRTY_MIN_FLAG=0; 
0D6D:  BCF    74.4
....................   MINUTE_FLAG=0; 
0D6E:  BCF    74.3
....................   PROMPT_FLAG=1; 
0D6F:  BSF    60.3
....................   TailChar=Tail; 
0D70:  MOVLB  00
0D71:  MOVF   65,W
0D72:  MOVWF  6C
....................   ConfirmChar=0; 
0D73:  CLRF   6D
....................   //AuxOut[0] = PO_AUX_OUT0; 
....................   //AuxOut[1] = PO_AUX_OUT1; 
....................   //AuxOut[2] = PO_AUX_OUT2; 
....................   AuxInSW[0] = 0; 
0D74:  CLRF   3F
....................   AuxInSW[1] = 0; 
0D75:  CLRF   40
....................   AuxInSW[2] = 0; 
0D76:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0D77:  BCF    74.6
....................   COR_IN_EFFECTIVE=0; 
0D78:  CLRF   72
....................   set_admin_mode(0); 
0D79:  MOVLB  02
0D7A:  CLRF   3D
0D7B:  MOVLB  00
0D7C:  CALL   4A9
....................   rs232_mode=0; 
0D7D:  MOVLB  01
0D7E:  BCF    60.5
.................... #ifdef LCD_TYPE_PI 
....................   init_lcd(); 
.................... #endif 
.................... } // }}} 
0D7F:  MOVLP  18
0D80:  MOVLB  00
0D81:  GOTO   6B5 (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180D:  MOVLB  02
180E:  BCF    25.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
180F:  CLRF   3C
1810:  CLRF   3D
1811:  MOVLW  20
1812:  MOVWF  05
1813:  MOVLW  A8
1814:  MOVWF  04
1815:  MOVF   3C,W
1816:  ADDWF  04,F
1817:  MOVLW  00
1818:  ADDWFC 05,F
1819:  MOVF   3D,W
181A:  MOVLP  00
181B:  MOVLB  00
181C:  CALL   140
181D:  MOVLP  18
181E:  MOVWF  00
181F:  IORLW  00
1820:  BTFSC  03.2
1821:  GOTO   027
1822:  MOVLB  02
1823:  INCF   3D,F
1824:  INCF   3C,F
1825:  GOTO   011
1826:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1827:  MOVLW  20
1828:  MOVLB  02
1829:  MOVWF  3D
182A:  MOVLW  50
182B:  MOVWF  3C
182C:  MOVLW  20
182D:  MOVWF  3F
182E:  MOVLW  A8
182F:  MOVWF  3E
1830:  MOVLP  08
1831:  MOVLB  00
1832:  CALL   582
1833:  MOVLP  18
1834:  MOVF   79,W
1835:  MOVLB  02
1836:  MOVWF  27
1837:  MOVF   78,W
1838:  MOVWF  26
....................   if (sptr!=0) {; 
1839:  MOVF   26,F
183A:  BTFSS  03.2
183B:  GOTO   03F
183C:  MOVF   27,F
183D:  BTFSC  03.2
183E:  GOTO   059
....................     strcpy(verb,sptr); 
183F:  MOVF   27,W
1840:  MOVWF  3F
1841:  MOVF   26,W
1842:  MOVWF  3E
1843:  MOVLW  20
1844:  MOVWF  3D
1845:  MOVLW  9D
1846:  MOVWF  3C
1847:  MOVF   3F,W
1848:  MOVWF  05
1849:  MOVF   3E,W
184A:  MOVWF  04
184B:  MOVF   00,W
184C:  MOVWF  40
184D:  MOVF   3D,W
184E:  MOVWF  05
184F:  MOVF   3C,W
1850:  MOVWF  04
1851:  MOVF   40,W
1852:  MOVWF  00
1853:  MOVF   00,F
1854:  BTFSC  03.2
1855:  GOTO   059
1856:  INCF   3C,F
1857:  INCF   3E,F
1858:  GOTO   047
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
1859:  CLRF   3D
185A:  CLRF   3C
185B:  MOVLW  20
185C:  MOVWF  3F
185D:  MOVLW  A8
185E:  MOVWF  3E
185F:  MOVLP  08
1860:  MOVLB  00
1861:  CALL   582
1862:  MOVLP  18
1863:  MOVF   79,W
1864:  MOVLB  02
1865:  MOVWF  27
1866:  MOVF   78,W
1867:  MOVWF  26
....................   if (sptr!=0) {; 
1868:  MOVF   26,F
1869:  BTFSS  03.2
186A:  GOTO   06E
186B:  MOVF   27,F
186C:  BTFSC  03.2
186D:  GOTO   088
....................     strcpy(argument_name,sptr); 
186E:  MOVF   27,W
186F:  MOVWF  3F
1870:  MOVF   26,W
1871:  MOVWF  3E
1872:  MOVLW  20
1873:  MOVWF  3D
1874:  MOVLW  70
1875:  MOVWF  3C
1876:  MOVF   3F,W
1877:  MOVWF  05
1878:  MOVF   3E,W
1879:  MOVWF  04
187A:  MOVF   00,W
187B:  MOVWF  40
187C:  MOVF   3D,W
187D:  MOVWF  05
187E:  MOVF   3C,W
187F:  MOVWF  04
1880:  MOVF   40,W
1881:  MOVWF  00
1882:  MOVF   00,F
1883:  BTFSC  03.2
1884:  GOTO   088
1885:  INCF   3C,F
1886:  INCF   3E,F
1887:  GOTO   076
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1888:  CLRF   3D
1889:  CLRF   3C
188A:  MOVLW  20
188B:  MOVWF  3F
188C:  MOVLW  A8
188D:  MOVWF  3E
188E:  MOVLP  08
188F:  MOVLB  00
1890:  CALL   582
1891:  MOVLP  18
1892:  MOVF   79,W
1893:  MOVLB  02
1894:  MOVWF  27
1895:  MOVF   78,W
1896:  MOVWF  26
....................   if (sptr!=0) {; 
1897:  MOVF   26,F
1898:  BTFSS  03.2
1899:  GOTO   09D
189A:  MOVF   27,F
189B:  BTFSC  03.2
189C:  GOTO   0C3
....................     strcpy(match_val,sptr); 
189D:  MOVF   27,W
189E:  MOVWF  3F
189F:  MOVF   26,W
18A0:  MOVWF  3E
18A1:  MOVLW  20
18A2:  MOVWF  3D
18A3:  MOVLW  B0
18A4:  MOVWF  3C
18A5:  MOVF   3F,W
18A6:  MOVWF  05
18A7:  MOVF   3E,W
18A8:  MOVWF  04
18A9:  MOVF   00,W
18AA:  MOVWF  40
18AB:  MOVF   3D,W
18AC:  MOVWF  05
18AD:  MOVF   3C,W
18AE:  MOVWF  04
18AF:  MOVF   40,W
18B0:  MOVWF  00
18B1:  MOVF   00,F
18B2:  BTFSC  03.2
18B3:  GOTO   0B7
18B4:  INCF   3C,F
18B5:  INCF   3E,F
18B6:  GOTO   0A5
....................     value = str_to_decimal(match_val); 
18B7:  MOVLW  20
18B8:  MOVWF  3D
18B9:  MOVLW  B0
18BA:  MOVWF  3C
18BB:  MOVLP  08
18BC:  MOVLB  00
18BD:  CALL   688
18BE:  MOVLP  18
18BF:  MOVF   78,W
18C0:  MOVWF  7D
....................   } else { 
18C1:  GOTO   0C6
18C2:  MOVLB  02
....................     value = 0; 
18C3:  CLRF   7D
....................     do_get_var = 1; 
18C4:  BSF    25.0
18C5:  MOVLB  00
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18C6:  MOVLB  02
18C7:  CLRF   3C
18C8:  CLRF   3D
18C9:  MOVLW  20
18CA:  MOVWF  05
18CB:  MOVLW  B4
18CC:  MOVWF  04
18CD:  MOVF   3C,W
18CE:  ADDWF  04,F
18CF:  MOVLW  00
18D0:  ADDWFC 05,F
18D1:  MOVF   3D,W
18D2:  MOVLP  00
18D3:  MOVLB  00
18D4:  CALL   146
18D5:  MOVLP  18
18D6:  MOVWF  00
18D7:  IORLW  00
18D8:  BTFSC  03.2
18D9:  GOTO   0DF
18DA:  MOVLB  02
18DB:  INCF   3D,F
18DC:  INCF   3C,F
18DD:  GOTO   0C9
18DE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
18DF:  MOVLW  20
18E0:  MOVLB  02
18E1:  MOVWF  3D
18E2:  MOVLW  B4
18E3:  MOVWF  3C
18E4:  MOVLW  20
18E5:  MOVWF  3F
18E6:  MOVLW  9D
18E7:  MOVWF  3E
18E8:  MOVLP  08
18E9:  MOVLB  00
18EA:  CALL   6C1
18EB:  MOVLP  18
18EC:  MOVF   78,F
18ED:  BTFSS  03.2
18EE:  GOTO   0F8
....................     if ( do_get_var ) { 
18EF:  MOVLB  02
18F0:  BTFSS  25.0
18F1:  GOTO   0F5
....................       command=GET_REG; 
18F2:  MOVLW  03
18F3:  MOVWF  70
....................     } else { 
18F4:  GOTO   0F7
....................       command=SET_REG; 
18F5:  MOVLW  02
18F6:  MOVWF  70
18F7:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18F8:  MOVLB  02
18F9:  CLRF   3C
18FA:  CLRF   3D
18FB:  MOVLW  20
18FC:  MOVWF  05
18FD:  MOVLW  B4
18FE:  MOVWF  04
18FF:  MOVF   3C,W
1900:  ADDWF  04,F
1901:  MOVLW  00
1902:  ADDWFC 05,F
1903:  MOVF   3D,W
1904:  MOVLP  00
1905:  MOVLB  00
1906:  CALL   14B
1907:  MOVLP  18
1908:  MOVWF  00
1909:  IORLW  00
190A:  BTFSC  03.2
190B:  GOTO   111
190C:  MOVLB  02
190D:  INCF   3D,F
190E:  INCF   3C,F
190F:  GOTO   0FB
1910:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1911:  MOVLW  20
1912:  MOVLB  02
1913:  MOVWF  3D
1914:  MOVLW  B4
1915:  MOVWF  3C
1916:  MOVLW  20
1917:  MOVWF  3F
1918:  MOVLW  9D
1919:  MOVWF  3E
191A:  MOVLP  08
191B:  MOVLB  00
191C:  CALL   6C1
191D:  MOVLP  18
191E:  MOVF   78,F
191F:  BTFSS  03.2
1920:  GOTO   123
....................       command=SAVE_SETTINGS; 
1921:  MOVLW  04
1922:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1923:  MOVLB  02
1924:  CLRF   3C
1925:  CLRF   3D
1926:  MOVLW  20
1927:  MOVWF  05
1928:  MOVLW  B4
1929:  MOVWF  04
192A:  MOVF   3C,W
192B:  ADDWF  04,F
192C:  MOVLW  00
192D:  ADDWFC 05,F
192E:  MOVF   3D,W
192F:  MOVLP  00
1930:  MOVLB  00
1931:  CALL   151
1932:  MOVLP  18
1933:  MOVWF  00
1934:  IORLW  00
1935:  BTFSC  03.2
1936:  GOTO   13C
1937:  MOVLB  02
1938:  INCF   3D,F
1939:  INCF   3C,F
193A:  GOTO   126
193B:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
193C:  MOVLW  20
193D:  MOVLB  02
193E:  MOVWF  3D
193F:  MOVLW  B4
1940:  MOVWF  3C
1941:  MOVLW  20
1942:  MOVWF  3F
1943:  MOVLW  9D
1944:  MOVWF  3E
1945:  MOVLP  08
1946:  MOVLB  00
1947:  CALL   6C1
1948:  MOVLP  18
1949:  MOVF   78,F
194A:  BTFSS  03.2
194B:  GOTO   14E
....................       command=RESTORE_SETTINGS; 
194C:  MOVLW  05
194D:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
194E:  MOVLB  02
194F:  CLRF   3C
1950:  CLRF   3D
1951:  MOVLW  20
1952:  MOVWF  05
1953:  MOVLW  B4
1954:  MOVWF  04
1955:  MOVF   3C,W
1956:  ADDWF  04,F
1957:  MOVLW  00
1958:  ADDWFC 05,F
1959:  MOVF   3D,W
195A:  MOVLP  00
195B:  MOVLB  00
195C:  CALL   15A
195D:  MOVLP  18
195E:  MOVWF  00
195F:  IORLW  00
1960:  BTFSC  03.2
1961:  GOTO   167
1962:  MOVLB  02
1963:  INCF   3D,F
1964:  INCF   3C,F
1965:  GOTO   151
1966:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1967:  MOVLW  20
1968:  MOVLB  02
1969:  MOVWF  3D
196A:  MOVLW  B4
196B:  MOVWF  3C
196C:  MOVLW  20
196D:  MOVWF  3F
196E:  MOVLW  9D
196F:  MOVWF  3E
1970:  MOVLP  08
1971:  MOVLB  00
1972:  CALL   6C1
1973:  MOVLP  18
1974:  MOVF   78,F
1975:  BTFSS  03.2
1976:  GOTO   179
....................     command=STATUS; 
1977:  MOVLW  08
1978:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
1979:  MOVLB  02
197A:  CLRF   3C
197B:  CLRF   3D
197C:  MOVLW  20
197D:  MOVWF  05
197E:  MOVLW  B4
197F:  MOVWF  04
1980:  MOVF   3C,W
1981:  ADDWF  04,F
1982:  MOVLW  00
1983:  ADDWFC 05,F
1984:  MOVF   3D,W
1985:  MOVLP  00
1986:  MOVLB  00
1987:  CALL   162
1988:  MOVLP  18
1989:  MOVWF  00
198A:  IORLW  00
198B:  BTFSC  03.2
198C:  GOTO   192
198D:  MOVLB  02
198E:  INCF   3D,F
198F:  INCF   3C,F
1990:  GOTO   17C
1991:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1992:  MOVLW  20
1993:  MOVLB  02
1994:  MOVWF  3D
1995:  MOVLW  B4
1996:  MOVWF  3C
1997:  MOVLW  20
1998:  MOVWF  3F
1999:  MOVLW  9D
199A:  MOVWF  3E
199B:  MOVLP  08
199C:  MOVLB  00
199D:  CALL   6C1
199E:  MOVLP  18
199F:  MOVF   78,F
19A0:  BTFSS  03.2
19A1:  GOTO   1A6
....................     command=ADMIN; 
19A2:  MOVLW  09
19A3:  MOVWF  70
....................     argument=REBOOT; 
19A4:  MOVLW  02
19A5:  MOVWF  7C
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19A6:  MOVLB  02
19A7:  CLRF   3C
19A8:  CLRF   3D
19A9:  MOVLW  20
19AA:  MOVWF  05
19AB:  MOVLW  B4
19AC:  MOVWF  04
19AD:  MOVF   3C,W
19AE:  ADDWF  04,F
19AF:  MOVLW  00
19B0:  ADDWFC 05,F
19B1:  MOVF   3D,W
19B2:  MOVLP  00
19B3:  MOVLB  00
19B4:  CALL   16A
19B5:  MOVLP  18
19B6:  MOVWF  00
19B7:  IORLW  00
19B8:  BTFSC  03.2
19B9:  GOTO   1BF
19BA:  MOVLB  02
19BB:  INCF   3D,F
19BC:  INCF   3C,F
19BD:  GOTO   1A9
19BE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19BF:  MOVLW  20
19C0:  MOVLB  02
19C1:  MOVWF  3D
19C2:  MOVLW  B4
19C3:  MOVWF  3C
19C4:  MOVLW  20
19C5:  MOVWF  3F
19C6:  MOVLW  9D
19C7:  MOVWF  3E
19C8:  MOVLP  08
19C9:  MOVLB  00
19CA:  CALL   6C1
19CB:  MOVLP  18
19CC:  MOVF   78,F
19CD:  BTFSS  03.2
19CE:  GOTO   220
....................     //command=DTMF_SEND; 
....................     command=0; 
19CF:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D0:  MOVLW  20
19D1:  MOVLB  02
19D2:  MOVWF  3D
19D3:  MOVLW  70
19D4:  MOVWF  3C
19D5:  MOVLP  08
19D6:  MOVLB  00
19D7:  CALL   688
19D8:  MOVLP  18
19D9:  MOVF   78,W
19DA:  MOVWF  7D
....................     if ( value == d0 ) { 
19DB:  MOVF   7D,W
19DC:  SUBLW  0A
19DD:  BTFSS  03.2
19DE:  GOTO   1E1
....................       value = dd; 
19DF:  CLRF   7D
....................     } else if (value == dd) { 
19E0:  GOTO   1E6
19E1:  MOVF   7D,F
19E2:  BTFSS  03.2
19E3:  GOTO   1E6
....................       value = d0; 
19E4:  MOVLW  0A
19E5:  MOVWF  7D
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19E6:  MOVF   7D,W
19E7:  ANDLW  0F
19E8:  MOVLB  02
19E9:  MOVWF  3C
19EA:  MOVF   3C,W
19EB:  MOVWF  3D
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A20:  MOVLB  02
1A21:  CLRF   3C
1A22:  CLRF   3D
1A23:  MOVLW  20
1A24:  MOVWF  05
1A25:  MOVLW  B4
1A26:  MOVWF  04
1A27:  MOVF   3C,W
1A28:  ADDWF  04,F
1A29:  MOVLW  00
1A2A:  ADDWFC 05,F
1A2B:  MOVF   3D,W
1A2C:  MOVLP  00
1A2D:  MOVLB  00
1A2E:  CALL   16D
1A2F:  MOVLP  18
1A30:  MOVWF  00
1A31:  IORLW  00
1A32:  BTFSC  03.2
1A33:  GOTO   239
1A34:  MOVLB  02
1A35:  INCF   3D,F
1A36:  INCF   3C,F
1A37:  GOTO   223
1A38:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A39:  MOVLW  20
1A3A:  MOVLB  02
1A3B:  MOVWF  3D
1A3C:  MOVLW  B4
1A3D:  MOVWF  3C
1A3E:  MOVLW  20
1A3F:  MOVWF  3F
1A40:  MOVLW  9D
1A41:  MOVWF  3E
1A42:  MOVLP  08
1A43:  MOVLB  00
1A44:  CALL   6C1
1A45:  MOVLP  18
1A46:  MOVF   78,F
1A47:  BTFSS  03.2
1A48:  GOTO   24B
....................     command=I2C_SEND; 
1A49:  MOVLW  0C
1A4A:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A4B:  MOVLB  02
1A4C:  CLRF   3C
1A4D:  CLRF   3D
1A4E:  MOVLW  20
1A4F:  MOVWF  05
1A50:  MOVLW  B4
1A51:  MOVWF  04
1A52:  MOVF   3C,W
1A53:  ADDWF  04,F
1A54:  MOVLW  00
1A55:  ADDWFC 05,F
1A56:  MOVF   3D,W
1A57:  MOVLP  00
1A58:  MOVLB  00
1A59:  CALL   172
1A5A:  MOVLP  18
1A5B:  MOVWF  00
1A5C:  IORLW  00
1A5D:  BTFSC  03.2
1A5E:  GOTO   264
1A5F:  MOVLB  02
1A60:  INCF   3D,F
1A61:  INCF   3C,F
1A62:  GOTO   24E
1A63:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A64:  MOVLW  20
1A65:  MOVLB  02
1A66:  MOVWF  3D
1A67:  MOVLW  B4
1A68:  MOVWF  3C
1A69:  MOVLW  20
1A6A:  MOVWF  3F
1A6B:  MOVLW  9D
1A6C:  MOVWF  3E
1A6D:  MOVLP  08
1A6E:  MOVLB  00
1A6F:  CALL   6C1
1A70:  MOVLP  18
1A71:  MOVF   78,F
1A72:  BTFSS  03.2
1A73:  GOTO   28B
....................     value = str_to_decimal(argument_name); 
1A74:  MOVLW  20
1A75:  MOVLB  02
1A76:  MOVWF  3D
1A77:  MOVLW  70
1A78:  MOVWF  3C
1A79:  MOVLP  08
1A7A:  MOVLB  00
1A7B:  CALL   688
1A7C:  MOVLP  18
1A7D:  MOVF   78,W
1A7E:  MOVWF  7D
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A7F:  MOVF   7D,W
1A80:  SUBLW  24
1A81:  BTFSS  03.0
1A82:  GOTO   287
....................       argument = 0; 
1A83:  CLRF   7C
....................       command  = MORSE_SEND; 
1A84:  MOVLW  0B
1A85:  MOVWF  70
....................     } else { 
1A86:  GOTO   28B
....................       command  = ADMIN; 
1A87:  MOVLW  09
1A88:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A89:  MOVLW  03
1A8A:  MOVWF  7C
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A8B:  MOVLB  02
1A8C:  CLRF   3C
1A8D:  CLRF   3D
1A8E:  MOVLW  20
1A8F:  MOVWF  05
1A90:  MOVLW  B4
1A91:  MOVWF  04
1A92:  MOVF   3C,W
1A93:  ADDWF  04,F
1A94:  MOVLW  00
1A95:  ADDWFC 05,F
1A96:  MOVF   3D,W
1A97:  MOVLP  00
1A98:  MOVLB  00
1A99:  CALL   179
1A9A:  MOVLP  18
1A9B:  MOVWF  00
1A9C:  IORLW  00
1A9D:  BTFSC  03.2
1A9E:  GOTO   2A4
1A9F:  MOVLB  02
1AA0:  INCF   3D,F
1AA1:  INCF   3C,F
1AA2:  GOTO   28E
1AA3:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AA4:  MOVLW  20
1AA5:  MOVLB  02
1AA6:  MOVWF  3D
1AA7:  MOVLW  B4
1AA8:  MOVWF  3C
1AA9:  MOVLW  20
1AAA:  MOVWF  3F
1AAB:  MOVLW  9D
1AAC:  MOVWF  3E
1AAD:  MOVLP  08
1AAE:  MOVLB  00
1AAF:  CALL   6C1
1AB0:  MOVLP  18
1AB1:  MOVF   78,F
1AB2:  BTFSS  03.2
1AB3:  GOTO   2B6
....................     command=INCREMENT_REG; 
1AB4:  MOVLW  06
1AB5:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1AB6:  MOVLB  02
1AB7:  CLRF   3C
1AB8:  CLRF   3D
1AB9:  MOVLW  20
1ABA:  MOVWF  05
1ABB:  MOVLW  B4
1ABC:  MOVWF  04
1ABD:  MOVF   3C,W
1ABE:  ADDWF  04,F
1ABF:  MOVLW  00
1AC0:  ADDWFC 05,F
1AC1:  MOVF   3D,W
1AC2:  MOVLP  00
1AC3:  MOVLB  00
1AC4:  CALL   17C
1AC5:  MOVLP  18
1AC6:  MOVWF  00
1AC7:  IORLW  00
1AC8:  BTFSC  03.2
1AC9:  GOTO   2CF
1ACA:  MOVLB  02
1ACB:  INCF   3D,F
1ACC:  INCF   3C,F
1ACD:  GOTO   2B9
1ACE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1ACF:  MOVLW  20
1AD0:  MOVLB  02
1AD1:  MOVWF  3D
1AD2:  MOVLW  B4
1AD3:  MOVWF  3C
1AD4:  MOVLW  20
1AD5:  MOVWF  3F
1AD6:  MOVLW  9D
1AD7:  MOVWF  3E
1AD8:  MOVLP  08
1AD9:  MOVLB  00
1ADA:  CALL   6C1
1ADB:  MOVLP  18
1ADC:  MOVF   78,F
1ADD:  BTFSS  03.2
1ADE:  GOTO   2E1
....................     command=DECREMENT_REG; 
1ADF:  MOVLW  07
1AE0:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AE1:  MOVLB  02
1AE2:  CLRF   3C
1AE3:  CLRF   3D
1AE4:  MOVLW  20
1AE5:  MOVWF  05
1AE6:  MOVLW  B4
1AE7:  MOVWF  04
1AE8:  MOVF   3C,W
1AE9:  ADDWF  04,F
1AEA:  MOVLW  00
1AEB:  ADDWFC 05,F
1AEC:  MOVF   3D,W
1AED:  MOVLP  00
1AEE:  MOVLB  00
1AEF:  CALL   17F
1AF0:  MOVLP  18
1AF1:  MOVWF  00
1AF2:  IORLW  00
1AF3:  BTFSC  03.2
1AF4:  GOTO   2FA
1AF5:  MOVLB  02
1AF6:  INCF   3D,F
1AF7:  INCF   3C,F
1AF8:  GOTO   2E4
1AF9:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AFA:  MOVLW  20
1AFB:  MOVLB  02
1AFC:  MOVWF  3D
1AFD:  MOVLW  B4
1AFE:  MOVWF  3C
1AFF:  MOVLW  20
1B00:  MOVWF  3F
1B01:  MOVLW  9D
1B02:  MOVWF  3E
1B03:  MOVLP  08
1B04:  MOVLB  00
1B05:  CALL   6C1
1B06:  MOVLP  18
1B07:  MOVF   78,F
1B08:  BTFSS  03.2
1B09:  GOTO   329
....................     command=SET_REG; 
1B0A:  MOVLW  02
1B0B:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B0C:  MOVLW  01
1B0D:  ADDWF  76,W
1B0E:  ANDLW  03
1B0F:  MOVWF  7D
....................     strcpy(argument_name,"CPOT"); 
1B10:  MOVLB  02
1B11:  CLRF   3C
1B12:  CLRF   3D
1B13:  MOVLW  20
1B14:  MOVWF  05
1B15:  MOVLW  70
1B16:  MOVWF  04
1B17:  MOVF   3C,W
1B18:  ADDWF  04,F
1B19:  MOVLW  00
1B1A:  ADDWFC 05,F
1B1B:  MOVF   3D,W
1B1C:  MOVLP  00
1B1D:  MOVLB  00
1B1E:  CALL   182
1B1F:  MOVLP  18
1B20:  MOVWF  00
1B21:  IORLW  00
1B22:  BTFSC  03.2
1B23:  GOTO   329
1B24:  MOVLB  02
1B25:  INCF   3D,F
1B26:  INCF   3C,F
1B27:  GOTO   313
1B28:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B29:  MOVLB  02
1B2A:  CLRF   3C
1B2B:  CLRF   3D
1B2C:  MOVLW  20
1B2D:  MOVWF  05
1B2E:  MOVLW  B4
1B2F:  MOVWF  04
1B30:  MOVF   3C,W
1B31:  ADDWF  04,F
1B32:  MOVLW  00
1B33:  ADDWFC 05,F
1B34:  MOVF   3D,W
1B35:  MOVLP  00
1B36:  MOVLB  00
1B37:  CALL   188
1B38:  MOVLP  18
1B39:  MOVWF  00
1B3A:  IORLW  00
1B3B:  BTFSC  03.2
1B3C:  GOTO   342
1B3D:  MOVLB  02
1B3E:  INCF   3D,F
1B3F:  INCF   3C,F
1B40:  GOTO   32C
1B41:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B42:  MOVLW  20
1B43:  MOVLB  02
1B44:  MOVWF  3D
1B45:  MOVLW  B4
1B46:  MOVWF  3C
1B47:  MOVLW  20
1B48:  MOVWF  3F
1B49:  MOVLW  9D
1B4A:  MOVWF  3E
1B4B:  MOVLP  08
1B4C:  MOVLB  00
1B4D:  CALL   6C1
1B4E:  MOVLP  18
1B4F:  MOVF   78,F
1B50:  BTFSS  03.2
1B51:  GOTO   362
....................     AdminMode = ~AdminMode; 
1B52:  MOVLW  10
1B53:  MOVLB  01
1B54:  XORWF  60,F
....................     set_admin_mode(AdminMode); 
1B55:  MOVLW  00
1B56:  BTFSC  60.4
1B57:  MOVLW  01
1B58:  MOVLB  02
1B59:  MOVWF  3C
1B5A:  MOVWF  3D
1B5B:  MOVLP  08
1B5C:  MOVLB  00
1B5D:  CALL   4A9
1B5E:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B5F:  MOVLB  01
1B60:  BSF    60.3
1B61:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
10AD:  MOVF   7D,W
10AE:  SUBLW  FF
10AF:  BTFSS  03.2
10B0:  GOTO   0D7
....................     printf ("\n\r%s %u",argument,value); 
10B1:  MOVLW  0A
10B2:  CLRWDT
10B3:  BTFSS  11.4
10B4:  GOTO   0B2
10B5:  MOVLB  03
10B6:  MOVWF  1A
10B7:  MOVLW  0D
10B8:  CLRWDT
10B9:  MOVLB  00
10BA:  BTFSC  11.4
10BB:  GOTO   0BE
10BC:  MOVLB  03
10BD:  GOTO   0B8
10BE:  MOVLB  03
10BF:  MOVWF  1A
10C0:  CLRF   05
10C1:  MOVF   7C,W
10C2:  MOVWF  04
10C3:  MOVLP  08
10C4:  MOVLB  00
10C5:  CALL   256
10C6:  MOVLP  10
10C7:  MOVLW  20
10C8:  CLRWDT
10C9:  BTFSS  11.4
10CA:  GOTO   0C8
10CB:  MOVLB  03
10CC:  MOVWF  1A
10CD:  MOVF   7D,W
10CE:  MOVLB  02
10CF:  MOVWF  4D
10D0:  MOVLW  1B
10D1:  MOVWF  4E
10D2:  MOVLP  00
10D3:  MOVLB  00
10D4:  CALL   73C
10D5:  MOVLP  10
....................   } else { 
10D6:  GOTO   176
....................     pObj=RegMap[argument].reg_ptr; 
10D7:  RLF    7C,W
10D8:  MOVWF  77
10D9:  RLF    77,F
10DA:  MOVLW  FC
10DB:  ANDWF  77,F
10DC:  MOVF   77,W
10DD:  MOVLB  02
10DE:  MOVWF  2C
10DF:  INCF   2C,W
10E0:  MOVLP  00
10E1:  MOVLB  00
10E2:  CALL   043
10E3:  MOVLP  10
10E4:  MOVWF  7A
10E5:  MOVLB  02
10E6:  MOVF   2C,W
10E7:  MOVLP  00
10E8:  MOVLB  00
10E9:  CALL   043
10EA:  MOVLP  10
10EB:  MOVLB  02
10EC:  MOVWF  29
10ED:  MOVF   7A,W
10EE:  MOVWF  2A
....................     // Consider allowing some registers to be updated outside AdminMode. 
....................     // Example : AuxOut registers, Enable 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
10EF:  MOVLP  08
10F0:  MOVLB  00
10F1:  CALL   729
10F2:  MOVLP  10
10F3:  MOVF   78,F
10F4:  BTFSS  03.2
10F5:  GOTO   103
10F6:  RLF    7C,W
10F7:  MOVWF  77
10F8:  RLF    77,F
10F9:  MOVLW  FC
10FA:  ANDWF  77,F
10FB:  MOVF   77,W
10FC:  ADDLW  03
10FD:  MOVLP  00
10FE:  CALL   043
10FF:  MOVLP  10
1100:  MOVWF  78
1101:  BTFSC  78.1
1102:  GOTO   10B
....................       *pObj=value; 
1103:  MOVLB  02
1104:  MOVF   29,W
1105:  MOVWF  04
1106:  MOVF   2A,W
1107:  MOVWF  05
1108:  MOVF   7D,W
1109:  MOVWF  00
110A:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
110B:  MOVLB  02
110C:  MOVF   29,W
110D:  MOVWF  04
110E:  MOVF   2A,W
110F:  MOVWF  05
1110:  MOVF   00,W
1111:  MOVWF  2B
....................     LastRegisterIndex = argument; 
1112:  MOVF   7C,W
1113:  MOVWF  7E
....................     LastRegisterIndexValid=1; 
1114:  MOVLW  01
1115:  MOVLB  01
1116:  MOVWF  5B
....................     printf ("\n\rSetting %s(%u) to %u",argument_name,argument,lVar); 
1117:  MOVLW  9E
1118:  MOVLB  03
1119:  MOVWF  11
111A:  MOVLW  04
111B:  MOVWF  12
111C:  BCF    03.0
111D:  MOVLW  0A
111E:  MOVLB  02
111F:  MOVWF  4D
1120:  MOVLP  00
1121:  MOVLB  00
1122:  CALL   6C8
1123:  MOVLP  10
1124:  MOVLW  20
1125:  MOVWF  05
1126:  MOVLW  70
1127:  MOVWF  04
1128:  MOVLP  08
1129:  CALL   256
112A:  MOVLP  10
112B:  MOVLW  28
112C:  CLRWDT
112D:  BTFSS  11.4
112E:  GOTO   12C
112F:  MOVLB  03
1130:  MOVWF  1A
1131:  MOVF   7C,W
1132:  MOVLB  02
1133:  MOVWF  4D
1134:  MOVLW  1B
1135:  MOVWF  4E
1136:  MOVLP  00
1137:  MOVLB  00
1138:  CALL   73C
1139:  MOVLP  10
113A:  MOVLW  A5
113B:  MOVLB  03
113C:  MOVWF  11
113D:  MOVLW  04
113E:  MOVWF  12
113F:  BSF    03.0
1140:  MOVLW  05
1141:  MOVLB  02
1142:  MOVWF  4D
1143:  MOVLP  00
1144:  MOVLB  00
1145:  CALL   6C8
1146:  MOVLP  10
1147:  MOVLB  02
1148:  MOVF   2B,W
1149:  MOVWF  4D
114A:  MOVLW  1B
114B:  MOVWF  4E
114C:  MOVLP  00
114D:  MOVLB  00
114E:  CALL   73C
114F:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
1150:  MOVLB  02
1151:  MOVF   2A,W
1152:  SUBLW  1F
1153:  BTFSC  03.0
1154:  GOTO   166
1155:  XORLW  FF
1156:  BTFSS  03.2
1157:  GOTO   15C
1158:  MOVF   29,W
1159:  SUBLW  0B
115A:  BTFSC  03.0
115B:  GOTO   166
115C:  MOVF   2A,W
115D:  SUBLW  20
115E:  BTFSS  03.0
115F:  GOTO   166
1160:  BTFSS  03.2
1161:  GOTO   16D
1162:  MOVF   29,W
1163:  SUBLW  1B
1164:  BTFSC  03.0
1165:  GOTO   16D
1166:  MOVF   29,W
1167:  SUBLW  76
1168:  BTFSS  03.2
1169:  GOTO   173
116A:  MOVF   2A,F
116B:  BTFSS  03.2
116C:  GOTO   173
....................       increment(0); // Increment is done in this function. Only update trim pot. 
116D:  CLRF   2C
116E:  MOVLP  08
116F:  MOVLB  00
1170:  CALL   738
1171:  MOVLP  10
1172:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
1173:  MOVLB  01
1174:  BSF    60.3
1175:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
0F38:  MOVF   76,W
0F39:  ANDLW  03
0F3A:  MOVLB  02
0F3B:  MOVWF  30
....................   if ( CurrentCorIndex ) { 
0F3C:  MOVLB  00
0F3D:  MOVF   6F,F
0F3E:  BTFSC  03.2
0F3F:  GOTO   777
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
0F40:  MOVLW  01
0F41:  SUBWF  6F,W
0F42:  MOVWF  77
0F43:  RLF    77,F
0F44:  RLF    77,F
0F45:  MOVLW  FC
0F46:  ANDWF  77,F
0F47:  MOVF   77,W
0F48:  MOVLB  02
0F49:  ADDWF  30,W
0F4A:  ADDLW  0C
0F4B:  MOVWF  78
0F4C:  MOVLW  20
0F4D:  MOVWF  7A
0F4E:  BTFSC  03.0
0F4F:  INCF   7A,F
0F50:  MOVF   78,W
0F51:  MOVWF  2D
0F52:  MOVF   7A,W
0F53:  MOVWF  2E
....................     value = *pot_ptr; 
0F54:  MOVF   2D,W
0F55:  MOVWF  04
0F56:  MOVF   2E,W
0F57:  MOVWF  05
0F58:  MOVF   00,W
0F59:  MOVWF  2F
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
0F5A:  MOVF   2D,W
0F5B:  MOVWF  04
0F5C:  MOVF   2E,W
0F5D:  MOVWF  05
0F5E:  MOVF   2C,W
0F5F:  ADDWF  2F,W
0F60:  MOVWF  00
....................     if ( in_admin_mode() ) { 
0F61:  MOVLB  00
0F62:  CALL   729
0F63:  MOVF   78,F
0F64:  BTFSC  03.2
0F65:  GOTO   777
....................       set_trimpot(CPotPtr,*pot_ptr); 
0F66:  MOVLB  02
0F67:  MOVF   2E,W
0F68:  MOVWF  7A
0F69:  MOVF   2D,W
0F6A:  MOVWF  04
0F6B:  MOVF   2E,W
0F6C:  MOVWF  05
0F6D:  MOVF   00,W
0F6E:  MOVWF  31
0F6F:  MOVF   30,W
0F70:  MOVWF  3C
0F71:  MOVF   31,W
0F72:  MOVWF  3D
0F73:  MOVLP  00
0F74:  MOVLB  00
0F75:  CALL   78B
0F76:  MOVLP  08
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
0F77:  CALL   270
.................... } // }}} 
0F78:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
0F00:  MOVLB  02
0F01:  CLRF   3C
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
0F02:  MOVF   3C,W
0F03:  SUBLW  05
0F04:  BTFSS  03.0
0F05:  GOTO   727
....................     dest[c]=src[c]; 
0F06:  MOVF   3C,W
0F07:  ADDWF  38,W
0F08:  MOVWF  78
0F09:  MOVLW  00
0F0A:  ADDWFC 39,W
0F0B:  MOVWF  7A
0F0C:  MOVF   78,W
0F0D:  MOVWF  3D
0F0E:  MOVF   7A,W
0F0F:  MOVWF  3E
0F10:  MOVF   3C,W
0F11:  ADDWF  3A,W
0F12:  MOVWF  78
0F13:  MOVLW  00
0F14:  ADDWFC 3B,W
0F15:  MOVWF  7A
0F16:  MOVF   78,W
0F17:  MOVLB  03
0F18:  MOVWF  11
0F19:  MOVF   7A,W
0F1A:  MOVWF  12
0F1B:  MOVLB  02
0F1C:  MOVF   3E,W
0F1D:  MOVWF  05
0F1E:  MOVF   3D,W
0F1F:  MOVWF  04
0F20:  MOVLW  01
0F21:  MOVWF  42
0F22:  MOVLB  00
0F23:  CALL   019
....................   c++; 
0F24:  MOVLB  02
0F25:  INCF   3C,F
....................   } 
0F26:  GOTO   702
.................... } // }}} 
0F27:  MOVLB  00
0F28:  RETURN
.................... void ExecAuxOutOp(int op,int arg,int ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
1620:  MOVF   27,W
1621:  ANDLW  0F
1622:  MOVWF  29
....................   uarg = (arg & 0xF0) >> 4; 
1623:  MOVF   27,W
1624:  ANDLW  F0
1625:  MOVWF  77
1626:  SWAPF  77,W
1627:  MOVWF  2A
1628:  MOVLW  0F
1629:  ANDWF  2A,F
....................   switch(op) { 
162A:  MOVF   26,W
162B:  XORLW  01
162C:  MOVLB  00
162D:  BTFSC  03.2
162E:  GOTO   633
162F:  XORLW  03
1630:  BTFSC  03.2
1631:  GOTO   646
1632:  GOTO   65F
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       AuxOut[ID] = ((COR_IN_EFFECTIVE ^ uarg) & larg) != 0; 
1633:  MOVLW  22
1634:  MOVLB  02
1635:  ADDWF  28,W
1636:  MOVWF  04
1637:  MOVLW  20
1638:  MOVWF  05
1639:  BTFSC  03.0
163A:  INCF   05,F
163B:  MOVF   72,W
163C:  XORWF  2A,W
163D:  ANDWF  29,W
163E:  BTFSS  03.2
163F:  GOTO   642
1640:  MOVLW  00
1641:  GOTO   643
1642:  MOVLW  01
1643:  MOVWF  00
....................     break; 
1644:  MOVLB  00
1645:  GOTO   65F
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
1646:  MOVLW  22
1647:  MOVLB  02
1648:  ADDWF  28,W
1649:  MOVWF  04
164A:  MOVLW  20
164B:  MOVWF  05
164C:  BTFSC  03.0
164D:  INCF   05,F
164E:  MOVF   29,W
164F:  ANDLW  1F
1650:  MOVWF  2D
1651:  MOVF   7A,W
1652:  MOVWF  2E
1653:  MOVF   2A,W
1654:  XORWF  2D,F
1655:  BTFSS  03.2
1656:  GOTO   65C
1657:  MOVF   2E,F
1658:  BTFSS  03.2
1659:  GOTO   65C
165A:  MOVLW  00
165B:  GOTO   65D
165C:  MOVLW  01
165D:  MOVWF  00
....................     break; 
165E:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0E88:  MOVLB  02
0E89:  CLRF   3E
0E8A:  CLRF   3F
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0E8B:  MOVF   3E,W
0E8C:  ADDWF  3C,W
0E8D:  MOVWF  04
0E8E:  MOVLW  00
0E8F:  ADDWFC 3D,W
0E90:  MOVWF  05
0E91:  MOVF   00,F
0E92:  BTFSC  03.2
0E93:  GOTO   6BD
0E94:  MOVF   3E,W
0E95:  ADDWF  3C,W
0E96:  MOVWF  04
0E97:  MOVLW  00
0E98:  ADDWFC 3D,W
0E99:  MOVWF  05
0E9A:  MOVF   00,W
0E9B:  SUBLW  2F
0E9C:  BTFSC  03.0
0E9D:  GOTO   6BD
0E9E:  MOVF   3E,W
0E9F:  ADDWF  3C,W
0EA0:  MOVWF  04
0EA1:  MOVLW  00
0EA2:  ADDWFC 3D,W
0EA3:  MOVWF  05
0EA4:  MOVF   00,W
0EA5:  SUBLW  39
0EA6:  BTFSS  03.0
0EA7:  GOTO   6BD
....................     value = (value * 10) + (str[x]-'0'); 
0EA8:  MOVF   3F,W
0EA9:  MOVWF  40
0EAA:  MOVLW  0A
0EAB:  MOVWF  41
0EAC:  MOVLB  00
0EAD:  CALL   661
0EAE:  MOVF   78,W
0EAF:  MOVLB  02
0EB0:  MOVWF  40
0EB1:  MOVF   3E,W
0EB2:  ADDWF  3C,W
0EB3:  MOVWF  04
0EB4:  MOVLW  00
0EB5:  ADDWFC 3D,W
0EB6:  MOVWF  05
0EB7:  MOVLW  30
0EB8:  SUBWF  00,W
0EB9:  ADDWF  40,W
0EBA:  MOVWF  3F
....................     x++; 
0EBB:  INCF   3E,F
....................   } 
0EBC:  GOTO   68B
....................   return(value); 
0EBD:  MOVF   3F,W
0EBE:  MOVWF  78
.................... } // }}} 
0EBF:  MOVLB  00
0EC0:  RETURN
.................... void ExecAuxInOp(int op,int arg,int ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
153A:  MOVLB  02
153B:  BCF    29.0
153C:  MOVLW  1F
153D:  ADDWF  28,W
153E:  MOVWF  04
153F:  MOVLW  20
1540:  MOVWF  05
1541:  BTFSC  03.0
1542:  INCF   05,F
1543:  MOVF   00,F
1544:  BTFSS  03.2
1545:  BSF    29.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   // Include arg[4] for COR4 emulation 
....................   larg = arg & 0x1F; 
1546:  MOVF   27,W
1547:  ANDLW  1F
1548:  MOVWF  2A
....................   uarg = (arg & 0xF0) >> 4; 
1549:  MOVF   27,W
154A:  ANDLW  F0
154B:  MOVWF  77
154C:  SWAPF  77,W
154D:  MOVWF  2B
154E:  MOVLW  0F
154F:  ANDWF  2B,F
....................   switch(op) { 
1550:  MOVLW  01
1551:  SUBWF  26,W
1552:  ADDLW  FC
1553:  BTFSC  03.0
1554:  GOTO   5A1
1555:  ADDLW  04
1556:  MOVLB  00
1557:  GOTO   5A4
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
1558:  MOVLB  02
1559:  BTFSS  29.0
155A:  GOTO   560
....................         Enable_Mask &= arg; 
155B:  MOVF   27,W
155C:  MOVLB  00
155D:  ANDWF  61,F
....................       } else { // AuxIn is not enabled 
155E:  GOTO   565
155F:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
1560:  MOVF   27,W
1561:  XORLW  FF
1562:  ANDLW  0F
1563:  MOVLB  00
1564:  IORWF  61,F
....................       } 
....................       break; 
1565:  MOVLB  02
1566:  GOTO   5A1
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
1567:  MOVLB  02
1568:  BTFSS  29.0
1569:  GOTO   570
....................         COR_DROP_FLAG=1; 
156A:  BSF    74.5
....................         TailChar=arg; 
156B:  MOVF   27,W
156C:  MOVLB  00
156D:  MOVWF  6C
....................       } else { 
156E:  GOTO   572
156F:  MOVLB  02
....................         TailChar=0; 
1570:  MOVLB  00
1571:  CLRF   6C
....................       } 
....................     break; 
1572:  MOVLB  02
1573:  GOTO   5A1
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
1574:  MOVLB  02
1575:  BTFSC  29.0
1576:  GOTO   57D
....................         COR_DROP_FLAG=1; 
1577:  BSF    74.5
....................         TailChar=arg; 
1578:  MOVF   27,W
1579:  MOVLB  00
157A:  MOVWF  6C
....................       } else { 
157B:  GOTO   57F
157C:  MOVLB  02
....................         TailChar=0; 
157D:  MOVLB  00
157E:  CLRF   6C
....................       } 
....................     break; 
157F:  MOVLB  02
1580:  GOTO   5A1
....................     case AUXI_EMULATE_COR: 
....................       int1 active_low = (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0; 
1581:  MOVLB  02
1582:  BCF    29.2
1583:  MOVF   27,W
1584:  ANDLW  20
1585:  BTFSS  03.2
1586:  BSF    29.2
....................       tmp_bit = (active_low ^ in_bit); 
1587:  MOVLW  00
1588:  BTFSC  29.2
1589:  MOVLW  01
158A:  MOVWF  2D
158B:  MOVLW  00
158C:  BTFSC  29.0
158D:  MOVLW  01
158E:  XORWF  2D,W
158F:  MOVWF  78
1590:  BCF    29.1
1591:  BTFSC  78.0
1592:  BSF    29.1
....................       if ( tmp_bit ) { 
1593:  BTFSS  29.1
1594:  GOTO   59A
....................         COR_AUX |= larg; 
1595:  MOVF   2A,W
1596:  MOVLB  00
1597:  IORWF  6B,F
....................       } else { 
1598:  GOTO   59E
1599:  MOVLB  02
....................         COR_AUX &= ~larg; 
159A:  MOVF   2A,W
159B:  XORLW  FF
159C:  MOVLB  00
159D:  ANDWF  6B,F
....................       } 
....................     break; 
159E:  MOVLB  02
159F:  GOTO   5A1
15A0:  MOVLB  02
....................   } 
.................... } // }}} 
15A1:  MOVLP  10
15A2:  MOVLB  00
15A3:  GOTO   6D0 (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
14F2:  MOVLB  01
14F3:  CLRF   63
14F4:  MOVF   63,W
14F5:  SUBLW  02
14F6:  BTFSS  03.0
14F7:  GOTO   537
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = ((input(AUX_IN_PIN[x])!=0 )|| (AuxIn[x]!=0)); 
14F8:  MOVLW  1F
14F9:  ADDWF  63,W
14FA:  MOVWF  64
14FB:  MOVLW  20
14FC:  MOVWF  65
14FD:  BTFSC  03.0
14FE:  INCF   65,F
14FF:  MOVF   63,W
1500:  MOVLP  00
1501:  MOVLB  00
1502:  CALL   03F
1503:  MOVLP  10
1504:  MOVLB  01
1505:  MOVWF  66
1506:  MOVLB  02
1507:  MOVWF  3D
1508:  MOVLW  01
1509:  MOVWF  3E
150A:  CLRF   40
150B:  MOVLW  80
150C:  MOVWF  3F
150D:  MOVLP  08
150E:  MOVLB  00
150F:  CALL   0F3
1510:  MOVLP  10
1511:  MOVLB  01
1512:  MOVF   66,W
1513:  MOVWF  67
1514:  CLRF   69
1515:  CLRF   68
1516:  MOVLP  08
1517:  MOVLB  00
1518:  GOTO   7D4
1519:  MOVLP  10
151A:  BTFSC  78.0
151B:  GOTO   52C
151C:  MOVLW  1C
151D:  MOVLB  01
151E:  ADDWF  63,W
151F:  MOVWF  04
1520:  MOVLW  20
1521:  MOVWF  05
1522:  BTFSC  03.0
1523:  INCF   05,F
1524:  MOVF   00,F
1525:  BTFSC  03.2
1526:  GOTO   529
1527:  MOVLB  00
1528:  GOTO   52C
1529:  MOVLW  00
152A:  GOTO   52E
152B:  MOVLB  00
152C:  MOVLW  01
152D:  MOVLB  01
152E:  MOVWF  67
152F:  MOVF   65,W
1530:  MOVWF  05
1531:  MOVF   64,W
1532:  MOVWF  04
1533:  MOVF   67,W
1534:  MOVWF  00
....................   } 
1535:  INCF   63,F
1536:  GOTO   4F4
.................... } // }}} 
1537:  MOVLP  18
1538:  MOVLB  00
1539:  GOTO   6C3 (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
15E5:  MOVLW  30
15E6:  MOVLB  01
15E7:  MOVWF  66
15E8:  MOVWF  67
15E9:  MOVWF  68
15EA:  CLRF   69
....................   char AuxOut_s[4]={'0','0','0',0}; 
15EB:  MOVWF  6A
15EC:  MOVWF  6B
15ED:  MOVWF  6C
15EE:  CLRF   6D
....................   char ADM[]=" ADMIN"; 
15EF:  MOVLW  20
15F0:  MOVWF  6E
15F1:  MOVLW  41
15F2:  MOVWF  6F
15F3:  MOVLW  44
15F4:  MOVLB  02
15F5:  MOVWF  20
15F6:  MOVLW  4D
15F7:  MOVWF  21
15F8:  MOVLW  49
15F9:  MOVWF  22
15FA:  MOVLW  4E
15FB:  MOVWF  23
15FC:  CLRF   24
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
15FD:  MOVLB  01
15FE:  CLRF   63
15FF:  MOVF   63,W
1600:  SUBLW  02
1601:  BTFSS  03.0
1602:  GOTO   6D3
....................     AuxOp = AuxOutOp[x]; 
1603:  MOVLW  33
1604:  ADDWF  63,W
1605:  MOVWF  04
1606:  MOVLW  20
1607:  MOVWF  05
1608:  BTFSC  03.0
1609:  INCF   05,F
160A:  MOVF   00,W
160B:  MOVWF  64
....................     AuxArg = AuxOutArg[x]; 
160C:  MOVLW  36
160D:  ADDWF  63,W
160E:  MOVWF  04
160F:  MOVLW  20
1610:  MOVWF  05
1611:  BTFSC  03.0
1612:  INCF   05,F
1613:  MOVF   00,W
1614:  MOVWF  65
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
1615:  MOVF   64,W
1616:  MOVLB  02
1617:  MOVWF  26
1618:  MOVLB  01
1619:  MOVF   65,W
161A:  MOVLB  02
161B:  MOVWF  27
161C:  MOVLB  01
161D:  MOVF   63,W
161E:  MOVLB  02
161F:  MOVWF  28
....................     out_bit = (AuxOut[x])==0; 
*
165F:  MOVLB  02
1660:  BCF    25.0
1661:  MOVLW  22
1662:  MOVLB  01
1663:  ADDWF  63,W
1664:  MOVWF  04
1665:  MOVLW  20
1666:  MOVWF  05
1667:  BTFSC  03.0
1668:  INCF   05,F
1669:  MOVF   00,F
166A:  BTFSS  03.2
166B:  GOTO   66F
166C:  MOVLB  02
166D:  BSF    25.0
166E:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
166F:  MOVF   63,W
1670:  MOVLP  00
1671:  MOVLB  00
1672:  CALL   03B
1673:  MOVLP  10
1674:  MOVLB  02
1675:  MOVWF  26
1676:  MOVLW  00
1677:  BTFSC  25.0
1678:  MOVLW  01
1679:  MOVWF  77
167A:  MOVF   26,W
167B:  MOVWF  3D
167C:  MOVF   77,W
167D:  MOVWF  3E
167E:  MOVLW  01
167F:  MOVWF  40
1680:  CLRF   3F
1681:  MOVLP  08
1682:  MOVLB  00
1683:  CALL   0F3
1684:  MOVLP  10
1685:  MOVLB  02
1686:  MOVF   26,W
1687:  MOVWF  3D
1688:  CLRF   3E
1689:  CLRF   40
168A:  MOVLW  80
168B:  MOVWF  3F
168C:  MOVLP  08
168D:  MOVLB  00
168E:  CALL   0F3
168F:  MOVLP  10
....................     if(out_bit==0) { 
1690:  MOVLB  02
1691:  BTFSC  25.0
1692:  GOTO   69E
....................       AuxOut_s[x]='1'; 
1693:  MOVLW  9A
1694:  MOVLB  01
1695:  ADDWF  63,W
1696:  MOVWF  04
1697:  MOVLW  20
1698:  MOVWF  05
1699:  BTFSC  03.0
169A:  INCF   05,F
169B:  MOVLW  31
169C:  MOVWF  00
169D:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
169E:  MOVLW  39
169F:  MOVLB  01
16A0:  ADDWF  63,W
16A1:  MOVWF  04
16A2:  MOVLW  20
16A3:  MOVWF  05
16A4:  BTFSC  03.0
16A5:  INCF   05,F
16A6:  MOVF   00,W
16A7:  MOVWF  64
....................     AuxArg = AuxInArg[x]; 
16A8:  MOVLW  3C
16A9:  ADDWF  63,W
16AA:  MOVWF  04
16AB:  MOVLW  20
16AC:  MOVWF  05
16AD:  BTFSC  03.0
16AE:  INCF   05,F
16AF:  MOVF   00,W
16B0:  MOVWF  65
....................     if(AuxInSW[x]==1) { 
16B1:  MOVLW  1F
16B2:  ADDWF  63,W
16B3:  MOVWF  04
16B4:  MOVLW  20
16B5:  MOVWF  05
16B6:  BTFSC  03.0
16B7:  INCF   05,F
16B8:  DECFSZ 00,W
16B9:  GOTO   6C3
....................       AuxIn_s[x]='1'; 
16BA:  MOVLW  96
16BB:  ADDWF  63,W
16BC:  MOVWF  04
16BD:  MOVLW  20
16BE:  MOVWF  05
16BF:  BTFSC  03.0
16C0:  INCF   05,F
16C1:  MOVLW  31
16C2:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
16C3:  MOVF   64,W
16C4:  MOVLB  02
16C5:  MOVWF  26
16C6:  MOVLB  01
16C7:  MOVF   65,W
16C8:  MOVLB  02
16C9:  MOVWF  27
16CA:  MOVLB  01
16CB:  MOVF   63,W
16CC:  MOVLB  02
16CD:  MOVWF  28
16CE:  MOVLB  00
16CF:  GOTO   53A
....................     // }}} 
....................   } 
16D0:  MOVLB  01
16D1:  INCF   63,F
16D2:  GOTO   5FF
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
16D3:  MOVLW  20
16D4:  MOVWF  62
16D5:  MOVLW  76
16D6:  MOVWF  61
16D7:  MOVLW  49
16D8:  MOVLB  02
16D9:  MOVWF  4D
16DA:  MOVLP  08
16DB:  MOVLB  00
16DC:  CALL   115
16DD:  MOVLP  10
16DE:  MOVLW  3A
16DF:  MOVLB  02
16E0:  MOVWF  4D
16E1:  MOVLP  08
16E2:  MOVLB  00
16E3:  CALL   115
16E4:  MOVLP  10
16E5:  MOVLW  20
16E6:  MOVWF  05
16E7:  MOVLW  96
16E8:  MOVWF  04
16E9:  MOVLP  08
16EA:  CALL   177
16EB:  MOVLP  10
16EC:  MOVLW  20
16ED:  MOVLB  02
16EE:  MOVWF  4D
16EF:  MOVLP  08
16F0:  MOVLB  00
16F1:  CALL   115
16F2:  MOVLP  10
16F3:  MOVLW  4F
16F4:  MOVLB  02
16F5:  MOVWF  4D
16F6:  MOVLP  08
16F7:  MOVLB  00
16F8:  CALL   115
16F9:  MOVLP  10
16FA:  MOVLW  3A
16FB:  MOVLB  02
16FC:  MOVWF  4D
16FD:  MOVLP  08
16FE:  MOVLB  00
16FF:  CALL   115
1700:  MOVLP  10
1701:  MOVLW  20
1702:  MOVWF  05
1703:  MOVLW  9A
1704:  MOVWF  04
1705:  MOVLP  08
1706:  CALL   177
1707:  MOVLP  10
....................   if ( AdminMode ) { 
1708:  MOVLB  01
1709:  BTFSS  60.4
170A:  GOTO   717
....................     strcat(LCD_str,ADM); 
170B:  MOVLW  20
170C:  MOVLB  02
170D:  MOVWF  27
170E:  MOVLW  76
170F:  MOVWF  26
1710:  MOVLW  20
1711:  MOVWF  29
1712:  MOVLW  9E
1713:  MOVWF  28
1714:  MOVLB  00
1715:  CALL   5AC
1716:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
1717:  MOVLW  03
1718:  MOVLB  02
1719:  MOVWF  47
171A:  MOVLW  20
171B:  MOVWF  49
171C:  MOVLW  76
171D:  MOVWF  48
171E:  MOVLP  08
171F:  MOVLB  00
1720:  CALL   18C
1721:  MOVLP  10
.................... } // }}} 
1722:  RETURN
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
1000:  MOVLW  01
1001:  MOVLB  02
1002:  MOVWF  2B
1003:  MOVLP  08
1004:  MOVLB  00
1005:  CALL   360
1006:  MOVLP  10
....................   delay_ms(1000); 
1007:  MOVLW  04
1008:  MOVLB  02
1009:  MOVWF  2B
100A:  MOVLW  FA
100B:  MOVWF  47
100C:  MOVLP  08
100D:  MOVLB  00
100E:  CALL   000
100F:  MOVLP  10
1010:  MOVLB  02
1011:  DECFSZ 2B,F
1012:  GOTO   00A
....................   for(x=0;x<6;x++) { 
1013:  CLRF   29
1014:  MOVF   29,W
1015:  SUBLW  05
1016:  BTFSS  03.0
1017:  GOTO   034
....................     mchar=Morse[x]; 
1018:  MOVLW  2D
1019:  ADDWF  29,W
101A:  MOVWF  04
101B:  MOVLW  20
101C:  MOVWF  05
101D:  BTFSC  03.0
101E:  INCF   05,F
101F:  MOVF   00,W
1020:  MOVWF  2A
....................     morse(mchar); 
1021:  MOVF   2A,W
1022:  MOVWF  3C
1023:  MOVLP  08
1024:  MOVLB  00
1025:  CALL   09C
1026:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
1027:  MOVLB  01
1028:  CLRF   33
1029:  MOVLW  06
102A:  MOVWF  32
....................     while(aux_timer) { 
102B:  MOVF   32,W
102C:  IORWF  33,W
102D:  BTFSC  03.2
102E:  GOTO   031
....................       delay_cycles(1); 
102F:  NOP
....................     } 
1030:  GOTO   02B
....................   } 
1031:  MOVLB  02
1032:  INCF   29,F
1033:  GOTO   014
....................   delay_ms(1000); 
1034:  MOVLW  04
1035:  MOVWF  2B
1036:  MOVLW  FA
1037:  MOVWF  47
1038:  MOVLP  08
1039:  MOVLB  00
103A:  CALL   000
103B:  MOVLP  10
103C:  MOVLB  02
103D:  DECFSZ 2B,F
103E:  GOTO   036
....................   COR_FLAG=1; 
103F:  BSF    74.1
.................... } // }}} 
1040:  MOVLB  00
1041:  RETURN
.................... void main (void) { // {{{ 
*
1E82:  CLRF   05
1E83:  CLRF   04
1E84:  MOVLW  1F
1E85:  ANDWF  03,F
1E86:  MOVLW  72
1E87:  MOVLB  01
1E88:  MOVWF  19
1E89:  BSF    0E.3
1E8A:  BSF    0E.4
1E8B:  MOVLB  04
1E8C:  BCF    17.0
1E8D:  BCF    17.1
1E8E:  BCF    17.3
1E8F:  MOVLW  13
1E90:  MOVWF  12
1E91:  MOVLW  28
1E92:  MOVWF  15
1E93:  BSF    14.7
1E94:  BCF    14.6
1E95:  MOVLW  0C
1E96:  MOVLB  03
1E97:  MOVWF  1B
1E98:  MOVLW  A2
1E99:  MOVWF  1E
1E9A:  MOVLW  90
1E9B:  MOVWF  1D
1E9C:  MOVLB  01
1E9D:  BSF    60.6
1E9E:  CLRF   62
1E9F:  CLRF   61
1EA0:  MOVLB  0F
1EA1:  CLRF   11
1EA2:  CLRF   12
1EA3:  CLRF   18
1EA4:  CLRF   19
1EA5:  CLRF   1A
1EA6:  MOVLB  03
1EA7:  CLRF   0C
1EA8:  CLRF   0D
1EA9:  CLRF   0F
1EAA:  CLRF   10
1EAB:  MOVLB  02
1EAC:  CLRF   12
1EAD:  CLRF   11
1EAE:  CLRF   14
1EAF:  CLRF   13
....................   initialize(); 
*
1EB3:  MOVLP  08
1EB4:  GOTO   4C0
1EB5:  MOVLP  18
.................... #ignore_warnings 203 
....................   while(1) { // {{{ 
.................... #ignore_warnings none 
....................     restart_wdt(); 
1EB6:  CLRWDT
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "\r" or "+" or "-" is received. 
....................     if ( sBufferFlag ) { 
1EB7:  BTFSS  74.0
1EB8:  GOTO   6BE
....................       process_sBuffer(); 
1EB9:  GOTO   000
....................       clear_sBuffer(); 
1EBA:  MOVLP  00
1EBB:  CALL   4BD
1EBC:  MOVLP  18
....................       sBufferFlag=0; 
1EBD:  BCF    74.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1EBE:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1EBF:  BTFSS  74.6
1EC0:  GOTO   6C5
....................       update_aux_in(); 
1EC1:  MOVLP  10
1EC2:  GOTO   4F2
1EC3:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1EC4:  BCF    74.6
....................     } 
....................     do_delay_counters(); 
1EC5:  MOVLP  10
1EC6:  GOTO   723
1EC7:  MOVLP  18
....................     restart_wdt(); 
1EC8:  CLRWDT
....................     if ( COR_FLAG ) { 
1EC9:  BTFSS  74.1
1ECA:  GOTO   6D1
....................       process_cor(); 
1ECB:  GOTO   42B
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       update_aux_out();  
1ECC:  MOVLP  10
1ECD:  CALL   5E5
1ECE:  MOVLP  18
....................       COR_FLAG=0; 
1ECF:  BCF    74.1
....................       restart_wdt(); 
1ED0:  CLRWDT
....................     } 
....................     if ( DTMF_INTERRUPT_FLAG ) { 
1ED1:  MOVLB  01
1ED2:  BTFSS  60.1
1ED3:  GOTO   6DA
....................       // Extract data from DTMF device 
....................       process_dtmf_interrupt(); 
1ED4:  MOVLP  10
1ED5:  MOVLB  00
1ED6:  GOTO   7AA
1ED7:  MOVLP  18
....................       DTMF_INTERRUPT_FLAG=0; 
1ED8:  MOVLB  01
1ED9:  BCF    60.1
....................     } 
....................     if ( DTMF_IN_FLAG ) { 
1EDA:  BTFSS  60.0
1EDB:  GOTO   6E1
....................       print_dtmf_info(); 
1EDC:  MOVLB  00
1EDD:  GOTO   4BB
....................       DTMF_IN_FLAG=0; 
1EDE:  MOVLB  01
1EDF:  BCF    60.0
....................       restart_wdt(); 
1EE0:  CLRWDT
....................     } 
....................     if ( DTMF_FLAG ) { 
1EE1:  BTFSS  74.7
1EE2:  GOTO   6E8
....................       process_dtmf(); 
1EE3:  MOVLB  00
1EE4:  GOTO   57D
....................       DTMF_FLAG=0; 
1EE5:  BCF    74.7
....................     restart_wdt(); 
1EE6:  CLRWDT
1EE7:  MOVLB  01
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1EE8:  BTFSS  60.2
1EE9:  GOTO   6EE
....................       clear_dtmf_array(); 
1EEA:  MOVLB  00
1EEB:  GOTO   66B
....................       CLEAR_DTMF_FLAG=0; 
1EEC:  MOVLB  01
1EED:  BCF    60.2
....................     } 
....................     if ( PROMPT_FLAG ) { 
1EEE:  BTFSS  60.3
1EEF:  GOTO   6F7
....................       prompt(); 
1EF0:  MOVLP  08
1EF1:  MOVLB  00
1EF2:  CALL   7BC
1EF3:  MOVLP  18
....................       PROMPT_FLAG=0; 
1EF4:  MOVLB  01
1EF5:  BCF    60.3
....................     restart_wdt(); 
1EF6:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1EF7:  MOVLB  00
1EF8:  GOTO   6B6
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0B8F:  CLRWDT
*
1EF9:  SLEEP
....................   delay_ms(1000); 
*
0B90:  MOVLW  04
0B91:  MOVLB  02
0B92:  MOVWF  3C
0B93:  MOVLW  FA
0B94:  MOVWF  47
0B95:  MOVLB  00
0B96:  CALL   000
0B97:  MOVLB  02
0B98:  DECFSZ 3C,F
0B99:  GOTO   393
....................   if ( ConfirmChar!=0 ) { 
0B9A:  MOVLB  00
0B9B:  MOVF   6D,F
0B9C:  BTFSC  03.2
0B9D:  GOTO   3B0
....................     morse(ConfirmChar); 
0B9E:  MOVF   6D,W
0B9F:  MOVLB  02
0BA0:  MOVWF  3C
0BA1:  MOVLB  00
0BA2:  CALL   09C
....................     ConfirmChar=0; 
0BA3:  CLRF   6D
....................     restart_wdt(); 
0BA4:  CLRWDT
....................     delay_ms(500); 
0BA5:  MOVLW  02
0BA6:  MOVLB  02
0BA7:  MOVWF  3C
0BA8:  MOVLW  FA
0BA9:  MOVWF  47
0BAA:  MOVLB  00
0BAB:  CALL   000
0BAC:  MOVLB  02
0BAD:  DECFSZ 3C,F
0BAE:  GOTO   3A8
0BAF:  MOVLB  00
....................   } 
....................   if (TailChar != 0) { 
0BB0:  MOVF   6C,F
0BB1:  BTFSC  03.2
0BB2:  GOTO   3C5
....................     morse(TailChar); 
0BB3:  MOVF   6C,W
0BB4:  MOVLB  02
0BB5:  MOVWF  3C
0BB6:  MOVLB  00
0BB7:  CALL   09C
....................     TailChar=0; 
0BB8:  CLRF   6C
....................     restart_wdt(); 
0BB9:  CLRWDT
....................     delay_ms(500); 
0BBA:  MOVLW  02
0BBB:  MOVLB  02
0BBC:  MOVWF  3C
0BBD:  MOVLW  FA
0BBE:  MOVWF  47
0BBF:  MOVLB  00
0BC0:  CALL   000
0BC1:  MOVLB  02
0BC2:  DECFSZ 3C,F
0BC3:  GOTO   3BD
0BC4:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0BC5:  CLRWDT
0BC6:  MOVLB  02
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
0F29:  MOVLB  01
0F2A:  BTFSS  60.4
0F2B:  GOTO   72E
....................     admin_timer = ADMIN_TIMEOUT; 
0F2C:  MOVLW  FF
0F2D:  MOVWF  75
....................   } 
....................   return(AdminMode||rs232_mode); 
0F2E:  BTFSC  60.4
0F2F:  GOTO   734
0F30:  BTFSC  60.5
0F31:  GOTO   734
0F32:  MOVLW  00
0F33:  GOTO   735
0F34:  MOVLW  01
0F35:  MOVWF  78
.................... } // }}} 
0F36:  MOVLB  00
0F37:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0CA9:  MOVLB  01
0CAA:  BCF    60.4
0CAB:  MOVLB  02
0CAC:  MOVF   3D,F
0CAD:  BTFSC  03.2
0CAE:  GOTO   4B2
0CAF:  MOVLB  01
0CB0:  BSF    60.4
0CB1:  MOVLB  02
....................   if (AdminMode) { 
0CB2:  MOVLB  01
0CB3:  BTFSS  60.4
0CB4:  GOTO   4BC
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0CB5:  MOVLW  0A
0CB6:  MOVLB  00
0CB7:  MOVWF  6D
....................     admin_timer = ADMIN_TIMEOUT; 
0CB8:  MOVLW  FF
0CB9:  MOVWF  75
....................   } else { 
0CBA:  GOTO   4BF
0CBB:  MOVLB  01
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0CBC:  MOVLW  18
0CBD:  MOVLB  00
0CBE:  MOVWF  6D
....................   }  
.................... } // }}} 
0CBF:  RETURN
.................... // string matchnig function with case insensitive match. 
.................... int1 my_stricmp(char *s1,char *s2) { // {{{ 
*
0EC1:  MOVLB  02
0EC2:  CLRF   40
....................   unsigned int x=0; 
....................   const char AMASK=0xDF; 
....................   while((AMASK&s1[x])==(AMASK&s2[x])) { 
0EC3:  MOVF   40,W
0EC4:  ADDWF  3C,W
0EC5:  MOVWF  04
0EC6:  MOVLW  00
0EC7:  ADDWFC 3D,W
0EC8:  MOVWF  05
0EC9:  MOVF   00,W
0ECA:  ANDLW  DF
0ECB:  MOVWF  41
0ECC:  MOVF   40,W
0ECD:  ADDWF  3E,W
0ECE:  MOVWF  04
0ECF:  MOVLW  00
0ED0:  ADDWFC 3F,W
0ED1:  MOVWF  05
0ED2:  MOVF   00,W
0ED3:  ANDLW  DF
0ED4:  SUBWF  41,W
0ED5:  BTFSS  03.2
0ED6:  GOTO   6E5
....................     if(s1[x]==0) { 
0ED7:  MOVF   40,W
0ED8:  ADDWF  3C,W
0ED9:  MOVWF  04
0EDA:  MOVLW  00
0EDB:  ADDWFC 3D,W
0EDC:  MOVWF  05
0EDD:  MOVF   00,F
0EDE:  BTFSS  03.2
0EDF:  GOTO   6E3
....................       return 0; 
0EE0:  MOVLW  00
0EE1:  MOVWF  78
0EE2:  GOTO   6E7
....................     } 
....................     x++; 
0EE3:  INCF   40,F
....................   } 
0EE4:  GOTO   6C3
....................   // Strings don't match. Return 1. 
....................   return 1; 
0EE5:  MOVLW  01
0EE6:  MOVWF  78
.................... } // }}} 
0EE7:  MOVLB  00
0EE8:  RETURN
.................... // Fetches data from MC8888 device upon interrupt 
.................... void process_dtmf_interrupt(void) { // {{{ 
....................   int value,dtmf_status; 
....................   dtmf_status = dtmf_read(CONTROL_REG); 
*
17AA:  MOVLW  01
17AB:  MOVLB  02
17AC:  MOVWF  38
17AD:  MOVLP  00
17AE:  MOVLB  00
17AF:  CALL   69A
17B0:  MOVLP  10
17B1:  MOVF   78,W
17B2:  MOVLB  01
17B3:  MOVWF  64
....................   if ( dtmf_status & DTMF_BUFFER_FULL) { 
17B4:  BTFSS  64.2
17B5:  GOTO   7F9
....................     value=dtmf_read(DATA_REG); 
17B6:  MOVLB  02
17B7:  CLRF   38
17B8:  MOVLP  00
17B9:  MOVLB  00
17BA:  CALL   69A
17BB:  MOVLP  10
17BC:  MOVF   78,W
17BD:  MOVLB  01
17BE:  MOVWF  63
....................     DTMF_IN_FLAG=1; 
17BF:  BSF    60.0
....................     if ( value == dd ) { 
17C0:  MOVF   63,F
17C1:  BTFSS  03.2
17C2:  GOTO   7C6
....................       value=d0; 
17C3:  MOVLW  0A
17C4:  MOVWF  63
....................     } else if ( value == d0 ) { 
17C5:  GOTO   7CA
17C6:  MOVF   63,W
17C7:  SUBLW  0A
17C8:  BTFSC  03.2
....................       value=dd; 
17C9:  CLRF   63
....................     } 
....................     if ( value == ds ) { 
17CA:  MOVF   63,W
17CB:  SUBLW  0B
17CC:  BTFSC  03.2
....................       CLEAR_DTMF_FLAG=1; 
17CD:  BSF    60.2
....................     } 
....................     // Check for '#' 
....................     if ( value == dp ) { 
17CE:  MOVF   63,W
17CF:  SUBLW  0C
17D0:  BTFSS  03.2
17D1:  GOTO   7DA
....................       DTMF_FLAG = 1; 
17D2:  BSF    74.7
....................       DTMF_ptr->Last=1; 
17D3:  MOVF   3E,W
17D4:  MOVWF  04
17D5:  MOVF   3F,W
17D6:  MOVWF  05
17D7:  ADDFSR 00,FSR0
17D8:  BSF    00.5
....................     } else { 
17D9:  GOTO   7F9
....................       if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
17DA:  MOVF   3F,W
17DB:  SUBLW  20
17DC:  BTFSS  03.0
17DD:  GOTO   7F9
17DE:  BTFSS  03.2
17DF:  GOTO   7E4
17E0:  MOVF   3E,W
17E1:  SUBLW  6D
17E2:  BTFSS  03.0
17E3:  GOTO   7F9
....................         DTMF_ptr->Key=value; 
17E4:  MOVF   3E,W
17E5:  MOVWF  04
17E6:  MOVF   3F,W
17E7:  MOVWF  05
17E8:  ADDFSR 00,FSR0
17E9:  MOVF   63,W
17EA:  ANDLW  0F
17EB:  MOVWF  77
17EC:  MOVLW  F0
17ED:  ANDWF  00,W
17EE:  IORWF  77,W
17EF:  MOVWF  00
....................         DTMF_ptr->Strobe=1; 
17F0:  MOVF   3E,W
17F1:  MOVWF  04
17F2:  MOVF   3F,W
17F3:  MOVWF  05
17F4:  ADDFSR 00,FSR0
17F5:  BSF    00.4
....................         DTMF_ptr++; 
17F6:  INCF   3E,F
17F7:  BTFSC  03.2
17F8:  INCF   3F,F
....................       } 
....................     } 
....................   } 
.................... } // }}} 
17F9:  MOVLP  18
17FA:  MOVLB  00
17FB:  GOTO   6D7 (RETURN)
.................... void init_lcd(void) { // {{{ 
.................... #define INIT 0x18 
.................... #define MODE_SET 0x1C 
.................... #define ENABLE 0x04 
....................   i2c_start(); 
....................   i2c_write(LCD_I2C_ADD<<1); 
....................   // Function set 
....................   // Initialize in 8-bit mode first for 3 clock cycles 
....................   lcd_strobe(0x30);lcd_strobe(0x30);lcd_strobe(0x30); 
....................   // Init 4-bit interface mode 
....................   lcd_strobe(0x20); 
....................   lcd_write(0,0x2C); 
....................   // Display On/Off, Cursor off 
....................   lcd_write(0,0x0C); 
....................   // Display clear 
....................   lcd_write(0,0x01); 
....................   // Entry mode set 
....................   lcd_write(0,0x04); 
....................   i2c_stop(); 
.................... } // }}} 
.................... void do_delay_counters(void) { 
....................   // Second Flag {{{ 
....................   if ( SECOND_FLAG ) { 
*
1723:  BTFSS  74.2
1724:  GOTO   771
....................     update_aux_out(); 
1725:  CALL   5E5
....................     // Time Out PTT {{{ 
....................     if ( TOT_SecondCounter || TOT_Min == 0) { 
1726:  MOVLB  01
1727:  MOVF   5E,W
1728:  IORWF  5F,W
1729:  BTFSS  03.2
172A:  GOTO   730
172B:  MOVLB  00
172C:  MOVF   66,F
172D:  BTFSS  03.2
172E:  GOTO   74C
172F:  MOVLB  01
....................       TOT_SecondCounter--; 
1730:  MOVF   5E,W
1731:  BTFSC  03.2
1732:  DECF   5F,F
1733:  DECF   5E,F
....................       if ( TOT_Min && !TOT_SecondCounter ) { 
1734:  MOVLB  00
1735:  MOVF   66,F
1736:  BTFSC  03.2
1737:  GOTO   74B
1738:  MOVLB  01
1739:  MOVF   5E,W
173A:  IORWF  5F,W
173B:  BTFSC  03.2
173C:  GOTO   73F
173D:  MOVLB  00
173E:  GOTO   74B
....................         printf("\n\r# PTT Timeout!\n"); 
173F:  MOVLW  AA
1740:  MOVLB  03
1741:  MOVWF  11
1742:  MOVLW  04
1743:  MOVWF  12
1744:  MOVLP  00
1745:  MOVLB  00
1746:  CALL   4D7
1747:  MOVLP  10
....................         PROMPT_FLAG=1; 
1748:  MOVLB  01
1749:  BSF    60.3
174A:  MOVLB  00
....................       } 
....................     } else if ( COR_IN_EFFECTIVE != 0x00 ) { 
174B:  GOTO   757
174C:  MOVF   72,F
174D:  BTFSC  03.2
174E:  GOTO   757
....................       TOT_FLAG_Mask=COR_IN_EFFECTIVE; 
174F:  MOVF   72,W
1750:  MOVWF  67
....................       update_ptt(0); 
1751:  MOVLB  02
1752:  CLRF   2B
1753:  MOVLP  08
1754:  MOVLB  00
1755:  CALL   360
1756:  MOVLP  10
....................     } 
....................     // }}} 
....................     // Admin mode timeout {{{ 
....................     if ( admin_timer ) { 
1757:  MOVF   75,F
1758:  BTFSC  03.2
1759:  GOTO   75C
....................       admin_timer--; 
175A:  DECF   75,F
....................     } else { 
175B:  GOTO   765
....................       // Exit admin mode. 
....................       if ( AdminMode ) { 
175C:  MOVLB  01
175D:  BTFSS  60.4
175E:  GOTO   766
....................         set_admin_mode(0); 
175F:  MOVLB  02
1760:  CLRF   3D
1761:  MOVLP  08
1762:  MOVLB  00
1763:  CALL   4A9
1764:  MOVLP  10
1765:  MOVLB  01
....................       } 
....................     } 
....................     // }}} 
....................     restart_wdt(); 
1766:  CLRWDT
....................     if ( SecondCounter ) { 
1767:  MOVF   5C,F
1768:  BTFSC  03.2
1769:  GOTO   76C
....................       SecondCounter--; 
176A:  DECF   5C,F
....................     } else { 
176B:  GOTO   76F
....................       SecondCounter=SEC_COUNTER; 
176C:  MOVLW  3B
176D:  MOVWF  5C
....................       MINUTE_FLAG = 1; 
176E:  BSF    74.3
....................     } 
....................     SECOND_FLAG=0; 
176F:  BCF    74.2
1770:  MOVLB  00
....................   } 
....................   // Second Flag }}} 
....................   // Minute flag {{{ 
....................   if ( MINUTE_FLAG ) { 
1771:  BTFSS  74.3
1772:  GOTO   790
....................     if ( MinuteCounter ) { 
1773:  MOVLB  01
1774:  MOVF   5D,F
1775:  BTFSC  03.2
1776:  GOTO   779
....................       MinuteCounter--; 
1777:  DECF   5D,F
....................     } else { 
1778:  GOTO   77C
....................       THIRTY_MIN_FLAG=1; 
1779:  BSF    74.4
....................       MinuteCounter = MIN_COUNTER; 
177A:  MOVLW  1D
177B:  MOVWF  5D
....................     } 
....................     MINUTE_FLAG = 0; 
177C:  BCF    74.3
....................     // Link timeout timer {{{ 
....................     if ( Link_TOT != 0 ) { 
177D:  MOVLB  00
177E:  MOVF   68,F
177F:  BTFSC  03.2
1780:  GOTO   790
....................       if ( LinkDurationTimer ) { 
1781:  MOVF   69,F
1782:  BTFSC  03.2
1783:  GOTO   786
....................         LinkDurationTimer--; 
1784:  DECF   69,F
....................       } else { 
1785:  GOTO   790
....................         // Disable Link 
....................         printf("\n\r# Link Timeout!\n"); 
1786:  MOVLW  B3
1787:  MOVLB  03
1788:  MOVWF  11
1789:  MOVLW  04
178A:  MOVWF  12
178B:  MOVLP  00
178C:  MOVLB  00
178D:  CALL   4D7
178E:  MOVLP  10
....................         Enable&=0xFE; 
178F:  BCF    60.0
....................       } 
....................     } 
....................     // Link timeout timer }}} 
....................   } 
....................   // Minute flag }}} 
....................   if ( THIRTY_MIN_FLAG ) { // {{{ 
1790:  BTFSS  74.4
1791:  GOTO   7A8
....................     if ( (TXSiteID&0x03) !=0 ) { 
1792:  MOVF   64,W
1793:  ANDLW  03
1794:  BTFSC  03.2
1795:  GOTO   7A7
....................       // Transmit Site ID every 30 mins when: 
....................       // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................       // E = Transmit every 30 mins 
....................       // M = Transmit only if EnableMask is off 
....................       if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
1796:  MOVF   64,W
1797:  ANDLW  01
1798:  BTFSS  03.2
1799:  GOTO   7A6
179A:  MOVF   64,W
179B:  ANDLW  02
179C:  BTFSC  03.2
179D:  GOTO   7A7
179E:  SWAPF  64,W
179F:  MOVWF  77
17A0:  MOVLW  0F
17A1:  ANDWF  77,F
17A2:  MOVF   77,W
17A3:  ANDLW  0F
17A4:  ANDWF  60,W
17A5:  BTFSC  03.2
....................         send_morse_id(); 
17A6:  CALL   000
....................       } 
....................     } 
....................     THIRTY_MIN_FLAG=0; 
17A7:  BCF    74.4
....................   } // }}} 
.................... } 
17A8:  MOVLP  18
17A9:  GOTO   6C7 (RETURN)
....................  

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
