CCS PCM C Compiler, Version 4.140, 64991               02-May-20 10:53

               Filename:   C:\Users\Luc\Projects\RC2G Branches\RC2G - Buckingham\Firmware.lst

               ROM used:   7985 words (97%)
                           Largest free fragment is 126
               RAM used:   167 (33%) at main() level
                           234 (46%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   64E
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   357
002D:  MOVLP  00
002E:  GOTO   3C8
002F:  MOVLP  00
0030:  GOTO   2E1
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
1685:  MOVLB  02
1686:  MOVF   29,W
1687:  MOVWF  2D
1688:  MOVF   28,W
1689:  MOVWF  2C
168A:  MOVF   2D,W
168B:  MOVWF  7A
168C:  MOVF   2C,W
168D:  MOVWF  04
168E:  MOVF   7A,W
168F:  MOVWF  05
1690:  MOVF   00,F
1691:  BTFSC  03.2
1692:  GOTO   697
1693:  INCF   2C,F
1694:  BTFSC  03.2
1695:  INCF   2D,F
1696:  GOTO   68A
....................    while(*s2 != '\0') 
....................    { 
1697:  MOVF   2B,W
1698:  MOVWF  7A
1699:  MOVF   2A,W
169A:  MOVWF  04
169B:  MOVF   7A,W
169C:  MOVWF  05
169D:  MOVF   00,F
169E:  BTFSC  03.2
169F:  GOTO   6B3
....................       *s = *s2; 
16A0:  MOVF   2A,W
16A1:  MOVWF  04
16A2:  MOVF   2B,W
16A3:  MOVWF  05
16A4:  MOVF   00,W
16A5:  MOVWF  30
16A6:  MOVF   2D,W
16A7:  MOVWF  05
16A8:  MOVF   2C,W
16A9:  MOVWF  04
16AA:  MOVF   30,W
16AB:  MOVWF  00
....................       ++s; 
16AC:  INCF   2C,F
16AD:  BTFSC  03.2
16AE:  INCF   2D,F
....................       ++s2; 
16AF:  INCF   2A,F
16B0:  BTFSC  03.2
16B1:  INCF   2B,F
....................    } 
16B2:  GOTO   697
....................  
....................    *s = '\0'; 
16B3:  MOVF   2C,W
16B4:  MOVWF  04
16B5:  MOVF   2D,W
16B6:  MOVWF  05
16B7:  CLRF   00
....................    return(s1); 
16B8:  MOVF   28,W
16B9:  MOVWF  78
16BA:  MOVF   29,W
16BB:  MOVWF  79
.................... } 
16BC:  MOVLB  00
16BD:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0EC2:  MOVF   48,W
0EC3:  MOVWF  4C
0EC4:  MOVF   47,W
0EC5:  MOVWF  4B
0EC6:  MOVF   4C,W
0EC7:  MOVWF  7A
0EC8:  MOVF   4B,W
0EC9:  MOVWF  04
0ECA:  MOVF   7A,W
0ECB:  MOVWF  05
0ECC:  MOVF   00,F
0ECD:  BTFSC  03.2
0ECE:  GOTO   6FB
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0ECF:  MOVF   4A,W
0ED0:  MOVWF  4E
0ED1:  MOVF   49,W
0ED2:  MOVWF  4D
0ED3:  MOVF   4E,W
0ED4:  MOVWF  7A
0ED5:  MOVF   4D,W
0ED6:  MOVWF  04
0ED7:  MOVF   7A,W
0ED8:  MOVWF  05
0ED9:  MOVF   00,F
0EDA:  BTFSC  03.2
0EDB:  GOTO   6F7
....................          if (*sc1 == *sc2) 
0EDC:  MOVF   4C,W
0EDD:  MOVWF  7A
0EDE:  MOVF   4B,W
0EDF:  MOVWF  04
0EE0:  MOVF   7A,W
0EE1:  MOVWF  05
0EE2:  MOVF   00,W
0EE3:  MOVWF  4F
0EE4:  MOVF   4E,W
0EE5:  MOVWF  7A
0EE6:  MOVF   4D,W
0EE7:  MOVWF  04
0EE8:  MOVF   7A,W
0EE9:  MOVWF  05
0EEA:  MOVF   00,W
0EEB:  SUBWF  4F,W
0EEC:  BTFSS  03.2
0EED:  GOTO   6F3
....................             return(sc1); 
0EEE:  MOVF   4B,W
0EEF:  MOVWF  78
0EF0:  MOVF   4C,W
0EF1:  MOVWF  79
0EF2:  GOTO   6FE
0EF3:  INCF   4D,F
0EF4:  BTFSC  03.2
0EF5:  INCF   4E,F
0EF6:  GOTO   6D3
0EF7:  INCF   4B,F
0EF8:  BTFSC  03.2
0EF9:  INCF   4C,F
0EFA:  GOTO   6C6
....................    return(0); 
0EFB:  MOVLW  00
0EFC:  MOVWF  78
0EFD:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E5B:  MOVF   48,W
0E5C:  MOVWF  4C
0E5D:  MOVF   47,W
0E5E:  MOVWF  4B
0E5F:  MOVF   4C,W
0E60:  MOVWF  7A
0E61:  MOVF   4B,W
0E62:  MOVWF  04
0E63:  MOVF   7A,W
0E64:  MOVWF  05
0E65:  MOVF   00,F
0E66:  BTFSC  03.2
0E67:  GOTO   699
....................       for (sc2 = s2; ; sc2++) 
0E68:  MOVF   4A,W
0E69:  MOVWF  4E
0E6A:  MOVF   49,W
0E6B:  MOVWF  4D
....................     if (*sc2 == '\0') 
0E6C:  MOVF   4E,W
0E6D:  MOVWF  7A
0E6E:  MOVF   4D,W
0E6F:  MOVWF  04
0E70:  MOVF   7A,W
0E71:  MOVWF  05
0E72:  MOVF   00,F
0E73:  BTFSS  03.2
0E74:  GOTO   67F
....................        return(sc1 - s1); 
0E75:  MOVF   47,W
0E76:  SUBWF  4B,W
0E77:  MOVWF  77
0E78:  MOVF   48,W
0E79:  SUBWFC 4C,W
0E7A:  MOVWF  7A
0E7B:  MOVF   77,W
0E7C:  MOVWF  78
0E7D:  GOTO   6A1
....................          else if (*sc1 == *sc2) 
0E7E:  GOTO   691
0E7F:  MOVF   4C,W
0E80:  MOVWF  7A
0E81:  MOVF   4B,W
0E82:  MOVWF  04
0E83:  MOVF   7A,W
0E84:  MOVWF  05
0E85:  MOVF   00,W
0E86:  MOVWF  4F
0E87:  MOVF   4E,W
0E88:  MOVWF  7A
0E89:  MOVF   4D,W
0E8A:  MOVWF  04
0E8B:  MOVF   7A,W
0E8C:  MOVWF  05
0E8D:  MOVF   00,W
0E8E:  SUBWF  4F,W
0E8F:  BTFSC  03.2
....................             break; 
0E90:  GOTO   695
0E91:  INCF   4D,F
0E92:  BTFSC  03.2
0E93:  INCF   4E,F
0E94:  GOTO   66C
0E95:  INCF   4B,F
0E96:  BTFSC  03.2
0E97:  INCF   4C,F
0E98:  GOTO   65F
....................    return(sc1 - s1); 
0E99:  MOVF   47,W
0E9A:  SUBWF  4B,W
0E9B:  MOVWF  77
0E9C:  MOVF   48,W
0E9D:  SUBWFC 4C,W
0E9E:  MOVWF  7A
0E9F:  MOVF   77,W
0EA0:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1E7C:  MOVLB  00
1E7D:  CLRF   26
1E7E:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0E42:  MOVLB  02
0E43:  MOVF   3F,W
0E44:  IORWF  40,W
0E45:  BTFSC  03.2
0E46:  GOTO   64B
0E47:  MOVF   40,W
0E48:  MOVWF  7A
0E49:  MOVF   3F,W
0E4A:  GOTO   650
0E4B:  MOVLB  00
0E4C:  MOVF   27,W
0E4D:  MOVWF  7A
0E4E:  MOVF   26,W
0E4F:  MOVLB  02
0E50:  MOVWF  43
0E51:  MOVF   7A,W
0E52:  MOVWF  44
....................    beg += strspn(beg, s2); 
0E53:  MOVF   44,W
0E54:  MOVWF  48
0E55:  MOVF   43,W
0E56:  MOVWF  47
0E57:  MOVF   42,W
0E58:  MOVWF  4A
0E59:  MOVF   41,W
0E5A:  MOVWF  49
*
0EA1:  MOVF   78,W
0EA2:  ADDWF  43,F
0EA3:  MOVLW  00
0EA4:  ADDWFC 44,F
....................    if (*beg == '\0') 
0EA5:  MOVF   44,W
0EA6:  MOVWF  7A
0EA7:  MOVF   43,W
0EA8:  MOVWF  04
0EA9:  MOVF   7A,W
0EAA:  MOVWF  05
0EAB:  MOVF   00,F
0EAC:  BTFSS  03.2
0EAD:  GOTO   6BA
....................    { 
....................       *save = ' '; 
0EAE:  MOVLB  00
0EAF:  MOVF   26,W
0EB0:  MOVWF  04
0EB1:  MOVF   27,W
0EB2:  MOVWF  05
0EB3:  MOVLW  20
0EB4:  MOVWF  00
....................       return(0); 
0EB5:  MOVLW  00
0EB6:  MOVWF  78
0EB7:  MOVWF  79
0EB8:  GOTO   71F
0EB9:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0EBA:  MOVF   44,W
0EBB:  MOVWF  48
0EBC:  MOVF   43,W
0EBD:  MOVWF  47
0EBE:  MOVF   42,W
0EBF:  MOVWF  4A
0EC0:  MOVF   41,W
0EC1:  MOVWF  49
*
0EFE:  MOVF   79,W
0EFF:  MOVWF  46
0F00:  MOVF   78,W
0F01:  MOVWF  45
....................    if (*end != '\0') 
0F02:  MOVF   46,W
0F03:  MOVWF  7A
0F04:  MOVF   45,W
0F05:  MOVWF  04
0F06:  MOVF   7A,W
0F07:  MOVWF  05
0F08:  MOVF   00,F
0F09:  BTFSC  03.2
0F0A:  GOTO   713
....................    { 
....................       *end = '\0'; 
0F0B:  MOVF   45,W
0F0C:  MOVWF  04
0F0D:  MOVF   46,W
0F0E:  MOVWF  05
0F0F:  CLRF   00
....................       end++; 
0F10:  INCF   45,F
0F11:  BTFSC  03.2
0F12:  INCF   46,F
....................    } 
....................    save = end; 
0F13:  MOVF   46,W
0F14:  MOVLB  00
0F15:  MOVWF  27
0F16:  MOVLB  02
0F17:  MOVF   45,W
0F18:  MOVLB  00
0F19:  MOVWF  26
....................    return(beg); 
0F1A:  MOVLB  02
0F1B:  MOVF   43,W
0F1C:  MOVWF  78
0F1D:  MOVF   44,W
0F1E:  MOVWF  79
0F1F:  MOVLB  00
.................... } 
0F20:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
1000:  MOVLB  02
1001:  MOVF   40,W
1002:  MOVWF  7A
1003:  MOVF   3F,W
1004:  MOVWF  04
1005:  MOVF   7A,W
1006:  MOVWF  05
1007:  MOVF   00,W
1008:  MOVWF  43
1009:  MOVF   42,W
100A:  MOVWF  7A
100B:  MOVF   41,W
100C:  MOVWF  04
100D:  MOVF   7A,W
100E:  MOVWF  05
100F:  MOVF   00,W
1010:  SUBWF  43,W
1011:  BTFSC  03.2
1012:  GOTO   069
1013:  MOVF   40,W
1014:  MOVWF  7A
1015:  MOVF   3F,W
1016:  MOVWF  04
1017:  MOVF   7A,W
1018:  MOVWF  05
1019:  MOVF   00,W
101A:  MOVWF  43
101B:  MOVF   43,W
101C:  SUBLW  40
101D:  BTFSC  03.0
101E:  GOTO   023
101F:  MOVF   43,W
1020:  SUBLW  5A
1021:  BTFSC  03.0
1022:  GOTO   02B
1023:  MOVF   43,W
1024:  SUBLW  60
1025:  BTFSC  03.0
1026:  GOTO   07F
1027:  MOVF   43,W
1028:  SUBLW  7A
1029:  BTFSS  03.0
102A:  GOTO   07F
102B:  MOVF   42,W
102C:  MOVWF  7A
102D:  MOVF   41,W
102E:  MOVWF  04
102F:  MOVF   7A,W
1030:  MOVWF  05
1031:  MOVF   00,W
1032:  MOVWF  43
1033:  MOVF   43,W
1034:  SUBLW  40
1035:  BTFSC  03.0
1036:  GOTO   03B
1037:  MOVF   43,W
1038:  SUBLW  5A
1039:  BTFSC  03.0
103A:  GOTO   043
103B:  MOVF   43,W
103C:  SUBLW  60
103D:  BTFSC  03.0
103E:  GOTO   07F
103F:  MOVF   43,W
1040:  SUBLW  7A
1041:  BTFSS  03.0
1042:  GOTO   07F
1043:  MOVF   40,W
1044:  MOVWF  7A
1045:  MOVF   3F,W
1046:  MOVWF  04
1047:  MOVF   7A,W
1048:  MOVWF  05
1049:  MOVF   00,W
104A:  MOVWF  43
104B:  MOVF   42,W
104C:  MOVWF  7A
104D:  MOVF   41,W
104E:  MOVWF  04
104F:  MOVF   7A,W
1050:  MOVWF  05
1051:  MOVLW  20
1052:  ADDWF  00,W
1053:  SUBWF  43,W
1054:  BTFSC  03.2
1055:  GOTO   069
1056:  MOVF   42,W
1057:  MOVWF  7A
1058:  MOVF   41,W
1059:  MOVWF  04
105A:  MOVF   7A,W
105B:  MOVWF  05
105C:  MOVF   00,W
105D:  MOVWF  43
105E:  MOVF   40,W
105F:  MOVWF  7A
1060:  MOVF   3F,W
1061:  MOVWF  04
1062:  MOVF   7A,W
1063:  MOVWF  05
1064:  MOVLW  20
1065:  ADDWF  00,W
1066:  SUBWF  43,W
1067:  BTFSS  03.2
1068:  GOTO   07F
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
1069:  MOVF   40,W
106A:  MOVWF  7A
106B:  MOVF   3F,W
106C:  MOVWF  04
106D:  MOVF   7A,W
106E:  MOVWF  05
106F:  MOVF   00,F
1070:  BTFSS  03.2
1071:  GOTO   075
....................        return(0); 
1072:  MOVLW  00
1073:  MOVWF  78
1074:  GOTO   095
1075:  MOVF   40,W
1076:  MOVWF  7A
1077:  MOVF   3F,W
1078:  INCF   3F,F
1079:  BTFSC  03.2
107A:  INCF   40,F
107B:  INCF   41,F
107C:  BTFSC  03.2
107D:  INCF   42,F
107E:  GOTO   001
....................  return((*s1 < *s2) ? -1: 1); 
107F:  MOVF   40,W
1080:  MOVWF  7A
1081:  MOVF   3F,W
1082:  MOVWF  04
1083:  MOVF   40,W
1084:  MOVWF  05
1085:  MOVF   00,W
1086:  MOVWF  43
1087:  MOVF   42,W
1088:  MOVWF  7A
1089:  MOVF   41,W
108A:  MOVWF  04
108B:  MOVF   42,W
108C:  MOVWF  05
108D:  MOVF   00,W
108E:  SUBWF  43,W
108F:  BTFSC  03.0
1090:  GOTO   093
1091:  MOVLW  FF
1092:  GOTO   094
1093:  MOVLW  01
1094:  MOVWF  78
.................... } 
1095:  MOVLB  00
1096:  RETURN
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
08C6:  MOVLW  20
08C7:  MOVWF  05
08C8:  MOVLW  CA
08C9:  MOVWF  04
08CA:  MOVF   00,W
08CB:  BTFSC  03.2
08CC:  GOTO   0DE
08CD:  MOVLW  02
08CE:  MOVWF  78
08CF:  MOVLW  BF
08D0:  MOVWF  77
08D1:  CLRWDT
08D2:  DECFSZ 77,F
08D3:  GOTO   0D1
08D4:  DECFSZ 78,F
08D5:  GOTO   0CF
08D6:  MOVLW  96
08D7:  MOVWF  77
08D8:  DECFSZ 77,F
08D9:  GOTO   0D8
08DA:  GOTO   0DB
08DB:  CLRWDT
08DC:  DECFSZ 00,F
08DD:  GOTO   0CD
08DE:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
0769:  MOVLB  04
076A:  BCF    15.7
076B:  MOVLB  00
076C:  BCF    11.3
076D:  MOVLB  02
076E:  MOVF   50,W
076F:  MOVLB  04
0770:  MOVWF  11
0771:  MOVLW  02
0772:  BTFSC  15.7
0773:  GOTO   77B
0774:  MOVLB  00
0775:  BTFSS  11.3
0776:  GOTO   775
0777:  MOVLW  00
0778:  MOVLB  04
0779:  BTFSC  16.6
077A:  MOVLW  01
077B:  MOVWF  78
077C:  MOVLB  00
077D:  RETURN
*
0B65:  MOVLB  04
0B66:  BCF    15.6
0B67:  BSF    16.3
0B68:  BTFSC  16.3
0B69:  GOTO   368
0B6A:  BTFSC  77.0
0B6B:  BCF    16.5
0B6C:  BTFSS  77.0
0B6D:  BSF    16.5
0B6E:  BSF    16.4
0B6F:  BTFSC  16.4
0B70:  GOTO   36F
0B71:  MOVF   11,W
0B72:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02DA:  CLRWDT
02DB:  BTFSS  11.4
02DC:  GOTO   2DA
02DD:  MOVLB  03
02DE:  MOVWF  1A
02DF:  MOVLB  00
02E0:  RETURN
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void send_tail(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN; 
.................... unsigned int Enable,Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned int TOT_Min; 
.................... unsigned int COR_EMUL; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 240  
.................... char admin_timer; 
.................... // Admin args: 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... //#define DTMF_SEND_OLD 10 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR0 0x01 
.................... #define AUX_OUT_FOLLOW_COR1 0x02 
.................... #define AUX_OUT_FOLLOW_COR2 0x04 
.................... #define AUX_OUT_FOLLOW_COR3 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT0 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x10 
.................... #define AUXI_EMULATE_COR0 0x01 
.................... #define AUXI_EMULATE_COR1 0x02 
.................... #define AUXI_EMULATE_COR2 0x04 
.................... #define AUXI_EMULATE_COR3 0x08 
....................  
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... #define LCD_I2C_ADD 0x60 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... char command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... unsigned int  LastRegisterIndex; 
.................... unsigned int  LastRegisterIndexValid; 
....................  
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101 // z (dah dah dit dit)	35 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... //	int      reg_name_index; 
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1       COR_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... unsigned long TOT_SecondCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... #define PTT_TIMEOUT_SECS 60 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
....................  
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... #ifndef GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... // ENABLE_DEFAULT <Morse Enable [3:0]>,<COR_ENABLE[3:0]> 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 
.................... 	{"XI2"},	  // 19 
.................... 	{"XI3"},	  // 20 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"COR"},  // 54 
....................     {"CPOT"}  // 55 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
....................  
.................... #define SITE_ID_VAL  	52 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... // ENABLE_DEFAULT <Morse Enable [3:0]>,<COR_ENABLE[3:0]> 
.................... #define ENABLE_DEFAULT 0xEF 
.................... #define TOT_MIN 5 
.................... #define DEFAULT_GAIN 22 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('e') 
.................... #define MORSEID5	MCHAR('h') 
....................  
.................... #define AUXOUTOP0  AUX_OUT_FOLLOW_COR 
.................... #define AUXOUTARG0 AUX_OUT_FOLLOW_COR0 | AUX_OUT_FOLLOW_COR_INVERT0 
.................... #define AUXOUTOP1  0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2  0 
.................... #define AUXOUTARG2 0 
....................  
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  AUXI_EMULATE_COR 
.................... #define AUXINARG0 AUXI_EMULATE_COR0 | AUXI_EMULATE_COR_ACTIVE_LO 
.................... #define AUXINOP1  AUXI_TAIL_WHEN_HI 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
....................  
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT,EEPROM}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL,EEPROM}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&AuxIn[0]      ,0           , EEPROM}, 
.................... 	{&AuxIn[1]      ,0           , EEPROM}, 
.................... 	{&AuxIn[2]      ,0           , EEPROM}, 
.................... 	{&AuxOut[0]     ,0           , EEPROM}, 
.................... 	{&AuxOut[1]     ,0           , EEPROM}, 
.................... 	{&AuxOut[2]     ,0           , EEPROM}, 
.................... 	{&RXPriority[0] ,2           , EEPROM}, 
.................... 	{&RXPriority[1] ,6           , EEPROM}, 
.................... 	{&RXPriority[2] ,4           , EEPROM}, 
.................... 	{&RXPriority[3] ,4           , EEPROM}, 
.................... 	{&RX_PTT[0]     ,0x0E        , EEPROM}, 
.................... 	{&RX_PTT[1]     ,0x0D        , EEPROM}, 
.................... 	{&RX_PTT[2]     ,0x0B        , EEPROM}, 
.................... 	{&RX_PTT[3]     ,0x07        , EEPROM}, 
.................... 	{&SiteID        ,SITE_ID_VAL , EEPROM}, 
.................... 	{&TXSiteID      ,0x12        , EEPROM}, 
....................   {&Morse[0]      ,MCHAR('v')  , EEPROM}, 
....................   {&Morse[1]      ,MCHAR('e')  , EEPROM}, 
....................   {&Morse[2]      ,2           , EEPROM}, 
....................   {&Morse[3]      ,MCHAR('r')  , EEPROM}, 
....................   {&Morse[4]      ,MCHAR('e')  , EEPROM}, 
....................   {&Morse[5]      ,MCHAR('h')  , EEPROM}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0   , EEPROM}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1   , EEPROM}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2   , EEPROM}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0  , EEPROM}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1  , EEPROM}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2  , EEPROM}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0    , EEPROM}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1    , EEPROM}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2    , EEPROM}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0   , EEPROM}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1   , EEPROM}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2   , EEPROM}, 
....................   {&Tail          ,TAIL_CHAR   , EEPROM}, 
....................   {&TOT_Min       ,TOT_MIN     , EEPROM}, 
.................... 	{&COR_EMUL      ,0x00        , RAM}, 
.................... 	{&CurrentTrimPot,0x00        , RAM}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02E1:  BTFSS  11.5
02E2:  GOTO   338
....................     c = getc(); 
02E3:  CLRWDT
02E4:  BTFSS  11.5
02E5:  GOTO   2E3
02E6:  MOVLB  03
02E7:  MOVF   19,W
02E8:  MOVLB  02
02E9:  MOVWF  55
....................     if ( c == '\b' ) { 
02EA:  MOVF   55,W
02EB:  SUBLW  08
02EC:  BTFSS  03.2
02ED:  GOTO   316
....................       if ( sBufferIndex > 0 ) { 
02EE:  MOVF   71,F
02EF:  BTFSC  03.2
02F0:  GOTO   310
....................         sBufferIndex--; 
02F1:  DECF   71,F
....................         sBuffer[sBufferIndex]='\0'; 
02F2:  MOVLW  4D
02F3:  ADDWF  71,W
02F4:  MOVWF  04
02F5:  MOVLW  20
02F6:  MOVWF  05
02F7:  BTFSC  03.0
02F8:  INCF   05,F
02F9:  CLRF   00
....................         putc('\b'); 
02FA:  MOVLW  08
02FB:  MOVLB  00
02FC:  CALL   2DA
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
02FD:  MOVLW  1B
02FE:  CALL   2DA
....................   printf("[K"); 
02FF:  MOVLW  5B
0300:  CLRWDT
0301:  BTFSS  11.4
0302:  GOTO   300
0303:  MOVLB  03
0304:  MOVWF  1A
0305:  MOVLW  4B
0306:  CLRWDT
0307:  MOVLB  00
0308:  BTFSC  11.4
0309:  GOTO   30C
030A:  MOVLB  03
030B:  GOTO   306
030C:  MOVLB  03
030D:  MOVWF  1A
....................       } else { 
030E:  GOTO   314
030F:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
0310:  MOVLW  07
0311:  MOVLB  00
0312:  CALL   2DA
0313:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
0314:  GOTO   33A
0315:  MOVLB  02
0316:  MOVF   71,W
0317:  SUBLW  0F
0318:  BTFSS  03.0
0319:  GOTO   335
....................       putc(c); // echo the character 
031A:  MOVF   55,W
031B:  MOVLB  00
031C:  CALL   2DA
....................       sBuffer[sBufferIndex++] = c; 
031D:  MOVF   71,W
031E:  INCF   71,F
031F:  ADDLW  4D
0320:  MOVWF  04
0321:  MOVLW  20
0322:  MOVWF  05
0323:  BTFSC  03.0
0324:  INCF   05,F
0325:  MOVLB  02
0326:  MOVF   55,W
0327:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0328:  MOVF   55,W
0329:  SUBLW  0D
032A:  BTFSC  03.2
032B:  GOTO   333
032C:  MOVF   55,W
032D:  SUBLW  2B
032E:  BTFSC  03.2
032F:  GOTO   333
0330:  MOVF   55,W
0331:  SUBLW  2D
0332:  BTFSC  03.2
....................         sBufferFlag=1; 
0333:  BSF    72.0
....................       } 
....................     } else { 
0334:  GOTO   339
....................       putc('\a'); // Send alert. Avoid buffer overflow 
0335:  MOVLW  07
0336:  MOVLB  00
0337:  CALL   2DA
0338:  MOVLB  02
0339:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
....................  
033A:  MOVLB  00
033B:  BCF    11.5
033C:  MOVLP  00
033D:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   int value,dtmf_status; 
....................   int LAST_COR_IN; 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if(IOCBF&0x0F) { // Check for interrupts on RB[3:0] only 
*
0357:  MOVLB  07
0358:  MOVF   16,W
0359:  ANDLW  0F
035A:  BTFSC  03.2
035B:  GOTO   36D
....................     LAST_COR_IN=COR_IN; 
035C:  MOVLB  00
035D:  MOVF   5F,W
035E:  MOVLB  02
035F:  MOVWF  57
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
0360:  MOVLB  00
0361:  MOVF   0D,W
0362:  XORWF  62,W
0363:  ANDLW  0F
0364:  MOVWF  5F
....................     if ( LAST_COR_IN != COR_IN ) { 
0365:  MOVF   5F,W
0366:  MOVLB  02
0367:  SUBWF  57,W
0368:  BTFSS  03.2
....................       COR_FLAG = 1; 
0369:  BSF    72.1
....................     } 
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
036A:  MOVLW  F0
036B:  MOVLB  07
036C:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
036D:  BTFSS  0B.0
036E:  GOTO   3BF
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     dtmf_status = dtmf_read(CONTROL_REG); 
036F:  MOVLW  01
0370:  MOVLB  02
0371:  MOVWF  58
0372:  MOVLB  00
0373:  CALL   33E
0374:  MOVF   78,W
0375:  MOVLB  02
0376:  MOVWF  56
....................     if ( dtmf_status & DTMF_BUFFER_FULL) { 
0377:  BTFSS  56.2
0378:  GOTO   3BD
....................       value=dtmf_read(DATA_REG); 
0379:  CLRF   58
037A:  MOVLB  00
037B:  CALL   33E
037C:  MOVF   78,W
037D:  MOVLB  02
037E:  MOVWF  55
....................       DTMF_IN_FLAG=1; 
037F:  MOVLB  01
0380:  BSF    5B.0
....................       if ( value == dd ) { 
0381:  MOVLB  02
0382:  MOVF   55,F
0383:  BTFSS  03.2
0384:  GOTO   388
....................         value=d0; 
0385:  MOVLW  0A
0386:  MOVWF  55
....................       } else if ( value == d0 ) { 
0387:  GOTO   38C
0388:  MOVF   55,W
0389:  SUBLW  0A
038A:  BTFSC  03.2
....................         value=dd; 
038B:  CLRF   55
....................       } 
....................       // Check for '#' 
....................       if ( value == dp ) { 
038C:  MOVF   55,W
038D:  SUBLW  0C
038E:  BTFSS  03.2
038F:  GOTO   39A
....................         DTMF_FLAG = 1; 
0390:  BSF    72.7
....................         DTMF_ptr->Last=1; 
0391:  MOVLB  01
0392:  MOVF   3B,W
0393:  MOVWF  04
0394:  MOVF   3C,W
0395:  MOVWF  05
0396:  ADDFSR 00,FSR0
0397:  BSF    00.5
....................       } else { 
0398:  GOTO   3BC
0399:  MOVLB  02
....................         if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
039A:  MOVLB  01
039B:  MOVF   3C,W
039C:  SUBLW  20
039D:  BTFSS  03.0
039E:  GOTO   3BC
039F:  BTFSS  03.2
03A0:  GOTO   3A5
03A1:  MOVF   3B,W
03A2:  SUBLW  6A
03A3:  BTFSS  03.0
03A4:  GOTO   3BC
....................           DTMF_ptr->Key=value; 
03A5:  MOVF   3B,W
03A6:  MOVWF  04
03A7:  MOVF   3C,W
03A8:  MOVWF  05
03A9:  ADDFSR 00,FSR0
03AA:  MOVLB  02
03AB:  MOVF   55,W
03AC:  ANDLW  0F
03AD:  MOVWF  77
03AE:  MOVLW  F0
03AF:  ANDWF  00,W
03B0:  IORWF  77,W
03B1:  MOVWF  00
....................           DTMF_ptr->Strobe=1; 
03B2:  MOVLB  01
03B3:  MOVF   3B,W
03B4:  MOVWF  04
03B5:  MOVF   3C,W
03B6:  MOVWF  05
03B7:  ADDFSR 00,FSR0
03B8:  BSF    00.4
....................           DTMF_ptr++; 
03B9:  INCF   3B,F
03BA:  BTFSC  03.2
03BB:  INCF   3C,F
03BC:  MOVLB  02
....................         } 
....................       } 
....................     } 
....................   clear_interrupt(INT_RB4_H2L); 
03BD:  MOVLB  07
03BE:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
03BF:  BTFSS  0B.0
03C0:  GOTO   3C4
....................     AUX_IN_FLAG=1; 
03C1:  BSF    72.6
....................     clear_interrupt(INT_RB6|INT_RB7); 
03C2:  MOVLW  3F
03C3:  ANDWF  16,F
....................   } 
.................... } // }}} 
....................  
03C4:  BCF    0B.0
03C5:  MOVLP  00
03C6:  MOVLB  00
03C7:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
03C8:  MOVLB  01
03C9:  MOVF   2D,W
03CA:  IORWF  2E,W
03CB:  BTFSC  03.2
03CC:  GOTO   3D2
....................     rtcc_cnt--; 
03CD:  MOVF   2D,W
03CE:  BTFSC  03.2
03CF:  DECF   2E,F
03D0:  DECF   2D,F
....................   } else { 
03D1:  GOTO   3DE
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
03D2:  MOVLB  00
03D3:  MOVF   0D,W
03D4:  XORWF  62,W
03D5:  ANDLW  0F
03D6:  MOVWF  5F
....................     COR_FLAG=1; 
03D7:  BSF    72.1
....................     SECOND_FLAG=1; 
03D8:  BSF    72.2
....................     AUX_IN_FLAG=1; 
03D9:  BSF    72.6
....................     rtcc_cnt=30; 
03DA:  MOVLB  01
03DB:  CLRF   2E
03DC:  MOVLW  1E
03DD:  MOVWF  2D
....................   } 
....................   if (aux_timer ) { 
03DE:  MOVF   2F,W
03DF:  IORWF  30,W
03E0:  BTFSC  03.2
03E1:  GOTO   3E6
....................     aux_timer--; 
03E2:  MOVF   2F,W
03E3:  BTFSC  03.2
03E4:  DECF   30,F
03E5:  DECF   2F,F
....................   } 
.................... } // }}} 
....................  
03E6:  BCF    0B.2
03E7:  MOVLP  00
03E8:  MOVLB  00
03E9:  GOTO   020
.................... int1 warn_no_lcd = 1; 
.................... void lcd_send(int line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
*
0A52:  BCF    03.0
0A53:  MOVLB  02
0A54:  RLF    4A,W
0A55:  ANDLW  0E
0A56:  IORLW  60
0A57:  MOVWF  4D
....................   i2c_start(); 
0A58:  MOVLB  04
0A59:  BSF    16.0
0A5A:  BTFSC  16.0
0A5B:  GOTO   25A
....................   ack=i2c_write(lcd_cmd); 
0A5C:  MOVLB  02
0A5D:  MOVF   4D,W
0A5E:  MOVWF  50
0A5F:  MOVLP  00
0A60:  MOVLB  00
0A61:  CALL   769
0A62:  MOVLP  08
0A63:  MOVF   78,W
0A64:  MOVLB  02
0A65:  BCF    4E.0
0A66:  BTFSC  78.0
0A67:  BSF    4E.0
....................   if ( ack!=0 ) { 
0A68:  BTFSS  4E.0
0A69:  GOTO   28A
....................     if ( warn_no_lcd ) { 
0A6A:  MOVLB  01
0A6B:  BTFSS  5B.5
0A6C:  GOTO   288
....................       printf("\n\rI2C ERROR : No ACK from LCD : %u",ack); 
0A6D:  MOVLW  00
0A6E:  MOVLB  02
0A6F:  BTFSC  4E.0
0A70:  MOVLW  01
0A71:  MOVWF  4F
0A72:  MOVLW  EA
0A73:  MOVLB  03
0A74:  MOVWF  11
0A75:  MOVLW  03
0A76:  MOVWF  12
0A77:  BCF    03.0
0A78:  MOVLW  20
0A79:  MOVLB  02
0A7A:  MOVWF  50
0A7B:  MOVLP  00
0A7C:  MOVLB  00
0A7D:  CALL   77E
0A7E:  MOVLP  08
0A7F:  MOVLB  02
0A80:  MOVF   4F,W
0A81:  MOVWF  50
0A82:  MOVLW  1B
0A83:  MOVWF  51
0A84:  MOVLB  00
0A85:  CALL   000
....................       warn_no_lcd = 0; 
0A86:  MOVLB  01
0A87:  BCF    5B.5
....................     } 
....................   } else { 
0A88:  GOTO   28C
0A89:  MOVLB  02
....................     warn_no_lcd = 1; 
0A8A:  MOVLB  01
0A8B:  BSF    5B.5
....................   } 
....................   while(*s) { 
0A8C:  MOVLB  02
0A8D:  MOVF   4C,W
0A8E:  MOVWF  7A
0A8F:  MOVF   4B,W
0A90:  MOVWF  04
0A91:  MOVF   7A,W
0A92:  MOVWF  05
0A93:  MOVF   00,F
0A94:  BTFSC  03.2
0A95:  GOTO   2A9
....................     i2c_write(*s++); 
0A96:  MOVF   4C,W
0A97:  MOVWF  7A
0A98:  MOVF   4B,W
0A99:  INCF   4B,F
0A9A:  BTFSC  03.2
0A9B:  INCF   4C,F
0A9C:  MOVWF  04
0A9D:  MOVF   7A,W
0A9E:  MOVWF  05
0A9F:  MOVF   00,W
0AA0:  MOVWF  4F
0AA1:  MOVWF  50
0AA2:  MOVLP  00
0AA3:  MOVLB  00
0AA4:  CALL   769
0AA5:  MOVLP  08
....................   } 
0AA6:  MOVLB  01
0AA7:  GOTO   28C
0AA8:  MOVLB  02
....................   i2c_write(0); // EOL 
0AA9:  CLRF   50
0AAA:  MOVLP  00
0AAB:  MOVLB  00
0AAC:  CALL   769
0AAD:  MOVLP  08
....................   i2c_stop(); 
0AAE:  MOVLB  04
0AAF:  BSF    16.2
0AB0:  BTFSC  16.2
0AB1:  GOTO   2B0
.................... #endif 
.................... } // }}} 
0AB2:  MOVLB  00
0AB3:  RETURN
....................  
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
1163:  MOVF   70,F
1164:  BTFSC  03.2
1165:  GOTO   1C7
....................     printf("\n\rProcessing Command:"); 
1166:  MOVLW  FC
1167:  MOVLB  03
1168:  MOVWF  11
1169:  MOVLW  03
116A:  MOVWF  12
116B:  MOVLP  00
116C:  MOVLB  00
116D:  CALL   55C
116E:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
116F:  MOVLW  07
1170:  MOVLB  03
1171:  MOVWF  11
1172:  MOVLW  04
1173:  MOVWF  12
1174:  BCF    03.0
1175:  MOVLW  0E
1176:  MOVLB  02
1177:  MOVWF  50
1178:  MOVLP  00
1179:  MOVLB  00
117A:  CALL   77E
117B:  MOVLP  10
117C:  MOVF   63,W
117D:  MOVLB  02
117E:  MOVWF  50
117F:  MOVLW  1B
1180:  MOVWF  51
1181:  MOVLP  08
1182:  MOVLB  00
1183:  CALL   000
1184:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
1185:  MOVLW  10
1186:  MOVLB  03
1187:  MOVWF  11
1188:  MOVLW  04
1189:  MOVWF  12
118A:  BCF    03.0
118B:  MOVLW  0E
118C:  MOVLB  02
118D:  MOVWF  50
118E:  MOVLP  00
118F:  MOVLB  00
1190:  CALL   77E
1191:  MOVLP  10
1192:  MOVF   70,W
1193:  MOVLB  02
1194:  MOVWF  50
1195:  MOVLW  1B
1196:  MOVWF  51
1197:  MOVLP  08
1198:  MOVLB  00
1199:  CALL   000
119A:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
119B:  MOVLW  19
119C:  MOVLB  03
119D:  MOVWF  11
119E:  MOVLW  04
119F:  MOVWF  12
11A0:  BCF    03.0
11A1:  MOVLW  0E
11A2:  MOVLB  02
11A3:  MOVWF  50
11A4:  MOVLP  00
11A5:  MOVLB  00
11A6:  CALL   77E
11A7:  MOVLP  10
11A8:  MOVF   75,W
11A9:  MOVLB  02
11AA:  MOVWF  50
11AB:  MOVLW  1B
11AC:  MOVWF  51
11AD:  MOVLP  08
11AE:  MOVLB  00
11AF:  CALL   000
11B0:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
11B1:  MOVLW  22
11B2:  MOVLB  03
11B3:  MOVWF  11
11B4:  MOVLW  04
11B5:  MOVWF  12
11B6:  BCF    03.0
11B7:  MOVLW  0E
11B8:  MOVLB  02
11B9:  MOVWF  50
11BA:  MOVLP  00
11BB:  MOVLB  00
11BC:  CALL   77E
11BD:  MOVLP  10
11BE:  MOVF   76,W
11BF:  MOVLB  02
11C0:  MOVWF  50
11C1:  MOVLW  1B
11C2:  MOVWF  51
11C3:  MOVLP  08
11C4:  MOVLB  00
11C5:  CALL   000
11C6:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
11C7:  MOVLW  02
11C8:  SUBWF  70,W
11C9:  ADDLW  F5
11CA:  BTFSC  03.0
11CB:  GOTO   5A5
11CC:  ADDLW  0B
11CD:  GOTO   5A6
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
1287:  GOTO   5A5
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
1288:  RLF    75,W
1289:  MOVWF  77
128A:  RLF    77,F
128B:  MOVLW  FC
128C:  ANDWF  77,F
128D:  MOVF   77,W
128E:  MOVLB  02
128F:  MOVWF  2C
1290:  INCF   2C,W
1291:  MOVLP  00
1292:  MOVLB  00
1293:  CALL   043
1294:  MOVLP  10
1295:  MOVWF  7A
1296:  MOVLB  02
1297:  MOVF   2C,W
1298:  MOVLP  00
1299:  MOVLB  00
129A:  CALL   043
129B:  MOVLP  10
129C:  MOVLB  02
129D:  MOVWF  20
129E:  MOVF   7A,W
129F:  MOVWF  21
....................       LastRegisterIndex = argument; 
12A0:  MOVF   75,W
12A1:  MOVWF  7C
....................       LastRegisterIndexValid=1; 
12A2:  MOVLW  01
12A3:  MOVWF  7D
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
12A4:  MOVLW  01
12A5:  MOVWF  7A
12A6:  MOVLW  8B
12A7:  MOVWF  2C
12A8:  MOVF   7A,W
12A9:  MOVWF  2D
12AA:  CLRF   2F
12AB:  MOVF   75,W
12AC:  MOVWF  2E
12AD:  MOVF   2F,W
12AE:  MOVWF  3E
12AF:  MOVF   2E,W
12B0:  MOVWF  3D
12B1:  CLRF   40
12B2:  MOVLW  06
12B3:  MOVWF  3F
12B4:  MOVLP  08
12B5:  MOVLB  00
12B6:  CALL   781
12B7:  MOVLP  10
12B8:  MOVF   78,W
12B9:  MOVLB  02
12BA:  ADDWF  2C,W
12BB:  MOVWF  24
12BC:  MOVF   79,W
12BD:  ADDWFC 2D,W
12BE:  MOVWF  25
....................       romstrcpy(rname,cPtr); 
12BF:  MOVLW  20
12C0:  MOVWF  3C
12C1:  MOVLW  A6
12C2:  MOVWF  3B
12C3:  MOVF   25,W
12C4:  MOVWF  3E
12C5:  MOVF   24,W
12C6:  MOVWF  3D
12C7:  MOVLP  08
12C8:  MOVLB  00
12C9:  CALL   798
12CA:  MOVLP  10
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
12CB:  MOVLB  02
12CC:  MOVF   21,W
12CD:  MOVWF  7A
12CE:  MOVF   20,W
12CF:  MOVWF  04
12D0:  MOVF   21,W
12D1:  MOVWF  05
12D2:  MOVF   00,W
12D3:  MOVWF  2C
12D4:  MOVLW  20
12D5:  MOVLB  01
12D6:  MOVWF  5D
12D7:  MOVLW  73
12D8:  MOVWF  5C
12D9:  MOVLW  5B
12DA:  MOVLB  02
12DB:  MOVWF  50
12DC:  MOVLP  08
12DD:  MOVLB  00
12DE:  CALL   1DB
12DF:  MOVLP  10
12E0:  MOVF   75,W
12E1:  MOVLB  02
12E2:  MOVWF  2D
12E3:  MOVLW  01
12E4:  MOVWF  2E
12E5:  MOVLB  00
12E6:  CALL   0D8
12E7:  MOVLW  5D
12E8:  MOVLB  02
12E9:  MOVWF  50
12EA:  MOVLP  08
12EB:  MOVLB  00
12EC:  CALL   1DB
12ED:  MOVLP  10
12EE:  MOVLW  20
12EF:  MOVLB  02
12F0:  MOVWF  50
12F1:  MOVLP  08
12F2:  MOVLB  00
12F3:  CALL   1DB
12F4:  MOVLP  10
12F5:  MOVLW  20
12F6:  MOVWF  05
12F7:  MOVLW  A6
12F8:  MOVWF  04
12F9:  MOVLP  08
12FA:  CALL   23D
12FB:  MOVLP  10
12FC:  MOVLW  20
12FD:  MOVLB  02
12FE:  MOVWF  50
12FF:  MOVLP  08
1300:  MOVLB  00
1301:  CALL   1DB
1302:  MOVLP  10
1303:  MOVLB  02
1304:  MOVF   2C,W
1305:  MOVWF  2D
1306:  MOVLW  1B
1307:  MOVWF  2E
1308:  MOVLB  00
1309:  CALL   0D8
130A:  MOVLW  0A
130B:  MOVLB  02
130C:  MOVWF  50
130D:  MOVLP  08
130E:  MOVLB  00
130F:  CALL   1DB
1310:  MOVLP  10
1311:  MOVLW  0D
1312:  MOVLB  02
1313:  MOVWF  50
1314:  MOVLP  08
1315:  MOVLB  00
1316:  CALL   1DB
1317:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
1318:  MOVLW  0A
1319:  CLRWDT
131A:  BTFSS  11.4
131B:  GOTO   319
131C:  MOVLB  03
131D:  MOVWF  1A
131E:  MOVLW  0D
131F:  CLRWDT
1320:  MOVLB  00
1321:  BTFSC  11.4
1322:  GOTO   325
1323:  MOVLB  03
1324:  GOTO   31F
1325:  MOVLB  03
1326:  MOVWF  1A
1327:  MOVLW  20
1328:  MOVWF  05
1329:  MOVLW  73
132A:  MOVWF  04
132B:  MOVLP  08
132C:  MOVLB  00
132D:  CALL   31B
132E:  MOVLP  10
....................       lcd_send(2,LCD_str); 
132F:  MOVLW  02
1330:  MOVLB  02
1331:  MOVWF  4A
1332:  MOVLW  20
1333:  MOVWF  4C
1334:  MOVLW  73
1335:  MOVWF  4B
1336:  MOVLP  08
1337:  MOVLB  00
1338:  CALL   252
1339:  MOVLP  10
....................       prompt(); 
133A:  MOVLP  08
133B:  CALL   7D5
133C:  MOVLP  10
....................       break; 
133D:  GOTO   5A5
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
133E:  MOVLP  08
133F:  CALL   7C1
1340:  MOVLP  10
1341:  MOVF   78,F
1342:  BTFSC  03.2
1343:  GOTO   347
....................         store_variables(); 
1344:  MOVLP  00
1345:  CALL   674
1346:  MOVLP  10
....................       } 
....................       break; 
1347:  GOTO   5A5
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
1348:  DECFSZ 76,W
1349:  GOTO   34E
....................         init_src=USE_EEPROM_VARS; 
134A:  MOVLB  02
134B:  BSF    22.0
....................       } else { 
134C:  GOTO   350
134D:  MOVLB  00
....................         init_src=USE_DEFAULT_VARS; 
134E:  MOVLB  02
134F:  BCF    22.0
....................       } 
....................       if ( in_admin_mode() ) { 
1350:  MOVLP  08
1351:  MOVLB  00
1352:  CALL   7C1
1353:  MOVLP  10
1354:  MOVF   78,F
1355:  BTFSC  03.2
1356:  GOTO   361
....................         init_variables(init_src); 
1357:  MOVLW  00
1358:  MOVLB  02
1359:  BTFSC  22.0
135A:  MOVLW  01
135B:  MOVWF  2C
135C:  MOVWF  2D
135D:  MOVLP  00
135E:  MOVLB  00
135F:  CALL   6EF
1360:  MOVLP  10
....................       } 
....................       break; 
1361:  GOTO   5A5
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1362:  MOVF   75,W
1363:  ANDLW  03
1364:  MOVWF  74
....................       increment(value); 
1365:  MOVF   76,W
1366:  MOVLB  02
1367:  MOVWF  2F
1368:  MOVLB  00
1369:  CALL   097
....................       PROMPT_FLAG=1; 
136A:  MOVLB  01
136B:  BSF    5B.2
....................       break; 
136C:  MOVLB  00
136D:  GOTO   5A5
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
136E:  MOVF   75,W
136F:  ANDLW  03
1370:  MOVWF  74
....................       increment(-1*value); 
1371:  MOVLW  FF
1372:  MOVLB  02
1373:  MOVWF  43
1374:  MOVF   76,W
1375:  MOVWF  44
1376:  MOVLP  08
1377:  MOVLB  00
1378:  CALL   721
1379:  MOVLP  10
137A:  MOVF   78,W
137B:  MOVLB  02
137C:  MOVWF  2C
137D:  MOVWF  2F
137E:  MOVLB  00
137F:  CALL   097
....................       PROMPT_FLAG=1; 
1380:  MOVLB  01
1381:  BSF    5B.2
....................       break; 
1382:  MOVLB  00
1383:  GOTO   5A5
....................     case STATUS: 
....................       status(); 
....................       break; 
*
1520:  MOVLB  00
1521:  GOTO   5A5
....................     case ADMIN: 
....................       switch(argument) { 
1522:  MOVF   75,W
1523:  XORLW  02
1524:  BTFSC  03.2
1525:  GOTO   52D
1526:  XORLW  03
1527:  BTFSC  03.2
1528:  GOTO   534
1529:  XORLW  02
152A:  BTFSC  03.2
152B:  GOTO   53C
152C:  GOTO   53E
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
152D:  MOVLP  08
152E:  CALL   7C1
152F:  MOVLP  10
1530:  MOVF   78,F
1531:  BTFSS  03.2
....................             reset_cpu(); 
1532:  RESET
....................           } 
....................           break; 
1533:  GOTO   544
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
1534:  MOVLW  01
1535:  MOVLB  02
1536:  MOVWF  40
1537:  MOVLP  08
1538:  MOVLB  00
1539:  CALL   568
153A:  MOVLP  10
....................           break; 
153B:  GOTO   544
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
153C:  CALL   121
....................         break; 
153D:  GOTO   544
....................         default: 
....................           set_admin_mode(0); 
153E:  MOVLB  02
153F:  CLRF   40
1540:  MOVLP  08
1541:  MOVLB  00
1542:  CALL   568
1543:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
1544:  GOTO   5A5
.................... //    case DTMF_SEND: 
.................... //      if ( value == d0 ) { 
.................... //        value=dd; 
.................... //      } else if (value == dd) { 
.................... //        value = d0; 
.................... //      } 
.................... //      dtmf_send_digit(value&0x0F); 
.................... //      break; 
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
....................       lcd_cmd=4+(value&0x03); 
1545:  MOVF   76,W
1546:  ANDLW  03
1547:  ADDLW  04
1548:  MOVLB  02
1549:  MOVWF  23
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
154A:  MOVLW  20
154B:  MOVLB  01
154C:  MOVWF  5D
154D:  MOVLW  73
154E:  MOVWF  5C
154F:  MOVLW  2B
1550:  MOVLB  03
1551:  MOVWF  11
1552:  MOVLW  04
1553:  MOVWF  12
1554:  BCF    03.0
1555:  MOVLW  04
1556:  MOVLB  02
1557:  MOVWF  4A
1558:  MOVLP  08
1559:  MOVLB  00
155A:  CALL   1EA
155B:  MOVLP  10
155C:  MOVLW  60
155D:  MOVLB  02
155E:  MOVWF  4A
155F:  MOVLW  18
1560:  MOVWF  4B
1561:  MOVLP  08
1562:  MOVLB  00
1563:  CALL   2B4
1564:  MOVLP  10
1565:  MOVLW  2E
1566:  MOVLB  03
1567:  MOVWF  11
1568:  MOVLW  04
1569:  MOVWF  12
156A:  BCF    03.0
156B:  MOVLW  08
156C:  MOVLB  02
156D:  MOVWF  4A
156E:  MOVLP  08
156F:  MOVLB  00
1570:  CALL   1EA
1571:  MOVLP  10
1572:  MOVLB  02
1573:  MOVF   23,W
1574:  MOVWF  4A
1575:  MOVLW  18
1576:  MOVWF  4B
1577:  MOVLP  08
1578:  MOVLB  00
1579:  CALL   2B4
157A:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
157B:  MOVLW  0A
157C:  CLRWDT
157D:  BTFSS  11.4
157E:  GOTO   57C
157F:  MOVLB  03
1580:  MOVWF  1A
1581:  MOVLW  0D
1582:  CLRWDT
1583:  MOVLB  00
1584:  BTFSC  11.4
1585:  GOTO   588
1586:  MOVLB  03
1587:  GOTO   582
1588:  MOVLB  03
1589:  MOVWF  1A
158A:  MOVLW  20
158B:  MOVWF  05
158C:  MOVLW  73
158D:  MOVWF  04
158E:  MOVLP  08
158F:  MOVLB  00
1590:  CALL   31B
1591:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
1592:  MOVLB  02
1593:  MOVF   23,W
1594:  MOVWF  4A
1595:  MOVLW  20
1596:  MOVWF  4C
1597:  MOVLW  73
1598:  MOVWF  4B
1599:  MOVLP  08
159A:  MOVLB  00
159B:  CALL   252
159C:  MOVLP  10
....................       break; 
159D:  GOTO   5A5
....................     case MORSE_SEND: 
....................       morse(value); 
159E:  MOVF   76,W
159F:  MOVLB  02
15A0:  MOVWF  3F
15A1:  MOVLP  08
15A2:  MOVLB  00
15A3:  CALL   162
15A4:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
15A5:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  4A
1803:  MOVLW  20
1804:  MOVWF  4C
1805:  MOVLW  4D
1806:  MOVWF  4B
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   252
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVWF  75
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B62:  MOVLB  01
1B63:  CLRF   66
1B64:  CLRF   65
1B65:  MOVF   66,F
1B66:  BTFSS  03.2
1B67:  GOTO   3B6
1B68:  MOVF   65,W
1B69:  SUBLW  37
1B6A:  BTFSS  03.0
1B6B:  GOTO   3B6
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B6C:  MOVLW  01
1B6D:  MOVWF  7A
1B6E:  MOVLW  8B
1B6F:  MOVLB  02
1B70:  MOVWF  20
1B71:  MOVF   7A,W
1B72:  MOVWF  21
1B73:  MOVLB  01
1B74:  MOVF   66,W
1B75:  MOVLB  02
1B76:  MOVWF  3E
1B77:  MOVLB  01
1B78:  MOVF   65,W
1B79:  MOVLB  02
1B7A:  MOVWF  3D
1B7B:  CLRF   40
1B7C:  MOVLW  06
1B7D:  MOVWF  3F
1B7E:  MOVLP  08
1B7F:  MOVLB  00
1B80:  CALL   781
1B81:  MOVLP  18
1B82:  MOVF   78,W
1B83:  MOVLB  02
1B84:  ADDWF  20,W
1B85:  MOVLB  01
1B86:  MOVWF  67
1B87:  MOVF   79,W
1B88:  MOVLB  02
1B89:  ADDWFC 21,W
1B8A:  MOVLB  01
1B8B:  MOVWF  68
....................     romstrcpy(rname,cPtr); 
1B8C:  MOVLW  20
1B8D:  MOVLB  02
1B8E:  MOVWF  3C
1B8F:  MOVLW  99
1B90:  MOVWF  3B
1B91:  MOVLB  01
1B92:  MOVF   68,W
1B93:  MOVLB  02
1B94:  MOVWF  3E
1B95:  MOVLB  01
1B96:  MOVF   67,W
1B97:  MOVLB  02
1B98:  MOVWF  3D
1B99:  MOVLP  08
1B9A:  MOVLB  00
1B9B:  CALL   798
1B9C:  MOVLP  18
....................     if(stricmp(argument_name,rname)==0) { 
1B9D:  MOVLW  20
1B9E:  MOVLB  02
1B9F:  MOVWF  40
1BA0:  MOVLW  6D
1BA1:  MOVWF  3F
1BA2:  MOVLW  20
1BA3:  MOVWF  42
1BA4:  MOVLW  99
1BA5:  MOVWF  41
1BA6:  MOVLP  10
1BA7:  MOVLB  00
1BA8:  CALL   000
1BA9:  MOVLP  18
1BAA:  MOVF   78,F
1BAB:  BTFSS  03.2
1BAC:  GOTO   3B1
....................       argument=x; 
1BAD:  MOVLB  01
1BAE:  MOVF   65,W
1BAF:  MOVWF  75
1BB0:  MOVLB  00
....................     } 
....................   } 
1BB1:  MOVLB  01
1BB2:  INCF   65,F
1BB3:  BTFSC  03.2
1BB4:  INCF   66,F
1BB5:  GOTO   365
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BB6:  MOVF   75,W
1BB7:  SUBLW  FF
1BB8:  BTFSS  03.2
1BB9:  GOTO   41A
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BBA:  MOVLW  20
1BBB:  MOVLB  02
1BBC:  MOVWF  40
1BBD:  MOVLW  6D
1BBE:  MOVWF  3F
1BBF:  MOVLP  08
1BC0:  MOVLB  00
1BC1:  CALL   748
1BC2:  MOVLP  18
1BC3:  MOVF   78,W
1BC4:  MOVWF  76
....................     strcpy(rname,"eeprom"); 
1BC5:  MOVLB  02
1BC6:  CLRF   20
1BC7:  CLRF   21
1BC8:  MOVLW  20
1BC9:  MOVWF  05
1BCA:  MOVLW  99
1BCB:  MOVWF  04
1BCC:  MOVF   20,W
1BCD:  ADDWF  04,F
1BCE:  MOVLW  00
1BCF:  ADDWFC 05,F
1BD0:  MOVF   21,W
1BD1:  MOVLP  00
1BD2:  MOVLB  00
1BD3:  CALL   124
1BD4:  MOVLP  18
1BD5:  MOVWF  00
1BD6:  IORLW  00
1BD7:  BTFSC  03.2
1BD8:  GOTO   3DE
1BD9:  MOVLB  02
1BDA:  INCF   21,F
1BDB:  INCF   20,F
1BDC:  GOTO   3C8
1BDD:  MOVLB  00
....................     if(stricmp(argument_name,rname)==0) { 
1BDE:  MOVLW  20
1BDF:  MOVLB  02
1BE0:  MOVWF  40
1BE1:  MOVLW  6D
1BE2:  MOVWF  3F
1BE3:  MOVLW  20
1BE4:  MOVWF  42
1BE5:  MOVLW  99
1BE6:  MOVWF  41
1BE7:  MOVLP  10
1BE8:  MOVLB  00
1BE9:  CALL   000
1BEA:  MOVLP  18
1BEB:  MOVF   78,F
1BEC:  BTFSS  03.2
1BED:  GOTO   3F0
....................       value=USE_EEPROM_VARS; 
1BEE:  MOVLW  01
1BEF:  MOVWF  76
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BF0:  MOVLB  02
1BF1:  CLRF   20
1BF2:  CLRF   21
1BF3:  MOVLW  20
1BF4:  MOVWF  05
1BF5:  MOVLW  99
1BF6:  MOVWF  04
1BF7:  MOVF   20,W
1BF8:  ADDWF  04,F
1BF9:  MOVLW  00
1BFA:  ADDWFC 05,F
1BFB:  MOVF   21,W
1BFC:  MOVLP  00
1BFD:  MOVLB  00
1BFE:  CALL   12C
1BFF:  MOVLP  18
1C00:  MOVWF  00
1C01:  IORLW  00
1C02:  BTFSC  03.2
1C03:  GOTO   409
1C04:  MOVLB  02
1C05:  INCF   21,F
1C06:  INCF   20,F
1C07:  GOTO   3F3
1C08:  MOVLB  00
....................     if(stricmp(argument_name,rname)==0) { 
1C09:  MOVLW  20
1C0A:  MOVLB  02
1C0B:  MOVWF  40
1C0C:  MOVLW  6D
1C0D:  MOVWF  3F
1C0E:  MOVLW  20
1C0F:  MOVWF  42
1C10:  MOVLW  99
1C11:  MOVWF  41
1C12:  MOVLP  10
1C13:  MOVLB  00
1C14:  CALL   000
1C15:  MOVLP  18
1C16:  MOVF   78,F
1C17:  BTFSC  03.2
....................       value=USE_DEFAULT_VARS; 
1C18:  CLRF   76
1C19:  MOVLB  01
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C1A:  MOVF   70,W
1C1B:  SUBLW  06
1C1C:  BTFSC  03.2
1C1D:  GOTO   422
1C1E:  MOVF   70,W
1C1F:  SUBLW  07
1C20:  BTFSS  03.2
1C21:  GOTO   426
....................     value = 1; 
1C22:  MOVLW  01
1C23:  MOVWF  76
....................     argument = CurrentTrimPot; 
1C24:  MOVF   74,W
1C25:  MOVWF  75
....................   } 
....................   rs232_mode = 1; 
1C26:  BSF    5B.4
....................   execute_command(); 
1C27:  MOVLP  10
1C28:  MOVLB  00
1C29:  CALL   163
1C2A:  MOVLP  18
....................   rs232_mode = 0; 
1C2B:  MOVLB  01
1C2C:  BCF    5B.4
.................... } // }}} 
1C2D:  MOVLP  18
1C2E:  MOVLB  00
1C2F:  GOTO   686 (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
05B1:  MOVLW  1B
05B2:  CALL   2DA
....................   printf("[2J"); 
05B3:  MOVLW  5B
05B4:  CLRWDT
05B5:  BTFSS  11.4
05B6:  GOTO   5B4
05B7:  MOVLB  03
05B8:  MOVWF  1A
05B9:  MOVLW  32
05BA:  CLRWDT
05BB:  MOVLB  00
05BC:  BTFSC  11.4
05BD:  GOTO   5C0
05BE:  MOVLB  03
05BF:  GOTO   5BA
05C0:  MOVLB  03
05C1:  MOVWF  1A
05C2:  MOVLW  4A
05C3:  CLRWDT
05C4:  MOVLB  00
05C5:  BTFSC  11.4
05C6:  GOTO   5C9
05C7:  MOVLB  03
05C8:  GOTO   5C3
05C9:  MOVLB  03
05CA:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
05CB:  MOVLW  1B
05CC:  MOVLB  00
05CD:  CALL   2DA
....................   printf("[0;0H"); 
05CE:  MOVLW  34
05CF:  MOVLB  03
05D0:  MOVWF  11
05D1:  MOVLW  04
05D2:  MOVWF  12
05D3:  MOVLB  00
05D4:  CALL   55C
.................... } // }}} 
05D5:  RETURN
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
0853:  MOVLB  02
0854:  SWAPF  3F,W
0855:  MOVWF  41
0856:  RLF    41,F
0857:  RLF    41,F
0858:  MOVLW  C0
0859:  ANDWF  41,F
....................   tx_value=tx_value + (value & 0x3F); 
085A:  MOVF   40,W
085B:  ANDLW  3F
085C:  ADDWF  41,F
....................   i2c_start(); 
085D:  MOVLB  04
085E:  BSF    16.0
085F:  BTFSC  16.0
0860:  GOTO   05F
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
0861:  MOVLW  50
0862:  MOVLB  02
0863:  MOVWF  50
0864:  MOVLP  00
0865:  MOVLB  00
0866:  CALL   769
0867:  MOVLP  08
0868:  MOVF   78,W
0869:  MOVLB  02
086A:  BCF    42.0
086B:  BTFSC  78.0
086C:  BSF    42.0
....................   if ( ack != 0) { 
086D:  BTFSS  42.0
086E:  GOTO   088
....................     printf("\n\rI2C : No ACK : %u",ack); 
086F:  MOVLW  00
0870:  BTFSC  42.0
0871:  MOVLW  01
0872:  MOVWF  43
0873:  MOVLW  37
0874:  MOVLB  03
0875:  MOVWF  11
0876:  MOVLW  04
0877:  MOVWF  12
0878:  BCF    03.0
0879:  MOVLW  11
087A:  MOVLB  02
087B:  MOVWF  50
087C:  MOVLP  00
087D:  MOVLB  00
087E:  CALL   77E
087F:  MOVLP  08
0880:  MOVLB  02
0881:  MOVF   43,W
0882:  MOVWF  50
0883:  MOVLW  1B
0884:  MOVWF  51
0885:  MOVLB  00
0886:  CALL   000
0887:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
0888:  MOVF   41,W
0889:  MOVWF  50
088A:  MOVLP  00
088B:  MOVLB  00
088C:  CALL   769
088D:  MOVLP  08
....................   i2c_stop();   
088E:  MOVLB  04
088F:  BSF    16.2
0890:  BTFSC  16.2
0891:  GOTO   090
....................   printf("\n\rPot(%u)<=%u",pot,value); 
0892:  MOVLW  41
0893:  MOVLB  03
0894:  MOVWF  11
0895:  MOVLW  04
0896:  MOVWF  12
0897:  BCF    03.0
0898:  MOVLW  06
0899:  MOVLB  02
089A:  MOVWF  50
089B:  MOVLP  00
089C:  MOVLB  00
089D:  CALL   77E
089E:  MOVLP  08
089F:  MOVLB  02
08A0:  MOVF   3F,W
08A1:  MOVWF  50
08A2:  MOVLW  1B
08A3:  MOVWF  51
08A4:  MOVLB  00
08A5:  CALL   000
08A6:  MOVLW  29
08A7:  CLRWDT
08A8:  BTFSS  11.4
08A9:  GOTO   0A7
08AA:  MOVLB  03
08AB:  MOVWF  1A
08AC:  MOVLW  3C
08AD:  CLRWDT
08AE:  MOVLB  00
08AF:  BTFSC  11.4
08B0:  GOTO   0B3
08B1:  MOVLB  03
08B2:  GOTO   0AD
08B3:  MOVLB  03
08B4:  MOVWF  1A
08B5:  MOVLW  3D
08B6:  CLRWDT
08B7:  MOVLB  00
08B8:  BTFSC  11.4
08B9:  GOTO   0BC
08BA:  MOVLB  03
08BB:  GOTO   0B6
08BC:  MOVLB  03
08BD:  MOVWF  1A
08BE:  MOVLB  02
08BF:  MOVF   40,W
08C0:  MOVWF  50
08C1:  MOVLW  1B
08C2:  MOVWF  51
08C3:  MOVLB  00
08C4:  CALL   000
....................  
.................... } // }}} 
08C5:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
0962:  MOVLW  DC
0963:  MOVLB  02
0964:  ADDWF  3F,W
0965:  MOVWF  43
0966:  MOVLW  1F
0967:  MOVWF  44
0968:  BTFSC  03.0
0969:  INCF   44,F
096A:  MOVF   44,W
096B:  MOVLB  03
096C:  MOVWF  12
096D:  MOVLB  02
096E:  MOVF   43,W
096F:  MOVLB  03
0970:  MOVWF  11
0971:  MOVLW  20
0972:  MOVWF  05
0973:  MOVLW  C0
0974:  MOVWF  04
0975:  MOVLW  01
0976:  MOVLB  02
0977:  MOVWF  45
0978:  MOVLB  00
0979:  CALL   0DF
....................    
....................   PROMPT_FLAG=1; 
097A:  MOVLB  01
097B:  BSF    5B.2
....................   for(x=0;x<4;x++) { 
097C:  MOVLB  02
097D:  CLRF   41
097E:  MOVF   41,W
097F:  SUBLW  03
0980:  BTFSS  03.0
0981:  GOTO   1A8
....................     do_delay=1; 
0982:  BSF    42.0
....................     switch(mc & 0xc0) { // Check two MSB's 
0983:  MOVF   40,W
0984:  ANDLW  C0
0985:  XORLW  40
0986:  MOVLB  00
0987:  BTFSC  03.2
0988:  GOTO   18D
0989:  XORLW  C0
098A:  BTFSC  03.2
098B:  GOTO   18F
098C:  GOTO   191
....................       case(0x40): 
....................         dit(); 
098D:  CALL   0F2
....................         break; 
098E:  GOTO   194
....................       case(0x80): 
....................         dah(); 
098F:  CALL   12A
....................         break; 
0990:  GOTO   194
....................       default: 
....................         do_delay=0; 
0991:  MOVLB  02
0992:  BCF    42.0
....................         break; 
0993:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
0994:  MOVLB  02
0995:  RLF    40,F
0996:  RLF    40,F
0997:  MOVLW  FC
0998:  ANDWF  40,F
....................     if ( do_delay ) { 
0999:  BTFSS  42.0
099A:  GOTO   1A6
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
099B:  MOVLB  01
099C:  CLRF   30
099D:  MOVLW  02
099E:  MOVWF  2F
....................       while(aux_timer) { 
099F:  MOVF   2F,W
09A0:  IORWF  30,W
09A1:  BTFSC  03.2
09A2:  GOTO   1A5
....................         delay_cycles(1); 
09A3:  NOP
....................       } 
09A4:  GOTO   19F
09A5:  MOVLB  02
....................     } 
....................   } 
09A6:  INCF   41,F
09A7:  GOTO   17E
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
09A8:  MOVF   3F,W
09A9:  SUBLW  09
09AA:  BTFSS  03.0
09AB:  GOTO   1B7
....................     if ( c < 5 ) { 
09AC:  MOVF   3F,W
09AD:  SUBLW  04
09AE:  BTFSS  03.0
09AF:  GOTO   1B4
....................       dah(); 
09B0:  MOVLB  00
09B1:  CALL   12A
....................     } 
....................     else { 
09B2:  GOTO   1B6
09B3:  MOVLB  02
....................       dit(); 
09B4:  MOVLB  00
09B5:  CALL   0F2
09B6:  MOVLB  02
....................     } 
....................   } 
....................   //aux_timer=MorseLen[(MorseDitLength&0x03)]; 
....................   //while(aux_timer) { 
....................   //  delay_cycles(1); 
....................   //} 
.................... } // }}} 
09B7:  MOVLB  00
09B8:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0C23:  MOVLW  30
0C24:  MOVLB  02
0C25:  MOVWF  34
0C26:  MOVWF  35
0C27:  MOVWF  36
0C28:  MOVWF  37
0C29:  CLRF   38
....................   char PTT_s[5]={'0','0','0','0',0}; 
0C2A:  MOVWF  39
0C2B:  MOVWF  3A
0C2C:  MOVWF  3B
0C2D:  MOVWF  3C
0C2E:  CLRF   3D
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0C2F:  MOVF   2E,W
0C30:  MOVLB  00
0C31:  MOVWF  6B
....................  
....................   if ( cor ) { 
0C32:  MOVLB  02
0C33:  MOVF   2E,F
0C34:  BTFSC  03.2
0C35:  GOTO   447
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0C36:  MOVLW  01
0C37:  SUBWF  2E,W
0C38:  ADDLW  29
0C39:  MOVWF  04
0C3A:  MOVLW  20
0C3B:  MOVWF  05
0C3C:  BTFSC  03.0
0C3D:  INCF   05,F
0C3E:  MOVF   00,W
0C3F:  MOVWF  3F
0C40:  MOVLB  00
0C41:  MOVF   60,W
0C42:  ANDWF  61,W
0C43:  MOVLB  02
0C44:  ANDWF  3F,W
0C45:  MOVWF  33
....................   } else { 
0C46:  GOTO   483
....................     ptt=0; 
0C47:  CLRF   33
....................     if ( COR_DROP_FLAG ) { 
0C48:  BTFSS  72.5
0C49:  GOTO   483
....................       COR_DROP_FLAG=0; 
0C4A:  BCF    72.5
....................       if ( ConfirmChar || TailChar ) { 
0C4B:  MOVLB  00
0C4C:  MOVF   69,F
0C4D:  BTFSS  03.2
0C4E:  GOTO   452
0C4F:  MOVF   68,F
0C50:  BTFSC  03.2
0C51:  GOTO   484
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0C84:  MOVLW  01
0C85:  MOVLB  02
0C86:  MOVWF  32
....................   for(x=0;x<4;x++) { 
0C87:  CLRF   2F
0C88:  MOVF   2F,W
0C89:  SUBLW  03
0C8A:  BTFSS  03.0
0C8B:  GOTO   4F0
....................     if ( !cor ) { 
0C8C:  MOVF   2E,F
0C8D:  BTFSS  03.2
0C8E:  GOTO   492
....................       rx_bit=0; 
0C8F:  BCF    3E.0
....................       ptt_bit=0; 
0C90:  BCF    3E.1
....................     } else { 
0C91:  GOTO   4A5
....................       if ( cor == (x+1) ) { 
0C92:  MOVLW  01
0C93:  ADDWF  2F,W
0C94:  SUBWF  2E,W
0C95:  BTFSS  03.2
0C96:  GOTO   49D
....................         rx_bit=1; 
0C97:  BSF    3E.0
....................         CurrentCorMask=mask; 
0C98:  MOVF   32,W
0C99:  MOVLB  00
0C9A:  MOVWF  6A
....................       } else { 
0C9B:  GOTO   49F
0C9C:  MOVLB  02
....................         rx_bit=0; 
0C9D:  BCF    3E.0
0C9E:  MOVLB  00
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0C9F:  MOVLB  02
0CA0:  BCF    3E.1
0CA1:  MOVF   33,W
0CA2:  ANDWF  32,W
0CA3:  BTFSS  03.2
0CA4:  BSF    3E.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0CA5:  MOVF   2F,W
0CA6:  MOVLP  00
0CA7:  MOVLB  00
0CA8:  CALL   031
0CA9:  MOVLP  08
0CAA:  MOVLB  02
0CAB:  MOVWF  3F
0CAC:  MOVLW  00
0CAD:  BTFSC  3E.0
0CAE:  MOVLW  01
0CAF:  MOVWF  77
0CB0:  MOVF   3F,W
0CB1:  MOVWF  40
0CB2:  MOVF   77,W
0CB3:  MOVWF  41
0CB4:  MOVLW  01
0CB5:  MOVWF  43
0CB6:  CLRF   42
0CB7:  MOVLB  00
0CB8:  CALL   1B9
0CB9:  MOVLB  02
0CBA:  MOVF   3F,W
0CBB:  MOVWF  40
0CBC:  CLRF   41
0CBD:  CLRF   43
0CBE:  MOVLW  80
0CBF:  MOVWF  42
0CC0:  MOVLB  00
0CC1:  CALL   1B9
....................     output_bit(PTT_PIN[x],ptt_bit); 
0CC2:  MOVLB  02
0CC3:  MOVF   2F,W
0CC4:  MOVLP  00
0CC5:  MOVLB  00
0CC6:  CALL   036
0CC7:  MOVLP  08
0CC8:  MOVLB  02
0CC9:  MOVWF  3F
0CCA:  MOVLW  00
0CCB:  BTFSC  3E.1
0CCC:  MOVLW  01
0CCD:  MOVWF  77
0CCE:  MOVF   3F,W
0CCF:  MOVWF  40
0CD0:  MOVF   77,W
0CD1:  MOVWF  41
0CD2:  MOVLW  01
0CD3:  MOVWF  43
0CD4:  CLRF   42
0CD5:  MOVLB  00
0CD6:  CALL   1B9
0CD7:  MOVLB  02
0CD8:  MOVF   3F,W
0CD9:  MOVWF  40
0CDA:  CLRF   41
0CDB:  CLRF   43
0CDC:  MOVLW  80
0CDD:  MOVWF  42
0CDE:  MOVLB  00
0CDF:  CALL   1B9
....................     if(ptt_bit) { 
0CE0:  MOVLB  02
0CE1:  BTFSS  3E.1
0CE2:  GOTO   4EC
....................       PTT_s[x]='1'; 
0CE3:  MOVLW  B9
0CE4:  ADDWF  2F,W
0CE5:  MOVWF  04
0CE6:  MOVLW  20
0CE7:  MOVWF  05
0CE8:  BTFSC  03.0
0CE9:  INCF   05,F
0CEA:  MOVLW  31
0CEB:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0CEC:  BCF    03.0
0CED:  RLF    32,F
....................   }  
0CEE:  INCF   2F,F
0CEF:  GOTO   488
....................   if(!cor) { 
0CF0:  MOVF   2E,F
0CF1:  BTFSS  03.2
0CF2:  GOTO   4F7
....................     CurrentCorPriority=0; 
0CF3:  MOVLB  00
0CF4:  CLRF   6C
....................   } else { 
0CF5:  GOTO   525
0CF6:  MOVLB  02
....................     CurrentCorPriority=RXPriority[cor-1]; 
0CF7:  MOVLW  01
0CF8:  SUBWF  2E,W
0CF9:  ADDLW  25
0CFA:  MOVWF  04
0CFB:  MOVLW  20
0CFC:  MOVWF  05
0CFD:  BTFSC  03.0
0CFE:  INCF   05,F
0CFF:  MOVF   00,W
0D00:  MOVLB  00
0D01:  MOVWF  6C
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0D02:  MOVLB  02
0D03:  CLRF   30
0D04:  MOVF   30,W
0D05:  SUBLW  03
0D06:  BTFSS  03.0
0D07:  GOTO   522
....................       pot_val=RX_GAIN[cor-1][pot]; 
0D08:  MOVLW  01
0D09:  SUBWF  2E,W
0D0A:  MOVWF  77
0D0B:  RLF    77,F
0D0C:  RLF    77,F
0D0D:  MOVLW  FC
0D0E:  ANDWF  77,F
0D0F:  MOVF   77,W
0D10:  ADDWF  30,W
0D11:  ADDLW  0C
0D12:  MOVWF  04
0D13:  MOVLW  20
0D14:  MOVWF  05
0D15:  BTFSC  03.0
0D16:  INCF   05,F
0D17:  MOVF   00,W
0D18:  MOVWF  31
....................       set_trimpot(pot,pot_val); 
0D19:  MOVF   30,W
0D1A:  MOVWF  3F
0D1B:  MOVF   31,W
0D1C:  MOVWF  40
0D1D:  MOVLB  00
0D1E:  CALL   053
....................     } 
0D1F:  MOVLB  02
0D20:  INCF   30,F
0D21:  GOTO   504
....................     PROMPT_FLAG=1; 
0D22:  MOVLB  01
0D23:  BSF    5B.2
0D24:  MOVLB  00
....................   } 
....................   if(cor>0) { 
0D25:  MOVLB  02
0D26:  MOVF   2E,F
0D27:  BTFSC  03.2
0D28:  GOTO   533
....................     COR_s[cor-1]='1'; 
0D29:  MOVLW  01
0D2A:  SUBWF  2E,W
0D2B:  ADDLW  B4
0D2C:  MOVWF  04
0D2D:  MOVLW  20
0D2E:  MOVWF  05
0D2F:  BTFSC  03.0
0D30:  INCF   05,F
0D31:  MOVLW  31
0D32:  MOVWF  00
....................   } 
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0D33:  MOVLW  20
0D34:  MOVLB  01
0D35:  MOVWF  5D
0D36:  MOVLW  73
0D37:  MOVWF  5C
0D38:  MOVLW  48
0D39:  MOVLB  03
0D3A:  MOVWF  11
0D3B:  MOVLW  04
0D3C:  MOVWF  12
0D3D:  BCF    03.0
0D3E:  MOVLW  04
0D3F:  MOVLB  02
0D40:  MOVWF  4A
0D41:  MOVLB  00
0D42:  CALL   1EA
0D43:  MOVLW  20
0D44:  MOVWF  05
0D45:  MOVLW  B4
0D46:  MOVWF  04
0D47:  CALL   23D
0D48:  MOVLW  4B
0D49:  MOVLB  03
0D4A:  MOVWF  11
0D4B:  MOVLW  04
0D4C:  MOVWF  12
0D4D:  BCF    03.0
0D4E:  MOVLW  05
0D4F:  MOVLB  02
0D50:  MOVWF  4A
0D51:  MOVLB  00
0D52:  CALL   1EA
0D53:  MOVLW  20
0D54:  MOVWF  05
0D55:  MOVLW  B9
0D56:  MOVWF  04
0D57:  CALL   23D
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0D58:  MOVLW  01
0D59:  MOVLB  02
0D5A:  MOVWF  4A
0D5B:  MOVLW  20
0D5C:  MOVWF  4C
0D5D:  MOVLW  73
0D5E:  MOVWF  4B
0D5F:  MOVLB  00
0D60:  CALL   252
....................   delay_ms(50); 
0D61:  MOVLW  32
0D62:  MOVLB  02
0D63:  MOVWF  4A
0D64:  MOVLB  00
0D65:  CALL   0C6
....................   pot_values_to_lcd(); 
0D66:  CALL   335
.................... }// }}} 
0D67:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1DC2:  MOVF   67,W
1DC3:  SUBLW  0A
1DC4:  BTFSS  03.0
1DC5:  GOTO   5E0
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1DC6:  MOVLW  61
1DC7:  ADDWF  67,W
1DC8:  MOVWF  04
1DC9:  MOVLW  20
1DCA:  MOVWF  05
1DCB:  BTFSC  03.0
1DCC:  INCF   05,F
1DCD:  BTFSS  00.4
1DCE:  GOTO   5DE
1DCF:  MOVLW  61
1DD0:  ADDWF  67,W
1DD1:  MOVWF  04
1DD2:  MOVLW  20
1DD3:  MOVWF  05
1DD4:  BTFSC  03.0
1DD5:  INCF   05,F
1DD6:  MOVF   00,W
1DD7:  ANDLW  0F
1DD8:  SUBLW  0C
1DD9:  BTFSC  03.2
1DDA:  GOTO   5DE
....................       strobe=1; 
1DDB:  MOVLW  01
1DDC:  MOVWF  68
....................      } else { 
1DDD:  GOTO   5DF
....................       strobe = 0; 
1DDE:  CLRF   68
....................     }  
....................   } else { 
1DDF:  GOTO   5E1
....................     strobe=0; 
1DE0:  CLRF   68
....................   } 
....................   return(strobe); 
1DE1:  MOVF   68,W
1DE2:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
173A:  MOVLB  01
173B:  MOVF   67,W
173C:  SUBWF  68,W
173D:  BTFSS  03.0
173E:  GOTO   764
173F:  MOVF   67,W
1740:  SUBLW  09
1741:  BTFSS  03.0
1742:  GOTO   764
....................     valid=1; 
1743:  BSF    6B.0
....................     for(x=a;x<=b;x++) { 
1744:  MOVF   67,W
1745:  MOVWF  6A
1746:  MOVF   6A,W
1747:  SUBWF  68,W
1748:  BTFSS  03.0
1749:  GOTO   763
....................       key=(int)DTMF_ARRAY[x].Key; 
174A:  MOVLW  61
174B:  ADDWF  6A,W
174C:  MOVWF  04
174D:  MOVLW  20
174E:  MOVWF  05
174F:  BTFSC  03.0
1750:  INCF   05,F
1751:  MOVF   00,W
1752:  ANDLW  0F
1753:  MOVWF  69
....................       if(! DTMF_ARRAY[x].Strobe ) { 
1754:  MOVLW  61
1755:  ADDWF  6A,W
1756:  MOVWF  04
1757:  MOVLW  20
1758:  MOVWF  05
1759:  BTFSC  03.0
175A:  INCF   05,F
175B:  BTFSS  00.4
....................         valid=0; 
175C:  BCF    6B.0
....................       } 
....................      if(key==dp) { 
175D:  MOVF   69,W
175E:  SUBLW  0C
175F:  BTFSC  03.2
....................         valid=0; 
1760:  BCF    6B.0
....................       } 
....................     } 
1761:  INCF   6A,F
1762:  GOTO   746
....................   } else { 
1763:  GOTO   765
....................     valid=0; 
1764:  BCF    6B.0
....................   } 
....................   return(valid); 
1765:  MOVLW  00
1766:  BTFSC  6B.0
1767:  MOVLW  01
1768:  MOVWF  78
.................... } // }}} 
1769:  MOVLB  00
176A:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   int site_id; 
....................   int digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : DTMF send 
....................   // 11 : Morse send 
....................   // 12 : Send to I2C 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   value = 0; 
*
1D7A:  CLRF   76
....................   command=0; 
1D7B:  CLRF   70
....................   if ( ValidKeyRange(0,5)) { 
1D7C:  MOVLB  01
1D7D:  CLRF   67
1D7E:  MOVLW  05
1D7F:  MOVWF  68
1D80:  MOVLP  10
1D81:  MOVLB  00
1D82:  CALL   73A
1D83:  MOVLP  18
1D84:  MOVF   78,F
1D85:  BTFSC  03.2
1D86:  GOTO   612
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1D87:  MOVLB  01
1D88:  MOVF   31,W
1D89:  ANDLW  0F
1D8A:  MOVWF  68
1D8B:  MOVLB  02
1D8C:  MOVWF  43
1D8D:  MOVLW  0A
1D8E:  MOVWF  44
1D8F:  MOVLP  08
1D90:  MOVLB  00
1D91:  CALL   721
1D92:  MOVLP  18
1D93:  MOVF   78,W
1D94:  MOVLB  01
1D95:  MOVWF  67
1D96:  MOVF   32,W
1D97:  ANDLW  0F
1D98:  ADDWF  67,W
1D99:  MOVWF  65
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1D9A:  MOVF   33,W
1D9B:  ANDLW  0F
1D9C:  MOVWF  68
1D9D:  MOVLB  02
1D9E:  MOVWF  43
1D9F:  MOVLW  0A
1DA0:  MOVWF  44
1DA1:  MOVLP  08
1DA2:  MOVLB  00
1DA3:  CALL   721
1DA4:  MOVLP  18
1DA5:  MOVF   78,W
1DA6:  MOVLB  01
1DA7:  MOVWF  67
1DA8:  MOVF   34,W
1DA9:  ANDLW  0F
1DAA:  ADDWF  67,W
1DAB:  MOVWF  70
....................     argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1DAC:  MOVF   35,W
1DAD:  ANDLW  0F
1DAE:  MOVWF  68
1DAF:  MOVLB  02
1DB0:  MOVWF  43
1DB1:  MOVLW  0A
1DB2:  MOVWF  44
1DB3:  MOVLP  08
1DB4:  MOVLB  00
1DB5:  CALL   721
1DB6:  MOVLP  18
1DB7:  MOVF   78,W
1DB8:  MOVLB  01
1DB9:  MOVWF  67
1DBA:  MOVF   36,W
1DBB:  ANDLW  0F
1DBC:  ADDWF  67,W
1DBD:  MOVWF  75
....................     digit=6; 
1DBE:  MOVLW  06
1DBF:  MOVWF  66
....................     while(ValidKey(digit)) { 
1DC0:  MOVF   66,W
1DC1:  MOVWF  67
*
1DE3:  MOVF   78,F
1DE4:  BTFSC  03.2
1DE5:  GOTO   5FF
....................      value = value * 10 + DTMF_ARRAY[digit].Key; 
1DE6:  MOVF   76,W
1DE7:  MOVLB  02
1DE8:  MOVWF  43
1DE9:  MOVLW  0A
1DEA:  MOVWF  44
1DEB:  MOVLP  08
1DEC:  MOVLB  00
1DED:  CALL   721
1DEE:  MOVLP  18
1DEF:  MOVF   78,W
1DF0:  MOVLB  01
1DF1:  MOVWF  67
1DF2:  MOVLW  61
1DF3:  ADDWF  66,W
1DF4:  MOVWF  04
1DF5:  MOVLW  20
1DF6:  MOVWF  05
1DF7:  BTFSC  03.0
1DF8:  INCF   05,F
1DF9:  MOVF   00,W
1DFA:  ANDLW  0F
1DFB:  ADDWF  67,W
1DFC:  MOVWF  76
....................      digit++; 
1DFD:  INCF   66,F
....................     } 
1DFE:  GOTO   5C0
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1DFF:  MOVF   70,W
1E00:  XORLW  04
1E01:  MOVLB  00
1E02:  BTFSC  03.2
1E03:  GOTO   607
1E04:  XORLW  01
1E05:  BTFSS  03.2
1E06:  GOTO   609
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1E07:  MOVF   75,W
1E08:  MOVWF  76
....................         break; 
....................     } 
....................     if ( site_id == SiteID ) { 
1E09:  MOVF   63,W
1E0A:  MOVLB  01
1E0B:  SUBWF  65,W
1E0C:  BTFSS  03.2
1E0D:  GOTO   613
....................       execute_command(); 
1E0E:  MOVLP  10
1E0F:  MOVLB  00
1E10:  CALL   163
1E11:  MOVLP  18
1E12:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1E13:  MOVF   31,W
1E14:  ANDLW  0F
1E15:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1E16:  BTFSS  5B.3
1E17:  GOTO   64A
1E18:  CLRF   67
1E19:  CLRF   68
1E1A:  MOVLP  10
1E1B:  MOVLB  00
1E1C:  CALL   73A
1E1D:  MOVLP  18
1E1E:  MOVF   78,F
1E1F:  BTFSS  03.2
1E20:  GOTO   623
1E21:  MOVLB  01
1E22:  GOTO   64A
....................     restart_wdt(); 
1E23:  CLRWDT
....................     switch(command) { 
1E24:  MOVF   70,W
1E25:  XORLW  0E
1E26:  BTFSC  03.2
1E27:  GOTO   62F
1E28:  XORLW  01
1E29:  BTFSC  03.2
1E2A:  GOTO   637
1E2B:  XORLW  05
1E2C:  BTFSC  03.2
1E2D:  GOTO   63F
1E2E:  GOTO   646
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1E2F:  MOVLW  01
1E30:  ADDWF  74,W
1E31:  ANDLW  03
1E32:  MOVWF  74
....................         pot_values_to_lcd(); 
1E33:  MOVLP  08
1E34:  CALL   335
1E35:  MOVLP  18
....................         break; 
1E36:  GOTO   646
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1E37:  MOVLW  FF
1E38:  MOVLB  02
1E39:  MOVWF  2F
1E3A:  MOVLP  10
1E3B:  MOVLB  00
1E3C:  CALL   097
1E3D:  MOVLP  18
....................         break; 
1E3E:  GOTO   646
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1E3F:  MOVLW  01
1E40:  MOVLB  02
1E41:  MOVWF  2F
1E42:  MOVLP  10
1E43:  MOVLB  00
1E44:  CALL   097
1E45:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1E46:  MOVLP  08
1E47:  CALL   7C1
1E48:  MOVLP  18
1E49:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1E4A:  BSF    5B.1
.................... } // }}} 
1E4B:  MOVLP  18
1E4C:  MOVLB  00
1E4D:  GOTO   796 (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask,cor_index; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
16BE:  MOVLW  01
16BF:  MOVLB  01
16C0:  MOVWF  65
....................   do_update_ptt=0; 
16C1:  CLRF   69
....................   cor_in = COR_IN | (COR_EMUL&0x0F); 
16C2:  MOVLB  00
16C3:  MOVF   67,W
16C4:  ANDLW  0F
16C5:  IORWF  5F,W
16C6:  MOVLB  01
16C7:  MOVWF  68
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in&CurrentCorMask) ) { 
16C8:  MOVLB  00
16C9:  MOVF   6C,F
16CA:  BTFSC  03.2
16CB:  GOTO   6E3
16CC:  MOVLB  01
16CD:  MOVF   68,W
16CE:  MOVLB  00
16CF:  ANDWF  6A,W
16D0:  BTFSS  03.2
16D1:  GOTO   6E3
....................     CurrentCorPriority=0; 
16D2:  CLRF   6C
....................     CurrentCorMask=0; 
16D3:  CLRF   6A
....................     do_update_ptt=1; 
16D4:  MOVLW  01
16D5:  MOVLB  01
16D6:  MOVWF  69
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
16D7:  MOVF   68,W
16D8:  MOVLB  00
16D9:  ANDWF  60,W
16DA:  ANDWF  61,W
16DB:  BTFSS  03.2
16DC:  GOTO   6E3
....................       COR_DROP_FLAG=1; 
16DD:  BSF    72.5
....................       if ( Tail ) { 
16DE:  MOVF   65,F
16DF:  BTFSC  03.2
16E0:  GOTO   6E3
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
16E1:  MOVF   65,W
16E2:  MOVWF  68
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
16E3:  MOVLB  01
16E4:  CLRF   66
....................   for(x=0;x<4;x++) { 
16E5:  CLRF   6A
16E6:  MOVF   6A,W
16E7:  SUBLW  03
16E8:  BTFSS  03.0
16E9:  GOTO   728
....................     if ( cor_in & cor_mask ) { 
16EA:  MOVF   68,W
16EB:  ANDWF  65,W
16EC:  BTFSC  03.2
16ED:  GOTO   722
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
16EE:  MOVLB  00
16EF:  MOVF   60,W
16F0:  ANDWF  61,W
16F1:  MOVLB  01
16F2:  ANDWF  65,W
16F3:  BTFSC  03.2
16F4:  GOTO   6FF
....................         rx_priority=RXPriority[x]; 
16F5:  MOVLW  25
16F6:  ADDWF  6A,W
16F7:  MOVWF  04
16F8:  MOVLW  20
16F9:  MOVWF  05
16FA:  BTFSC  03.0
16FB:  INCF   05,F
16FC:  MOVF   00,W
16FD:  MOVWF  67
....................       } else { 
16FE:  GOTO   701
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
16FF:  MOVLW  01
1700:  MOVWF  67
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1701:  MOVF   67,W
1702:  MOVLB  00
1703:  SUBWF  6C,W
1704:  BTFSC  03.0
1705:  GOTO   723
....................         if ( ! CurrentCorPriority ) { 
1706:  MOVF   6C,F
1707:  BTFSS  03.2
1708:  GOTO   70D
....................           CurrentCorPriority = rx_priority; 
1709:  MOVLB  01
170A:  MOVF   67,W
170B:  MOVLB  00
170C:  MOVWF  6C
....................         } 
....................         cor_index=x+1; 
170D:  MOVLW  01
170E:  MOVLB  01
170F:  ADDWF  6A,W
1710:  MOVWF  66
....................         do_update_ptt=1; 
1711:  MOVLW  01
1712:  MOVWF  69
....................         TOT_SecondCounter= 60 * TOT_Min; 
1713:  MOVLW  3C
1714:  MOVLB  02
1715:  MOVWF  43
1716:  MOVLB  00
1717:  MOVF   66,W
1718:  MOVLB  02
1719:  MOVWF  44
171A:  MOVLP  08
171B:  MOVLB  00
171C:  CALL   721
171D:  MOVLP  10
171E:  MOVLB  01
171F:  CLRF   5A
1720:  MOVF   78,W
1721:  MOVWF  59
1722:  MOVLB  00
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
1723:  BCF    03.0
1724:  MOVLB  01
1725:  RLF    65,F
....................   } 
1726:  INCF   6A,F
1727:  GOTO   6E6
....................   if ( do_update_ptt ) { 
1728:  MOVF   69,F
1729:  BTFSC  03.2
172A:  GOTO   734
....................     update_ptt(cor_index); 
172B:  MOVF   66,W
172C:  MOVLB  02
172D:  MOVWF  2E
172E:  MOVLP  08
172F:  MOVLB  00
1730:  CALL   423
1731:  MOVLP  10
....................     PROMPT_FLAG=1; 
1732:  MOVLB  01
1733:  BSF    5B.2
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
1734:  MOVF   68,F
1735:  BTFSC  03.2
....................     CLEAR_DTMF_FLAG=1; 
1736:  BSF    5B.1
....................   } 
.................... } // }}} 
1737:  MOVLP  18
1738:  MOVLB  00
1739:  GOTO   6FA (RETURN)
....................  
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
176B:  MOVLB  01
176C:  CLRF   65
176D:  MOVF   65,W
176E:  SUBLW  09
176F:  BTFSS  03.0
1770:  GOTO   77B
....................     DTMF_ARRAY[x]=(sDTMF)0; 
1771:  MOVLW  61
1772:  ADDWF  65,W
1773:  MOVWF  04
1774:  MOVLW  20
1775:  MOVWF  05
1776:  BTFSC  03.0
1777:  INCF   05,F
1778:  CLRF   00
....................   } 
1779:  INCF   65,F
177A:  GOTO   76D
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
177B:  MOVLW  20
177C:  MOVWF  3C
177D:  MOVLW  61
177E:  MOVWF  3B
.................... } // }}} 
177F:  MOVLP  18
1780:  MOVLB  00
1781:  GOTO   79E (RETURN)
....................  
.................... void header (void) { // {{{ 
....................   putc(ESC); 
*
0744:  MOVLW  1B
0745:  CALL   2DA
....................   printf("[47;34m\n\rRadio Repeater Controller - "); 
0746:  MOVLW  4F
0747:  MOVLB  03
0748:  MOVWF  11
0749:  MOVLW  04
074A:  MOVWF  12
074B:  MOVLB  00
074C:  CALL   55C
....................   putc(ESC); 
074D:  MOVLW  1B
074E:  CALL   2DA
....................   printf("[47;31mVE2LRS"); 
074F:  MOVLW  62
0750:  MOVLB  03
0751:  MOVWF  11
0752:  MOVLW  04
0753:  MOVWF  12
0754:  MOVLB  00
0755:  CALL   55C
....................   putc(ESC); 
0756:  MOVLW  1B
0757:  CALL   2DA
....................   printf("[47;34m (C) 2013\n\n\r"); 
0758:  MOVLW  69
0759:  MOVLB  03
075A:  MOVWF  11
075B:  MOVLW  04
075C:  MOVWF  12
075D:  MOVLB  00
075E:  CALL   55C
....................   putc(ESC); 
075F:  MOVLW  1B
0760:  CALL   2DA
....................   printf("[40;37m"); 
0761:  MOVLW  73
0762:  MOVLB  03
0763:  MOVWF  11
0764:  MOVLW  04
0765:  MOVWF  12
0766:  MOVLB  00
0767:  CALL   55C
.................... } // }}} 
0768:  RETURN
....................  
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
*
1384:  MOVLP  00
1385:  CALL   5B1
1386:  MOVLP  10
....................   header(); 
1387:  MOVLP  00
1388:  CALL   744
1389:  MOVLP  10
138A:  CLRF   25
138B:  BTFSC  0B.7
138C:  BSF    25.7
138D:  BCF    0B.7
....................   dtmf_in=dtmf_read(CONTROL_REG); 
138E:  MOVLW  01
138F:  MOVLB  02
1390:  MOVWF  58
1391:  MOVLP  00
1392:  MOVLB  00
1393:  CALL   33E
1394:  MOVLP  10
1395:  BTFSC  25.7
1396:  BSF    0B.7
1397:  MOVF   78,W
1398:  MOVLB  02
1399:  MOVWF  33
....................   aux_in = 0; 
139A:  CLRF   34
....................   for(x=0;x<RegMapNum;x++) { 
139B:  CLRF   2D
139C:  CLRF   2C
139D:  MOVF   2D,F
139E:  BTFSS  03.2
139F:  GOTO   498
13A0:  MOVF   2C,W
13A1:  SUBLW  37
13A2:  BTFSS  03.0
13A3:  GOTO   498
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
13A4:  MOVLW  01
13A5:  MOVWF  7A
13A6:  MOVLW  8B
13A7:  MOVWF  3B
13A8:  MOVF   7A,W
13A9:  MOVWF  3C
13AA:  MOVF   2D,W
13AB:  MOVWF  3E
13AC:  MOVF   2C,W
13AD:  MOVWF  3D
13AE:  CLRF   40
13AF:  MOVLW  06
13B0:  MOVWF  3F
13B1:  MOVLP  08
13B2:  MOVLB  00
13B3:  CALL   781
13B4:  MOVLP  10
13B5:  MOVF   78,W
13B6:  MOVLB  02
13B7:  ADDWF  3B,W
13B8:  MOVWF  2F
13B9:  MOVF   79,W
13BA:  ADDWFC 3C,W
13BB:  MOVWF  30
....................     romstrcpy(rname,cPtr); 
13BC:  MOVLW  20
13BD:  MOVWF  3C
13BE:  MOVLW  B5
13BF:  MOVWF  3B
13C0:  MOVF   30,W
13C1:  MOVWF  3E
13C2:  MOVF   2F,W
13C3:  MOVWF  3D
13C4:  MOVLP  08
13C5:  MOVLB  00
13C6:  CALL   798
13C7:  MOVLP  10
....................   regPtr=RegMap[x].reg_ptr; 
13C8:  MOVLB  02
13C9:  RLF    2C,W
13CA:  MOVWF  3B
13CB:  RLF    2D,W
13CC:  MOVWF  3C
13CD:  RLF    3B,F
13CE:  RLF    3C,F
13CF:  MOVLW  FC
13D0:  ANDWF  3B,F
13D1:  MOVF   3C,W
13D2:  MOVWF  7A
13D3:  MOVF   3B,W
13D4:  MOVWF  3D
13D5:  INCF   3B,W
13D6:  MOVLP  00
13D7:  MOVLB  00
13D8:  CALL   043
13D9:  MOVLP  10
13DA:  MOVWF  7A
13DB:  MOVLB  02
13DC:  MOVF   3D,W
13DD:  MOVLP  00
13DE:  MOVLB  00
13DF:  CALL   043
13E0:  MOVLP  10
13E1:  MOVLB  02
13E2:  MOVWF  31
13E3:  MOVF   7A,W
13E4:  MOVWF  32
....................     printf("[%02Lu] %s %u\n\r",x,rname,*regPtr); 
13E5:  MOVF   32,W
13E6:  MOVWF  7A
13E7:  MOVF   31,W
13E8:  MOVWF  04
13E9:  MOVF   7A,W
13EA:  MOVWF  05
13EB:  MOVF   00,W
13EC:  MOVWF  3B
13ED:  MOVLW  5B
13EE:  CLRWDT
13EF:  MOVLB  00
13F0:  BTFSC  11.4
13F1:  GOTO   3F4
13F2:  MOVLB  02
13F3:  GOTO   3EE
13F4:  MOVLB  03
13F5:  MOVWF  1A
13F6:  MOVLW  0B
13F7:  MOVWF  04
13F8:  MOVLB  02
13F9:  MOVF   2D,W
13FA:  MOVWF  3D
13FB:  MOVF   2C,W
13FC:  MOVWF  3C
*
145A:  MOVLW  5D
145B:  CLRWDT
145C:  MOVLB  00
145D:  BTFSC  11.4
145E:  GOTO   461
145F:  MOVLB  02
1460:  GOTO   45B
1461:  MOVLB  03
1462:  MOVWF  1A
1463:  MOVLW  20
1464:  CLRWDT
1465:  MOVLB  00
1466:  BTFSC  11.4
1467:  GOTO   46A
1468:  MOVLB  03
1469:  GOTO   464
146A:  MOVLB  03
146B:  MOVWF  1A
146C:  MOVLW  20
146D:  MOVWF  05
146E:  MOVLW  B5
146F:  MOVWF  04
1470:  MOVLP  08
1471:  MOVLB  00
1472:  CALL   31B
1473:  MOVLP  10
1474:  MOVLW  20
1475:  CLRWDT
1476:  BTFSS  11.4
1477:  GOTO   475
1478:  MOVLB  03
1479:  MOVWF  1A
147A:  MOVLB  02
147B:  MOVF   3B,W
147C:  MOVWF  50
147D:  MOVLW  1B
147E:  MOVWF  51
147F:  MOVLP  08
1480:  MOVLB  00
1481:  CALL   000
1482:  MOVLP  10
1483:  MOVLW  0A
1484:  CLRWDT
1485:  BTFSS  11.4
1486:  GOTO   484
1487:  MOVLB  03
1488:  MOVWF  1A
1489:  MOVLW  0D
148A:  CLRWDT
148B:  MOVLB  00
148C:  BTFSC  11.4
148D:  GOTO   490
148E:  MOVLB  03
148F:  GOTO   48A
1490:  MOVLB  03
1491:  MOVWF  1A
....................     restart_wdt(); 
1492:  CLRWDT
....................   } 
1493:  MOVLB  02
1494:  INCF   2C,F
1495:  BTFSC  03.2
1496:  INCF   2D,F
1497:  GOTO   39D
....................   for(y=0;y<3;y++) { 
1498:  CLRF   2E
1499:  MOVF   2E,W
149A:  SUBLW  02
149B:  BTFSS  03.0
149C:  GOTO   4B3
....................     if(AuxInSW[y]==1) { 
149D:  MOVLW  1F
149E:  ADDWF  2E,W
149F:  MOVWF  04
14A0:  MOVLW  20
14A1:  MOVWF  05
14A2:  BTFSC  03.0
14A3:  INCF   05,F
14A4:  DECFSZ 00,W
14A5:  GOTO   4B1
....................       aux_in += 2<<y; 
14A6:  MOVLW  02
14A7:  MOVWF  77
14A8:  MOVF   2E,W
14A9:  MOVWF  78
14AA:  BTFSC  03.2
14AB:  GOTO   4AF
14AC:  LSLF   77,F
14AD:  DECFSZ 78,F
14AE:  GOTO   4AC
14AF:  MOVF   77,W
14B0:  ADDWF  34,F
....................     } 
....................   } 
14B1:  INCF   2E,F
14B2:  GOTO   499
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u",COR_IN,COR_EMUL,aux_in); 
14B3:  MOVLW  77
14B4:  MOVLB  03
14B5:  MOVWF  11
14B6:  MOVLW  04
14B7:  MOVWF  12
14B8:  BCF    03.0
14B9:  MOVLW  07
14BA:  MOVLB  02
14BB:  MOVWF  50
14BC:  MOVLP  00
14BD:  MOVLB  00
14BE:  CALL   77E
14BF:  MOVLP  10
14C0:  MOVF   5F,W
14C1:  MOVLB  02
14C2:  MOVWF  50
14C3:  MOVLW  1B
14C4:  MOVWF  51
14C5:  MOVLP  08
14C6:  MOVLB  00
14C7:  CALL   000
14C8:  MOVLP  10
14C9:  MOVLW  7B
14CA:  MOVLB  03
14CB:  MOVWF  11
14CC:  MOVLW  04
14CD:  MOVWF  12
14CE:  BSF    03.0
14CF:  MOVLW  07
14D0:  MOVLB  02
14D1:  MOVWF  50
14D2:  MOVLP  00
14D3:  MOVLB  00
14D4:  CALL   77E
14D5:  MOVLP  10
14D6:  MOVF   67,W
14D7:  MOVLB  02
14D8:  MOVWF  50
14D9:  MOVLW  1B
14DA:  MOVWF  51
14DB:  MOVLP  08
14DC:  MOVLB  00
14DD:  CALL   000
14DE:  MOVLP  10
14DF:  MOVLW  80
14E0:  MOVLB  03
14E1:  MOVWF  11
14E2:  MOVLW  04
14E3:  MOVWF  12
14E4:  BCF    03.0
14E5:  MOVLW  09
14E6:  MOVLB  02
14E7:  MOVWF  50
14E8:  MOVLP  00
14E9:  MOVLB  00
14EA:  CALL   77E
14EB:  MOVLP  10
14EC:  MOVLB  02
14ED:  MOVF   34,W
14EE:  MOVWF  50
14EF:  MOVLW  1B
14F0:  MOVWF  51
14F1:  MOVLP  08
14F2:  MOVLB  00
14F3:  CALL   000
14F4:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
14F5:  MOVLW  86
14F6:  MOVLB  03
14F7:  MOVWF  11
14F8:  MOVLW  04
14F9:  MOVWF  12
14FA:  BCF    03.0
14FB:  MOVLW  10
14FC:  MOVLB  02
14FD:  MOVWF  50
14FE:  MOVLP  00
14FF:  MOVLB  00
1500:  CALL   77E
1501:  MOVLP  10
1502:  MOVLB  02
1503:  MOVF   33,W
1504:  MOVWF  50
1505:  MOVLW  1B
1506:  MOVWF  51
1507:  MOVLP  08
1508:  MOVLB  00
1509:  CALL   000
150A:  MOVLP  10
150B:  MOVLW  0A
150C:  CLRWDT
150D:  BTFSS  11.4
150E:  GOTO   50C
150F:  MOVLB  03
1510:  MOVWF  1A
1511:  MOVLW  0D
1512:  CLRWDT
1513:  MOVLB  00
1514:  BTFSC  11.4
1515:  GOTO   518
1516:  MOVLB  03
1517:  GOTO   512
1518:  MOVLB  03
1519:  MOVWF  1A
....................   pot_values_to_lcd(); 
151A:  MOVLP  08
151B:  MOVLB  00
151C:  CALL   335
151D:  MOVLP  10
....................   PROMPT_FLAG=1; 
151E:  MOVLB  01
151F:  BSF    5B.2
.................... } // }}} 
....................  
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0B35:  MOVLW  20
0B36:  MOVLB  02
0B37:  MOVWF  42
0B38:  MOVWF  43
0B39:  MOVWF  44
0B3A:  MOVWF  45
....................   unsigned pval[4]={0,0,0,0}; 
0B3B:  CLRF   46
0B3C:  CLRF   47
0B3D:  CLRF   48
0B3E:  CLRF   49
....................   delay_ms(40); 
0B3F:  MOVLW  28
0B40:  MOVWF  4A
0B41:  MOVLB  00
0B42:  CALL   0C6
....................   i2c_start(); 
0B43:  MOVLB  04
0B44:  BSF    16.0
0B45:  BTFSC  16.0
0B46:  GOTO   345
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0B47:  MOVLW  51
0B48:  MOVLB  02
0B49:  MOVWF  50
0B4A:  MOVLP  00
0B4B:  MOVLB  00
0B4C:  CALL   769
0B4D:  MOVLP  08
0B4E:  MOVF   78,W
0B4F:  MOVLB  02
0B50:  BCF    41.1
0B51:  BTFSC  78.0
0B52:  BSF    41.1
....................   for(x=0;x<4;x++) { 
0B53:  CLRF   3F
0B54:  MOVF   3F,W
0B55:  SUBLW  03
0B56:  BTFSS  03.0
0B57:  GOTO   391
....................     if(x==3) { 
0B58:  MOVF   3F,W
0B59:  SUBLW  03
0B5A:  BTFSS  03.2
0B5B:  GOTO   35E
....................       ack=0; 
0B5C:  BCF    41.0
....................     } else { 
0B5D:  GOTO   35F
....................       ack=1; 
0B5E:  BSF    41.0
....................     } 
....................     pot_val=i2c_read(ack); 
0B5F:  MOVLW  00
0B60:  BTFSC  41.0
0B61:  MOVLW  01
0B62:  MOVWF  4A
0B63:  MOVF   4A,W
0B64:  MOVWF  77
*
0B73:  MOVF   78,W
0B74:  MOVLB  02
0B75:  MOVWF  40
....................     pot_val=pot_val&0x3F; 
0B76:  MOVLW  3F
0B77:  ANDWF  40,F
....................     pval[x]=pot_val; 
0B78:  MOVLW  C6
0B79:  ADDWF  3F,W
0B7A:  MOVWF  04
0B7B:  MOVLW  20
0B7C:  MOVWF  05
0B7D:  BTFSC  03.0
0B7E:  INCF   05,F
0B7F:  MOVF   40,W
0B80:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0B81:  MOVF   74,W
0B82:  ANDLW  03
0B83:  SUBWF  3F,W
0B84:  BTFSS  03.2
0B85:  GOTO   38F
....................       c[x] = '*'; 
0B86:  MOVLW  C2
0B87:  ADDWF  3F,W
0B88:  MOVWF  04
0B89:  MOVLW  20
0B8A:  MOVWF  05
0B8B:  BTFSC  03.0
0B8C:  INCF   05,F
0B8D:  MOVLW  2A
0B8E:  MOVWF  00
....................     } 
....................   } 
0B8F:  INCF   3F,F
0B90:  GOTO   354
....................   i2c_stop(); 
0B91:  MOVLB  04
0B92:  BSF    16.2
0B93:  BTFSC  16.2
0B94:  GOTO   393
....................   delay_ms(50); 
0B95:  MOVLW  32
0B96:  MOVLB  02
0B97:  MOVWF  4A
0B98:  MOVLB  00
0B99:  CALL   0C6
....................   if ( ack_in!=0 ) { 
0B9A:  MOVLB  02
0B9B:  BTFSS  41.1
0B9C:  GOTO   3B6
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0B9D:  MOVLW  00
0B9E:  BTFSC  41.0
0B9F:  MOVLW  01
0BA0:  MOVWF  4A
0BA1:  MOVLW  91
0BA2:  MOVLB  03
0BA3:  MOVWF  11
0BA4:  MOVLW  04
0BA5:  MOVWF  12
0BA6:  BCF    03.0
0BA7:  MOVLW  25
0BA8:  MOVLB  02
0BA9:  MOVWF  50
0BAA:  MOVLP  00
0BAB:  MOVLB  00
0BAC:  CALL   77E
0BAD:  MOVLP  08
0BAE:  MOVLB  02
0BAF:  MOVF   4A,W
0BB0:  MOVWF  50
0BB1:  MOVLW  1B
0BB2:  MOVWF  51
0BB3:  MOVLB  00
0BB4:  CALL   000
0BB5:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0BB6:  MOVLW  20
0BB7:  MOVLB  01
0BB8:  MOVWF  5D
0BB9:  MOVLW  73
0BBA:  MOVWF  5C
0BBB:  MOVLW  A5
0BBC:  MOVLB  03
0BBD:  MOVWF  11
0BBE:  MOVLW  04
0BBF:  MOVWF  12
0BC0:  BCF    03.0
0BC1:  MOVLW  04
0BC2:  MOVLB  02
0BC3:  MOVWF  4A
0BC4:  MOVLB  00
0BC5:  CALL   1EA
0BC6:  MOVLB  02
0BC7:  MOVF   42,W
0BC8:  MOVWF  50
0BC9:  MOVLB  00
0BCA:  CALL   1DB
0BCB:  MOVLB  02
0BCC:  MOVF   46,W
0BCD:  MOVWF  4A
0BCE:  MOVLW  18
0BCF:  MOVWF  4B
0BD0:  MOVLB  00
0BD1:  CALL   2B4
0BD2:  MOVLW  20
0BD3:  MOVLB  02
0BD4:  MOVWF  50
0BD5:  MOVLB  00
0BD6:  CALL   1DB
0BD7:  MOVLB  02
0BD8:  MOVF   43,W
0BD9:  MOVWF  50
0BDA:  MOVLB  00
0BDB:  CALL   1DB
0BDC:  MOVLB  02
0BDD:  MOVF   47,W
0BDE:  MOVWF  4A
0BDF:  MOVLW  18
0BE0:  MOVWF  4B
0BE1:  MOVLB  00
0BE2:  CALL   2B4
0BE3:  MOVLW  20
0BE4:  MOVLB  02
0BE5:  MOVWF  50
0BE6:  MOVLB  00
0BE7:  CALL   1DB
0BE8:  MOVLB  02
0BE9:  MOVF   44,W
0BEA:  MOVWF  50
0BEB:  MOVLB  00
0BEC:  CALL   1DB
0BED:  MOVLB  02
0BEE:  MOVF   48,W
0BEF:  MOVWF  4A
0BF0:  MOVLW  18
0BF1:  MOVWF  4B
0BF2:  MOVLB  00
0BF3:  CALL   2B4
0BF4:  MOVLW  20
0BF5:  MOVLB  02
0BF6:  MOVWF  50
0BF7:  MOVLB  00
0BF8:  CALL   1DB
0BF9:  MOVLB  02
0BFA:  MOVF   45,W
0BFB:  MOVWF  50
0BFC:  MOVLB  00
0BFD:  CALL   1DB
0BFE:  MOVLB  02
0BFF:  MOVF   49,W
0C00:  MOVWF  4A
0C01:  MOVLW  18
0C02:  MOVWF  4B
0C03:  MOVLB  00
0C04:  CALL   2B4
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0C05:  MOVLB  02
0C06:  CLRF   4A
0C07:  MOVLW  20
0C08:  MOVWF  4C
0C09:  MOVLW  73
0C0A:  MOVWF  4B
0C0B:  MOVLB  00
0C0C:  CALL   252
....................   printf("\n\r%s",LCD_str); 
0C0D:  MOVLW  0A
0C0E:  CLRWDT
0C0F:  BTFSS  11.4
0C10:  GOTO   40E
0C11:  MOVLB  03
0C12:  MOVWF  1A
0C13:  MOVLW  0D
0C14:  CLRWDT
0C15:  MOVLB  00
0C16:  BTFSC  11.4
0C17:  GOTO   41A
0C18:  MOVLB  03
0C19:  GOTO   414
0C1A:  MOVLB  03
0C1B:  MOVWF  1A
0C1C:  MOVLW  20
0C1D:  MOVWF  05
0C1E:  MOVLW  73
0C1F:  MOVWF  04
0C20:  MOVLB  00
0C21:  CALL   31B
....................  
.................... } // }}} 
0C22:  RETURN
....................  
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
0FD5:  MOVLB  01
0FD6:  BTFSS  5B.3
0FD7:  GOTO   7E3
....................     printf("\n\n\rADMIN> "); 
0FD8:  MOVLW  B1
0FD9:  MOVLB  03
0FDA:  MOVWF  11
0FDB:  MOVLW  04
0FDC:  MOVWF  12
0FDD:  MOVLP  00
0FDE:  MOVLB  00
0FDF:  CALL   55C
0FE0:  MOVLP  08
....................   } else { 
0FE1:  GOTO   7EC
0FE2:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
0FE3:  MOVLW  B7
0FE4:  MOVLB  03
0FE5:  MOVWF  11
0FE6:  MOVLW  04
0FE7:  MOVWF  12
0FE8:  MOVLP  00
0FE9:  MOVLB  00
0FEA:  CALL   55C
0FEB:  MOVLP  08
....................   } 
.................... } // }}} 
0FEC:  RETURN
....................  
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
0542:  MOVLW  10
0543:  MOVLB  01
0544:  MOVWF  66
....................   for (x=0;x<char_num;x++) { 
0545:  CLRF   65
0546:  MOVF   66,W
0547:  SUBWF  65,W
0548:  BTFSC  03.0
0549:  GOTO   554
....................     sBuffer[x]='\0'; 
054A:  MOVLW  4D
054B:  ADDWF  65,W
054C:  MOVWF  04
054D:  MOVLW  20
054E:  MOVWF  05
054F:  BTFSC  03.0
0550:  INCF   05,F
0551:  CLRF   00
....................   } 
0552:  INCF   65,F
0553:  GOTO   546
....................   sBufferIndex=0; 
0554:  CLRF   71
....................   sBufferFlag=0;   
0555:  BCF    72.0
....................   argument=-1; 
0556:  MOVLW  FF
0557:  MOVWF  75
....................   argument_name[0]='\0'; 
0558:  CLRF   3D
....................   command=0; 
0559:  CLRF   70
.................... } // }}} 
055A:  MOVLB  00
055B:  RETURN
....................  
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
0704:  MOVLW  00
0705:  MOVLB  01
0706:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
0707:  MOVLB  02
0708:  BCF    45.0
0709:  MOVF   43,W
070A:  ANDLW  0F
070B:  ANDLW  01
070C:  BTFSS  03.2
070D:  BSF    45.0
....................   output_bit(DTMF_D0,dbit); 
070E:  BTFSC  45.0
070F:  GOTO   712
0710:  BCF    0F.0
0711:  GOTO   713
0712:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
0713:  BCF    45.0
0714:  MOVF   43,W
0715:  ANDLW  0F
0716:  ANDLW  02
0717:  BTFSS  03.2
0718:  BSF    45.0
....................   output_bit(DTMF_D1,dbit); 
0719:  BTFSC  45.0
071A:  GOTO   71D
071B:  BCF    0F.1
071C:  GOTO   71E
071D:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
071E:  BCF    45.0
071F:  MOVF   43,W
0720:  ANDLW  0F
0721:  ANDLW  04
0722:  BTFSS  03.2
0723:  BSF    45.0
....................   output_bit(DTMF_D2,dbit); 
0724:  BTFSC  45.0
0725:  GOTO   728
0726:  BCF    0F.2
0727:  GOTO   729
0728:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
0729:  BCF    45.0
072A:  MOVF   43,W
072B:  ANDLW  0F
072C:  ANDLW  08
072D:  BTFSS  03.2
072E:  BSF    45.0
....................   output_bit(DTMF_D3,dbit); 
072F:  BTFSC  45.0
0730:  GOTO   733
0731:  BCF    0F.3
0732:  GOTO   734
0733:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
0734:  MOVF   44,F
0735:  BTFSS  03.2
0736:  GOTO   739
0737:  BCF    0F.6
0738:  GOTO   73A
0739:  BSF    0F.6
....................   delay_cycles(2); 
073A:  GOTO   73B
....................   output_bit(DTMF_WEB,0); 
073B:  BCF    0F.5
....................   delay_cycles(2); 
073C:  GOTO   73D
....................   output_bit(DTMF_WEB,1);   
073D:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
073E:  GOTO   73F
....................   set_tris_d(0x0F); 
073F:  MOVLW  0F
0740:  MOVLB  01
0741:  MOVWF  0F
.................... } // }}} 
0742:  MOVLB  00
0743:  RETURN
....................  
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
*
033E:  MOVLW  0F
033F:  MOVLB  01
0340:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
0341:  MOVLB  02
0342:  MOVF   58,F
0343:  BTFSS  03.2
0344:  GOTO   347
0345:  BCF    0F.6
0346:  GOTO   348
0347:  BSF    0F.6
....................   delay_cycles(1); 
0348:  NOP
....................   output_bit(DTMF_REB,0); 
0349:  BCF    0F.4
....................   delay_cycles(1); 
034A:  NOP
....................   value=input_d(); 
034B:  MOVLB  00
034C:  MOVF   0F,W
034D:  MOVLB  02
034E:  MOVWF  59
....................   value&=0x0F; 
034F:  MOVLW  0F
0350:  ANDWF  59,F
....................   output_bit(DTMF_REB,1); 
0351:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
0352:  NOP
....................   return(value); 
0353:  MOVF   59,W
0354:  MOVWF  78
.................... } // }}} 
0355:  MOVLB  00
0356:  RETURN
....................  
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0DBE:  MOVLB  02
0DBF:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0DC0:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0DC1:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0DC2:  CLRF   43
0DC3:  MOVLW  01
0DC4:  MOVWF  44
0DC5:  MOVLP  00
0DC6:  MOVLB  00
0DC7:  CALL   704
0DC8:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0DC9:  MOVLB  02
0DCA:  CLRF   43
0DCB:  MOVLW  01
0DCC:  MOVWF  44
0DCD:  MOVLP  00
0DCE:  MOVLB  00
0DCF:  CALL   704
0DD0:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0DD1:  MOVLW  0C
0DD2:  MOVLB  02
0DD3:  MOVWF  43
0DD4:  MOVLW  01
0DD5:  MOVWF  44
0DD6:  MOVLP  00
0DD7:  MOVLB  00
0DD8:  CALL   704
0DD9:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0DDA:  MOVLW  01
0DDB:  MOVLB  02
0DDC:  MOVWF  43
0DDD:  MOVWF  44
0DDE:  MOVLP  00
0DDF:  MOVLB  00
0DE0:  CALL   704
0DE1:  MOVLP  08
0DE2:  CLRF   25
0DE3:  BTFSC  0B.7
0DE4:  BSF    25.7
0DE5:  BCF    0B.7
....................     dtmf_read(CONTROL_REG); 
0DE6:  MOVLW  01
0DE7:  MOVLB  02
0DE8:  MOVWF  58
0DE9:  MOVLP  00
0DEA:  MOVLB  00
0DEB:  CALL   33E
0DEC:  MOVLP  08
0DED:  BTFSC  25.7
0DEE:  BSF    0B.7
.................... } // }}} 
....................  
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19EC:  MOVF   40,W
19ED:  MOVWF  43
19EE:  CLRF   44
19EF:  MOVLP  00
19F0:  MOVLB  00
19F1:  CALL   704
19F2:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19F3:  MOVLW  0C
19F4:  MOVLB  02
19F5:  MOVWF  43
19F6:  MOVLW  01
19F7:  MOVWF  44
19F8:  MOVLP  00
19F9:  MOVLB  00
19FA:  CALL   704
19FB:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
19FC:  MOVLW  01
19FD:  MOVLB  02
19FE:  MOVWF  43
19FF:  MOVWF  44
1A00:  MOVLP  00
1A01:  MOVLB  00
1A02:  CALL   704
1A03:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A04:  MOVLW  05
1A05:  MOVLB  02
1A06:  MOVWF  43
1A07:  MOVLW  01
1A08:  MOVWF  44
1A09:  MOVLP  00
1A0A:  MOVLB  00
1A0B:  CALL   704
1A0C:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A0D:  MOVLB  01
1A0E:  CLRF   30
1A0F:  MOVLW  10
1A10:  MOVWF  2F
....................   while(aux_timer) { 
1A11:  MOVF   2F,W
1A12:  IORWF  30,W
1A13:  BTFSC  03.2
1A14:  GOTO   217
....................     delay_cycles(1); 
1A15:  NOP
....................   } 
1A16:  GOTO   211
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A17:  MOVLW  04
1A18:  MOVLB  02
1A19:  MOVWF  43
1A1A:  MOVLW  01
1A1B:  MOVWF  44
1A1C:  MOVLP  00
1A1D:  MOVLB  00
1A1E:  CALL   704
1A1F:  MOVLP  18
.................... } // }}} 
....................  
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
08F2:  MOVLW  01
08F3:  MOVLB  02
08F4:  MOVWF  43
08F5:  CLRF   44
08F6:  MOVLP  00
08F7:  MOVLB  00
08F8:  CALL   704
08F9:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
08FA:  MOVLW  0C
08FB:  MOVLB  02
08FC:  MOVWF  43
08FD:  MOVLW  01
08FE:  MOVWF  44
08FF:  MOVLP  00
0900:  MOVLB  00
0901:  CALL   704
0902:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0903:  MOVLW  05
0904:  MOVLB  02
0905:  MOVWF  43
0906:  MOVLW  01
0907:  MOVWF  44
0908:  MOVLP  00
0909:  MOVLB  00
090A:  CALL   704
090B:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
090C:  MOVLW  05
090D:  MOVLB  02
090E:  MOVWF  43
090F:  MOVLW  01
0910:  MOVWF  44
0911:  MOVLP  00
0912:  MOVLB  00
0913:  CALL   704
0914:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
0915:  MOVLB  01
0916:  CLRF   30
0917:  MOVLW  02
0918:  MOVWF  2F
....................   while(aux_timer) { 
0919:  MOVF   2F,W
091A:  IORWF  30,W
091B:  BTFSC  03.2
091C:  GOTO   11F
....................     delay_cycles(1); 
091D:  NOP
....................   } 
091E:  GOTO   119
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
091F:  MOVLW  04
0920:  MOVLB  02
0921:  MOVWF  43
0922:  MOVLW  01
0923:  MOVWF  44
0924:  MOVLP  00
0925:  MOVLB  00
0926:  CALL   704
0927:  MOVLP  08
....................   restart_wdt(); 
0928:  CLRWDT
.................... } // }}} 
0929:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
092A:  MOVLW  01
092B:  MOVLB  02
092C:  MOVWF  43
092D:  CLRF   44
092E:  MOVLP  00
092F:  MOVLB  00
0930:  CALL   704
0931:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0932:  MOVLW  0C
0933:  MOVLB  02
0934:  MOVWF  43
0935:  MOVLW  01
0936:  MOVWF  44
0937:  MOVLP  00
0938:  MOVLB  00
0939:  CALL   704
093A:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
093B:  MOVLW  05
093C:  MOVLB  02
093D:  MOVWF  43
093E:  MOVLW  01
093F:  MOVWF  44
0940:  MOVLP  00
0941:  MOVLB  00
0942:  CALL   704
0943:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0944:  MOVLW  05
0945:  MOVLB  02
0946:  MOVWF  43
0947:  MOVLW  01
0948:  MOVWF  44
0949:  MOVLP  00
094A:  MOVLB  00
094B:  CALL   704
094C:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
094D:  MOVLB  01
094E:  CLRF   30
094F:  MOVLW  06
0950:  MOVWF  2F
....................   while(aux_timer) { 
0951:  MOVF   2F,W
0952:  IORWF  30,W
0953:  BTFSC  03.2
0954:  GOTO   157
....................     delay_cycles(1); 
0955:  NOP
....................   } 
0956:  GOTO   151
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0957:  MOVLW  04
0958:  MOVLB  02
0959:  MOVWF  43
095A:  MOVLW  01
095B:  MOVWF  44
095C:  MOVLP  00
095D:  MOVLB  00
095E:  CALL   704
095F:  MOVLP  08
....................   restart_wdt(); 
0960:  CLRWDT
.................... } // }}} 
0961:  RETURN
....................  
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
05D6:  MOVLB  02
05D7:  MOVF   38,W
05D8:  MOVWF  04
05D9:  MOVF   39,W
05DA:  MOVWF  05
05DB:  MOVF   00,W
05DC:  MOVWF  3B
....................   if ( tmp > 127 ) { 
05DD:  MOVF   3B,W
05DE:  SUBLW  7F
05DF:  BTFSS  03.0
....................     tmp++; 
05E0:  INCF   3B,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
05E1:  BCF    03.0
05E2:  RLF    3B,W
05E3:  XORLW  09
05E4:  ADDWF  3A,W
05E5:  MOVWF  3B
....................   *cksum=tmp; 
05E6:  MOVF   38,W
05E7:  MOVWF  04
05E8:  MOVF   39,W
05E9:  MOVWF  05
05EA:  MOVF   3B,W
05EB:  MOVWF  00
.................... } // }}} 
05EC:  MOVLB  00
05ED:  RETURN
....................  
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
05EE:  MOVLW  01
05EF:  MOVLB  02
05F0:  MOVWF  32
....................   eeprom_index=0; 
05F1:  CLRF   33
....................   retVal = 1; 
05F2:  MOVWF  35
....................   if ( source == USE_EEPROM_VARS ) { 
05F3:  DECFSZ 2E,W
05F4:  GOTO   5FE
....................     printf("\n\rInitializing RAM variables from EEPROM"); 
05F5:  MOVLW  BE
05F6:  MOVLB  03
05F7:  MOVWF  11
05F8:  MOVLW  04
05F9:  MOVWF  12
05FA:  MOVLB  00
05FB:  CALL   55C
....................   } else { 
05FC:  GOTO   605
05FD:  MOVLB  02
....................     printf("\n\rInitializing RAM variables with firmware default values"); 
05FE:  MOVLW  D3
05FF:  MOVLB  03
0600:  MOVWF  11
0601:  MOVLW  04
0602:  MOVWF  12
0603:  MOVLB  00
0604:  CALL   55C
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
0605:  MOVLB  02
0606:  CLRF   2F
0607:  MOVF   2F,W
0608:  SUBLW  37
0609:  BTFSS  03.0
060A:  GOTO   664
....................     regPtr=RegMap[x].reg_ptr; 
060B:  RLF    2F,W
060C:  MOVWF  77
060D:  RLF    77,F
060E:  MOVLW  FC
060F:  ANDWF  77,F
0610:  MOVF   77,W
0611:  MOVWF  37
0612:  INCF   37,W
0613:  MOVLB  00
0614:  CALL   043
0615:  MOVWF  7A
0616:  MOVLB  02
0617:  MOVF   37,W
0618:  MOVLB  00
0619:  CALL   043
061A:  MOVLB  02
061B:  MOVWF  30
061C:  MOVF   7A,W
061D:  MOVWF  31
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
061E:  DECFSZ 2E,W
061F:  GOTO   650
0620:  RLF    2F,W
0621:  MOVWF  77
0622:  RLF    77,F
0623:  MOVLW  FC
0624:  ANDWF  77,F
0625:  MOVF   77,W
0626:  ADDLW  03
0627:  MOVLB  00
0628:  CALL   043
0629:  MOVWF  78
062A:  BTFSC  78.0
062B:  GOTO   62E
062C:  MOVLB  02
062D:  GOTO   650
....................     eeprom_val=read_eeprom(eeprom_index); 
062E:  MOVLB  02
062F:  MOVF   33,W
0630:  MOVLB  03
0631:  MOVWF  11
0632:  BCF    15.7
0633:  BSF    15.0
0634:  MOVF   13,W
0635:  MOVLB  02
0636:  MOVWF  36
....................     *regPtr=eeprom_val; 
0637:  MOVF   30,W
0638:  MOVWF  04
0639:  MOVF   31,W
063A:  MOVWF  05
063B:  MOVF   36,W
063C:  MOVWF  00
....................     update_checksum(&cksum,*regPtr);     
063D:  MOVF   31,W
063E:  MOVWF  7A
063F:  MOVF   30,W
0640:  MOVWF  04
0641:  MOVF   31,W
0642:  MOVWF  05
0643:  MOVF   00,W
0644:  MOVWF  37
0645:  MOVLW  20
0646:  MOVWF  39
0647:  MOVLW  B2
0648:  MOVWF  38
0649:  MOVF   37,W
064A:  MOVWF  3A
064B:  MOVLB  00
064C:  CALL   5D6
....................       eeprom_index++; 
064D:  MOVLB  02
064E:  INCF   33,F
....................     } else { 
064F:  GOTO   662
....................       default_value=(int8)RegMap[x].default_value; 
0650:  RLF    2F,W
0651:  MOVWF  77
0652:  RLF    77,F
0653:  MOVLW  FC
0654:  ANDWF  77,F
0655:  MOVF   77,W
0656:  ADDLW  02
0657:  MOVLB  00
0658:  CALL   043
0659:  MOVWF  78
065A:  MOVLB  02
065B:  MOVWF  34
....................       *regPtr=default_value; 
065C:  MOVF   30,W
065D:  MOVWF  04
065E:  MOVF   31,W
065F:  MOVWF  05
0660:  MOVF   34,W
0661:  MOVWF  00
....................     } 
....................   } 
0662:  INCF   2F,F
0663:  GOTO   607
....................   if ( source == USE_EEPROM_VARS ) { 
0664:  DECFSZ 2E,W
0665:  GOTO   670
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
0666:  MOVF   33,W
0667:  MOVLB  03
0668:  MOVWF  11
0669:  BCF    15.7
066A:  BSF    15.0
066B:  MOVF   13,W
066C:  MOVLB  02
066D:  SUBWF  32,W
066E:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match whenn initializing variables from EEPROM 
066F:  CLRF   35
....................     } 
....................   } 
....................   return (retVal); 
0670:  MOVF   35,W
0671:  MOVWF  78
.................... } // }}} 
0672:  MOVLB  00
0673:  RETURN
....................  
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
0674:  MOVLW  01
0675:  MOVLB  02
0676:  MOVWF  32
....................  
....................   eeprom_index=0; 
0677:  CLRF   2F
....................   for(x=0;x<RegMapNum;x++) { 
0678:  CLRF   2E
0679:  MOVF   2E,W
067A:  SUBLW  37
067B:  BTFSS  03.0
067C:  GOTO   6D2
....................     regPtr=RegMap[x].reg_ptr; 
067D:  RLF    2E,W
067E:  MOVWF  77
067F:  RLF    77,F
0680:  MOVLW  FC
0681:  ANDWF  77,F
0682:  MOVF   77,W
0683:  MOVWF  34
0684:  INCF   34,W
0685:  MOVLB  00
0686:  CALL   043
0687:  MOVWF  7A
0688:  MOVLB  02
0689:  MOVF   34,W
068A:  MOVLB  00
068B:  CALL   043
068C:  MOVLB  02
068D:  MOVWF  30
068E:  MOVF   7A,W
068F:  MOVWF  31
....................     if ( RegMap[x].non_volatile ) { 
0690:  RLF    2E,W
0691:  MOVWF  77
0692:  RLF    77,F
0693:  MOVLW  FC
0694:  ANDWF  77,F
0695:  MOVF   77,W
0696:  ADDLW  03
0697:  MOVLB  00
0698:  CALL   043
0699:  MOVWF  78
069A:  BTFSS  78.0
069B:  GOTO   6CF
....................      value=*regPtr; 
069C:  MOVLB  02
069D:  MOVF   30,W
069E:  MOVWF  04
069F:  MOVF   31,W
06A0:  MOVWF  05
06A1:  MOVF   00,W
06A2:  MOVWF  33
....................      if ( read_eeprom(eeprom_index) != value ) { 
06A3:  MOVF   2F,W
06A4:  MOVLB  03
06A5:  MOVWF  11
06A6:  BCF    15.7
06A7:  BSF    15.0
06A8:  MOVF   13,W
06A9:  MOVLB  02
06AA:  SUBWF  33,W
06AB:  BTFSC  03.2
06AC:  GOTO   6C4
....................        write_eeprom(eeprom_index,value); 
06AD:  MOVF   0B,W
06AE:  MOVWF  77
06AF:  BCF    0B.7
06B0:  MOVF   2F,W
06B1:  MOVLB  03
06B2:  MOVWF  11
06B3:  MOVLB  02
06B4:  MOVF   33,W
06B5:  MOVLB  03
06B6:  MOVWF  13
06B7:  BCF    15.7
06B8:  BSF    15.2
06B9:  MOVLW  55
06BA:  MOVWF  16
06BB:  MOVLW  AA
06BC:  MOVWF  16
06BD:  BSF    15.1
06BE:  BTFSC  15.1
06BF:  GOTO   6BE
06C0:  BCF    15.2
06C1:  MOVF   77,W
06C2:  IORWF  0B,F
06C3:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
06C4:  MOVLW  20
06C5:  MOVWF  39
06C6:  MOVLW  B2
06C7:  MOVWF  38
06C8:  MOVF   33,W
06C9:  MOVWF  3A
06CA:  MOVLB  00
06CB:  CALL   5D6
....................      eeprom_index++; 
06CC:  MOVLB  02
06CD:  INCF   2F,F
06CE:  MOVLB  00
....................     } 
....................   } 
06CF:  MOVLB  02
06D0:  INCF   2E,F
06D1:  GOTO   679
....................   write_eeprom(eeprom_index,cksum); 
06D2:  MOVF   0B,W
06D3:  MOVWF  77
06D4:  BCF    0B.7
06D5:  MOVF   2F,W
06D6:  MOVLB  03
06D7:  MOVWF  11
06D8:  MOVLB  02
06D9:  MOVF   32,W
06DA:  MOVLB  03
06DB:  MOVWF  13
06DC:  BCF    15.7
06DD:  BSF    15.2
06DE:  MOVLW  55
06DF:  MOVWF  16
06E0:  MOVLW  AA
06E1:  MOVWF  16
06E2:  BSF    15.1
06E3:  BTFSC  15.1
06E4:  GOTO   6E3
06E5:  BCF    15.2
06E6:  MOVF   77,W
06E7:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
06E8:  MOVLW  F0
06E9:  MOVWF  11
06EA:  MOVLW  04
06EB:  MOVWF  12
06EC:  MOVLB  00
06ED:  CALL   55C
.................... } // }}} 
06EE:  RETURN
....................  
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
06EF:  MOVLB  02
06F0:  MOVF   2D,W
06F1:  MOVWF  2E
06F2:  MOVLB  00
06F3:  CALL   5EE
06F4:  MOVF   78,F
06F5:  BTFSS  03.2
06F6:  GOTO   703
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
06F7:  MOVLW  03
06F8:  MOVLB  03
06F9:  MOVWF  11
06FA:  MOVLW  05
06FB:  MOVWF  12
06FC:  MOVLB  00
06FD:  CALL   55C
....................         _init_variables(USE_DEFAULT_VARS); 
06FE:  MOVLB  02
06FF:  CLRF   2E
0700:  MOVLB  00
0701:  CALL   5EE
....................     store_variables(); 
0702:  CALL   674
....................     } 
.................... } // }}} 
0703:  RETURN
....................  
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0DF9:  MOVLB  02
0DFA:  CLRF   3F
0DFB:  CLRF   40
0DFC:  MOVLB  00
0DFD:  CALL   053
....................   set_trimpot(1,0); 
0DFE:  MOVLW  01
0DFF:  MOVLB  02
0E00:  MOVWF  3F
0E01:  CLRF   40
0E02:  MOVLB  00
0E03:  CALL   053
....................   set_trimpot(2,0); 
0E04:  MOVLW  02
0E05:  MOVLB  02
0E06:  MOVWF  3F
0E07:  CLRF   40
0E08:  MOVLB  00
0E09:  CALL   053
....................   set_trimpot(3,0); 
0E0A:  MOVLW  03
0E0B:  MOVLB  02
0E0C:  MOVWF  3F
0E0D:  CLRF   40
0E0E:  MOVLB  00
0E0F:  CALL   053
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0D7F:  MOVLP  00
0D80:  CALL   542
0D81:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0D82:  MOVLB  02
0D83:  CLRF   12
0D84:  CLRF   11
0D85:  CLRF   14
0D86:  CLRF   13
....................   setup_wdt(WDT_2S); 
0D87:  MOVLW  17
0D88:  MOVLB  01
0D89:  MOVWF  17
....................   WPUB=0x00; 
0D8A:  MOVLB  04
0D8B:  CLRF   0D
....................   // AuxIn pins : B6, B7, C0 
....................   port_b_pullups(AUX_IN0|AUX_IN1); 
0D8C:  MOVLW  6F
0D8D:  MOVWF  0D
0D8E:  MOVLB  01
0D8F:  BCF    15.7
....................   // No pull-ups are available on port c 
....................   //port_c_pullups(AUX_IN2); 
....................   COR_IN=0; 
0D90:  MOVLB  00
0D91:  CLRF   5F
....................   COR_DROP_FLAG=0; 
0D92:  BCF    72.5
....................   LastRegisterIndexValid=0; 
0D93:  CLRF   7D
....................   LastRegisterIndex=0; 
0D94:  CLRF   7C
....................   CurrentCorMask=0; 
0D95:  CLRF   6A
....................   CurrentCorPriority=0; 
0D96:  CLRF   6C
....................   CurrentCorIndex=0; 
0D97:  CLRF   6B
....................   CurrentTrimPot=0; 
0D98:  CLRF   74
....................   setup_adc(NO_ANALOGS); 
0D99:  MOVLB  01
0D9A:  BCF    1D.0
....................   set_tris_b(0xFF); 
0D9B:  MOVLW  FF
0D9C:  TRIS   6
....................   set_tris_d(0x00); 
0D9D:  MOVLW  00
0D9E:  MOVWF  0F
....................   set_tris_e(0xF8); 
0D9F:  BCF    10.0
0DA0:  BCF    10.1
0DA1:  BCF    10.2
0DA2:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0DA3:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0DA4:  BSF    0B.3
0DA5:  MOVLW  CF
0DA6:  MOVLB  07
0DA7:  IORWF  14,F
0DA8:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0DA9:  BSF    0B.3
0DAA:  BSF    15.4
0DAB:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0DAC:  MOVLW  C0
0DAD:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0DAE:  MOVLB  02
0DAF:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0DB0:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0DB1:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0DB2:  BCF    0F.6
....................   clearscr(); 
0DB3:  MOVLP  00
0DB4:  MOVLB  00
0DB5:  CALL   5B1
0DB6:  MOVLP  08
....................   init_variables(USE_EEPROM_VARS); 
0DB7:  MOVLW  01
0DB8:  MOVLB  02
0DB9:  MOVWF  2D
0DBA:  MOVLP  00
0DBB:  MOVLB  00
0DBC:  CALL   6EF
0DBD:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0DEF:  MOVLB  01
0DF0:  BSF    5B.1
....................   Enable_Mask = 0x0F; 
0DF1:  MOVLW  0F
0DF2:  MOVLB  00
0DF3:  MOVWF  61
....................   header(); 
0DF4:  MOVLP  00
0DF5:  CALL   744
0DF6:  MOVLP  08
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0DF7:  MOVLW  9D
0DF8:  TRIS   7
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0E10:  MOVLB  01
0E11:  CLRF   2E
0E12:  MOVLW  1E
0E13:  MOVWF  2D
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0E14:  MOVF   15,W
0E15:  ANDLW  C0
0E16:  IORLW  07
0E17:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0E18:  BSF    0B.5
....................   update_ptt(0); 
0E19:  MOVLB  02
0E1A:  CLRF   2E
0E1B:  MOVLB  00
0E1C:  CALL   423
....................   MinuteCounter=MIN_COUNTER; 
0E1D:  MOVLW  1D
0E1E:  MOVLB  01
0E1F:  MOVWF  58
....................   SecondCounter=SEC_COUNTER; 
0E20:  MOVLW  3B
0E21:  MOVWF  7E
....................   THIRTY_MIN_FLAG=0; 
0E22:  BCF    72.4
....................   MINUTE_FLAG=0; 
0E23:  BCF    72.3
....................   PROMPT_FLAG=1; 
0E24:  BSF    5B.2
....................   TailChar=Tail; 
0E25:  MOVLB  00
0E26:  MOVF   65,W
0E27:  MOVWF  68
....................   ConfirmChar=0; 
0E28:  CLRF   69
....................   AuxOut[0] = PO_AUX_OUT0; 
0E29:  MOVLW  01
0E2A:  MOVWF  42
....................   AuxOut[1] = PO_AUX_OUT1; 
0E2B:  MOVWF  43
....................   AuxOut[2] = PO_AUX_OUT2; 
0E2C:  MOVWF  44
....................   AuxInSW[0] = 0; 
0E2D:  CLRF   3F
....................   AuxInSW[1] = 0; 
0E2E:  CLRF   40
....................   AuxInSW[2] = 0; 
0E2F:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0E30:  BCF    72.6
....................   set_admin_mode(0); 
0E31:  MOVLB  02
0E32:  CLRF   40
0E33:  MOVLB  00
0E34:  CALL   568
....................   rs232_mode=0; 
0E35:  MOVLB  01
0E36:  BCF    5B.4
....................   printf("\n\rInitialization complete"); 
0E37:  MOVLW  1C
0E38:  MOVLB  03
0E39:  MOVWF  11
0E3A:  MOVLW  05
0E3B:  MOVWF  12
0E3C:  MOVLP  00
0E3D:  MOVLB  00
0E3E:  CALL   55C
0E3F:  MOVLP  08
.................... } // }}} 
0E40:  MOVLP  18
0E41:  GOTO   681 (RETURN)
....................  
.................... void tokenize_sBuffer() { // {{{ 
*
180D:  MOVLB  02
180E:  BCF    28.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
180F:  CLRF   3F
1810:  CLRF   40
1811:  MOVLW  20
1812:  MOVWF  05
1813:  MOVLW  AB
1814:  MOVWF  04
1815:  MOVF   3F,W
1816:  ADDWF  04,F
1817:  MOVLW  00
1818:  ADDWFC 05,F
1819:  MOVF   40,W
181A:  MOVLP  00
181B:  MOVLB  00
181C:  CALL   135
181D:  MOVLP  18
181E:  MOVWF  00
181F:  IORLW  00
1820:  BTFSC  03.2
1821:  GOTO   027
1822:  MOVLB  02
1823:  INCF   40,F
1824:  INCF   3F,F
1825:  GOTO   011
1826:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1827:  MOVLW  20
1828:  MOVLB  02
1829:  MOVWF  40
182A:  MOVLW  4D
182B:  MOVWF  3F
182C:  MOVLW  20
182D:  MOVWF  42
182E:  MOVLW  AB
182F:  MOVWF  41
1830:  MOVLP  08
1831:  MOVLB  00
1832:  CALL   642
1833:  MOVLP  18
1834:  MOVF   79,W
1835:  MOVLB  02
1836:  MOVWF  2A
1837:  MOVF   78,W
1838:  MOVWF  29
....................   if (sptr!=0) {; 
1839:  MOVF   29,F
183A:  BTFSS  03.2
183B:  GOTO   03F
183C:  MOVF   2A,F
183D:  BTFSC  03.2
183E:  GOTO   059
....................     strcpy(verb,sptr); 
183F:  MOVF   2A,W
1840:  MOVWF  42
1841:  MOVF   29,W
1842:  MOVWF  41
1843:  MOVLW  20
1844:  MOVWF  40
1845:  MOVLW  A0
1846:  MOVWF  3F
1847:  MOVF   42,W
1848:  MOVWF  05
1849:  MOVF   41,W
184A:  MOVWF  04
184B:  MOVF   00,W
184C:  MOVWF  43
184D:  MOVF   40,W
184E:  MOVWF  05
184F:  MOVF   3F,W
1850:  MOVWF  04
1851:  MOVF   43,W
1852:  MOVWF  00
1853:  MOVF   00,F
1854:  BTFSC  03.2
1855:  GOTO   059
1856:  INCF   3F,F
1857:  INCF   41,F
1858:  GOTO   047
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
1859:  CLRF   40
185A:  CLRF   3F
185B:  MOVLW  20
185C:  MOVWF  42
185D:  MOVLW  AB
185E:  MOVWF  41
185F:  MOVLP  08
1860:  MOVLB  00
1861:  CALL   642
1862:  MOVLP  18
1863:  MOVF   79,W
1864:  MOVLB  02
1865:  MOVWF  2A
1866:  MOVF   78,W
1867:  MOVWF  29
....................   if (sptr!=0) {; 
1868:  MOVF   29,F
1869:  BTFSS  03.2
186A:  GOTO   06E
186B:  MOVF   2A,F
186C:  BTFSC  03.2
186D:  GOTO   088
....................     strcpy(argument_name,sptr); 
186E:  MOVF   2A,W
186F:  MOVWF  42
1870:  MOVF   29,W
1871:  MOVWF  41
1872:  MOVLW  20
1873:  MOVWF  40
1874:  MOVLW  6D
1875:  MOVWF  3F
1876:  MOVF   42,W
1877:  MOVWF  05
1878:  MOVF   41,W
1879:  MOVWF  04
187A:  MOVF   00,W
187B:  MOVWF  43
187C:  MOVF   40,W
187D:  MOVWF  05
187E:  MOVF   3F,W
187F:  MOVWF  04
1880:  MOVF   43,W
1881:  MOVWF  00
1882:  MOVF   00,F
1883:  BTFSC  03.2
1884:  GOTO   088
1885:  INCF   3F,F
1886:  INCF   41,F
1887:  GOTO   076
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1888:  CLRF   40
1889:  CLRF   3F
188A:  MOVLW  20
188B:  MOVWF  42
188C:  MOVLW  AB
188D:  MOVWF  41
188E:  MOVLP  08
188F:  MOVLB  00
1890:  CALL   642
1891:  MOVLP  18
1892:  MOVF   79,W
1893:  MOVLB  02
1894:  MOVWF  2A
1895:  MOVF   78,W
1896:  MOVWF  29
....................   if (sptr!=0) {; 
1897:  MOVF   29,F
1898:  BTFSS  03.2
1899:  GOTO   09D
189A:  MOVF   2A,F
189B:  BTFSC  03.2
189C:  GOTO   0C3
....................     strcpy(match_val,sptr); 
189D:  MOVF   2A,W
189E:  MOVWF  42
189F:  MOVF   29,W
18A0:  MOVWF  41
18A1:  MOVLW  20
18A2:  MOVWF  40
18A3:  MOVLW  B3
18A4:  MOVWF  3F
18A5:  MOVF   42,W
18A6:  MOVWF  05
18A7:  MOVF   41,W
18A8:  MOVWF  04
18A9:  MOVF   00,W
18AA:  MOVWF  43
18AB:  MOVF   40,W
18AC:  MOVWF  05
18AD:  MOVF   3F,W
18AE:  MOVWF  04
18AF:  MOVF   43,W
18B0:  MOVWF  00
18B1:  MOVF   00,F
18B2:  BTFSC  03.2
18B3:  GOTO   0B7
18B4:  INCF   3F,F
18B5:  INCF   41,F
18B6:  GOTO   0A5
....................     value = str_to_decimal(match_val); 
18B7:  MOVLW  20
18B8:  MOVWF  40
18B9:  MOVLW  B3
18BA:  MOVWF  3F
18BB:  MOVLP  08
18BC:  MOVLB  00
18BD:  CALL   748
18BE:  MOVLP  18
18BF:  MOVF   78,W
18C0:  MOVWF  76
....................   } else { 
18C1:  GOTO   0C6
18C2:  MOVLB  02
....................     value = 0; 
18C3:  CLRF   76
....................     do_get_var = 1; 
18C4:  BSF    28.0
18C5:  MOVLB  00
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18C6:  MOVLB  02
18C7:  CLRF   3F
18C8:  CLRF   40
18C9:  MOVLW  20
18CA:  MOVWF  05
18CB:  MOVLW  B7
18CC:  MOVWF  04
18CD:  MOVF   3F,W
18CE:  ADDWF  04,F
18CF:  MOVLW  00
18D0:  ADDWFC 05,F
18D1:  MOVF   40,W
18D2:  MOVLP  00
18D3:  MOVLB  00
18D4:  CALL   13B
18D5:  MOVLP  18
18D6:  MOVWF  00
18D7:  IORLW  00
18D8:  BTFSC  03.2
18D9:  GOTO   0DF
18DA:  MOVLB  02
18DB:  INCF   40,F
18DC:  INCF   3F,F
18DD:  GOTO   0C9
18DE:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
18DF:  MOVLW  20
18E0:  MOVLB  02
18E1:  MOVWF  40
18E2:  MOVLW  B7
18E3:  MOVWF  3F
18E4:  MOVLW  20
18E5:  MOVWF  42
18E6:  MOVLW  A0
18E7:  MOVWF  41
18E8:  MOVLP  10
18E9:  MOVLB  00
18EA:  CALL   000
18EB:  MOVLP  18
18EC:  MOVF   78,F
18ED:  BTFSS  03.2
18EE:  GOTO   0F8
....................     if ( do_get_var ) { 
18EF:  MOVLB  02
18F0:  BTFSS  28.0
18F1:  GOTO   0F5
....................       command=GET_REG; 
18F2:  MOVLW  03
18F3:  MOVWF  70
....................     } else { 
18F4:  GOTO   0F7
....................       command=SET_REG; 
18F5:  MOVLW  02
18F6:  MOVWF  70
18F7:  MOVLB  00
....................       // infer admin mode when using "SET" command over RS232? 
....................       // set_admin_mode(1); 
....................     } 
....................   } // }}} 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18F8:  MOVLB  02
18F9:  CLRF   3F
18FA:  CLRF   40
18FB:  MOVLW  20
18FC:  MOVWF  05
18FD:  MOVLW  B7
18FE:  MOVWF  04
18FF:  MOVF   3F,W
1900:  ADDWF  04,F
1901:  MOVLW  00
1902:  ADDWFC 05,F
1903:  MOVF   40,W
1904:  MOVLP  00
1905:  MOVLB  00
1906:  CALL   140
1907:  MOVLP  18
1908:  MOVWF  00
1909:  IORLW  00
190A:  BTFSC  03.2
190B:  GOTO   111
190C:  MOVLB  02
190D:  INCF   40,F
190E:  INCF   3F,F
190F:  GOTO   0FB
1910:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1911:  MOVLW  20
1912:  MOVLB  02
1913:  MOVWF  40
1914:  MOVLW  B7
1915:  MOVWF  3F
1916:  MOVLW  20
1917:  MOVWF  42
1918:  MOVLW  A0
1919:  MOVWF  41
191A:  MOVLP  10
191B:  MOVLB  00
191C:  CALL   000
191D:  MOVLP  18
191E:  MOVF   78,F
191F:  BTFSS  03.2
1920:  GOTO   123
....................       command=SAVE_SETTINGS; 
1921:  MOVLW  04
1922:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1923:  MOVLB  02
1924:  CLRF   3F
1925:  CLRF   40
1926:  MOVLW  20
1927:  MOVWF  05
1928:  MOVLW  B7
1929:  MOVWF  04
192A:  MOVF   3F,W
192B:  ADDWF  04,F
192C:  MOVLW  00
192D:  ADDWFC 05,F
192E:  MOVF   40,W
192F:  MOVLP  00
1930:  MOVLB  00
1931:  CALL   146
1932:  MOVLP  18
1933:  MOVWF  00
1934:  IORLW  00
1935:  BTFSC  03.2
1936:  GOTO   13C
1937:  MOVLB  02
1938:  INCF   40,F
1939:  INCF   3F,F
193A:  GOTO   126
193B:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
193C:  MOVLW  20
193D:  MOVLB  02
193E:  MOVWF  40
193F:  MOVLW  B7
1940:  MOVWF  3F
1941:  MOVLW  20
1942:  MOVWF  42
1943:  MOVLW  A0
1944:  MOVWF  41
1945:  MOVLP  10
1946:  MOVLB  00
1947:  CALL   000
1948:  MOVLP  18
1949:  MOVF   78,F
194A:  BTFSS  03.2
194B:  GOTO   14E
....................       command=RESTORE_SETTINGS; 
194C:  MOVLW  05
194D:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
194E:  MOVLB  02
194F:  CLRF   3F
1950:  CLRF   40
1951:  MOVLW  20
1952:  MOVWF  05
1953:  MOVLW  B7
1954:  MOVWF  04
1955:  MOVF   3F,W
1956:  ADDWF  04,F
1957:  MOVLW  00
1958:  ADDWFC 05,F
1959:  MOVF   40,W
195A:  MOVLP  00
195B:  MOVLB  00
195C:  CALL   14F
195D:  MOVLP  18
195E:  MOVWF  00
195F:  IORLW  00
1960:  BTFSC  03.2
1961:  GOTO   167
1962:  MOVLB  02
1963:  INCF   40,F
1964:  INCF   3F,F
1965:  GOTO   151
1966:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1967:  MOVLW  20
1968:  MOVLB  02
1969:  MOVWF  40
196A:  MOVLW  B7
196B:  MOVWF  3F
196C:  MOVLW  20
196D:  MOVWF  42
196E:  MOVLW  A0
196F:  MOVWF  41
1970:  MOVLP  10
1971:  MOVLB  00
1972:  CALL   000
1973:  MOVLP  18
1974:  MOVF   78,F
1975:  BTFSS  03.2
1976:  GOTO   179
....................     command=STATUS; 
1977:  MOVLW  08
1978:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
1979:  MOVLB  02
197A:  CLRF   3F
197B:  CLRF   40
197C:  MOVLW  20
197D:  MOVWF  05
197E:  MOVLW  B7
197F:  MOVWF  04
1980:  MOVF   3F,W
1981:  ADDWF  04,F
1982:  MOVLW  00
1983:  ADDWFC 05,F
1984:  MOVF   40,W
1985:  MOVLP  00
1986:  MOVLB  00
1987:  CALL   157
1988:  MOVLP  18
1989:  MOVWF  00
198A:  IORLW  00
198B:  BTFSC  03.2
198C:  GOTO   192
198D:  MOVLB  02
198E:  INCF   40,F
198F:  INCF   3F,F
1990:  GOTO   17C
1991:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1992:  MOVLW  20
1993:  MOVLB  02
1994:  MOVWF  40
1995:  MOVLW  B7
1996:  MOVWF  3F
1997:  MOVLW  20
1998:  MOVWF  42
1999:  MOVLW  A0
199A:  MOVWF  41
199B:  MOVLP  10
199C:  MOVLB  00
199D:  CALL   000
199E:  MOVLP  18
199F:  MOVF   78,F
19A0:  BTFSS  03.2
19A1:  GOTO   1A6
....................     command=ADMIN; 
19A2:  MOVLW  09
19A3:  MOVWF  70
....................     argument=REBOOT; 
19A4:  MOVLW  02
19A5:  MOVWF  75
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19A6:  MOVLB  02
19A7:  CLRF   3F
19A8:  CLRF   40
19A9:  MOVLW  20
19AA:  MOVWF  05
19AB:  MOVLW  B7
19AC:  MOVWF  04
19AD:  MOVF   3F,W
19AE:  ADDWF  04,F
19AF:  MOVLW  00
19B0:  ADDWFC 05,F
19B1:  MOVF   40,W
19B2:  MOVLP  00
19B3:  MOVLB  00
19B4:  CALL   15F
19B5:  MOVLP  18
19B6:  MOVWF  00
19B7:  IORLW  00
19B8:  BTFSC  03.2
19B9:  GOTO   1BF
19BA:  MOVLB  02
19BB:  INCF   40,F
19BC:  INCF   3F,F
19BD:  GOTO   1A9
19BE:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
19BF:  MOVLW  20
19C0:  MOVLB  02
19C1:  MOVWF  40
19C2:  MOVLW  B7
19C3:  MOVWF  3F
19C4:  MOVLW  20
19C5:  MOVWF  42
19C6:  MOVLW  A0
19C7:  MOVWF  41
19C8:  MOVLP  10
19C9:  MOVLB  00
19CA:  CALL   000
19CB:  MOVLP  18
19CC:  MOVF   78,F
19CD:  BTFSS  03.2
19CE:  GOTO   220
....................     //command=DTMF_SEND; 
....................     command=0; 
19CF:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D0:  MOVLW  20
19D1:  MOVLB  02
19D2:  MOVWF  40
19D3:  MOVLW  6D
19D4:  MOVWF  3F
19D5:  MOVLP  08
19D6:  MOVLB  00
19D7:  CALL   748
19D8:  MOVLP  18
19D9:  MOVF   78,W
19DA:  MOVWF  76
....................     if ( value == d0 ) { 
19DB:  MOVF   76,W
19DC:  SUBLW  0A
19DD:  BTFSS  03.2
19DE:  GOTO   1E1
....................       value = dd; 
19DF:  CLRF   76
....................     } else if (value == dd) { 
19E0:  GOTO   1E6
19E1:  MOVF   76,F
19E2:  BTFSS  03.2
19E3:  GOTO   1E6
....................       value = d0; 
19E4:  MOVLW  0A
19E5:  MOVWF  76
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19E6:  MOVF   76,W
19E7:  ANDLW  0F
19E8:  MOVLB  02
19E9:  MOVWF  3F
19EA:  MOVF   3F,W
19EB:  MOVWF  40
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A20:  MOVLB  02
1A21:  CLRF   3F
1A22:  CLRF   40
1A23:  MOVLW  20
1A24:  MOVWF  05
1A25:  MOVLW  B7
1A26:  MOVWF  04
1A27:  MOVF   3F,W
1A28:  ADDWF  04,F
1A29:  MOVLW  00
1A2A:  ADDWFC 05,F
1A2B:  MOVF   40,W
1A2C:  MOVLP  00
1A2D:  MOVLB  00
1A2E:  CALL   162
1A2F:  MOVLP  18
1A30:  MOVWF  00
1A31:  IORLW  00
1A32:  BTFSC  03.2
1A33:  GOTO   239
1A34:  MOVLB  02
1A35:  INCF   40,F
1A36:  INCF   3F,F
1A37:  GOTO   223
1A38:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1A39:  MOVLW  20
1A3A:  MOVLB  02
1A3B:  MOVWF  40
1A3C:  MOVLW  B7
1A3D:  MOVWF  3F
1A3E:  MOVLW  20
1A3F:  MOVWF  42
1A40:  MOVLW  A0
1A41:  MOVWF  41
1A42:  MOVLP  10
1A43:  MOVLB  00
1A44:  CALL   000
1A45:  MOVLP  18
1A46:  MOVF   78,F
1A47:  BTFSS  03.2
1A48:  GOTO   24B
....................     command=I2C_SEND; 
1A49:  MOVLW  0C
1A4A:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse <value>36 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A4B:  MOVLB  02
1A4C:  CLRF   3F
1A4D:  CLRF   40
1A4E:  MOVLW  20
1A4F:  MOVWF  05
1A50:  MOVLW  B7
1A51:  MOVWF  04
1A52:  MOVF   3F,W
1A53:  ADDWF  04,F
1A54:  MOVLW  00
1A55:  ADDWFC 05,F
1A56:  MOVF   40,W
1A57:  MOVLP  00
1A58:  MOVLB  00
1A59:  CALL   167
1A5A:  MOVLP  18
1A5B:  MOVWF  00
1A5C:  IORLW  00
1A5D:  BTFSC  03.2
1A5E:  GOTO   264
1A5F:  MOVLB  02
1A60:  INCF   40,F
1A61:  INCF   3F,F
1A62:  GOTO   24E
1A63:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1A64:  MOVLW  20
1A65:  MOVLB  02
1A66:  MOVWF  40
1A67:  MOVLW  B7
1A68:  MOVWF  3F
1A69:  MOVLW  20
1A6A:  MOVWF  42
1A6B:  MOVLW  A0
1A6C:  MOVWF  41
1A6D:  MOVLP  10
1A6E:  MOVLB  00
1A6F:  CALL   000
1A70:  MOVLP  18
1A71:  MOVF   78,F
1A72:  BTFSS  03.2
1A73:  GOTO   28B
....................     value = str_to_decimal(argument_name); 
1A74:  MOVLW  20
1A75:  MOVLB  02
1A76:  MOVWF  40
1A77:  MOVLW  6D
1A78:  MOVWF  3F
1A79:  MOVLP  08
1A7A:  MOVLB  00
1A7B:  CALL   748
1A7C:  MOVLP  18
1A7D:  MOVF   78,W
1A7E:  MOVWF  76
....................     if ( value < 36 ) { 
1A7F:  MOVF   76,W
1A80:  SUBLW  23
1A81:  BTFSS  03.0
1A82:  GOTO   287
....................       argument = 0; 
1A83:  CLRF   75
....................       command  = MORSE_SEND; 
1A84:  MOVLW  0B
1A85:  MOVWF  70
....................     } else { 
1A86:  GOTO   28B
....................       command  = ADMIN; 
1A87:  MOVLW  09
1A88:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A89:  MOVLW  03
1A8A:  MOVWF  75
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A8B:  MOVLB  02
1A8C:  CLRF   3F
1A8D:  CLRF   40
1A8E:  MOVLW  20
1A8F:  MOVWF  05
1A90:  MOVLW  B7
1A91:  MOVWF  04
1A92:  MOVF   3F,W
1A93:  ADDWF  04,F
1A94:  MOVLW  00
1A95:  ADDWFC 05,F
1A96:  MOVF   40,W
1A97:  MOVLP  00
1A98:  MOVLB  00
1A99:  CALL   16E
1A9A:  MOVLP  18
1A9B:  MOVWF  00
1A9C:  IORLW  00
1A9D:  BTFSC  03.2
1A9E:  GOTO   2A4
1A9F:  MOVLB  02
1AA0:  INCF   40,F
1AA1:  INCF   3F,F
1AA2:  GOTO   28E
1AA3:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1AA4:  MOVLW  20
1AA5:  MOVLB  02
1AA6:  MOVWF  40
1AA7:  MOVLW  B7
1AA8:  MOVWF  3F
1AA9:  MOVLW  20
1AAA:  MOVWF  42
1AAB:  MOVLW  A0
1AAC:  MOVWF  41
1AAD:  MOVLP  10
1AAE:  MOVLB  00
1AAF:  CALL   000
1AB0:  MOVLP  18
1AB1:  MOVF   78,F
1AB2:  BTFSS  03.2
1AB3:  GOTO   2B6
....................     command=INCREMENT_REG; 
1AB4:  MOVLW  06
1AB5:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1AB6:  MOVLB  02
1AB7:  CLRF   3F
1AB8:  CLRF   40
1AB9:  MOVLW  20
1ABA:  MOVWF  05
1ABB:  MOVLW  B7
1ABC:  MOVWF  04
1ABD:  MOVF   3F,W
1ABE:  ADDWF  04,F
1ABF:  MOVLW  00
1AC0:  ADDWFC 05,F
1AC1:  MOVF   40,W
1AC2:  MOVLP  00
1AC3:  MOVLB  00
1AC4:  CALL   171
1AC5:  MOVLP  18
1AC6:  MOVWF  00
1AC7:  IORLW  00
1AC8:  BTFSC  03.2
1AC9:  GOTO   2CF
1ACA:  MOVLB  02
1ACB:  INCF   40,F
1ACC:  INCF   3F,F
1ACD:  GOTO   2B9
1ACE:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1ACF:  MOVLW  20
1AD0:  MOVLB  02
1AD1:  MOVWF  40
1AD2:  MOVLW  B7
1AD3:  MOVWF  3F
1AD4:  MOVLW  20
1AD5:  MOVWF  42
1AD6:  MOVLW  A0
1AD7:  MOVWF  41
1AD8:  MOVLP  10
1AD9:  MOVLB  00
1ADA:  CALL   000
1ADB:  MOVLP  18
1ADC:  MOVF   78,F
1ADD:  BTFSS  03.2
1ADE:  GOTO   2E1
....................     command=DECREMENT_REG; 
1ADF:  MOVLW  07
1AE0:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AE1:  MOVLB  02
1AE2:  CLRF   3F
1AE3:  CLRF   40
1AE4:  MOVLW  20
1AE5:  MOVWF  05
1AE6:  MOVLW  B7
1AE7:  MOVWF  04
1AE8:  MOVF   3F,W
1AE9:  ADDWF  04,F
1AEA:  MOVLW  00
1AEB:  ADDWFC 05,F
1AEC:  MOVF   40,W
1AED:  MOVLP  00
1AEE:  MOVLB  00
1AEF:  CALL   174
1AF0:  MOVLP  18
1AF1:  MOVWF  00
1AF2:  IORLW  00
1AF3:  BTFSC  03.2
1AF4:  GOTO   2FA
1AF5:  MOVLB  02
1AF6:  INCF   40,F
1AF7:  INCF   3F,F
1AF8:  GOTO   2E4
1AF9:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1AFA:  MOVLW  20
1AFB:  MOVLB  02
1AFC:  MOVWF  40
1AFD:  MOVLW  B7
1AFE:  MOVWF  3F
1AFF:  MOVLW  20
1B00:  MOVWF  42
1B01:  MOVLW  A0
1B02:  MOVWF  41
1B03:  MOVLP  10
1B04:  MOVLB  00
1B05:  CALL   000
1B06:  MOVLP  18
1B07:  MOVF   78,F
1B08:  BTFSS  03.2
1B09:  GOTO   329
....................     command=SET_REG; 
1B0A:  MOVLW  02
1B0B:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B0C:  MOVLW  01
1B0D:  ADDWF  74,W
1B0E:  ANDLW  03
1B0F:  MOVWF  76
....................     strcpy(argument_name,"CPOT"); 
1B10:  MOVLB  02
1B11:  CLRF   3F
1B12:  CLRF   40
1B13:  MOVLW  20
1B14:  MOVWF  05
1B15:  MOVLW  6D
1B16:  MOVWF  04
1B17:  MOVF   3F,W
1B18:  ADDWF  04,F
1B19:  MOVLW  00
1B1A:  ADDWFC 05,F
1B1B:  MOVF   40,W
1B1C:  MOVLP  00
1B1D:  MOVLB  00
1B1E:  CALL   177
1B1F:  MOVLP  18
1B20:  MOVWF  00
1B21:  IORLW  00
1B22:  BTFSC  03.2
1B23:  GOTO   329
1B24:  MOVLB  02
1B25:  INCF   40,F
1B26:  INCF   3F,F
1B27:  GOTO   313
1B28:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B29:  MOVLB  02
1B2A:  CLRF   3F
1B2B:  CLRF   40
1B2C:  MOVLW  20
1B2D:  MOVWF  05
1B2E:  MOVLW  B7
1B2F:  MOVWF  04
1B30:  MOVF   3F,W
1B31:  ADDWF  04,F
1B32:  MOVLW  00
1B33:  ADDWFC 05,F
1B34:  MOVF   40,W
1B35:  MOVLP  00
1B36:  MOVLB  00
1B37:  CALL   17D
1B38:  MOVLP  18
1B39:  MOVWF  00
1B3A:  IORLW  00
1B3B:  BTFSC  03.2
1B3C:  GOTO   342
1B3D:  MOVLB  02
1B3E:  INCF   40,F
1B3F:  INCF   3F,F
1B40:  GOTO   32C
1B41:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1B42:  MOVLW  20
1B43:  MOVLB  02
1B44:  MOVWF  40
1B45:  MOVLW  B7
1B46:  MOVWF  3F
1B47:  MOVLW  20
1B48:  MOVWF  42
1B49:  MOVLW  A0
1B4A:  MOVWF  41
1B4B:  MOVLP  10
1B4C:  MOVLB  00
1B4D:  CALL   000
1B4E:  MOVLP  18
1B4F:  MOVF   78,F
1B50:  BTFSS  03.2
1B51:  GOTO   362
....................     AdminMode = ~AdminMode; 
1B52:  MOVLW  08
1B53:  MOVLB  01
1B54:  XORWF  5B,F
....................     set_admin_mode(AdminMode); 
1B55:  MOVLW  00
1B56:  BTFSC  5B.3
1B57:  MOVLW  01
1B58:  MOVLB  02
1B59:  MOVWF  3F
1B5A:  MOVWF  40
1B5B:  MOVLP  08
1B5C:  MOVLB  00
1B5D:  CALL   568
1B5E:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B5F:  MOVLB  01
1B60:  BSF    5B.2
1B61:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
11CE:  MOVF   76,W
11CF:  SUBLW  FF
11D0:  BTFSS  03.2
11D1:  GOTO   1F8
....................     printf ("\n\r%s %u",argument,value); 
11D2:  MOVLW  0A
11D3:  CLRWDT
11D4:  BTFSS  11.4
11D5:  GOTO   1D3
11D6:  MOVLB  03
11D7:  MOVWF  1A
11D8:  MOVLW  0D
11D9:  CLRWDT
11DA:  MOVLB  00
11DB:  BTFSC  11.4
11DC:  GOTO   1DF
11DD:  MOVLB  03
11DE:  GOTO   1D9
11DF:  MOVLB  03
11E0:  MOVWF  1A
11E1:  CLRF   05
11E2:  MOVF   75,W
11E3:  MOVWF  04
11E4:  MOVLP  08
11E5:  MOVLB  00
11E6:  CALL   31B
11E7:  MOVLP  10
11E8:  MOVLW  20
11E9:  CLRWDT
11EA:  BTFSS  11.4
11EB:  GOTO   1E9
11EC:  MOVLB  03
11ED:  MOVWF  1A
11EE:  MOVF   76,W
11EF:  MOVLB  02
11F0:  MOVWF  50
11F1:  MOVLW  1B
11F2:  MOVWF  51
11F3:  MOVLP  08
11F4:  MOVLB  00
11F5:  CALL   000
11F6:  MOVLP  10
....................   } else { 
11F7:  GOTO   287
....................     pObj=RegMap[argument].reg_ptr; 
11F8:  RLF    75,W
11F9:  MOVWF  77
11FA:  RLF    77,F
11FB:  MOVLW  FC
11FC:  ANDWF  77,F
11FD:  MOVF   77,W
11FE:  MOVLB  02
11FF:  MOVWF  2F
1200:  INCF   2F,W
1201:  MOVLP  00
1202:  MOVLB  00
1203:  CALL   043
1204:  MOVLP  10
1205:  MOVWF  7A
1206:  MOVLB  02
1207:  MOVF   2F,W
1208:  MOVLP  00
1209:  MOVLB  00
120A:  CALL   043
120B:  MOVLP  10
120C:  MOVLB  02
120D:  MOVWF  2C
120E:  MOVF   7A,W
120F:  MOVWF  2D
....................     if ( in_admin_mode() ) { 
1210:  MOVLP  08
1211:  MOVLB  00
1212:  CALL   7C1
1213:  MOVLP  10
1214:  MOVF   78,F
1215:  BTFSC  03.2
1216:  GOTO   21F
....................       *pObj=value; 
1217:  MOVLB  02
1218:  MOVF   2C,W
1219:  MOVWF  04
121A:  MOVF   2D,W
121B:  MOVWF  05
121C:  MOVF   76,W
121D:  MOVWF  00
121E:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
121F:  MOVLB  02
1220:  MOVF   2C,W
1221:  MOVWF  04
1222:  MOVF   2D,W
1223:  MOVWF  05
1224:  MOVF   00,W
1225:  MOVWF  2E
....................     LastRegisterIndex = argument; 
1226:  MOVF   75,W
1227:  MOVWF  7C
....................     LastRegisterIndexValid=1; 
1228:  MOVLW  01
1229:  MOVWF  7D
....................     printf ("\n\rSetting %s(%u) to %u",argument_name,argument,lVar); 
122A:  MOVLW  29
122B:  MOVLB  03
122C:  MOVWF  11
122D:  MOVLW  05
122E:  MOVWF  12
122F:  BCF    03.0
1230:  MOVLW  0A
1231:  MOVLB  02
1232:  MOVWF  50
1233:  MOVLP  00
1234:  MOVLB  00
1235:  CALL   77E
1236:  MOVLP  10
1237:  MOVLW  20
1238:  MOVWF  05
1239:  MOVLW  6D
123A:  MOVWF  04
123B:  MOVLP  08
123C:  CALL   31B
123D:  MOVLP  10
123E:  MOVLW  28
123F:  CLRWDT
1240:  BTFSS  11.4
1241:  GOTO   23F
1242:  MOVLB  03
1243:  MOVWF  1A
1244:  MOVF   75,W
1245:  MOVLB  02
1246:  MOVWF  50
1247:  MOVLW  1B
1248:  MOVWF  51
1249:  MOVLP  08
124A:  MOVLB  00
124B:  CALL   000
124C:  MOVLP  10
124D:  MOVLW  30
124E:  MOVLB  03
124F:  MOVWF  11
1250:  MOVLW  05
1251:  MOVWF  12
1252:  BSF    03.0
1253:  MOVLW  05
1254:  MOVLB  02
1255:  MOVWF  50
1256:  MOVLP  00
1257:  MOVLB  00
1258:  CALL   77E
1259:  MOVLP  10
125A:  MOVLB  02
125B:  MOVF   2E,W
125C:  MOVWF  50
125D:  MOVLW  1B
125E:  MOVWF  51
125F:  MOVLP  08
1260:  MOVLB  00
1261:  CALL   000
1262:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
1263:  MOVLB  02
1264:  MOVF   2D,W
1265:  SUBLW  1F
1266:  BTFSC  03.0
1267:  GOTO   279
1268:  XORLW  FF
1269:  BTFSS  03.2
126A:  GOTO   26F
126B:  MOVF   2C,W
126C:  SUBLW  0B
126D:  BTFSC  03.0
126E:  GOTO   279
126F:  MOVF   2D,W
1270:  SUBLW  20
1271:  BTFSS  03.0
1272:  GOTO   279
1273:  BTFSS  03.2
1274:  GOTO   280
1275:  MOVF   2C,W
1276:  SUBLW  1B
1277:  BTFSC  03.0
1278:  GOTO   280
1279:  MOVF   2C,W
127A:  SUBLW  74
127B:  BTFSS  03.2
127C:  GOTO   284
127D:  MOVF   2D,F
127E:  BTFSS  03.2
127F:  GOTO   284
....................       increment(0); // Increment is done in this function. Only update trim pot. 
1280:  CLRF   2F
1281:  MOVLB  00
1282:  CALL   097
1283:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
1284:  MOVLB  01
1285:  BSF    5B.2
1286:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int *pot_ptr; 
....................   int value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
1097:  MOVF   74,W
1098:  ANDLW  03
1099:  MOVLB  02
109A:  MOVWF  33
....................   if ( CurrentCorIndex ) { 
109B:  MOVLB  00
109C:  MOVF   6B,F
109D:  BTFSC  03.2
109E:  GOTO   0D4
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
109F:  MOVLW  01
10A0:  SUBWF  6B,W
10A1:  MOVWF  77
10A2:  RLF    77,F
10A3:  RLF    77,F
10A4:  MOVLW  FC
10A5:  ANDWF  77,F
10A6:  MOVF   77,W
10A7:  MOVLB  02
10A8:  ADDWF  33,W
10A9:  ADDLW  0C
10AA:  MOVWF  30
10AB:  MOVLW  20
10AC:  MOVWF  31
10AD:  BTFSC  03.0
10AE:  INCF   31,F
....................     value = *pot_ptr; 
10AF:  MOVF   30,W
10B0:  MOVWF  04
10B1:  MOVF   31,W
10B2:  MOVWF  05
10B3:  MOVF   00,W
10B4:  MOVWF  32
....................     *pot_ptr = value + incr; 
10B5:  MOVF   30,W
10B6:  MOVWF  04
10B7:  MOVF   31,W
10B8:  MOVWF  05
10B9:  MOVF   2F,W
10BA:  ADDWF  32,W
10BB:  MOVWF  00
....................     if ( in_admin_mode() ) { 
10BC:  MOVLP  08
10BD:  MOVLB  00
10BE:  CALL   7C1
10BF:  MOVLP  10
10C0:  MOVF   78,F
10C1:  BTFSC  03.2
10C2:  GOTO   0D4
....................       set_trimpot(CPotPtr,*pot_ptr); 
10C3:  MOVLB  02
10C4:  MOVF   31,W
10C5:  MOVWF  7A
10C6:  MOVF   30,W
10C7:  MOVWF  04
10C8:  MOVF   31,W
10C9:  MOVWF  05
10CA:  MOVF   00,W
10CB:  MOVWF  34
10CC:  MOVF   33,W
10CD:  MOVWF  3F
10CE:  MOVF   34,W
10CF:  MOVWF  40
10D0:  MOVLP  08
10D1:  MOVLB  00
10D2:  CALL   053
10D3:  MOVLP  10
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
10D4:  MOVLP  08
10D5:  CALL   335
10D6:  MOVLP  10
.................... } // }}} 
10D7:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
0F98:  MOVLB  02
0F99:  CLRF   3F
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
0F9A:  MOVF   3F,W
0F9B:  SUBLW  05
0F9C:  BTFSS  03.0
0F9D:  GOTO   7BF
....................     dest[c]=src[c]; 
0F9E:  MOVF   3F,W
0F9F:  ADDWF  3B,W
0FA0:  MOVWF  78
0FA1:  MOVLW  00
0FA2:  ADDWFC 3C,W
0FA3:  MOVWF  7A
0FA4:  MOVF   78,W
0FA5:  MOVWF  40
0FA6:  MOVF   7A,W
0FA7:  MOVWF  41
0FA8:  MOVF   3F,W
0FA9:  ADDWF  3D,W
0FAA:  MOVWF  78
0FAB:  MOVLW  00
0FAC:  ADDWFC 3E,W
0FAD:  MOVWF  7A
0FAE:  MOVF   78,W
0FAF:  MOVLB  03
0FB0:  MOVWF  11
0FB1:  MOVF   7A,W
0FB2:  MOVWF  12
0FB3:  MOVLB  02
0FB4:  MOVF   41,W
0FB5:  MOVWF  05
0FB6:  MOVF   40,W
0FB7:  MOVWF  04
0FB8:  MOVLW  01
0FB9:  MOVWF  45
0FBA:  MOVLB  00
0FBB:  CALL   0DF
....................   c++; 
0FBC:  MOVLB  02
0FBD:  INCF   3F,F
....................   } 
0FBE:  GOTO   79A
.................... } // }}} 
0FBF:  MOVLB  00
0FC0:  RETURN
.................... void ExecAuxOutOp(int op,int arg,int ID) { // {{{ 
....................   int cor_in_local; 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
1C6B:  MOVF   29,W
1C6C:  ANDLW  0F
1C6D:  MOVWF  2C
....................   uarg = (arg & 0xF0) >> 4; 
1C6E:  MOVF   29,W
1C6F:  ANDLW  F0
1C70:  MOVWF  77
1C71:  SWAPF  77,W
1C72:  MOVWF  2D
1C73:  MOVLW  0F
1C74:  ANDWF  2D,F
....................   cor_in_local = COR_IN | (COR_EMUL&0x0F); 
1C75:  MOVLB  00
1C76:  MOVF   67,W
1C77:  ANDLW  0F
1C78:  IORWF  5F,W
1C79:  MOVLB  02
1C7A:  MOVWF  2B
....................   switch(op) { 
1C7B:  MOVF   28,W
1C7C:  XORLW  01
1C7D:  MOVLB  00
1C7E:  BTFSC  03.2
1C7F:  GOTO   484
1C80:  XORLW  03
1C81:  BTFSC  03.2
1C82:  GOTO   499
1C83:  GOTO   4B2
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Use COR_IN from HW ports here 
....................       AuxOut[ID] = ((COR_IN ^ uarg) & larg) != 0; 
1C84:  MOVLW  22
1C85:  MOVLB  02
1C86:  ADDWF  2A,W
1C87:  MOVWF  04
1C88:  MOVLW  20
1C89:  MOVWF  05
1C8A:  BTFSC  03.0
1C8B:  INCF   05,F
1C8C:  MOVLB  00
1C8D:  MOVF   5F,W
1C8E:  MOVLB  02
1C8F:  XORWF  2D,W
1C90:  ANDWF  2C,W
1C91:  BTFSS  03.2
1C92:  GOTO   495
1C93:  MOVLW  00
1C94:  GOTO   496
1C95:  MOVLW  01
1C96:  MOVWF  00
....................     break; 
1C97:  MOVLB  00
1C98:  GOTO   4B2
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
1C99:  MOVLW  22
1C9A:  MOVLB  02
1C9B:  ADDWF  2A,W
1C9C:  MOVWF  04
1C9D:  MOVLW  20
1C9E:  MOVWF  05
1C9F:  BTFSC  03.0
1CA0:  INCF   05,F
1CA1:  MOVF   2C,W
1CA2:  ANDLW  1F
1CA3:  MOVWF  30
1CA4:  MOVF   7A,W
1CA5:  MOVWF  31
1CA6:  MOVF   2D,W
1CA7:  XORWF  30,F
1CA8:  BTFSS  03.2
1CA9:  GOTO   4AF
1CAA:  MOVF   31,F
1CAB:  BTFSS  03.2
1CAC:  GOTO   4AF
1CAD:  MOVLW  00
1CAE:  GOTO   4B0
1CAF:  MOVLW  01
1CB0:  MOVWF  00
....................     break; 
1CB1:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0F48:  MOVLB  02
0F49:  CLRF   41
0F4A:  CLRF   42
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0F4B:  MOVF   41,W
0F4C:  ADDWF  3F,W
0F4D:  MOVWF  04
0F4E:  MOVLW  00
0F4F:  ADDWFC 40,W
0F50:  MOVWF  05
0F51:  MOVF   00,F
0F52:  BTFSC  03.2
0F53:  GOTO   77D
0F54:  MOVF   41,W
0F55:  ADDWF  3F,W
0F56:  MOVWF  04
0F57:  MOVLW  00
0F58:  ADDWFC 40,W
0F59:  MOVWF  05
0F5A:  MOVF   00,W
0F5B:  SUBLW  2F
0F5C:  BTFSC  03.0
0F5D:  GOTO   77D
0F5E:  MOVF   41,W
0F5F:  ADDWF  3F,W
0F60:  MOVWF  04
0F61:  MOVLW  00
0F62:  ADDWFC 40,W
0F63:  MOVWF  05
0F64:  MOVF   00,W
0F65:  SUBLW  39
0F66:  BTFSS  03.0
0F67:  GOTO   77D
....................     value = (value * 10) + (str[x]-'0'); 
0F68:  MOVF   42,W
0F69:  MOVWF  43
0F6A:  MOVLW  0A
0F6B:  MOVWF  44
0F6C:  MOVLB  00
0F6D:  CALL   721
0F6E:  MOVF   78,W
0F6F:  MOVLB  02
0F70:  MOVWF  43
0F71:  MOVF   41,W
0F72:  ADDWF  3F,W
0F73:  MOVWF  04
0F74:  MOVLW  00
0F75:  ADDWFC 40,W
0F76:  MOVWF  05
0F77:  MOVLW  30
0F78:  SUBWF  00,W
0F79:  ADDWF  43,W
0F7A:  MOVWF  42
....................     x++; 
0F7B:  INCF   41,F
....................   } 
0F7C:  GOTO   74B
....................   return(value); 
0F7D:  MOVF   42,W
0F7E:  MOVWF  78
.................... } // }}} 
0F7F:  MOVLB  00
0F80:  RETURN
....................  
.................... void ExecAuxInOp(int op,int arg,int ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
1619:  MOVLB  02
161A:  BCF    2B.0
161B:  MOVLW  1F
161C:  ADDWF  2A,W
161D:  MOVWF  04
161E:  MOVLW  20
161F:  MOVWF  05
1620:  BTFSC  03.0
1621:  INCF   05,F
1622:  MOVF   00,F
1623:  BTFSS  03.2
1624:  BSF    2B.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
1625:  MOVF   29,W
1626:  ANDLW  0F
1627:  MOVWF  2C
....................   uarg = (arg & 0xF0) >> 4; 
1628:  MOVF   29,W
1629:  ANDLW  F0
162A:  MOVWF  77
162B:  SWAPF  77,W
162C:  MOVWF  2D
162D:  MOVLW  0F
162E:  ANDWF  2D,F
....................   switch(op) { 
162F:  MOVLW  01
1630:  SUBWF  28,W
1631:  ADDLW  FC
1632:  BTFSC  03.0
1633:  GOTO   67A
1634:  ADDLW  04
1635:  MOVLB  00
1636:  GOTO   67D
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
1637:  MOVLB  02
1638:  BTFSS  2B.0
1639:  GOTO   63F
....................         Enable_Mask &= arg; 
163A:  MOVF   29,W
163B:  MOVLB  00
163C:  ANDWF  61,F
....................       } else { // AuxIn is not enabled 
163D:  GOTO   644
163E:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
163F:  MOVF   29,W
1640:  XORLW  FF
1641:  ANDLW  0F
1642:  MOVLB  00
1643:  IORWF  61,F
....................       } 
....................       break; 
1644:  MOVLB  02
1645:  GOTO   67A
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
1646:  MOVLB  02
1647:  BTFSS  2B.0
1648:  GOTO   64F
....................         COR_DROP_FLAG=1; 
1649:  BSF    72.5
....................         TailChar=arg; 
164A:  MOVF   29,W
164B:  MOVLB  00
164C:  MOVWF  68
....................       } else { 
164D:  GOTO   651
164E:  MOVLB  02
....................         TailChar=0; 
164F:  MOVLB  00
1650:  CLRF   68
....................       } 
....................     break; 
1651:  MOVLB  02
1652:  GOTO   67A
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
1653:  MOVLB  02
1654:  BTFSC  2B.0
1655:  GOTO   65C
....................         COR_DROP_FLAG=1; 
1656:  BSF    72.5
....................         TailChar=arg; 
1657:  MOVF   29,W
1658:  MOVLB  00
1659:  MOVWF  68
....................       } else { 
165A:  GOTO   65E
165B:  MOVLB  02
....................         TailChar=0; 
165C:  MOVLB  00
165D:  CLRF   68
....................       } 
....................     break; 
165E:  MOVLB  02
165F:  GOTO   67A
....................     case AUXI_EMULATE_COR: 
....................       if ( (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0 ) { 
1660:  MOVLB  02
1661:  MOVF   29,W
1662:  ANDLW  10
1663:  BTFSC  03.2
1664:  GOTO   669
....................         tmp_bit = ~in_bit; 
1665:  BCF    2B.1
1666:  BTFSS  2B.0
1667:  BSF    2B.1
....................       } else { 
1668:  GOTO   66C
....................         tmp_bit = in_bit; 
1669:  BCF    2B.1
166A:  BTFSC  2B.0
166B:  BSF    2B.1
....................       } 
....................       if ( tmp_bit ) { 
166C:  BTFSS  2B.1
166D:  GOTO   673
....................         COR_EMUL |= larg; 
166E:  MOVF   2C,W
166F:  MOVLB  00
1670:  IORWF  67,F
....................       } else { 
1671:  GOTO   677
1672:  MOVLB  02
....................         COR_EMUL &= ~larg; 
1673:  MOVF   2C,W
1674:  XORLW  FF
1675:  MOVLB  00
1676:  ANDWF  67,F
....................       } 
....................     break; 
1677:  MOVLB  02
1678:  GOTO   67A
1679:  MOVLB  02
....................   } 
.................... } // }}} 
167A:  MOVLP  18
167B:  MOVLB  00
167C:  GOTO   524 (RETURN)
....................  
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
15CF:  MOVLB  01
15D0:  CLRF   65
15D1:  MOVF   65,W
15D2:  SUBLW  02
15D3:  BTFSS  03.0
15D4:  GOTO   616
....................     AuxInSW[x] = (input(AUX_IN_PIN[x])!=0) || (AuxIn[x]!=0); 
15D5:  MOVLW  1F
15D6:  ADDWF  65,W
15D7:  MOVWF  78
15D8:  MOVLW  20
15D9:  MOVWF  7A
15DA:  BTFSC  03.0
15DB:  INCF   7A,F
15DC:  MOVF   78,W
15DD:  MOVWF  66
15DE:  MOVF   7A,W
15DF:  MOVWF  67
15E0:  MOVF   65,W
15E1:  MOVLP  00
15E2:  MOVLB  00
15E3:  CALL   03F
15E4:  MOVLP  10
15E5:  MOVLB  01
15E6:  MOVWF  68
15E7:  MOVLB  02
15E8:  MOVWF  40
15E9:  MOVLW  01
15EA:  MOVWF  41
15EB:  CLRF   43
15EC:  MOVLW  80
15ED:  MOVWF  42
15EE:  MOVLP  08
15EF:  MOVLB  00
15F0:  CALL   1B9
15F1:  MOVLP  10
15F2:  MOVLB  01
15F3:  MOVF   68,W
15F4:  MOVWF  69
15F5:  CLRF   6B
15F6:  CLRF   6A
15F7:  MOVLB  00
15F8:  GOTO   5B5
15F9:  BTFSC  78.0
15FA:  GOTO   60B
15FB:  MOVLW  1C
15FC:  MOVLB  01
15FD:  ADDWF  65,W
15FE:  MOVWF  04
15FF:  MOVLW  20
1600:  MOVWF  05
1601:  BTFSC  03.0
1602:  INCF   05,F
1603:  MOVF   00,F
1604:  BTFSC  03.2
1605:  GOTO   608
1606:  MOVLB  00
1607:  GOTO   60B
1608:  MOVLW  00
1609:  GOTO   60D
160A:  MOVLB  00
160B:  MOVLW  01
160C:  MOVLB  01
160D:  MOVWF  69
160E:  MOVF   67,W
160F:  MOVWF  05
1610:  MOVF   66,W
1611:  MOVWF  04
1612:  MOVF   69,W
1613:  MOVWF  00
....................   } 
1614:  INCF   65,F
1615:  GOTO   5D1
.................... } // }}} 
1616:  MOVLP  18
1617:  MOVLB  00
1618:  GOTO   68F (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
1C30:  MOVLW  30
1C31:  MOVLB  01
1C32:  MOVWF  68
1C33:  MOVWF  69
1C34:  MOVWF  6A
1C35:  CLRF   6B
....................   char AuxOut_s[4]={'0','0','0',0}; 
1C36:  MOVWF  6C
1C37:  MOVWF  6D
1C38:  MOVWF  6E
1C39:  CLRF   6F
....................   char ADM[]=" ADMIN"; 
1C3A:  MOVLW  20
1C3B:  MOVLB  02
1C3C:  MOVWF  20
1C3D:  MOVLW  41
1C3E:  MOVWF  21
1C3F:  MOVLW  44
1C40:  MOVWF  22
1C41:  MOVLW  4D
1C42:  MOVWF  23
1C43:  MOVLW  49
1C44:  MOVWF  24
1C45:  MOVLW  4E
1C46:  MOVWF  25
1C47:  CLRF   26
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
1C48:  MOVLB  01
1C49:  CLRF   65
1C4A:  MOVF   65,W
1C4B:  SUBLW  02
1C4C:  BTFSS  03.0
1C4D:  GOTO   528
....................     AuxOp = AuxOutOp[x]; 
1C4E:  MOVLW  33
1C4F:  ADDWF  65,W
1C50:  MOVWF  04
1C51:  MOVLW  20
1C52:  MOVWF  05
1C53:  BTFSC  03.0
1C54:  INCF   05,F
1C55:  MOVF   00,W
1C56:  MOVWF  66
....................     AuxArg = AuxOutArg[x]; 
1C57:  MOVLW  36
1C58:  ADDWF  65,W
1C59:  MOVWF  04
1C5A:  MOVLW  20
1C5B:  MOVWF  05
1C5C:  BTFSC  03.0
1C5D:  INCF   05,F
1C5E:  MOVF   00,W
1C5F:  MOVWF  67
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
1C60:  MOVF   66,W
1C61:  MOVLB  02
1C62:  MOVWF  28
1C63:  MOVLB  01
1C64:  MOVF   67,W
1C65:  MOVLB  02
1C66:  MOVWF  29
1C67:  MOVLB  01
1C68:  MOVF   65,W
1C69:  MOVLB  02
1C6A:  MOVWF  2A
....................     out_bit = (AuxOut[x])==0; 
*
1CB2:  MOVLB  02
1CB3:  BCF    27.0
1CB4:  MOVLW  22
1CB5:  MOVLB  01
1CB6:  ADDWF  65,W
1CB7:  MOVWF  04
1CB8:  MOVLW  20
1CB9:  MOVWF  05
1CBA:  BTFSC  03.0
1CBB:  INCF   05,F
1CBC:  MOVF   00,F
1CBD:  BTFSS  03.2
1CBE:  GOTO   4C2
1CBF:  MOVLB  02
1CC0:  BSF    27.0
1CC1:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
1CC2:  MOVF   65,W
1CC3:  MOVLP  00
1CC4:  MOVLB  00
1CC5:  CALL   03B
1CC6:  MOVLP  18
1CC7:  MOVLB  02
1CC8:  MOVWF  28
1CC9:  MOVLW  00
1CCA:  BTFSC  27.0
1CCB:  MOVLW  01
1CCC:  MOVWF  77
1CCD:  MOVF   28,W
1CCE:  MOVWF  40
1CCF:  MOVF   77,W
1CD0:  MOVWF  41
1CD1:  MOVLW  01
1CD2:  MOVWF  43
1CD3:  CLRF   42
1CD4:  MOVLP  08
1CD5:  MOVLB  00
1CD6:  CALL   1B9
1CD7:  MOVLP  18
1CD8:  MOVLB  02
1CD9:  MOVF   28,W
1CDA:  MOVWF  40
1CDB:  CLRF   41
1CDC:  CLRF   43
1CDD:  MOVLW  80
1CDE:  MOVWF  42
1CDF:  MOVLP  08
1CE0:  MOVLB  00
1CE1:  CALL   1B9
1CE2:  MOVLP  18
....................     if(out_bit==0) { 
1CE3:  MOVLB  02
1CE4:  BTFSC  27.0
1CE5:  GOTO   4F1
....................       AuxOut_s[x]='1'; 
1CE6:  MOVLW  9C
1CE7:  MOVLB  01
1CE8:  ADDWF  65,W
1CE9:  MOVWF  04
1CEA:  MOVLW  20
1CEB:  MOVWF  05
1CEC:  BTFSC  03.0
1CED:  INCF   05,F
1CEE:  MOVLW  31
1CEF:  MOVWF  00
1CF0:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
1CF1:  MOVLW  39
1CF2:  MOVLB  01
1CF3:  ADDWF  65,W
1CF4:  MOVWF  04
1CF5:  MOVLW  20
1CF6:  MOVWF  05
1CF7:  BTFSC  03.0
1CF8:  INCF   05,F
1CF9:  MOVF   00,W
1CFA:  MOVWF  66
....................     AuxArg = AuxInArg[x]; 
1CFB:  MOVLW  3C
1CFC:  ADDWF  65,W
1CFD:  MOVWF  04
1CFE:  MOVLW  20
1CFF:  MOVWF  05
1D00:  BTFSC  03.0
1D01:  INCF   05,F
1D02:  MOVF   00,W
1D03:  MOVWF  67
....................     if(AuxInSW[x]==1) { 
1D04:  MOVLW  1F
1D05:  ADDWF  65,W
1D06:  MOVWF  04
1D07:  MOVLW  20
1D08:  MOVWF  05
1D09:  BTFSC  03.0
1D0A:  INCF   05,F
1D0B:  DECFSZ 00,W
1D0C:  GOTO   516
....................       AuxIn_s[x]='1'; 
1D0D:  MOVLW  98
1D0E:  ADDWF  65,W
1D0F:  MOVWF  04
1D10:  MOVLW  20
1D11:  MOVWF  05
1D12:  BTFSC  03.0
1D13:  INCF   05,F
1D14:  MOVLW  31
1D15:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
1D16:  MOVF   66,W
1D17:  MOVLB  02
1D18:  MOVWF  28
1D19:  MOVLB  01
1D1A:  MOVF   67,W
1D1B:  MOVLB  02
1D1C:  MOVWF  29
1D1D:  MOVLB  01
1D1E:  MOVF   65,W
1D1F:  MOVLB  02
1D20:  MOVWF  2A
1D21:  MOVLP  10
1D22:  MOVLB  00
1D23:  GOTO   619
1D24:  MOVLP  18
....................     // }}} 
....................   } 
1D25:  MOVLB  01
1D26:  INCF   65,F
1D27:  GOTO   44A
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
1D28:  MOVLW  20
1D29:  MOVWF  5D
1D2A:  MOVLW  73
1D2B:  MOVWF  5C
1D2C:  MOVLW  49
1D2D:  MOVLB  02
1D2E:  MOVWF  50
1D2F:  MOVLP  08
1D30:  MOVLB  00
1D31:  CALL   1DB
1D32:  MOVLP  18
1D33:  MOVLW  3A
1D34:  MOVLB  02
1D35:  MOVWF  50
1D36:  MOVLP  08
1D37:  MOVLB  00
1D38:  CALL   1DB
1D39:  MOVLP  18
1D3A:  MOVLW  20
1D3B:  MOVWF  05
1D3C:  MOVLW  98
1D3D:  MOVWF  04
1D3E:  MOVLP  08
1D3F:  CALL   23D
1D40:  MOVLP  18
1D41:  MOVLW  20
1D42:  MOVLB  02
1D43:  MOVWF  50
1D44:  MOVLP  08
1D45:  MOVLB  00
1D46:  CALL   1DB
1D47:  MOVLP  18
1D48:  MOVLW  4F
1D49:  MOVLB  02
1D4A:  MOVWF  50
1D4B:  MOVLP  08
1D4C:  MOVLB  00
1D4D:  CALL   1DB
1D4E:  MOVLP  18
1D4F:  MOVLW  3A
1D50:  MOVLB  02
1D51:  MOVWF  50
1D52:  MOVLP  08
1D53:  MOVLB  00
1D54:  CALL   1DB
1D55:  MOVLP  18
1D56:  MOVLW  20
1D57:  MOVWF  05
1D58:  MOVLW  9C
1D59:  MOVWF  04
1D5A:  MOVLP  08
1D5B:  CALL   23D
1D5C:  MOVLP  18
....................   if ( AdminMode ) { 
1D5D:  MOVLB  01
1D5E:  BTFSS  5B.3
1D5F:  GOTO   56E
....................     strcat(LCD_str,ADM); 
1D60:  MOVLW  20
1D61:  MOVLB  02
1D62:  MOVWF  29
1D63:  MOVLW  73
1D64:  MOVWF  28
1D65:  MOVLW  20
1D66:  MOVWF  2B
1D67:  MOVLW  A0
1D68:  MOVWF  2A
1D69:  MOVLP  10
1D6A:  MOVLB  00
1D6B:  CALL   685
1D6C:  MOVLP  18
1D6D:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
1D6E:  MOVLW  03
1D6F:  MOVLB  02
1D70:  MOVWF  4A
1D71:  MOVLW  20
1D72:  MOVWF  4C
1D73:  MOVLW  73
1D74:  MOVWF  4B
1D75:  MOVLP  08
1D76:  MOVLB  00
1D77:  CALL   252
1D78:  MOVLP  18
.................... } // }}} 
1D79:  RETURN
....................  
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1); //  
*
1121:  MOVLW  01
1122:  MOVLB  02
1123:  MOVWF  2E
1124:  MOVLP  08
1125:  MOVLB  00
1126:  CALL   423
1127:  MOVLP  10
....................   delay_ms(1000); 
1128:  MOVLW  04
1129:  MOVLB  02
112A:  MOVWF  2E
112B:  MOVLW  FA
112C:  MOVWF  4A
112D:  MOVLP  08
112E:  MOVLB  00
112F:  CALL   0C6
1130:  MOVLP  10
1131:  MOVLB  02
1132:  DECFSZ 2E,F
1133:  GOTO   12B
....................   for(x=0;x<6;x++) { 
1134:  CLRF   2C
1135:  MOVF   2C,W
1136:  SUBLW  05
1137:  BTFSS  03.0
1138:  GOTO   155
....................     mchar=Morse[x]; 
1139:  MOVLW  2D
113A:  ADDWF  2C,W
113B:  MOVWF  04
113C:  MOVLW  20
113D:  MOVWF  05
113E:  BTFSC  03.0
113F:  INCF   05,F
1140:  MOVF   00,W
1141:  MOVWF  2D
....................     morse(mchar); 
1142:  MOVF   2D,W
1143:  MOVWF  3F
1144:  MOVLP  08
1145:  MOVLB  00
1146:  CALL   162
1147:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
1148:  MOVLB  01
1149:  CLRF   30
114A:  MOVLW  06
114B:  MOVWF  2F
....................     while(aux_timer) { 
114C:  MOVF   2F,W
114D:  IORWF  30,W
114E:  BTFSC  03.2
114F:  GOTO   152
....................       delay_cycles(1); 
1150:  NOP
....................     } 
1151:  GOTO   14C
....................   } 
1152:  MOVLB  02
1153:  INCF   2C,F
1154:  GOTO   135
....................   delay_ms(1000); 
1155:  MOVLW  04
1156:  MOVWF  2E
1157:  MOVLW  FA
1158:  MOVWF  4A
1159:  MOVLP  08
115A:  MOVLB  00
115B:  CALL   0C6
115C:  MOVLP  10
115D:  MOVLB  02
115E:  DECFSZ 2E,F
115F:  GOTO   157
....................   COR_FLAG=1; 
1160:  BSF    72.1
.................... } // }}} 
1161:  MOVLB  00
1162:  RETURN
....................  
.................... void main (void) { // {{{ 
*
1E4E:  CLRF   05
1E4F:  CLRF   04
1E50:  MOVLW  1F
1E51:  ANDWF  03,F
1E52:  MOVLW  72
1E53:  MOVLB  01
1E54:  MOVWF  19
1E55:  BSF    0E.3
1E56:  BSF    0E.4
1E57:  MOVLB  04
1E58:  BCF    17.0
1E59:  BCF    17.1
1E5A:  BCF    17.3
1E5B:  MOVLW  13
1E5C:  MOVWF  12
1E5D:  MOVLW  28
1E5E:  MOVWF  15
1E5F:  BSF    14.7
1E60:  BCF    14.6
1E61:  MOVLW  0C
1E62:  MOVLB  03
1E63:  MOVWF  1B
1E64:  MOVLW  A2
1E65:  MOVWF  1E
1E66:  MOVLW  90
1E67:  MOVWF  1D
1E68:  MOVLB  01
1E69:  BSF    5B.5
1E6A:  CLRF   5D
1E6B:  CLRF   5C
1E6C:  MOVLB  0F
1E6D:  CLRF   11
1E6E:  CLRF   12
1E6F:  CLRF   18
1E70:  CLRF   19
1E71:  CLRF   1A
1E72:  MOVLB  03
1E73:  CLRF   0C
1E74:  CLRF   0D
1E75:  CLRF   0F
1E76:  CLRF   10
1E77:  MOVLB  02
1E78:  CLRF   12
1E79:  CLRF   11
1E7A:  CLRF   14
1E7B:  CLRF   13
....................   int x,dtmf; 
....................   char tmp[5]; 
....................   initialize(); 
*
1E7F:  MOVLP  08
1E80:  GOTO   57F
1E81:  MOVLP  18
....................  
....................   while(1) { // {{{ 
....................   restart_wdt(); 
1E82:  CLRWDT
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "#" or a "\r" is received. 
....................     if ( sBufferFlag ) { 
1E83:  BTFSS  72.0
1E84:  GOTO   68A
....................       process_sBuffer(); 
1E85:  GOTO   000
....................       clear_sBuffer(); 
1E86:  MOVLP  00
1E87:  CALL   542
1E88:  MOVLP  18
....................       sBufferFlag=0; 
1E89:  BCF    72.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1E8A:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1E8B:  BTFSS  72.6
1E8C:  GOTO   691
....................       update_aux_in(); 
1E8D:  MOVLP  10
1E8E:  GOTO   5CF
1E8F:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1E90:  BCF    72.6
....................     } 
....................     if ( SECOND_FLAG ) { 
1E91:  BTFSS  72.2
1E92:  GOTO   6DA
....................       update_aux_out(); 
1E93:  CALL   430
.................... //      sprintf(LCD_str,"%u:%u (%u)",MinuteCounter,SecondCounter,TXSiteID); 
.................... //      lcd_send(2,LCD_str); 
....................       // Time Out PTT {{{ 
....................       if ( TOT_SecondCounter || TOT_Min == 0) { 
1E94:  MOVLB  01
1E95:  MOVF   59,W
1E96:  IORWF  5A,W
1E97:  BTFSS  03.2
1E98:  GOTO   69E
1E99:  MOVLB  00
1E9A:  MOVF   66,F
1E9B:  BTFSS  03.2
1E9C:  GOTO   6A4
1E9D:  MOVLB  01
....................         TOT_SecondCounter--; 
1E9E:  MOVF   59,W
1E9F:  BTFSC  03.2
1EA0:  DECF   5A,F
1EA1:  DECF   59,F
....................       } else if ( COR_IN != 0x00 ) { 
1EA2:  GOTO   6B8
1EA3:  MOVLB  00
1EA4:  MOVF   5F,F
1EA5:  BTFSC  03.2
1EA6:  GOTO   6B9
....................         update_ptt(0); 
1EA7:  MOVLB  02
1EA8:  CLRF   2E
1EA9:  MOVLP  08
1EAA:  MOVLB  00
1EAB:  CALL   423
1EAC:  MOVLP  18
....................         printf("\n\r# PTT Timeout!\n"); 
1EAD:  MOVLW  35
1EAE:  MOVLB  03
1EAF:  MOVWF  11
1EB0:  MOVLW  05
1EB1:  MOVWF  12
1EB2:  MOVLP  00
1EB3:  MOVLB  00
1EB4:  CALL   55C
1EB5:  MOVLP  18
....................         PROMPT_FLAG=1; 
1EB6:  MOVLB  01
1EB7:  BSF    5B.2
1EB8:  MOVLB  00
....................       } 
....................       // }}} 
....................       // Admin mode timeout {{{ 
....................       if ( admin_timer ) { 
1EB9:  MOVF   73,F
1EBA:  BTFSC  03.2
1EBB:  GOTO   6BE
....................         admin_timer--; 
1EBC:  DECF   73,F
....................       } else { 
1EBD:  GOTO   6C7
....................         // Exit admin mode. 
....................         if ( AdminMode ) { 
1EBE:  MOVLB  01
1EBF:  BTFSS  5B.3
1EC0:  GOTO   6C8
....................           set_admin_mode(0); 
1EC1:  MOVLB  02
1EC2:  CLRF   40
1EC3:  MOVLP  08
1EC4:  MOVLB  00
1EC5:  CALL   568
1EC6:  MOVLP  18
1EC7:  MOVLB  01
....................         } 
....................       } 
....................       // }}} 
....................       restart_wdt(); 
1EC8:  CLRWDT
....................       if ( SecondCounter ) { 
1EC9:  MOVF   7E,F
1ECA:  BTFSC  03.2
1ECB:  GOTO   6CE
....................         SecondCounter--; 
1ECC:  DECF   7E,F
....................       } else { 
1ECD:  GOTO   6D8
....................         SecondCounter=SEC_COUNTER; 
1ECE:  MOVLW  3B
1ECF:  MOVWF  7E
....................         if ( MinuteCounter ) { 
1ED0:  MOVF   58,F
1ED1:  BTFSC  03.2
1ED2:  GOTO   6D5
....................           MinuteCounter--; 
1ED3:  DECF   58,F
....................         } else { 
1ED4:  GOTO   6D8
....................           THIRTY_MIN_FLAG=1; 
1ED5:  BSF    72.4
....................           MinuteCounter = MIN_COUNTER; 
1ED6:  MOVLW  1D
1ED7:  MOVWF  58
....................         } 
....................       } 
....................       SECOND_FLAG=0; 
1ED8:  BCF    72.2
1ED9:  MOVLB  00
....................     } 
....................     if ( THIRTY_MIN_FLAG ) { 
1EDA:  BTFSS  72.4
1EDB:  GOTO   6F6
....................       if ( (TXSiteID&0x03) !=0 ) { 
1EDC:  MOVF   64,W
1EDD:  ANDLW  03
1EDE:  BTFSC  03.2
1EDF:  GOTO   6F4
....................         // Transmit Site ID every 30 mins when: 
....................         // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................         // E = Transmit every 30 mins 
....................         // M = Transmit only if EnableMask is off 
....................         if ( (TXSiteID & 0x01)!=0 || ( (TXSiteID & 0x02)!=0 && ( ((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
1EE0:  MOVF   64,W
1EE1:  ANDLW  01
1EE2:  BTFSS  03.2
1EE3:  GOTO   6F1
1EE4:  MOVF   64,W
1EE5:  ANDLW  02
1EE6:  BTFSC  03.2
1EE7:  GOTO   6F4
1EE8:  SWAPF  64,W
1EE9:  MOVWF  77
1EEA:  MOVLW  0F
1EEB:  ANDWF  77,F
1EEC:  MOVF   77,W
1EED:  ANDLW  0F
1EEE:  ANDWF  60,W
1EEF:  BTFSS  03.2
1EF0:  GOTO   6F4
....................           send_morse_id(); 
1EF1:  MOVLP  10
1EF2:  CALL   121
1EF3:  MOVLP  18
....................         } 
....................       } 
....................       THIRTY_MIN_FLAG=0; 
1EF4:  BCF    72.4
....................       restart_wdt(); 
1EF5:  CLRWDT
....................     } 
....................     if ( COR_FLAG ) { 
1EF6:  BTFSS  72.1
1EF7:  GOTO   6FE
....................       process_cor(); 
1EF8:  MOVLP  10
1EF9:  GOTO   6BE
1EFA:  MOVLP  18
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       update_aux_out();  
1EFB:  CALL   430
....................       COR_FLAG=0; 
1EFC:  BCF    72.1
....................       restart_wdt(); 
1EFD:  CLRWDT
....................      } 
....................     if ( DTMF_IN_FLAG ) { 
1EFE:  MOVLB  01
1EFF:  BTFSS  5B.0
1F00:  GOTO   792
....................       strcpy(LCD_str,"DTMF:"); 
1F01:  CLRF   65
1F02:  CLRF   66
1F03:  MOVLW  20
1F04:  MOVWF  05
1F05:  MOVLW  73
1F06:  MOVWF  04
1F07:  MOVF   65,W
1F08:  ADDWF  04,F
1F09:  MOVLW  00
1F0A:  ADDWFC 05,F
1F0B:  MOVF   66,W
1F0C:  MOVLP  00
1F0D:  MOVLB  00
1F0E:  CALL   184
1F0F:  MOVLP  18
1F10:  MOVWF  00
1F11:  IORLW  00
1F12:  BTFSC  03.2
1F13:  GOTO   719
1F14:  MOVLB  01
1F15:  INCF   66,F
1F16:  INCF   65,F
1F17:  GOTO   703
1F18:  MOVLB  00
....................       printf("\n\rDTMF="); 
1F19:  MOVLW  3E
1F1A:  MOVLB  03
1F1B:  MOVWF  11
1F1C:  MOVLW  05
1F1D:  MOVWF  12
1F1E:  MOVLP  00
1F1F:  MOVLB  00
1F20:  CALL   55C
1F21:  MOVLP  18
....................       for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1F22:  MOVLB  01
1F23:  CLRF   5E
1F24:  MOVF   5E,W
1F25:  SUBLW  09
1F26:  BTFSS  03.0
1F27:  GOTO   770
....................         if(DTMF_ARRAY[x].Strobe) { 
1F28:  MOVLW  61
1F29:  ADDWF  5E,W
1F2A:  MOVWF  04
1F2B:  MOVLW  20
1F2C:  MOVWF  05
1F2D:  BTFSC  03.0
1F2E:  INCF   05,F
1F2F:  BTFSS  00.4
1F30:  GOTO   76D
....................           dtmf=(int)DTMF_ARRAY[x].Key; 
1F31:  MOVLW  61
1F32:  ADDWF  5E,W
1F33:  MOVWF  04
1F34:  MOVLW  20
1F35:  MOVWF  05
1F36:  BTFSC  03.0
1F37:  INCF   05,F
1F38:  MOVF   00,W
1F39:  ANDLW  0F
1F3A:  MOVWF  5F
....................           sprintf(tmp,"%d ",dtmf); 
1F3B:  MOVLW  20
1F3C:  MOVWF  5D
1F3D:  MOVLW  90
1F3E:  MOVWF  5C
1F3F:  MOVF   5F,W
1F40:  MOVLB  02
1F41:  MOVWF  4A
1F42:  MOVLW  18
1F43:  MOVWF  4B
1F44:  MOVLP  08
1F45:  MOVLB  00
1F46:  CALL   2B4
1F47:  MOVLP  18
1F48:  MOVLW  20
1F49:  MOVLB  02
1F4A:  MOVWF  50
1F4B:  MOVLP  08
1F4C:  MOVLB  00
1F4D:  CALL   1DB
1F4E:  MOVLP  18
....................           strcat(LCD_str,tmp); 
1F4F:  MOVLW  20
1F50:  MOVLB  02
1F51:  MOVWF  29
1F52:  MOVLW  73
1F53:  MOVWF  28
1F54:  MOVLW  20
1F55:  MOVWF  2B
1F56:  MOVLW  90
1F57:  MOVWF  2A
1F58:  MOVLP  10
1F59:  MOVLB  00
1F5A:  CALL   685
1F5B:  MOVLP  18
....................           printf(" %u",dtmf); 
1F5C:  MOVLW  20
1F5D:  CLRWDT
1F5E:  BTFSS  11.4
1F5F:  GOTO   75D
1F60:  MOVLB  03
1F61:  MOVWF  1A
1F62:  MOVLB  01
1F63:  MOVF   5F,W
1F64:  MOVLB  02
1F65:  MOVWF  50
1F66:  MOVLW  1B
1F67:  MOVWF  51
1F68:  MOVLP  08
1F69:  MOVLB  00
1F6A:  CALL   000
1F6B:  MOVLP  18
1F6C:  MOVLB  01
....................         } 
....................       restart_wdt(); 
1F6D:  CLRWDT
....................       } 
1F6E:  INCF   5E,F
1F6F:  GOTO   724
....................       printf("\n\r"); 
1F70:  MOVLW  0A
1F71:  CLRWDT
1F72:  MOVLB  00
1F73:  BTFSC  11.4
1F74:  GOTO   777
1F75:  MOVLB  01
1F76:  GOTO   771
1F77:  MOVLB  03
1F78:  MOVWF  1A
1F79:  MOVLW  0D
1F7A:  CLRWDT
1F7B:  MOVLB  00
1F7C:  BTFSC  11.4
1F7D:  GOTO   780
1F7E:  MOVLB  03
1F7F:  GOTO   77A
1F80:  MOVLB  03
1F81:  MOVWF  1A
....................       DTMF_IN_FLAG=0; 
1F82:  MOVLB  01
1F83:  BCF    5B.0
....................       PROMPT_FLAG=1; 
1F84:  BSF    5B.2
....................       lcd_send(2,LCD_str); // Send DTMF on line 3 
1F85:  MOVLW  02
1F86:  MOVLB  02
1F87:  MOVWF  4A
1F88:  MOVLW  20
1F89:  MOVWF  4C
1F8A:  MOVLW  73
1F8B:  MOVWF  4B
1F8C:  MOVLP  08
1F8D:  MOVLB  00
1F8E:  CALL   252
1F8F:  MOVLP  18
....................     restart_wdt(); 
1F90:  CLRWDT
1F91:  MOVLB  01
....................     } 
....................     if ( DTMF_FLAG ) { 
1F92:  BTFSS  72.7
1F93:  GOTO   799
....................       process_dtmf(); 
1F94:  MOVLB  00
1F95:  GOTO   57A
....................       DTMF_FLAG=0; 
1F96:  BCF    72.7
....................     restart_wdt(); 
1F97:  CLRWDT
1F98:  MOVLB  01
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1F99:  BTFSS  5B.1
1F9A:  GOTO   7A1
....................       clear_dtmf_array(); 
1F9B:  MOVLP  10
1F9C:  MOVLB  00
1F9D:  GOTO   76B
1F9E:  MOVLP  18
....................       CLEAR_DTMF_FLAG=0; 
1F9F:  MOVLB  01
1FA0:  BCF    5B.1
....................     } 
....................     if ( PROMPT_FLAG ) { 
1FA1:  BTFSS  5B.2
1FA2:  GOTO   7AA
....................       prompt(); 
1FA3:  MOVLP  08
1FA4:  MOVLB  00
1FA5:  CALL   7D5
1FA6:  MOVLP  18
....................       PROMPT_FLAG=0; 
1FA7:  MOVLB  01
1FA8:  BCF    5B.2
....................     restart_wdt(); 
1FA9:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1FAA:  MOVLB  00
1FAB:  GOTO   682
.................... } // }}} 
....................  
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   delay_ms(1000); 
*
0C52:  MOVLW  04
0C53:  MOVLB  02
0C54:  MOVWF  3F
0C55:  MOVLW  FA
0C56:  MOVWF  4A
0C57:  MOVLB  00
0C58:  CALL   0C6
0C59:  MOVLB  02
0C5A:  DECFSZ 3F,F
0C5B:  GOTO   455
*
1FAC:  SLEEP
....................   if ( ConfirmChar!=0 ) { 
*
0C5C:  MOVLB  00
0C5D:  MOVF   69,F
0C5E:  BTFSC  03.2
0C5F:  GOTO   471
....................     morse(ConfirmChar); 
0C60:  MOVF   69,W
0C61:  MOVLB  02
0C62:  MOVWF  3F
0C63:  MOVLB  00
0C64:  CALL   162
....................     ConfirmChar=0; 
0C65:  CLRF   69
....................     delay_ms(500); 
0C66:  MOVLW  02
0C67:  MOVLB  02
0C68:  MOVWF  3F
0C69:  MOVLW  FA
0C6A:  MOVWF  4A
0C6B:  MOVLB  00
0C6C:  CALL   0C6
0C6D:  MOVLB  02
0C6E:  DECFSZ 3F,F
0C6F:  GOTO   469
0C70:  MOVLB  00
....................   } 
....................   if (TailChar != 0) { 
0C71:  MOVF   68,F
0C72:  BTFSC  03.2
0C73:  GOTO   484
....................     morse(TailChar); 
0C74:  MOVF   68,W
0C75:  MOVLB  02
0C76:  MOVWF  3F
0C77:  MOVLB  00
0C78:  CALL   162
....................     delay_ms(500); 
0C79:  MOVLW  02
0C7A:  MOVLB  02
0C7B:  MOVWF  3F
0C7C:  MOVLW  FA
0C7D:  MOVWF  4A
0C7E:  MOVLB  00
0C7F:  CALL   0C6
0C80:  MOVLB  02
0C81:  DECFSZ 3F,F
0C82:  GOTO   47C
0C83:  MOVLB  00
....................   } 
.................... } 
.................... // send_tail }}} 
....................  
.................... int1 in_admin_mode(void) { 
....................   // Refresh timer 
....................   set_admin_mode(AdminMode); 
*
0FC1:  MOVLW  00
0FC2:  MOVLB  01
0FC3:  BTFSC  5B.3
0FC4:  MOVLW  01
0FC5:  MOVLB  02
0FC6:  MOVWF  34
0FC7:  MOVWF  40
0FC8:  MOVLB  00
0FC9:  CALL   568
....................   return(AdminMode||rs232_mode); 
0FCA:  MOVLB  01
0FCB:  BTFSC  5B.3
0FCC:  GOTO   7D1
0FCD:  BTFSC  5B.4
0FCE:  GOTO   7D1
0FCF:  MOVLW  00
0FD0:  GOTO   7D2
0FD1:  MOVLW  01
0FD2:  MOVWF  78
.................... } 
0FD3:  MOVLB  00
0FD4:  RETURN
.................... void set_admin_mode(int1 enable) { 
....................   AdminMode = (enable!=0); 
*
0D68:  MOVLB  01
0D69:  BCF    5B.3
0D6A:  MOVLB  02
0D6B:  MOVF   40,F
0D6C:  BTFSC  03.2
0D6D:  GOTO   571
0D6E:  MOVLB  01
0D6F:  BSF    5B.3
0D70:  MOVLB  02
....................   if (AdminMode) { 
0D71:  MOVLB  01
0D72:  BTFSS  5B.3
0D73:  GOTO   57B
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0D74:  MOVLW  0A
0D75:  MOVLB  00
0D76:  MOVWF  69
....................     admin_timer = ADMIN_TIMEOUT; 
0D77:  MOVLW  F0
0D78:  MOVWF  73
....................   } else { 
0D79:  GOTO   57E
0D7A:  MOVLB  01
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0D7B:  MOVLW  18
0D7C:  MOVLB  00
0D7D:  MOVWF  69
....................   }  
.................... } 
0D7E:  RETURN
....................  

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDC: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE4: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEC: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF4: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFC: 3468 3496 349A 34A5 
