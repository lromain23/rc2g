CCS PCM C Compiler, Version 4.140, 64991               04-Mar-21 18:18

               Filename:   C:\Users\Luc\Projects\RC2G Branches\RC2G_b\63_VA2CMB\Firmware.lst

               ROM used:   8129 words (99%)
                           Largest free fragment is 23
               RAM used:   174 (34%) at main() level
                           242 (47%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   5A5
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   348
002D:  MOVLP  00
002E:  GOTO   36F
002F:  MOVLP  00
0030:  GOTO   2EB
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #device ADC=8; 
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
15C1:  MOVLB  02
15C2:  MOVF   32,W
15C3:  MOVWF  36
15C4:  MOVF   31,W
15C5:  MOVWF  35
15C6:  MOVF   36,W
15C7:  MOVWF  7A
15C8:  MOVF   35,W
15C9:  MOVWF  04
15CA:  MOVF   7A,W
15CB:  MOVWF  05
15CC:  MOVF   00,F
15CD:  BTFSC  03.2
15CE:  GOTO   5D3
15CF:  INCF   35,F
15D0:  BTFSC  03.2
15D1:  INCF   36,F
15D2:  GOTO   5C6
....................    while(*s2 != '\0') 
....................    { 
15D3:  MOVF   34,W
15D4:  MOVWF  7A
15D5:  MOVF   33,W
15D6:  MOVWF  04
15D7:  MOVF   7A,W
15D8:  MOVWF  05
15D9:  MOVF   00,F
15DA:  BTFSC  03.2
15DB:  GOTO   5EF
....................       *s = *s2; 
15DC:  MOVF   33,W
15DD:  MOVWF  04
15DE:  MOVF   34,W
15DF:  MOVWF  05
15E0:  MOVF   00,W
15E1:  MOVWF  39
15E2:  MOVF   36,W
15E3:  MOVWF  05
15E4:  MOVF   35,W
15E5:  MOVWF  04
15E6:  MOVF   39,W
15E7:  MOVWF  00
....................       ++s; 
15E8:  INCF   35,F
15E9:  BTFSC  03.2
15EA:  INCF   36,F
....................       ++s2; 
15EB:  INCF   33,F
15EC:  BTFSC  03.2
15ED:  INCF   34,F
....................    } 
15EE:  GOTO   5D3
....................  
....................    *s = '\0'; 
15EF:  MOVF   35,W
15F0:  MOVWF  04
15F1:  MOVF   36,W
15F2:  MOVWF  05
15F3:  CLRF   00
....................    return(s1); 
15F4:  MOVF   31,W
15F5:  MOVWF  78
15F6:  MOVF   32,W
15F7:  MOVWF  79
.................... } 
15F8:  MOVLB  00
15F9:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E31:  MOVF   50,W
0E32:  MOVWF  54
0E33:  MOVF   4F,W
0E34:  MOVWF  53
0E35:  MOVF   54,W
0E36:  MOVWF  7A
0E37:  MOVF   53,W
0E38:  MOVWF  04
0E39:  MOVF   7A,W
0E3A:  MOVWF  05
0E3B:  MOVF   00,F
0E3C:  BTFSC  03.2
0E3D:  GOTO   66A
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0E3E:  MOVF   52,W
0E3F:  MOVWF  56
0E40:  MOVF   51,W
0E41:  MOVWF  55
0E42:  MOVF   56,W
0E43:  MOVWF  7A
0E44:  MOVF   55,W
0E45:  MOVWF  04
0E46:  MOVF   7A,W
0E47:  MOVWF  05
0E48:  MOVF   00,F
0E49:  BTFSC  03.2
0E4A:  GOTO   666
....................          if (*sc1 == *sc2) 
0E4B:  MOVF   54,W
0E4C:  MOVWF  7A
0E4D:  MOVF   53,W
0E4E:  MOVWF  04
0E4F:  MOVF   7A,W
0E50:  MOVWF  05
0E51:  MOVF   00,W
0E52:  MOVWF  57
0E53:  MOVF   56,W
0E54:  MOVWF  7A
0E55:  MOVF   55,W
0E56:  MOVWF  04
0E57:  MOVF   7A,W
0E58:  MOVWF  05
0E59:  MOVF   00,W
0E5A:  SUBWF  57,W
0E5B:  BTFSS  03.2
0E5C:  GOTO   662
....................             return(sc1); 
0E5D:  MOVF   53,W
0E5E:  MOVWF  78
0E5F:  MOVF   54,W
0E60:  MOVWF  79
0E61:  GOTO   66D
0E62:  INCF   55,F
0E63:  BTFSC  03.2
0E64:  INCF   56,F
0E65:  GOTO   642
0E66:  INCF   53,F
0E67:  BTFSC  03.2
0E68:  INCF   54,F
0E69:  GOTO   635
....................    return(0); 
0E6A:  MOVLW  00
0E6B:  MOVWF  78
0E6C:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0DCA:  MOVF   50,W
0DCB:  MOVWF  54
0DCC:  MOVF   4F,W
0DCD:  MOVWF  53
0DCE:  MOVF   54,W
0DCF:  MOVWF  7A
0DD0:  MOVF   53,W
0DD1:  MOVWF  04
0DD2:  MOVF   7A,W
0DD3:  MOVWF  05
0DD4:  MOVF   00,F
0DD5:  BTFSC  03.2
0DD6:  GOTO   608
....................       for (sc2 = s2; ; sc2++) 
0DD7:  MOVF   52,W
0DD8:  MOVWF  56
0DD9:  MOVF   51,W
0DDA:  MOVWF  55
....................     if (*sc2 == '\0') 
0DDB:  MOVF   56,W
0DDC:  MOVWF  7A
0DDD:  MOVF   55,W
0DDE:  MOVWF  04
0DDF:  MOVF   7A,W
0DE0:  MOVWF  05
0DE1:  MOVF   00,F
0DE2:  BTFSS  03.2
0DE3:  GOTO   5EE
....................        return(sc1 - s1); 
0DE4:  MOVF   4F,W
0DE5:  SUBWF  53,W
0DE6:  MOVWF  77
0DE7:  MOVF   50,W
0DE8:  SUBWFC 54,W
0DE9:  MOVWF  7A
0DEA:  MOVF   77,W
0DEB:  MOVWF  78
0DEC:  GOTO   610
....................          else if (*sc1 == *sc2) 
0DED:  GOTO   600
0DEE:  MOVF   54,W
0DEF:  MOVWF  7A
0DF0:  MOVF   53,W
0DF1:  MOVWF  04
0DF2:  MOVF   7A,W
0DF3:  MOVWF  05
0DF4:  MOVF   00,W
0DF5:  MOVWF  57
0DF6:  MOVF   56,W
0DF7:  MOVWF  7A
0DF8:  MOVF   55,W
0DF9:  MOVWF  04
0DFA:  MOVF   7A,W
0DFB:  MOVWF  05
0DFC:  MOVF   00,W
0DFD:  SUBWF  57,W
0DFE:  BTFSC  03.2
....................             break; 
0DFF:  GOTO   604
0E00:  INCF   55,F
0E01:  BTFSC  03.2
0E02:  INCF   56,F
0E03:  GOTO   5DB
0E04:  INCF   53,F
0E05:  BTFSC  03.2
0E06:  INCF   54,F
0E07:  GOTO   5CE
....................    return(sc1 - s1); 
0E08:  MOVF   4F,W
0E09:  SUBWF  53,W
0E0A:  MOVWF  77
0E0B:  MOVF   50,W
0E0C:  SUBWFC 54,W
0E0D:  MOVWF  7A
0E0E:  MOVF   77,W
0E0F:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1DD3:  MOVLB  00
1DD4:  CLRF   26
1DD5:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0DB1:  MOVLB  02
0DB2:  MOVF   47,W
0DB3:  IORWF  48,W
0DB4:  BTFSC  03.2
0DB5:  GOTO   5BA
0DB6:  MOVF   48,W
0DB7:  MOVWF  7A
0DB8:  MOVF   47,W
0DB9:  GOTO   5BF
0DBA:  MOVLB  00
0DBB:  MOVF   27,W
0DBC:  MOVWF  7A
0DBD:  MOVF   26,W
0DBE:  MOVLB  02
0DBF:  MOVWF  4B
0DC0:  MOVF   7A,W
0DC1:  MOVWF  4C
....................    beg += strspn(beg, s2); 
0DC2:  MOVF   4C,W
0DC3:  MOVWF  50
0DC4:  MOVF   4B,W
0DC5:  MOVWF  4F
0DC6:  MOVF   4A,W
0DC7:  MOVWF  52
0DC8:  MOVF   49,W
0DC9:  MOVWF  51
*
0E10:  MOVF   78,W
0E11:  ADDWF  4B,F
0E12:  MOVLW  00
0E13:  ADDWFC 4C,F
....................    if (*beg == '\0') 
0E14:  MOVF   4C,W
0E15:  MOVWF  7A
0E16:  MOVF   4B,W
0E17:  MOVWF  04
0E18:  MOVF   7A,W
0E19:  MOVWF  05
0E1A:  MOVF   00,F
0E1B:  BTFSS  03.2
0E1C:  GOTO   629
....................    { 
....................       *save = ' '; 
0E1D:  MOVLB  00
0E1E:  MOVF   26,W
0E1F:  MOVWF  04
0E20:  MOVF   27,W
0E21:  MOVWF  05
0E22:  MOVLW  20
0E23:  MOVWF  00
....................       return(0); 
0E24:  MOVLW  00
0E25:  MOVWF  78
0E26:  MOVWF  79
0E27:  GOTO   68E
0E28:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0E29:  MOVF   4C,W
0E2A:  MOVWF  50
0E2B:  MOVF   4B,W
0E2C:  MOVWF  4F
0E2D:  MOVF   4A,W
0E2E:  MOVWF  52
0E2F:  MOVF   49,W
0E30:  MOVWF  51
*
0E6D:  MOVF   79,W
0E6E:  MOVWF  4E
0E6F:  MOVF   78,W
0E70:  MOVWF  4D
....................    if (*end != '\0') 
0E71:  MOVF   4E,W
0E72:  MOVWF  7A
0E73:  MOVF   4D,W
0E74:  MOVWF  04
0E75:  MOVF   7A,W
0E76:  MOVWF  05
0E77:  MOVF   00,F
0E78:  BTFSC  03.2
0E79:  GOTO   682
....................    { 
....................       *end = '\0'; 
0E7A:  MOVF   4D,W
0E7B:  MOVWF  04
0E7C:  MOVF   4E,W
0E7D:  MOVWF  05
0E7E:  CLRF   00
....................       end++; 
0E7F:  INCF   4D,F
0E80:  BTFSC  03.2
0E81:  INCF   4E,F
....................    } 
....................    save = end; 
0E82:  MOVF   4E,W
0E83:  MOVLB  00
0E84:  MOVWF  27
0E85:  MOVLB  02
0E86:  MOVF   4D,W
0E87:  MOVLB  00
0E88:  MOVWF  26
....................    return(beg); 
0E89:  MOVLB  02
0E8A:  MOVF   4B,W
0E8B:  MOVWF  78
0E8C:  MOVF   4C,W
0E8D:  MOVWF  79
0E8E:  MOVLB  00
.................... } 
0E8F:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
.................... #define BUTTON_STATES 
.................... #define POT_MAX 63 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
0800:  MOVLW  20
0801:  MOVWF  05
0802:  MOVLW  D2
0803:  MOVWF  04
0804:  MOVF   00,W
0805:  BTFSC  03.2
0806:  GOTO   018
0807:  MOVLW  02
0808:  MOVWF  78
0809:  MOVLW  BF
080A:  MOVWF  77
080B:  CLRWDT
080C:  DECFSZ 77,F
080D:  GOTO   00B
080E:  DECFSZ 78,F
080F:  GOTO   009
0810:  MOVLW  96
0811:  MOVWF  77
0812:  DECFSZ 77,F
0813:  GOTO   012
0814:  GOTO   015
0815:  CLRWDT
0816:  DECFSZ 00,F
0817:  GOTO   007
0818:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
06B4:  MOVLB  04
06B5:  BCF    15.7
06B6:  MOVLB  00
06B7:  BCF    11.3
06B8:  MOVLB  02
06B9:  MOVF   58,W
06BA:  MOVLB  04
06BB:  MOVWF  11
06BC:  MOVLW  02
06BD:  BTFSC  15.7
06BE:  GOTO   6C6
06BF:  MOVLB  00
06C0:  BTFSS  11.3
06C1:  GOTO   6C0
06C2:  MOVLW  00
06C3:  MOVLB  04
06C4:  BTFSC  16.6
06C5:  MOVLW  01
06C6:  MOVWF  78
06C7:  MOVLB  00
06C8:  RETURN
*
0AA1:  MOVLB  04
0AA2:  BCF    15.6
0AA3:  BSF    16.3
0AA4:  BTFSC  16.3
0AA5:  GOTO   2A4
0AA6:  BTFSC  77.0
0AA7:  BCF    16.5
0AA8:  BTFSS  77.0
0AA9:  BSF    16.5
0AAA:  BSF    16.4
0AAB:  BTFSC  16.4
0AAC:  GOTO   2AB
0AAD:  MOVF   11,W
0AAE:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02E4:  CLRWDT
02E5:  BTFSS  11.4
02E6:  GOTO   2E4
02E7:  MOVLB  03
02E8:  MOVWF  1A
02E9:  MOVLB  00
02EA:  RETURN
.................... //#use fast_io (a) 
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void process_dtmf_interrupt(void); 
.................... void send_tail(void); 
.................... void status_led(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
.................... int1 my_stricmp(char *, char *); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN; 
.................... unsigned int Enable,Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned int TOT_Min; 
.................... unsigned int Link_TOT,LinkDurationTimer; 
.................... unsigned int COR_EMUL; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... char COR_IN_EFFECTIVE; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... // 
.................... // Button calibration states 
.................... // 
.................... #define BUTTON_IDLE 0 
.................... #define CALIB 16 
.................... #define TRIM 15  
.................... // 
.................... // Command settings 
.................... // 
.................... #define LINK_CMD 1 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define DEBOUNCE_COUNT 8 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... // Arguments 
.................... #define AUXI_EMULATE_COR0 0x01 
.................... #define AUXI_EMULATE_COR1 0x02 
.................... #define AUXI_EMULATE_COR2 0x04 
.................... #define AUXI_EMULATE_COR3 0x08 
.................... #define AUXI_EMULATE_COR4 0x10 // COR from AUX only for DTMF control (No audio feed-thru) 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x20 
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... #define LCD_I2C_ADD 0x60 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... unsigned int command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... unsigned int  LastRegisterIndex; 
.................... unsigned int  LastRegisterIndexValid; 
....................  
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
....................   int  usage : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1 ENTER_PRESSED; 
.................... int1 SELECT_PRESSED; 
.................... int  adj_value_a,adj_value_b; 
.................... char button_state; 
.................... int1       COR_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... int1       STATUS_LED; 
.................... unsigned long TOT_SecondCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1       DTMF_INTERRUPT_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... // PROTECTED -- Must be in admin mode to set value 
.................... // PUBLIC    -- Register can be set in any mode 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
.................... #define PROTECTED 1 
.................... #define PUBLIC    0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 AuxIn[0] 
.................... 	{"XI2"},	  // 19 AuxIn[1] 
.................... 	{"XI3"},	  // 20 AuxIn[2] 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"LTO"},  // 54 
....................     {"COR"},  // 55 
....................     {"CPOT"}  // 56 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
....................  
.................... #define SITE_ID_VAL  	63 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... #define ENABLE_DEFAULT 15 
.................... #define TOT_MIN 5 
.................... #define LINK_TOT 5 
.................... #define DEFAULT_GAIN 32 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('a') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('c') 
.................... #define MORSEID4	MCHAR('m') 
.................... #define MORSEID5	MCHAR('b') 
....................  
.................... #define AUXOUTOP0 0 
.................... #define AUXOUTARG0 0 
.................... #define AUXOUTOP1 0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2 0 
.................... #define AUXOUTARG2 0 
....................  
.................... //#define AUXINOP0 AUXI_ENABLE 
.................... //#define AUXINARG0 AUXI_ENABLE2|AUXI_ENABLE3|AUXI_ENABLE4 
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  AUXI_TAIL_WHEN_HI 
.................... #define AUXINARG0 MCHAR('b') 
.................... #define AUXINOP1 0 
.................... #define AUXINARG1 0 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
.................... // Define default variables {{{ 
.................... #ifndef RX1_PTT 
....................   #define RX1_PTT 0x0E 
.................... #endif 
.................... #ifndef RX2_PTT 
....................   #define RX2_PTT 0x0D 
.................... #endif 
.................... #ifndef RX3_PTT 
....................   #define RX3_PTT 0x0B  
.................... #endif 
.................... #ifndef RX4_PTT 
....................   #define RX4_PTT 0x07 
.................... #endif 
.................... #ifndef DEFAULT_GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... // }}} 
....................  
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  , EEPROM,PUBLIC}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL, EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&AuxIn[0]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[1]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[2]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[0]     ,0               , EEPROM,PROTECTED}, 
.................... 	{&AuxOut[1]     ,0               , EEPROM,PROTECTED}, 
.................... 	{&AuxOut[2]     ,0               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[0] ,4               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[1] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[2] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[3] ,2               , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[0]     ,RX1_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[1]     ,RX2_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[2]     ,RX3_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[3]     ,RX4_PTT         , EEPROM,PROTECTED}, 
.................... 	{&SiteID        ,SITE_ID_VAL     , EEPROM,PROTECTED}, 
.................... 	{&TXSiteID      ,0x12            , EEPROM,PROTECTED}, 
....................   {&Morse[0]      ,MORSEID0        , EEPROM,PROTECTED}, 
....................   {&Morse[1]      ,MORSEID1        , EEPROM,PROTECTED}, 
....................   {&Morse[2]      ,MORSEID2        , EEPROM,PROTECTED}, 
....................   {&Morse[3]      ,MORSEID3        , EEPROM,PROTECTED}, 
....................   {&Morse[4]      ,MORSEID4        , EEPROM,PROTECTED}, 
....................   {&Morse[5]      ,MORSEID5        , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2      , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2        , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2       , EEPROM,PROTECTED}, 
....................   {&Tail          ,TAIL_CHAR       , EEPROM,PROTECTED}, 
....................   {&TOT_Min       ,TOT_MIN         , EEPROM,PROTECTED}, 
....................   {&Link_TOT      ,LINK_TOT        , EEPROM,PROTECTED}, 
.................... 	{&COR_EMUL      ,0x00            , RAM   ,PUBLIC}, 
.................... 	{&CurrentTrimPot,0x00            , RAM   ,PROTECTED}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02EB:  BTFSS  11.5
02EC:  GOTO   342
....................     c = getc(); 
02ED:  CLRWDT
02EE:  BTFSS  11.5
02EF:  GOTO   2ED
02F0:  MOVLB  03
02F1:  MOVF   19,W
02F2:  MOVLB  02
02F3:  MOVWF  5F
....................     if ( c == '\b' ) { 
02F4:  MOVF   5F,W
02F5:  SUBLW  08
02F6:  BTFSS  03.2
02F7:  GOTO   320
....................       if ( sBufferIndex > 0 ) { 
02F8:  MOVF   71,F
02F9:  BTFSC  03.2
02FA:  GOTO   31A
....................         sBufferIndex--; 
02FB:  DECF   71,F
....................         sBuffer[sBufferIndex]='\0'; 
02FC:  MOVLW  50
02FD:  ADDWF  71,W
02FE:  MOVWF  04
02FF:  MOVLW  20
0300:  MOVWF  05
0301:  BTFSC  03.0
0302:  INCF   05,F
0303:  CLRF   00
....................         putc('\b'); 
0304:  MOVLW  08
0305:  MOVLB  00
0306:  CALL   2E4
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
0307:  MOVLW  1B
0308:  CALL   2E4
....................   printf("[K"); 
0309:  MOVLW  5B
030A:  CLRWDT
030B:  BTFSS  11.4
030C:  GOTO   30A
030D:  MOVLB  03
030E:  MOVWF  1A
030F:  MOVLW  4B
0310:  CLRWDT
0311:  MOVLB  00
0312:  BTFSC  11.4
0313:  GOTO   316
0314:  MOVLB  03
0315:  GOTO   310
0316:  MOVLB  03
0317:  MOVWF  1A
....................       } else { 
0318:  GOTO   31E
0319:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
031A:  MOVLW  07
031B:  MOVLB  00
031C:  CALL   2E4
031D:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
031E:  GOTO   344
031F:  MOVLB  02
0320:  MOVF   71,W
0321:  SUBLW  0F
0322:  BTFSS  03.0
0323:  GOTO   33F
....................       putc(c); // echo the character 
0324:  MOVF   5F,W
0325:  MOVLB  00
0326:  CALL   2E4
....................       sBuffer[sBufferIndex++] = c; 
0327:  MOVF   71,W
0328:  INCF   71,F
0329:  ADDLW  50
032A:  MOVWF  04
032B:  MOVLW  20
032C:  MOVWF  05
032D:  BTFSC  03.0
032E:  INCF   05,F
032F:  MOVLB  02
0330:  MOVF   5F,W
0331:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0332:  MOVF   5F,W
0333:  SUBLW  0D
0334:  BTFSC  03.2
0335:  GOTO   33D
0336:  MOVF   5F,W
0337:  SUBLW  2B
0338:  BTFSC  03.2
0339:  GOTO   33D
033A:  MOVF   5F,W
033B:  SUBLW  2D
033C:  BTFSC  03.2
....................         sBufferFlag=1; 
033D:  BSF    72.0
....................       } 
....................     } else { 
033E:  GOTO   343
....................       putc('\a'); // Send alert. Avoid buffer overflow 
033F:  MOVLW  07
0340:  MOVLB  00
0341:  CALL   2E4
0342:  MOVLB  02
0343:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
0344:  MOVLB  00
0345:  BCF    11.5
0346:  MOVLP  00
0347:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   int LAST_COR_IN; 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if(IOCBF&0x0F) { // Check for interrupts on RB[3:0] only 
0348:  MOVLB  07
0349:  MOVF   16,W
034A:  ANDLW  0F
034B:  BTFSC  03.2
034C:  GOTO   35E
....................     LAST_COR_IN=COR_IN; 
034D:  MOVLB  00
034E:  MOVF   5F,W
034F:  MOVLB  02
0350:  MOVWF  5F
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
0351:  MOVLB  00
0352:  MOVF   0D,W
0353:  XORWF  62,W
0354:  ANDLW  0F
0355:  MOVWF  5F
....................     if ( LAST_COR_IN != COR_IN ) { 
0356:  MOVF   5F,W
0357:  MOVLB  02
0358:  SUBWF  5F,W
0359:  BTFSS  03.2
....................       COR_FLAG = 1; 
035A:  BSF    72.3
....................     } 
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
035B:  MOVLW  F0
035C:  MOVLB  07
035D:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
035E:  BTFSS  0B.0
035F:  GOTO   364
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     DTMF_INTERRUPT_FLAG = 1; 
0360:  MOVLB  01
0361:  BSF    5D.4
....................     clear_interrupt(INT_RB4_H2L); 
0362:  MOVLB  07
0363:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
0364:  BTFSS  0B.0
0365:  GOTO   36B
....................     AUX_IN_FLAG=1; 
0366:  MOVLB  01
0367:  BSF    5D.0
....................     clear_interrupt(INT_RB6|INT_RB7); 
0368:  MOVLW  3F
0369:  MOVLB  07
036A:  ANDWF  16,F
....................   } 
.................... } // }}} 
036B:  BCF    0B.0
036C:  MOVLP  00
036D:  MOVLB  00
036E:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
036F:  MOVLB  01
0370:  MOVF   30,W
0371:  IORWF  31,W
0372:  BTFSC  03.2
0373:  GOTO   379
....................     rtcc_cnt--; 
0374:  MOVF   30,W
0375:  BTFSC  03.2
0376:  DECF   31,F
0377:  DECF   30,F
....................   } else { 
0378:  GOTO   385
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
0379:  MOVLB  00
037A:  MOVF   0D,W
037B:  XORWF  62,W
037C:  ANDLW  0F
037D:  MOVWF  5F
....................     COR_FLAG=1; 
037E:  BSF    72.3
....................     SECOND_FLAG=1; 
037F:  BSF    72.4
....................     AUX_IN_FLAG=1; 
0380:  MOVLB  01
0381:  BSF    5D.0
....................     rtcc_cnt=30; 
0382:  CLRF   31
0383:  MOVLW  1E
0384:  MOVWF  30
....................   } 
....................   if (aux_timer ) { 
0385:  MOVF   32,W
0386:  IORWF  33,W
0387:  BTFSC  03.2
0388:  GOTO   38D
....................     aux_timer--; 
0389:  MOVF   32,W
038A:  BTFSC  03.2
038B:  DECF   33,F
038C:  DECF   32,F
....................   } 
.................... } // }}} 
038D:  BCF    0B.2
038E:  MOVLP  00
038F:  MOVLB  00
0390:  GOTO   020
.................... int1 warn_no_lcd = 1; 
.................... void lcd_send(int line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
*
098C:  BCF    03.0
098D:  MOVLB  02
098E:  RLF    52,W
098F:  ANDLW  0E
0990:  IORLW  60
0991:  MOVWF  55
....................   i2c_start(); 
0992:  MOVLB  04
0993:  BSF    16.0
0994:  BTFSC  16.0
0995:  GOTO   194
....................   ack=i2c_write(lcd_cmd); 
0996:  MOVLB  02
0997:  MOVF   55,W
0998:  MOVWF  58
0999:  MOVLP  00
099A:  MOVLB  00
099B:  CALL   6B4
099C:  MOVLP  08
099D:  MOVF   78,W
099E:  MOVLB  02
099F:  BCF    56.0
09A0:  BTFSC  78.0
09A1:  BSF    56.0
....................   if ( ack!=0 ) { 
09A2:  BTFSS  56.0
09A3:  GOTO   1C6
....................     if ( warn_no_lcd ) { 
09A4:  MOVLB  01
09A5:  BTFSS  62.1
09A6:  GOTO   1C4
....................       printf("\n\rI2C ERROR : No ACK from LCD : %u",ack); 
09A7:  MOVLW  00
09A8:  MOVLB  02
09A9:  BTFSC  56.0
09AA:  MOVLW  01
09AB:  MOVWF  57
09AC:  MOVLW  91
09AD:  MOVLB  03
09AE:  MOVWF  11
09AF:  MOVLW  03
09B0:  MOVWF  12
09B1:  BCF    03.0
09B2:  MOVLW  20
09B3:  MOVLB  02
09B4:  MOVWF  58
09B5:  MOVLP  00
09B6:  MOVLB  00
09B7:  CALL   6C9
09B8:  MOVLP  08
09B9:  MOVLB  02
09BA:  MOVF   57,W
09BB:  MOVWF  58
09BC:  MOVLW  1B
09BD:  MOVWF  59
09BE:  MOVLP  00
09BF:  MOVLB  00
09C0:  CALL   73D
09C1:  MOVLP  08
....................       warn_no_lcd = 0; 
09C2:  MOVLB  01
09C3:  BCF    62.1
....................     } 
....................   } else { 
09C4:  GOTO   1C8
09C5:  MOVLB  02
....................     warn_no_lcd = 1; 
09C6:  MOVLB  01
09C7:  BSF    62.1
....................   } 
....................   while(*s) { 
09C8:  MOVLB  02
09C9:  MOVF   54,W
09CA:  MOVWF  7A
09CB:  MOVF   53,W
09CC:  MOVWF  04
09CD:  MOVF   7A,W
09CE:  MOVWF  05
09CF:  MOVF   00,F
09D0:  BTFSC  03.2
09D1:  GOTO   1E5
....................     i2c_write(*s++); 
09D2:  MOVF   54,W
09D3:  MOVWF  7A
09D4:  MOVF   53,W
09D5:  INCF   53,F
09D6:  BTFSC  03.2
09D7:  INCF   54,F
09D8:  MOVWF  04
09D9:  MOVF   7A,W
09DA:  MOVWF  05
09DB:  MOVF   00,W
09DC:  MOVWF  57
09DD:  MOVWF  58
09DE:  MOVLP  00
09DF:  MOVLB  00
09E0:  CALL   6B4
09E1:  MOVLP  08
....................   } 
09E2:  MOVLB  01
09E3:  GOTO   1C8
09E4:  MOVLB  02
....................   i2c_write(0); // EOL 
09E5:  CLRF   58
09E6:  MOVLP  00
09E7:  MOVLB  00
09E8:  CALL   6B4
09E9:  MOVLP  08
....................   i2c_stop(); 
09EA:  MOVLB  04
09EB:  BSF    16.2
09EC:  BTFSC  16.2
09ED:  GOTO   1EC
.................... #endif 
.................... } // }}} 
09EE:  MOVLB  00
09EF:  RETURN
.................... #ifdef BUTTON_STATES 
.................... void status_led(void) { // {{{ 
....................   char cnt_val; 
....................   STATUS_LED=0; 
*
0D87:  MOVLB  01
0D88:  BCF    5D.1
....................   cnt_val = rtcc_cnt>>3; 
0D89:  RRF    31,W
0D8A:  MOVWF  7A
0D8B:  RRF    30,W
0D8C:  MOVWF  79
0D8D:  RRF    7A,F
0D8E:  RRF    79,F
0D8F:  RRF    7A,F
0D90:  RRF    79,F
0D91:  MOVF   79,W
0D92:  MOVWF  6E
....................   if ( button_state!=0 ) { 
0D93:  MOVF   5C,F
0D94:  BTFSC  03.2
0D95:  GOTO   5A4
....................     if ( (rtcc_cnt & 0x04) ) { 
0D96:  MOVF   30,W
0D97:  ANDLW  04
0D98:  MOVWF  77
0D99:  CLRF   7A
0D9A:  MOVF   77,W
0D9B:  IORWF  7A,W
0D9C:  BTFSC  03.2
0D9D:  GOTO   5A4
....................       STATUS_LED = (cnt_val < (CurrentTrimPot+1));  
0D9E:  BCF    5D.1
0D9F:  MOVLW  01
0DA0:  ADDWF  74,W
0DA1:  SUBWF  6E,W
0DA2:  BTFSS  03.0
0DA3:  BSF    5D.1
....................     } 
....................   }  
....................   output_bit(STATUS_LED_PIN,STATUS_LED); 
0DA4:  BTFSC  5D.1
0DA5:  GOTO   5AA
0DA6:  MOVLB  02
0DA7:  BCF    0C.6
0DA8:  GOTO   5AC
0DA9:  MOVLB  01
0DAA:  MOVLB  02
0DAB:  BSF    0C.6
0DAC:  MOVLB  01
0DAD:  BCF    0C.6
.................... } // }}} 
0DAE:  MOVLP  18
0DAF:  MOVLB  00
0DB0:  GOTO   67F (RETURN)
.................... #endif 
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
105A:  MOVF   70,F
105B:  BTFSC  03.2
105C:  GOTO   0BE
....................     printf("\n\rProcessing Command:"); 
105D:  MOVLW  A3
105E:  MOVLB  03
105F:  MOVWF  11
1060:  MOVLW  03
1061:  MOVWF  12
1062:  MOVLP  00
1063:  MOVLB  00
1064:  CALL   4D8
1065:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
1066:  MOVLW  AE
1067:  MOVLB  03
1068:  MOVWF  11
1069:  MOVLW  03
106A:  MOVWF  12
106B:  BCF    03.0
106C:  MOVLW  0E
106D:  MOVLB  02
106E:  MOVWF  58
106F:  MOVLP  00
1070:  MOVLB  00
1071:  CALL   6C9
1072:  MOVLP  10
1073:  MOVF   63,W
1074:  MOVLB  02
1075:  MOVWF  58
1076:  MOVLW  1B
1077:  MOVWF  59
1078:  MOVLP  00
1079:  MOVLB  00
107A:  CALL   73D
107B:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
107C:  MOVLW  B7
107D:  MOVLB  03
107E:  MOVWF  11
107F:  MOVLW  03
1080:  MOVWF  12
1081:  BCF    03.0
1082:  MOVLW  0E
1083:  MOVLB  02
1084:  MOVWF  58
1085:  MOVLP  00
1086:  MOVLB  00
1087:  CALL   6C9
1088:  MOVLP  10
1089:  MOVF   70,W
108A:  MOVLB  02
108B:  MOVWF  58
108C:  MOVLW  1B
108D:  MOVWF  59
108E:  MOVLP  00
108F:  MOVLB  00
1090:  CALL   73D
1091:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
1092:  MOVLW  C0
1093:  MOVLB  03
1094:  MOVWF  11
1095:  MOVLW  03
1096:  MOVWF  12
1097:  BCF    03.0
1098:  MOVLW  0E
1099:  MOVLB  02
109A:  MOVWF  58
109B:  MOVLP  00
109C:  MOVLB  00
109D:  CALL   6C9
109E:  MOVLP  10
109F:  MOVF   75,W
10A0:  MOVLB  02
10A1:  MOVWF  58
10A2:  MOVLW  1B
10A3:  MOVWF  59
10A4:  MOVLP  00
10A5:  MOVLB  00
10A6:  CALL   73D
10A7:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
10A8:  MOVLW  C9
10A9:  MOVLB  03
10AA:  MOVWF  11
10AB:  MOVLW  03
10AC:  MOVWF  12
10AD:  BCF    03.0
10AE:  MOVLW  0E
10AF:  MOVLB  02
10B0:  MOVWF  58
10B1:  MOVLP  00
10B2:  MOVLB  00
10B3:  CALL   6C9
10B4:  MOVLP  10
10B5:  MOVF   76,W
10B6:  MOVLB  02
10B7:  MOVWF  58
10B8:  MOVLW  1B
10B9:  MOVWF  59
10BA:  MOVLP  00
10BB:  MOVLB  00
10BC:  CALL   73D
10BD:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
10BE:  MOVLW  02
10BF:  SUBWF  70,W
10C0:  ADDLW  F5
10C1:  BTFSC  03.0
10C2:  GOTO   4DE
10C3:  ADDLW  0B
10C4:  GOTO   4DF
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
118D:  GOTO   4DE
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
118E:  RLF    75,W
118F:  MOVWF  77
1190:  RLF    77,F
1191:  MOVLW  FC
1192:  ANDWF  77,F
1193:  MOVF   77,W
1194:  MOVLB  02
1195:  MOVWF  34
1196:  INCF   34,W
1197:  MOVLP  00
1198:  MOVLB  00
1199:  CALL   043
119A:  MOVLP  10
119B:  MOVWF  7A
119C:  MOVLB  02
119D:  MOVF   34,W
119E:  MOVLP  00
119F:  MOVLB  00
11A0:  CALL   043
11A1:  MOVLP  10
11A2:  MOVLB  02
11A3:  MOVWF  28
11A4:  MOVF   7A,W
11A5:  MOVWF  29
....................       LastRegisterIndex = argument; 
11A6:  MOVF   75,W
11A7:  MOVWF  7C
....................       LastRegisterIndexValid=1; 
11A8:  MOVLW  01
11A9:  MOVWF  7D
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
11AA:  MOVLW  01
11AB:  MOVWF  7A
11AC:  MOVLW  8F
11AD:  MOVWF  34
11AE:  MOVF   7A,W
11AF:  MOVWF  35
11B0:  CLRF   37
11B1:  MOVF   75,W
11B2:  MOVWF  36
11B3:  MOVF   37,W
11B4:  MOVWF  46
11B5:  MOVF   36,W
11B6:  MOVWF  45
11B7:  CLRF   48
11B8:  MOVLW  06
11B9:  MOVWF  47
11BA:  MOVLP  08
11BB:  MOVLB  00
11BC:  CALL   718
11BD:  MOVLP  10
11BE:  MOVF   78,W
11BF:  MOVLB  02
11C0:  ADDWF  34,W
11C1:  MOVWF  2C
11C2:  MOVF   79,W
11C3:  ADDWFC 35,W
11C4:  MOVWF  2D
....................       romstrcpy(rname,cPtr); 
11C5:  MOVLW  20
11C6:  MOVWF  44
11C7:  MOVLW  AE
11C8:  MOVWF  43
11C9:  MOVF   2D,W
11CA:  MOVWF  46
11CB:  MOVF   2C,W
11CC:  MOVWF  45
11CD:  MOVLP  08
11CE:  MOVLB  00
11CF:  CALL   72F
11D0:  MOVLP  10
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
11D1:  MOVLB  02
11D2:  MOVF   29,W
11D3:  MOVWF  7A
11D4:  MOVF   28,W
11D5:  MOVWF  04
11D6:  MOVF   29,W
11D7:  MOVWF  05
11D8:  MOVF   00,W
11D9:  MOVWF  34
11DA:  MOVLW  20
11DB:  MOVLB  01
11DC:  MOVWF  64
11DD:  MOVLW  76
11DE:  MOVWF  63
11DF:  MOVLW  5B
11E0:  MOVLB  02
11E1:  MOVWF  58
11E2:  MOVLP  08
11E3:  MOVLB  00
11E4:  CALL   115
11E5:  MOVLP  10
11E6:  MOVF   75,W
11E7:  MOVLB  02
11E8:  MOVWF  35
11E9:  MOVLW  01
11EA:  MOVWF  36
11EB:  MOVLP  08
11EC:  MOVLB  00
11ED:  CALL   7A8
11EE:  MOVLP  10
11EF:  MOVLW  5D
11F0:  MOVLB  02
11F1:  MOVWF  58
11F2:  MOVLP  08
11F3:  MOVLB  00
11F4:  CALL   115
11F5:  MOVLP  10
11F6:  MOVLW  20
11F7:  MOVLB  02
11F8:  MOVWF  58
11F9:  MOVLP  08
11FA:  MOVLB  00
11FB:  CALL   115
11FC:  MOVLP  10
11FD:  MOVLW  20
11FE:  MOVWF  05
11FF:  MOVLW  AE
1200:  MOVWF  04
1201:  MOVLP  08
1202:  CALL   177
1203:  MOVLP  10
1204:  MOVLW  20
1205:  MOVLB  02
1206:  MOVWF  58
1207:  MOVLP  08
1208:  MOVLB  00
1209:  CALL   115
120A:  MOVLP  10
120B:  MOVLB  02
120C:  MOVF   34,W
120D:  MOVWF  35
120E:  MOVLW  1B
120F:  MOVWF  36
1210:  MOVLP  08
1211:  MOVLB  00
1212:  CALL   7A8
1213:  MOVLP  10
1214:  MOVLW  0A
1215:  MOVLB  02
1216:  MOVWF  58
1217:  MOVLP  08
1218:  MOVLB  00
1219:  CALL   115
121A:  MOVLP  10
121B:  MOVLW  0D
121C:  MOVLB  02
121D:  MOVWF  58
121E:  MOVLP  08
121F:  MOVLB  00
1220:  CALL   115
1221:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
1222:  MOVLW  0A
1223:  CLRWDT
1224:  BTFSS  11.4
1225:  GOTO   223
1226:  MOVLB  03
1227:  MOVWF  1A
1228:  MOVLW  0D
1229:  CLRWDT
122A:  MOVLB  00
122B:  BTFSC  11.4
122C:  GOTO   22F
122D:  MOVLB  03
122E:  GOTO   229
122F:  MOVLB  03
1230:  MOVWF  1A
1231:  MOVLW  20
1232:  MOVWF  05
1233:  MOVLW  76
1234:  MOVWF  04
1235:  MOVLP  08
1236:  MOVLB  00
1237:  CALL   257
1238:  MOVLP  10
....................       lcd_send(2,LCD_str); 
1239:  MOVLW  02
123A:  MOVLB  02
123B:  MOVWF  52
123C:  MOVLW  20
123D:  MOVWF  54
123E:  MOVLW  76
123F:  MOVWF  53
1240:  MOVLP  08
1241:  MOVLB  00
1242:  CALL   18C
1243:  MOVLP  10
....................       prompt(); 
1244:  CALL   000
....................       break; 
1245:  GOTO   4DE
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
1246:  MOVLP  08
1247:  CALL   758
1248:  MOVLP  10
1249:  MOVF   78,F
124A:  BTFSC  03.2
124B:  GOTO   24F
....................         store_variables(); 
124C:  MOVLP  00
124D:  CALL   5CB
124E:  MOVLP  10
....................       } 
....................       break; 
124F:  GOTO   4DE
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
1250:  DECFSZ 76,W
1251:  GOTO   256
....................         init_src=USE_EEPROM_VARS; 
1252:  MOVLB  02
1253:  BSF    2A.0
....................       } else { 
1254:  GOTO   258
1255:  MOVLB  00
....................         init_src=USE_DEFAULT_VARS; 
1256:  MOVLB  02
1257:  BCF    2A.0
....................       } 
....................       if ( in_admin_mode() ) { 
1258:  MOVLP  08
1259:  MOVLB  00
125A:  CALL   758
125B:  MOVLP  10
125C:  MOVF   78,F
125D:  BTFSC  03.2
125E:  GOTO   269
....................         init_variables(init_src); 
125F:  MOVLW  00
1260:  MOVLB  02
1261:  BTFSC  2A.0
1262:  MOVLW  01
1263:  MOVWF  34
1264:  MOVWF  35
1265:  MOVLP  00
1266:  MOVLB  00
1267:  CALL   646
1268:  MOVLP  10
....................       } 
....................       break; 
1269:  GOTO   4DE
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
126A:  MOVF   75,W
126B:  ANDLW  03
126C:  MOVWF  74
....................       increment(value); 
126D:  MOVF   76,W
126E:  MOVLB  02
126F:  MOVWF  37
1270:  MOVLP  08
1271:  MOVLB  00
1272:  CALL   767
1273:  MOVLP  10
....................       PROMPT_FLAG=1; 
1274:  MOVLB  01
1275:  BSF    5D.6
....................       break; 
1276:  MOVLB  00
1277:  GOTO   4DE
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1278:  MOVF   75,W
1279:  ANDLW  03
127A:  MOVWF  74
....................       increment(-1*value); 
127B:  MOVLW  FF
127C:  MOVLB  02
127D:  MOVWF  4B
127E:  MOVF   76,W
127F:  MOVWF  4C
1280:  MOVLP  08
1281:  MOVLB  00
1282:  CALL   690
1283:  MOVLP  10
1284:  MOVF   78,W
1285:  MOVLB  02
1286:  MOVWF  34
1287:  MOVWF  37
1288:  MOVLP  08
1289:  MOVLB  00
128A:  CALL   767
128B:  MOVLP  10
....................       PROMPT_FLAG=1; 
128C:  MOVLB  01
128D:  BSF    5D.6
....................       break; 
128E:  MOVLB  00
128F:  GOTO   4DE
....................     case STATUS: 
....................       status(); 
....................       break; 
*
1459:  MOVLB  00
145A:  GOTO   4DE
....................     case ADMIN: 
....................       switch(argument) { 
145B:  MOVF   75,W
145C:  XORLW  02
145D:  BTFSC  03.2
145E:  GOTO   466
145F:  XORLW  03
1460:  BTFSC  03.2
1461:  GOTO   46D
1462:  XORLW  02
1463:  BTFSC  03.2
1464:  GOTO   475
1465:  GOTO   477
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
1466:  MOVLP  08
1467:  CALL   758
1468:  MOVLP  10
1469:  MOVF   78,F
146A:  BTFSS  03.2
....................             reset_cpu(); 
146B:  RESET
....................           } 
....................           break; 
146C:  GOTO   47D
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
146D:  MOVLW  01
146E:  MOVLB  02
146F:  MOVWF  48
1470:  MOVLP  08
1471:  MOVLB  00
1472:  CALL   4AD
1473:  MOVLP  10
....................           break; 
1474:  GOTO   47D
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
1475:  CALL   018
....................         break; 
1476:  GOTO   47D
....................         default: 
....................           set_admin_mode(0); 
1477:  MOVLB  02
1478:  CLRF   48
1479:  MOVLP  08
147A:  MOVLB  00
147B:  CALL   4AD
147C:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
147D:  GOTO   4DE
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
....................       lcd_cmd=4+(value&0x03); 
147E:  MOVF   76,W
147F:  ANDLW  03
1480:  ADDLW  04
1481:  MOVLB  02
1482:  MOVWF  2B
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
1483:  MOVLW  20
1484:  MOVLB  01
1485:  MOVWF  64
1486:  MOVLW  76
1487:  MOVWF  63
1488:  MOVLW  D2
1489:  MOVLB  03
148A:  MOVWF  11
148B:  MOVLW  03
148C:  MOVWF  12
148D:  BCF    03.0
148E:  MOVLW  04
148F:  MOVLB  02
1490:  MOVWF  52
1491:  MOVLP  08
1492:  MOVLB  00
1493:  CALL   124
1494:  MOVLP  10
1495:  MOVLW  60
1496:  MOVLB  02
1497:  MOVWF  52
1498:  MOVLW  18
1499:  MOVWF  53
149A:  MOVLP  08
149B:  MOVLB  00
149C:  CALL   1F0
149D:  MOVLP  10
149E:  MOVLW  D5
149F:  MOVLB  03
14A0:  MOVWF  11
14A1:  MOVLW  03
14A2:  MOVWF  12
14A3:  BCF    03.0
14A4:  MOVLW  08
14A5:  MOVLB  02
14A6:  MOVWF  52
14A7:  MOVLP  08
14A8:  MOVLB  00
14A9:  CALL   124
14AA:  MOVLP  10
14AB:  MOVLB  02
14AC:  MOVF   2B,W
14AD:  MOVWF  52
14AE:  MOVLW  18
14AF:  MOVWF  53
14B0:  MOVLP  08
14B1:  MOVLB  00
14B2:  CALL   1F0
14B3:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
14B4:  MOVLW  0A
14B5:  CLRWDT
14B6:  BTFSS  11.4
14B7:  GOTO   4B5
14B8:  MOVLB  03
14B9:  MOVWF  1A
14BA:  MOVLW  0D
14BB:  CLRWDT
14BC:  MOVLB  00
14BD:  BTFSC  11.4
14BE:  GOTO   4C1
14BF:  MOVLB  03
14C0:  GOTO   4BB
14C1:  MOVLB  03
14C2:  MOVWF  1A
14C3:  MOVLW  20
14C4:  MOVWF  05
14C5:  MOVLW  76
14C6:  MOVWF  04
14C7:  MOVLP  08
14C8:  MOVLB  00
14C9:  CALL   257
14CA:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
14CB:  MOVLB  02
14CC:  MOVF   2B,W
14CD:  MOVWF  52
14CE:  MOVLW  20
14CF:  MOVWF  54
14D0:  MOVLW  76
14D1:  MOVWF  53
14D2:  MOVLP  08
14D3:  MOVLB  00
14D4:  CALL   18C
14D5:  MOVLP  10
....................       break; 
14D6:  GOTO   4DE
....................     case MORSE_SEND: 
....................       morse(value); 
14D7:  MOVF   76,W
14D8:  MOVLB  02
14D9:  MOVWF  47
14DA:  MOVLP  08
14DB:  MOVLB  00
14DC:  CALL   09C
14DD:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
14DE:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  52
1803:  MOVLW  20
1804:  MOVWF  54
1805:  MOVLW  50
1806:  MOVWF  53
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   18C
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVWF  75
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B62:  MOVLB  01
1B63:  CLRF   6F
1B64:  CLRF   6E
1B65:  MOVF   6F,F
1B66:  BTFSS  03.2
1B67:  GOTO   3AE
1B68:  MOVF   6E,W
1B69:  SUBLW  38
1B6A:  BTFSS  03.0
1B6B:  GOTO   3AE
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B6C:  MOVLW  01
1B6D:  MOVWF  7A
1B6E:  MOVLW  8F
1B6F:  MOVLB  02
1B70:  MOVWF  28
1B71:  MOVF   7A,W
1B72:  MOVWF  29
1B73:  MOVLB  01
1B74:  MOVF   6F,W
1B75:  MOVLB  02
1B76:  MOVWF  46
1B77:  MOVLB  01
1B78:  MOVF   6E,W
1B79:  MOVLB  02
1B7A:  MOVWF  45
1B7B:  CLRF   48
1B7C:  MOVLW  06
1B7D:  MOVWF  47
1B7E:  MOVLP  08
1B7F:  MOVLB  00
1B80:  CALL   718
1B81:  MOVLP  18
1B82:  MOVF   78,W
1B83:  MOVLB  02
1B84:  ADDWF  28,W
1B85:  MOVWF  20
1B86:  MOVF   79,W
1B87:  ADDWFC 29,W
1B88:  MOVWF  21
....................     romstrcpy(rname,cPtr); 
1B89:  MOVLW  20
1B8A:  MOVWF  44
1B8B:  MOVLW  A2
1B8C:  MOVWF  43
1B8D:  MOVF   21,W
1B8E:  MOVWF  46
1B8F:  MOVF   20,W
1B90:  MOVWF  45
1B91:  MOVLP  08
1B92:  MOVLB  00
1B93:  CALL   72F
1B94:  MOVLP  18
....................     if(my_stricmp(argument_name,rname)==0) { 
1B95:  MOVLW  20
1B96:  MOVLB  02
1B97:  MOVWF  48
1B98:  MOVLW  70
1B99:  MOVWF  47
1B9A:  MOVLW  20
1B9B:  MOVWF  4A
1B9C:  MOVLW  A2
1B9D:  MOVWF  49
1B9E:  MOVLP  08
1B9F:  MOVLB  00
1BA0:  CALL   6F0
1BA1:  MOVLP  18
1BA2:  MOVF   78,F
1BA3:  BTFSS  03.2
1BA4:  GOTO   3A9
....................       argument=x; 
1BA5:  MOVLB  01
1BA6:  MOVF   6E,W
1BA7:  MOVWF  75
1BA8:  MOVLB  00
....................     } 
....................   } 
1BA9:  MOVLB  01
1BAA:  INCF   6E,F
1BAB:  BTFSC  03.2
1BAC:  INCF   6F,F
1BAD:  GOTO   365
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BAE:  MOVF   75,W
1BAF:  SUBLW  FF
1BB0:  BTFSS  03.2
1BB1:  GOTO   412
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BB2:  MOVLW  20
1BB3:  MOVLB  02
1BB4:  MOVWF  48
1BB5:  MOVLW  70
1BB6:  MOVWF  47
1BB7:  MOVLP  08
1BB8:  MOVLB  00
1BB9:  CALL   6B7
1BBA:  MOVLP  18
1BBB:  MOVF   78,W
1BBC:  MOVWF  76
....................     strcpy(rname,"eeprom"); 
1BBD:  MOVLB  02
1BBE:  CLRF   28
1BBF:  CLRF   29
1BC0:  MOVLW  20
1BC1:  MOVWF  05
1BC2:  MOVLW  A2
1BC3:  MOVWF  04
1BC4:  MOVF   28,W
1BC5:  ADDWF  04,F
1BC6:  MOVLW  00
1BC7:  ADDWFC 05,F
1BC8:  MOVF   29,W
1BC9:  MOVLP  00
1BCA:  MOVLB  00
1BCB:  CALL   128
1BCC:  MOVLP  18
1BCD:  MOVWF  00
1BCE:  IORLW  00
1BCF:  BTFSC  03.2
1BD0:  GOTO   3D6
1BD1:  MOVLB  02
1BD2:  INCF   29,F
1BD3:  INCF   28,F
1BD4:  GOTO   3C0
1BD5:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1BD6:  MOVLW  20
1BD7:  MOVLB  02
1BD8:  MOVWF  48
1BD9:  MOVLW  70
1BDA:  MOVWF  47
1BDB:  MOVLW  20
1BDC:  MOVWF  4A
1BDD:  MOVLW  A2
1BDE:  MOVWF  49
1BDF:  MOVLP  08
1BE0:  MOVLB  00
1BE1:  CALL   6F0
1BE2:  MOVLP  18
1BE3:  MOVF   78,F
1BE4:  BTFSS  03.2
1BE5:  GOTO   3E8
....................       value=USE_EEPROM_VARS; 
1BE6:  MOVLW  01
1BE7:  MOVWF  76
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BE8:  MOVLB  02
1BE9:  CLRF   28
1BEA:  CLRF   29
1BEB:  MOVLW  20
1BEC:  MOVWF  05
1BED:  MOVLW  A2
1BEE:  MOVWF  04
1BEF:  MOVF   28,W
1BF0:  ADDWF  04,F
1BF1:  MOVLW  00
1BF2:  ADDWFC 05,F
1BF3:  MOVF   29,W
1BF4:  MOVLP  00
1BF5:  MOVLB  00
1BF6:  CALL   130
1BF7:  MOVLP  18
1BF8:  MOVWF  00
1BF9:  IORLW  00
1BFA:  BTFSC  03.2
1BFB:  GOTO   401
1BFC:  MOVLB  02
1BFD:  INCF   29,F
1BFE:  INCF   28,F
1BFF:  GOTO   3EB
1C00:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C01:  MOVLW  20
1C02:  MOVLB  02
1C03:  MOVWF  48
1C04:  MOVLW  70
1C05:  MOVWF  47
1C06:  MOVLW  20
1C07:  MOVWF  4A
1C08:  MOVLW  A2
1C09:  MOVWF  49
1C0A:  MOVLP  08
1C0B:  MOVLB  00
1C0C:  CALL   6F0
1C0D:  MOVLP  18
1C0E:  MOVF   78,F
1C0F:  BTFSC  03.2
....................       value=USE_DEFAULT_VARS; 
1C10:  CLRF   76
1C11:  MOVLB  01
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C12:  MOVF   70,W
1C13:  SUBLW  06
1C14:  BTFSC  03.2
1C15:  GOTO   41A
1C16:  MOVF   70,W
1C17:  SUBLW  07
1C18:  BTFSS  03.2
1C19:  GOTO   41E
....................     value = 1; 
1C1A:  MOVLW  01
1C1B:  MOVWF  76
....................     argument = CurrentTrimPot; 
1C1C:  MOVF   74,W
1C1D:  MOVWF  75
....................   } 
....................   rs232_mode = 1; 
1C1E:  BSF    62.0
....................   execute_command(); 
1C1F:  MOVLP  10
1C20:  MOVLB  00
1C21:  CALL   05A
1C22:  MOVLP  18
....................   rs232_mode = 0; 
1C23:  MOVLB  01
1C24:  BCF    62.0
.................... } // }}} 
1C25:  MOVLP  18
1C26:  MOVLB  00
1C27:  GOTO   683 (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
1290:  MOVLW  1B
1291:  MOVLP  00
1292:  CALL   2E4
1293:  MOVLP  10
....................   printf("[2J"); 
1294:  MOVLW  5B
1295:  CLRWDT
1296:  BTFSS  11.4
1297:  GOTO   295
1298:  MOVLB  03
1299:  MOVWF  1A
129A:  MOVLW  32
129B:  CLRWDT
129C:  MOVLB  00
129D:  BTFSC  11.4
129E:  GOTO   2A1
129F:  MOVLB  03
12A0:  GOTO   29B
12A1:  MOVLB  03
12A2:  MOVWF  1A
12A3:  MOVLW  4A
12A4:  CLRWDT
12A5:  MOVLB  00
12A6:  BTFSC  11.4
12A7:  GOTO   2AA
12A8:  MOVLB  03
12A9:  GOTO   2A4
12AA:  MOVLB  03
12AB:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
12AC:  MOVLW  1B
12AD:  MOVLP  00
12AE:  MOVLB  00
12AF:  CALL   2E4
12B0:  MOVLP  10
....................   printf("[0;0H"); 
12B1:  MOVLW  DB
12B2:  MOVLB  03
12B3:  MOVWF  11
12B4:  MOVLW  03
12B5:  MOVWF  12
12B6:  MOVLP  00
12B7:  MOVLB  00
12B8:  CALL   4D8
12B9:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
078C:  MOVLB  02
078D:  SWAPF  47,W
078E:  MOVWF  49
078F:  RLF    49,F
0790:  RLF    49,F
0791:  MOVLW  C0
0792:  ANDWF  49,F
....................   tx_value=tx_value + (value & 0x3F); 
0793:  MOVF   48,W
0794:  ANDLW  3F
0795:  ADDWF  49,F
....................   i2c_start(); 
0796:  MOVLB  04
0797:  BSF    16.0
0798:  BTFSC  16.0
0799:  GOTO   798
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
079A:  MOVLW  50
079B:  MOVLB  02
079C:  MOVWF  58
079D:  MOVLB  00
079E:  CALL   6B4
079F:  MOVF   78,W
07A0:  MOVLB  02
07A1:  BCF    4A.0
07A2:  BTFSC  78.0
07A3:  BSF    4A.0
....................   if ( ack != 0) { 
07A4:  BTFSS  4A.0
07A5:  GOTO   7BD
....................     printf("\n\rI2C : No ACK : %u",ack); 
07A6:  MOVLW  00
07A7:  BTFSC  4A.0
07A8:  MOVLW  01
07A9:  MOVWF  4B
07AA:  MOVLW  DE
07AB:  MOVLB  03
07AC:  MOVWF  11
07AD:  MOVLW  03
07AE:  MOVWF  12
07AF:  BCF    03.0
07B0:  MOVLW  11
07B1:  MOVLB  02
07B2:  MOVWF  58
07B3:  MOVLB  00
07B4:  CALL   6C9
07B5:  MOVLB  02
07B6:  MOVF   4B,W
07B7:  MOVWF  58
07B8:  MOVLW  1B
07B9:  MOVWF  59
07BA:  MOVLB  00
07BB:  CALL   73D
07BC:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
07BD:  MOVF   49,W
07BE:  MOVWF  58
07BF:  MOVLB  00
07C0:  CALL   6B4
....................   i2c_stop();   
07C1:  MOVLB  04
07C2:  BSF    16.2
07C3:  BTFSC  16.2
07C4:  GOTO   7C3
....................   printf("\n\rPot(%u)<=%u",pot,value); 
07C5:  MOVLW  E8
07C6:  MOVLB  03
07C7:  MOVWF  11
07C8:  MOVLW  03
07C9:  MOVWF  12
07CA:  BCF    03.0
07CB:  MOVLW  06
07CC:  MOVLB  02
07CD:  MOVWF  58
07CE:  MOVLB  00
07CF:  CALL   6C9
07D0:  MOVLB  02
07D1:  MOVF   47,W
07D2:  MOVWF  58
07D3:  MOVLW  1B
07D4:  MOVWF  59
07D5:  MOVLB  00
07D6:  CALL   73D
07D7:  MOVLW  29
07D8:  CLRWDT
07D9:  BTFSS  11.4
07DA:  GOTO   7D8
07DB:  MOVLB  03
07DC:  MOVWF  1A
07DD:  MOVLW  3C
07DE:  CLRWDT
07DF:  MOVLB  00
07E0:  BTFSC  11.4
07E1:  GOTO   7E4
07E2:  MOVLB  03
07E3:  GOTO   7DE
07E4:  MOVLB  03
07E5:  MOVWF  1A
07E6:  MOVLW  3D
07E7:  CLRWDT
07E8:  MOVLB  00
07E9:  BTFSC  11.4
07EA:  GOTO   7ED
07EB:  MOVLB  03
07EC:  GOTO   7E7
07ED:  MOVLB  03
07EE:  MOVWF  1A
07EF:  MOVLB  02
07F0:  MOVF   48,W
07F1:  MOVWF  58
07F2:  MOVLW  1B
07F3:  MOVWF  59
07F4:  MOVLB  00
07F5:  CALL   73D
....................  
.................... } // }}} 
07F6:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
089C:  MOVLW  DB
089D:  MOVLB  02
089E:  ADDWF  47,W
089F:  MOVWF  4B
08A0:  MOVLW  1F
08A1:  MOVWF  4C
08A2:  BTFSC  03.0
08A3:  INCF   4C,F
08A4:  MOVF   4C,W
08A5:  MOVLB  03
08A6:  MOVWF  12
08A7:  MOVLB  02
08A8:  MOVF   4B,W
08A9:  MOVLB  03
08AA:  MOVWF  11
08AB:  MOVLW  20
08AC:  MOVWF  05
08AD:  MOVLW  C8
08AE:  MOVWF  04
08AF:  MOVLW  01
08B0:  MOVLB  02
08B1:  MOVWF  4D
08B2:  MOVLB  00
08B3:  CALL   019
....................    
....................   PROMPT_FLAG=1; 
08B4:  MOVLB  01
08B5:  BSF    5D.6
....................   for(x=0;x<4;x++) { 
08B6:  MOVLB  02
08B7:  CLRF   49
08B8:  MOVF   49,W
08B9:  SUBLW  03
08BA:  BTFSS  03.0
08BB:  GOTO   0E2
....................     do_delay=1; 
08BC:  BSF    4A.0
....................     switch(mc & 0xc0) { // Check two MSB's 
08BD:  MOVF   48,W
08BE:  ANDLW  C0
08BF:  XORLW  40
08C0:  MOVLB  00
08C1:  BTFSC  03.2
08C2:  GOTO   0C7
08C3:  XORLW  C0
08C4:  BTFSC  03.2
08C5:  GOTO   0C9
08C6:  GOTO   0CB
....................       case(0x40): 
....................         dit(); 
08C7:  CALL   02C
....................         break; 
08C8:  GOTO   0CE
....................       case(0x80): 
....................         dah(); 
08C9:  CALL   064
....................         break; 
08CA:  GOTO   0CE
....................       default: 
....................         do_delay=0; 
08CB:  MOVLB  02
08CC:  BCF    4A.0
....................         break; 
08CD:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
08CE:  MOVLB  02
08CF:  RLF    48,F
08D0:  RLF    48,F
08D1:  MOVLW  FC
08D2:  ANDWF  48,F
....................     if ( do_delay ) { 
08D3:  BTFSS  4A.0
08D4:  GOTO   0E0
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
08D5:  MOVLB  01
08D6:  CLRF   33
08D7:  MOVLW  02
08D8:  MOVWF  32
....................       while(aux_timer) { 
08D9:  MOVF   32,W
08DA:  IORWF  33,W
08DB:  BTFSC  03.2
08DC:  GOTO   0DF
....................         delay_cycles(1); 
08DD:  NOP
....................       } 
08DE:  GOTO   0D9
08DF:  MOVLB  02
....................     } 
....................   } 
08E0:  INCF   49,F
08E1:  GOTO   0B8
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
08E2:  MOVF   47,W
08E3:  SUBLW  09
08E4:  BTFSS  03.0
08E5:  GOTO   0F1
....................     if ( c < 5 ) { 
08E6:  MOVF   47,W
08E7:  SUBLW  04
08E8:  BTFSS  03.0
08E9:  GOTO   0EE
....................       dah(); 
08EA:  MOVLB  00
08EB:  CALL   064
....................     } 
....................     else { 
08EC:  GOTO   0F0
08ED:  MOVLB  02
....................       dit(); 
08EE:  MOVLB  00
08EF:  CALL   02C
08F0:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
08F1:  MOVLB  00
08F2:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0B61:  MOVLW  30
0B62:  MOVLB  02
0B63:  MOVWF  3C
0B64:  MOVWF  3D
0B65:  MOVWF  3E
0B66:  MOVWF  3F
0B67:  CLRF   40
....................   char PTT_s[5]={'0','0','0','0',0}; 
0B68:  MOVWF  41
0B69:  MOVWF  42
0B6A:  MOVWF  43
0B6B:  MOVWF  44
0B6C:  CLRF   45
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0B6D:  MOVF   36,W
0B6E:  MOVLB  00
0B6F:  MOVWF  6D
....................  
....................   if ( cor ) { 
0B70:  MOVLB  02
0B71:  MOVF   36,F
0B72:  BTFSC  03.2
0B73:  GOTO   385
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0B74:  MOVLW  01
0B75:  SUBWF  36,W
0B76:  ADDLW  29
0B77:  MOVWF  04
0B78:  MOVLW  20
0B79:  MOVWF  05
0B7A:  BTFSC  03.0
0B7B:  INCF   05,F
0B7C:  MOVF   00,W
0B7D:  MOVWF  47
0B7E:  MOVLB  00
0B7F:  MOVF   60,W
0B80:  ANDWF  61,W
0B81:  MOVLB  02
0B82:  ANDWF  47,W
0B83:  MOVWF  3B
....................   } else { 
0B84:  GOTO   3C8
....................     ptt=0; 
0B85:  CLRF   3B
....................     if ( COR_DROP_FLAG ) { 
0B86:  BTFSS  72.7
0B87:  GOTO   3C8
....................       COR_DROP_FLAG=0; 
0B88:  BCF    72.7
....................       if ( ConfirmChar || TailChar ) { 
0B89:  MOVLB  00
0B8A:  MOVF   6B,F
0B8B:  BTFSS  03.2
0B8C:  GOTO   390
0B8D:  MOVF   6A,F
0B8E:  BTFSC  03.2
0B8F:  GOTO   3C7
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0BC8:  MOVLW  01
0BC9:  MOVWF  3A
....................   for(x=0;x<4;x++) { 
0BCA:  CLRF   37
0BCB:  MOVF   37,W
0BCC:  SUBLW  03
0BCD:  BTFSS  03.0
0BCE:  GOTO   433
....................     if ( !cor ) { 
0BCF:  MOVF   36,F
0BD0:  BTFSS  03.2
0BD1:  GOTO   3D5
....................       rx_bit=0; 
0BD2:  BCF    46.0
....................       ptt_bit=0; 
0BD3:  BCF    46.1
....................     } else { 
0BD4:  GOTO   3E8
....................       if ( cor == (x+1) ) { 
0BD5:  MOVLW  01
0BD6:  ADDWF  37,W
0BD7:  SUBWF  36,W
0BD8:  BTFSS  03.2
0BD9:  GOTO   3E0
....................         rx_bit=1; 
0BDA:  BSF    46.0
....................         CurrentCorMask=mask; 
0BDB:  MOVF   3A,W
0BDC:  MOVLB  00
0BDD:  MOVWF  6C
....................       } else { 
0BDE:  GOTO   3E2
0BDF:  MOVLB  02
....................         rx_bit=0; 
0BE0:  BCF    46.0
0BE1:  MOVLB  00
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0BE2:  MOVLB  02
0BE3:  BCF    46.1
0BE4:  MOVF   3B,W
0BE5:  ANDWF  3A,W
0BE6:  BTFSS  03.2
0BE7:  BSF    46.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0BE8:  MOVF   37,W
0BE9:  MOVLP  00
0BEA:  MOVLB  00
0BEB:  CALL   031
0BEC:  MOVLP  08
0BED:  MOVLB  02
0BEE:  MOVWF  47
0BEF:  MOVLW  00
0BF0:  BTFSC  46.0
0BF1:  MOVLW  01
0BF2:  MOVWF  77
0BF3:  MOVF   47,W
0BF4:  MOVWF  48
0BF5:  MOVF   77,W
0BF6:  MOVWF  49
0BF7:  MOVLW  01
0BF8:  MOVWF  4B
0BF9:  CLRF   4A
0BFA:  MOVLB  00
0BFB:  CALL   0F3
0BFC:  MOVLB  02
0BFD:  MOVF   47,W
0BFE:  MOVWF  48
0BFF:  CLRF   49
0C00:  CLRF   4B
0C01:  MOVLW  80
0C02:  MOVWF  4A
0C03:  MOVLB  00
0C04:  CALL   0F3
....................     output_bit(PTT_PIN[x],ptt_bit); 
0C05:  MOVLB  02
0C06:  MOVF   37,W
0C07:  MOVLP  00
0C08:  MOVLB  00
0C09:  CALL   036
0C0A:  MOVLP  08
0C0B:  MOVLB  02
0C0C:  MOVWF  47
0C0D:  MOVLW  00
0C0E:  BTFSC  46.1
0C0F:  MOVLW  01
0C10:  MOVWF  77
0C11:  MOVF   47,W
0C12:  MOVWF  48
0C13:  MOVF   77,W
0C14:  MOVWF  49
0C15:  MOVLW  01
0C16:  MOVWF  4B
0C17:  CLRF   4A
0C18:  MOVLB  00
0C19:  CALL   0F3
0C1A:  MOVLB  02
0C1B:  MOVF   47,W
0C1C:  MOVWF  48
0C1D:  CLRF   49
0C1E:  CLRF   4B
0C1F:  MOVLW  80
0C20:  MOVWF  4A
0C21:  MOVLB  00
0C22:  CALL   0F3
....................     if(ptt_bit) { 
0C23:  MOVLB  02
0C24:  BTFSS  46.1
0C25:  GOTO   42F
....................       PTT_s[x]='1'; 
0C26:  MOVLW  C1
0C27:  ADDWF  37,W
0C28:  MOVWF  04
0C29:  MOVLW  20
0C2A:  MOVWF  05
0C2B:  BTFSC  03.0
0C2C:  INCF   05,F
0C2D:  MOVLW  31
0C2E:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C2F:  BCF    03.0
0C30:  RLF    3A,F
....................   }  
0C31:  INCF   37,F
0C32:  GOTO   3CB
....................   if(!cor) { 
0C33:  MOVF   36,F
0C34:  BTFSS  03.2
0C35:  GOTO   43A
....................     CurrentCorPriority=0; 
0C36:  MOVLB  00
0C37:  CLRF   6E
....................   } else { 
0C38:  GOTO   46A
0C39:  MOVLB  02
....................     CurrentCorPriority=RXPriority[cor-1]; 
0C3A:  MOVLW  01
0C3B:  SUBWF  36,W
0C3C:  ADDLW  25
0C3D:  MOVWF  04
0C3E:  MOVLW  20
0C3F:  MOVWF  05
0C40:  BTFSC  03.0
0C41:  INCF   05,F
0C42:  MOVF   00,W
0C43:  MOVLB  00
0C44:  MOVWF  6E
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0C45:  MOVLB  02
0C46:  CLRF   38
0C47:  MOVF   38,W
0C48:  SUBLW  03
0C49:  BTFSS  03.0
0C4A:  GOTO   467
....................       pot_val=RX_GAIN[cor-1][pot]; 
0C4B:  MOVLW  01
0C4C:  SUBWF  36,W
0C4D:  MOVWF  77
0C4E:  RLF    77,F
0C4F:  RLF    77,F
0C50:  MOVLW  FC
0C51:  ANDWF  77,F
0C52:  MOVF   77,W
0C53:  ADDWF  38,W
0C54:  ADDLW  0C
0C55:  MOVWF  04
0C56:  MOVLW  20
0C57:  MOVWF  05
0C58:  BTFSC  03.0
0C59:  INCF   05,F
0C5A:  MOVF   00,W
0C5B:  MOVWF  39
....................       set_trimpot(pot,pot_val); 
0C5C:  MOVF   38,W
0C5D:  MOVWF  47
0C5E:  MOVF   39,W
0C5F:  MOVWF  48
0C60:  MOVLP  00
0C61:  MOVLB  00
0C62:  CALL   78C
0C63:  MOVLP  08
....................     } 
0C64:  MOVLB  02
0C65:  INCF   38,F
0C66:  GOTO   447
....................     PROMPT_FLAG=1; 
0C67:  MOVLB  01
0C68:  BSF    5D.6
0C69:  MOVLB  00
....................   } 
....................   if(cor>0) { 
0C6A:  MOVLB  02
0C6B:  MOVF   36,F
0C6C:  BTFSC  03.2
0C6D:  GOTO   478
....................     COR_s[cor-1]='1'; 
0C6E:  MOVLW  01
0C6F:  SUBWF  36,W
0C70:  ADDLW  BC
0C71:  MOVWF  04
0C72:  MOVLW  20
0C73:  MOVWF  05
0C74:  BTFSC  03.0
0C75:  INCF   05,F
0C76:  MOVLW  31
0C77:  MOVWF  00
....................   } 
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0C78:  MOVLW  20
0C79:  MOVLB  01
0C7A:  MOVWF  64
0C7B:  MOVLW  76
0C7C:  MOVWF  63
0C7D:  MOVLW  EF
0C7E:  MOVLB  03
0C7F:  MOVWF  11
0C80:  MOVLW  03
0C81:  MOVWF  12
0C82:  BCF    03.0
0C83:  MOVLW  04
0C84:  MOVLB  02
0C85:  MOVWF  52
0C86:  MOVLB  00
0C87:  CALL   124
0C88:  MOVLW  20
0C89:  MOVWF  05
0C8A:  MOVLW  BC
0C8B:  MOVWF  04
0C8C:  CALL   177
0C8D:  MOVLW  F2
0C8E:  MOVLB  03
0C8F:  MOVWF  11
0C90:  MOVLW  03
0C91:  MOVWF  12
0C92:  BCF    03.0
0C93:  MOVLW  05
0C94:  MOVLB  02
0C95:  MOVWF  52
0C96:  MOVLB  00
0C97:  CALL   124
0C98:  MOVLW  20
0C99:  MOVWF  05
0C9A:  MOVLW  C1
0C9B:  MOVWF  04
0C9C:  CALL   177
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0C9D:  MOVLW  01
0C9E:  MOVLB  02
0C9F:  MOVWF  52
0CA0:  MOVLW  20
0CA1:  MOVWF  54
0CA2:  MOVLW  76
0CA3:  MOVWF  53
0CA4:  MOVLB  00
0CA5:  CALL   18C
....................   delay_ms(50); 
0CA6:  MOVLW  32
0CA7:  MOVLB  02
0CA8:  MOVWF  52
0CA9:  MOVLB  00
0CAA:  CALL   000
....................   pot_values_to_lcd(); 
0CAB:  CALL   271
.................... }// }}} 
0CAC:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1D03:  MOVF   20,W
1D04:  SUBLW  0A
1D05:  BTFSS  03.0
1D06:  GOTO   521
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1D07:  MOVLW  64
1D08:  ADDWF  20,W
1D09:  MOVWF  04
1D0A:  MOVLW  20
1D0B:  MOVWF  05
1D0C:  BTFSC  03.0
1D0D:  INCF   05,F
1D0E:  BTFSS  00.4
1D0F:  GOTO   51F
1D10:  MOVLW  64
1D11:  ADDWF  20,W
1D12:  MOVWF  04
1D13:  MOVLW  20
1D14:  MOVWF  05
1D15:  BTFSC  03.0
1D16:  INCF   05,F
1D17:  MOVF   00,W
1D18:  ANDLW  0F
1D19:  SUBLW  0C
1D1A:  BTFSC  03.2
1D1B:  GOTO   51F
....................       strobe=1; 
1D1C:  MOVLW  01
1D1D:  MOVWF  21
....................      } else { 
1D1E:  GOTO   520
....................       strobe = 0; 
1D1F:  CLRF   21
....................     }  
....................   } else { 
1D20:  GOTO   522
....................     strobe=0; 
1D21:  CLRF   21
....................   } 
....................   return(strobe); 
1D22:  MOVF   21,W
1D23:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
1C7A:  MOVLB  02
1C7B:  MOVF   20,W
1C7C:  SUBWF  21,W
1C7D:  BTFSS  03.0
1C7E:  GOTO   4A4
1C7F:  MOVF   20,W
1C80:  SUBLW  09
1C81:  BTFSS  03.0
1C82:  GOTO   4A4
....................     valid=1; 
1C83:  BSF    24.0
....................     for(x=a;x<=b;x++) { 
1C84:  MOVF   20,W
1C85:  MOVWF  23
1C86:  MOVF   23,W
1C87:  SUBWF  21,W
1C88:  BTFSS  03.0
1C89:  GOTO   4A3
....................       key=(int)DTMF_ARRAY[x].Key; 
1C8A:  MOVLW  64
1C8B:  ADDWF  23,W
1C8C:  MOVWF  04
1C8D:  MOVLW  20
1C8E:  MOVWF  05
1C8F:  BTFSC  03.0
1C90:  INCF   05,F
1C91:  MOVF   00,W
1C92:  ANDLW  0F
1C93:  MOVWF  22
....................       if(! DTMF_ARRAY[x].Strobe ) { 
1C94:  MOVLW  64
1C95:  ADDWF  23,W
1C96:  MOVWF  04
1C97:  MOVLW  20
1C98:  MOVWF  05
1C99:  BTFSC  03.0
1C9A:  INCF   05,F
1C9B:  BTFSS  00.4
....................         valid=0; 
1C9C:  BCF    24.0
....................       } 
....................      if(key==dp) { 
1C9D:  MOVF   22,W
1C9E:  SUBLW  0C
1C9F:  BTFSC  03.2
....................         valid=0; 
1CA0:  BCF    24.0
....................       } 
....................     } 
1CA1:  INCF   23,F
1CA2:  GOTO   486
....................   } else { 
1CA3:  GOTO   4A5
....................     valid=0; 
1CA4:  BCF    24.0
....................   } 
....................   return(valid); 
1CA5:  MOVLW  00
1CA6:  BTFSC  24.0
1CA7:  MOVLW  01
1CA8:  MOVWF  78
.................... } // }}} 
1CA9:  MOVLB  00
1CAA:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   unsigned site_id; 
....................   unsigned digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 01 : Link commands 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : -- UNUSED -- 
....................   // 11 : Morse send 
....................   // 12 : Send to I2C 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   command=0; 
1CAB:  CLRF   70
....................   if ( ValidKeyRange(0,3)) { 
1CAC:  MOVLB  02
1CAD:  CLRF   20
1CAE:  MOVLW  03
1CAF:  MOVWF  21
1CB0:  MOVLB  00
1CB1:  CALL   47A
1CB2:  MOVF   78,F
1CB3:  BTFSC  03.2
1CB4:  GOTO   56A
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1CB5:  MOVLB  01
1CB6:  MOVF   34,W
1CB7:  ANDLW  0F
1CB8:  MOVLB  02
1CB9:  MOVWF  21
1CBA:  MOVWF  4B
1CBB:  MOVLW  0A
1CBC:  MOVWF  4C
1CBD:  MOVLP  08
1CBE:  MOVLB  00
1CBF:  CALL   690
1CC0:  MOVLP  18
1CC1:  MOVF   78,W
1CC2:  MOVLB  02
1CC3:  MOVWF  20
1CC4:  MOVLB  01
1CC5:  MOVF   35,W
1CC6:  ANDLW  0F
1CC7:  MOVLB  02
1CC8:  ADDWF  20,W
1CC9:  MOVLB  01
1CCA:  MOVWF  6E
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1CCB:  MOVF   36,W
1CCC:  ANDLW  0F
1CCD:  MOVLB  02
1CCE:  MOVWF  21
1CCF:  MOVWF  4B
1CD0:  MOVLW  0A
1CD1:  MOVWF  4C
1CD2:  MOVLP  08
1CD3:  MOVLB  00
1CD4:  CALL   690
1CD5:  MOVLP  18
1CD6:  MOVF   78,W
1CD7:  MOVLB  02
1CD8:  MOVWF  20
1CD9:  MOVLB  01
1CDA:  MOVF   37,W
1CDB:  ANDLW  0F
1CDC:  MOVLB  02
1CDD:  ADDWF  20,W
1CDE:  MOVWF  70
....................     if ( ValidKeyRange(4,5) ) { 
1CDF:  MOVLW  04
1CE0:  MOVWF  20
1CE1:  MOVLW  05
1CE2:  MOVWF  21
1CE3:  MOVLB  00
1CE4:  CALL   47A
1CE5:  MOVF   78,F
1CE6:  BTFSC  03.2
1CE7:  GOTO   545
....................       // Admin mode {{{ 
....................       argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1CE8:  MOVLB  01
1CE9:  MOVF   38,W
1CEA:  ANDLW  0F
1CEB:  MOVLB  02
1CEC:  MOVWF  21
1CED:  MOVWF  4B
1CEE:  MOVLW  0A
1CEF:  MOVWF  4C
1CF0:  MOVLP  08
1CF1:  MOVLB  00
1CF2:  CALL   690
1CF3:  MOVLP  18
1CF4:  MOVF   78,W
1CF5:  MOVLB  02
1CF6:  MOVWF  20
1CF7:  MOVLB  01
1CF8:  MOVF   39,W
1CF9:  ANDLW  0F
1CFA:  MOVLB  02
1CFB:  ADDWF  20,W
1CFC:  MOVWF  75
....................       digit=6; 
1CFD:  MOVLW  06
1CFE:  MOVLB  01
1CFF:  MOVWF  6F
....................       while(ValidKey(digit)) { 
1D00:  MOVF   6F,W
1D01:  MOVLB  02
1D02:  MOVWF  20
*
1D24:  MOVF   78,F
1D25:  BTFSC  03.2
1D26:  GOTO   543
....................        value = value * 10 + DTMF_ARRAY[digit].Key; 
1D27:  MOVF   76,W
1D28:  MOVWF  4B
1D29:  MOVLW  0A
1D2A:  MOVWF  4C
1D2B:  MOVLP  08
1D2C:  MOVLB  00
1D2D:  CALL   690
1D2E:  MOVLP  18
1D2F:  MOVF   78,W
1D30:  MOVLB  02
1D31:  MOVWF  20
1D32:  MOVLW  64
1D33:  MOVLB  01
1D34:  ADDWF  6F,W
1D35:  MOVWF  04
1D36:  MOVLW  20
1D37:  MOVWF  05
1D38:  BTFSC  03.0
1D39:  INCF   05,F
1D3A:  MOVF   00,W
1D3B:  ANDLW  0F
1D3C:  MOVLB  02
1D3D:  ADDWF  20,W
1D3E:  MOVWF  76
....................        digit++; 
1D3F:  MOVLB  01
1D40:  INCF   6F,F
....................       } 
1D41:  GOTO   500
1D42:  MOVLB  02
....................       // Admin mode }}} 
....................     } else { 
1D43:  GOTO   557
1D44:  MOVLB  00
....................       // User function {{{ 
....................       // Only 4 digits were entered.  
....................       // Use 'command' value as user function. 
....................       switch(command) { 
1D45:  MOVF   70,W
1D46:  XORLW  0A
1D47:  BTFSC  03.2
1D48:  GOTO   54D
1D49:  XORLW  01
1D4A:  BTFSC  03.2
1D4B:  GOTO   551
1D4C:  GOTO   554
....................         // Commands 10 (disable link) and 11 (enable link) 
....................         case(10): 
....................           argument = 0; 
1D4D:  CLRF   75
....................           value = 0x0E; 
1D4E:  MOVLW  0E
1D4F:  MOVWF  76
....................   	      break; 
1D50:  GOTO   554
....................         case(11): 
....................           argument = 0; 
1D51:  CLRF   75
....................           value = 0x0F; 
1D52:  MOVLW  0F
1D53:  MOVWF  76
....................    		    break; 
....................       } 
....................       // Override command 
....................       command=SET_REG; 
1D54:  MOVLW  02
1D55:  MOVWF  70
1D56:  MOVLB  02
....................       // User function }}} 
....................     } 
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1D57:  MOVF   70,W
1D58:  XORLW  04
1D59:  MOVLB  00
1D5A:  BTFSC  03.2
1D5B:  GOTO   55F
1D5C:  XORLW  01
1D5D:  BTFSS  03.2
1D5E:  GOTO   561
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1D5F:  MOVF   75,W
1D60:  MOVWF  76
....................         break; 
....................     } 
....................     if ( site_id == SiteID ) { 
1D61:  MOVF   63,W
1D62:  MOVLB  01
1D63:  SUBWF  6E,W
1D64:  BTFSS  03.2
1D65:  GOTO   56B
....................       execute_command(); 
1D66:  MOVLP  10
1D67:  MOVLB  00
1D68:  CALL   05A
1D69:  MOVLP  18
1D6A:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1D6B:  MOVF   34,W
1D6C:  ANDLW  0F
1D6D:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1D6E:  BTFSS  5D.7
1D6F:  GOTO   5A1
1D70:  MOVLB  02
1D71:  CLRF   20
1D72:  CLRF   21
1D73:  MOVLB  00
1D74:  CALL   47A
1D75:  MOVF   78,F
1D76:  BTFSS  03.2
1D77:  GOTO   57A
1D78:  MOVLB  01
1D79:  GOTO   5A1
....................     restart_wdt(); 
1D7A:  CLRWDT
....................     switch(command) { 
1D7B:  MOVF   70,W
1D7C:  XORLW  0E
1D7D:  BTFSC  03.2
1D7E:  GOTO   586
1D7F:  XORLW  01
1D80:  BTFSC  03.2
1D81:  GOTO   58E
1D82:  XORLW  05
1D83:  BTFSC  03.2
1D84:  GOTO   596
1D85:  GOTO   59D
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1D86:  MOVLW  01
1D87:  ADDWF  74,W
1D88:  ANDLW  03
1D89:  MOVWF  74
....................         pot_values_to_lcd(); 
1D8A:  MOVLP  08
1D8B:  CALL   271
1D8C:  MOVLP  18
....................         break; 
1D8D:  GOTO   59D
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1D8E:  MOVLW  FF
1D8F:  MOVLB  02
1D90:  MOVWF  37
1D91:  MOVLP  08
1D92:  MOVLB  00
1D93:  CALL   767
1D94:  MOVLP  18
....................         break; 
1D95:  GOTO   59D
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1D96:  MOVLW  01
1D97:  MOVLB  02
1D98:  MOVWF  37
1D99:  MOVLP  08
1D9A:  MOVLB  00
1D9B:  CALL   767
1D9C:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1D9D:  MOVLP  08
1D9E:  CALL   758
1D9F:  MOVLP  18
1DA0:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1DA1:  BSF    5D.5
.................... } // }}} 
1DA2:  MOVLP  18
1DA3:  MOVLB  00
1DA4:  GOTO   7BB (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask,cor_index; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
1739:  MOVLW  01
173A:  MOVLB  01
173B:  MOVWF  6E
....................   do_update_ptt=0; 
173C:  MOVLB  02
173D:  CLRF   22
....................   // Allow emulated COR[4] for DTMF control (No audio feed-thru) 
....................   cor_in = COR_IN | (COR_EMUL&0x1F); 
173E:  MOVLB  00
173F:  MOVF   69,W
1740:  ANDLW  1F
1741:  IORWF  5F,W
1742:  MOVLB  02
1743:  MOVWF  21
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in&CurrentCorMask) ) { 
1744:  MOVLB  00
1745:  MOVF   6E,F
1746:  BTFSC  03.2
1747:  GOTO   75F
1748:  MOVLB  02
1749:  MOVF   21,W
174A:  MOVLB  00
174B:  ANDWF  6C,W
174C:  BTFSS  03.2
174D:  GOTO   75F
....................     CurrentCorPriority=0; 
174E:  CLRF   6E
....................     CurrentCorMask=0; 
174F:  CLRF   6C
....................     do_update_ptt=1; 
1750:  MOVLW  01
1751:  MOVLB  02
1752:  MOVWF  22
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
1753:  MOVF   21,W
1754:  MOVLB  00
1755:  ANDWF  60,W
1756:  ANDWF  61,W
1757:  BTFSS  03.2
1758:  GOTO   75F
....................       COR_DROP_FLAG=1; 
1759:  BSF    72.7
....................       if ( Tail ) { 
175A:  MOVF   65,F
175B:  BTFSC  03.2
175C:  GOTO   75F
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
175D:  MOVF   65,W
175E:  MOVWF  6A
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
175F:  MOVLB  01
1760:  CLRF   6F
....................   for(x=0;x<4;x++) { 
1761:  MOVLB  02
1762:  CLRF   23
1763:  MOVF   23,W
1764:  SUBLW  03
1765:  BTFSS  03.0
1766:  GOTO   7AD
....................     if ( cor_in & cor_mask ) { 
1767:  MOVF   21,W
1768:  MOVLB  01
1769:  ANDWF  6E,W
176A:  BTFSC  03.2
176B:  GOTO   7A8
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
176C:  MOVLB  00
176D:  MOVF   60,W
176E:  ANDWF  61,W
176F:  MOVLB  01
1770:  ANDWF  6E,W
1771:  BTFSC  03.2
1772:  GOTO   77F
....................         rx_priority=RXPriority[x]; 
1773:  MOVLW  25
1774:  MOVLB  02
1775:  ADDWF  23,W
1776:  MOVWF  04
1777:  MOVLW  20
1778:  MOVWF  05
1779:  BTFSC  03.0
177A:  INCF   05,F
177B:  MOVF   00,W
177C:  MOVWF  20
....................       } else { 
177D:  GOTO   782
177E:  MOVLB  01
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
177F:  MOVLW  01
1780:  MOVLB  02
1781:  MOVWF  20
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1782:  MOVF   20,W
1783:  MOVLB  00
1784:  SUBWF  6E,W
1785:  BTFSC  03.0
1786:  GOTO   7A7
....................         if ( ! CurrentCorPriority ) { 
1787:  MOVF   6E,F
1788:  BTFSS  03.2
1789:  GOTO   78E
....................           CurrentCorPriority = rx_priority; 
178A:  MOVLB  02
178B:  MOVF   20,W
178C:  MOVLB  00
178D:  MOVWF  6E
....................         } 
....................         cor_index=x+1; 
178E:  MOVLW  01
178F:  MOVLB  02
1790:  ADDWF  23,W
1791:  MOVLB  01
1792:  MOVWF  6F
....................         do_update_ptt=1; 
1793:  MOVLW  01
1794:  MOVLB  02
1795:  MOVWF  22
....................         TOT_SecondCounter= 60 * TOT_Min; 
1796:  MOVLW  3C
1797:  MOVWF  4B
1798:  MOVLB  00
1799:  MOVF   66,W
179A:  MOVLB  02
179B:  MOVWF  4C
179C:  MOVLP  08
179D:  MOVLB  00
179E:  CALL   690
179F:  MOVLP  10
17A0:  MOVLB  01
17A1:  CLRF   61
17A2:  MOVF   78,W
17A3:  MOVWF  60
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
17A4:  MOVF   6E,W
17A5:  MOVLB  00
17A6:  MOVWF  6F
17A7:  MOVLB  01
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
17A8:  BCF    03.0
17A9:  RLF    6E,F
....................   } 
17AA:  MOVLB  02
17AB:  INCF   23,F
17AC:  GOTO   763
....................   if ( do_update_ptt ) { 
17AD:  MOVF   22,F
17AE:  BTFSC  03.2
17AF:  GOTO   7BB
....................     update_ptt(cor_index); 
17B0:  MOVLB  01
17B1:  MOVF   6F,W
17B2:  MOVLB  02
17B3:  MOVWF  36
17B4:  MOVLP  08
17B5:  MOVLB  00
17B6:  CALL   361
17B7:  MOVLP  10
....................     PROMPT_FLAG=1; 
17B8:  MOVLB  01
17B9:  BSF    5D.6
17BA:  MOVLB  02
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
17BB:  MOVF   21,F
17BC:  BTFSS  03.2
17BD:  GOTO   7C3
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
17BE:  MOVLB  01
17BF:  BSF    5D.5
....................     COR_IN_EFFECTIVE=0; 
17C0:  MOVLB  00
17C1:  CLRF   6F
17C2:  MOVLB  02
....................   } 
....................   // Refresh Link Time-out timer when COR is received. 
....................   // Any COR value refreshes teh link TOT timer. 
....................   if ( Link_TOT != 0 && (cor_in)!=0 ) { 
17C3:  MOVLB  00
17C4:  MOVF   67,F
17C5:  BTFSC  03.2
17C6:  GOTO   7D0
17C7:  MOVLB  02
17C8:  MOVF   21,F
17C9:  BTFSS  03.2
17CA:  GOTO   7CD
17CB:  MOVLB  00
17CC:  GOTO   7D0
....................     LinkDurationTimer = Link_TOT; 
17CD:  MOVLB  00
17CE:  MOVF   67,W
17CF:  MOVWF  68
....................   } 
.................... } // }}} 
17D0:  MOVLP  18
17D1:  GOTO   717 (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
17D2:  MOVLB  01
17D3:  CLRF   6E
17D4:  MOVF   6E,W
17D5:  SUBLW  09
17D6:  BTFSS  03.0
17D7:  GOTO   7E2
....................     DTMF_ARRAY[x]=(sDTMF)0; 
17D8:  MOVLW  64
17D9:  ADDWF  6E,W
17DA:  MOVWF  04
17DB:  MOVLW  20
17DC:  MOVWF  05
17DD:  BTFSC  03.0
17DE:  INCF   05,F
17DF:  CLRF   00
....................   } 
17E0:  INCF   6E,F
17E1:  GOTO   7D4
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
17E2:  MOVLW  20
17E3:  MOVWF  3F
17E4:  MOVLW  64
17E5:  MOVWF  3E
.................... } // }}} 
17E6:  MOVLP  18
17E7:  MOVLB  00
17E8:  GOTO   7C3 (RETURN)
.................... void header (void) { // {{{ 
.................... //  putc(ESC); 
.................... //  printf("[47;34m\n\rRadio Repeater Controller - "); 
.................... //  putc(ESC); 
.................... //  printf("[47;31mVE2LRS"); 
.................... //  putc(ESC); 
.................... //  printf("[47;34m (C) 2013\n\n\r"); 
.................... //  putc(ESC); 
.................... //  printf("[40;37m"); 
.................... } // }}} 
*
0003:  RETURN
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   header(); 
*
12BA:  MOVLP  00
12BB:  CALL   003
12BC:  MOVLP  10
....................   dtmf_in=dtmf_read(CONTROL_REG); 
12BD:  MOVLW  01
12BE:  MOVLB  02
12BF:  MOVWF  43
12C0:  MOVLP  00
12C1:  MOVLB  00
12C2:  CALL   69B
12C3:  MOVLP  10
12C4:  MOVF   78,W
12C5:  MOVLB  02
12C6:  MOVWF  3B
....................   aux_in = 0; 
12C7:  CLRF   3C
....................   for(x=0;x<RegMapNum;x++) { 
12C8:  CLRF   35
12C9:  CLRF   34
12CA:  MOVF   35,F
12CB:  BTFSS  03.2
12CC:  GOTO   3D1
12CD:  MOVF   34,W
12CE:  SUBLW  38
12CF:  BTFSS  03.0
12D0:  GOTO   3D1
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
12D1:  MOVLW  01
12D2:  MOVWF  7A
12D3:  MOVLW  8F
12D4:  MOVWF  43
12D5:  MOVF   7A,W
12D6:  MOVWF  44
12D7:  MOVF   35,W
12D8:  MOVWF  46
12D9:  MOVF   34,W
12DA:  MOVWF  45
12DB:  CLRF   48
12DC:  MOVLW  06
12DD:  MOVWF  47
12DE:  MOVLP  08
12DF:  MOVLB  00
12E0:  CALL   718
12E1:  MOVLP  10
12E2:  MOVF   78,W
12E3:  MOVLB  02
12E4:  ADDWF  43,W
12E5:  MOVWF  37
12E6:  MOVF   79,W
12E7:  ADDWFC 44,W
12E8:  MOVWF  38
....................     romstrcpy(rname,cPtr); 
12E9:  MOVLW  20
12EA:  MOVWF  44
12EB:  MOVLW  BD
12EC:  MOVWF  43
12ED:  MOVF   38,W
12EE:  MOVWF  46
12EF:  MOVF   37,W
12F0:  MOVWF  45
12F1:  MOVLP  08
12F2:  MOVLB  00
12F3:  CALL   72F
12F4:  MOVLP  10
....................   regPtr=RegMap[x].reg_ptr; 
12F5:  MOVLB  02
12F6:  RLF    34,W
12F7:  MOVWF  43
12F8:  RLF    35,W
12F9:  MOVWF  44
12FA:  RLF    43,F
12FB:  RLF    44,F
12FC:  MOVLW  FC
12FD:  ANDWF  43,F
12FE:  MOVF   44,W
12FF:  MOVWF  7A
1300:  MOVF   43,W
1301:  MOVWF  45
1302:  INCF   43,W
1303:  MOVLP  00
1304:  MOVLB  00
1305:  CALL   043
1306:  MOVLP  10
1307:  MOVWF  7A
1308:  MOVLB  02
1309:  MOVF   45,W
130A:  MOVLP  00
130B:  MOVLB  00
130C:  CALL   043
130D:  MOVLP  10
130E:  MOVLB  02
130F:  MOVWF  39
1310:  MOVF   7A,W
1311:  MOVWF  3A
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
1312:  MOVF   3A,W
1313:  MOVWF  7A
1314:  MOVF   39,W
1315:  MOVWF  04
1316:  MOVF   7A,W
1317:  MOVWF  05
1318:  MOVF   00,W
1319:  MOVWF  43
131A:  MOVLW  5B
131B:  CLRWDT
131C:  MOVLB  00
131D:  BTFSC  11.4
131E:  GOTO   321
131F:  MOVLB  02
1320:  GOTO   31B
1321:  MOVLB  03
1322:  MOVWF  1A
1323:  MOVLW  0B
1324:  MOVWF  04
1325:  MOVLB  02
1326:  MOVF   35,W
1327:  MOVWF  45
1328:  MOVF   34,W
1329:  MOVWF  44
*
1387:  MOVLW  5D
1388:  CLRWDT
1389:  MOVLB  00
138A:  BTFSC  11.4
138B:  GOTO   38E
138C:  MOVLB  02
138D:  GOTO   388
138E:  MOVLB  03
138F:  MOVWF  1A
1390:  MOVLW  20
1391:  CLRWDT
1392:  MOVLB  00
1393:  BTFSC  11.4
1394:  GOTO   397
1395:  MOVLB  03
1396:  GOTO   391
1397:  MOVLB  03
1398:  MOVWF  1A
1399:  MOVLW  20
139A:  MOVWF  05
139B:  MOVLW  BD
139C:  MOVWF  04
139D:  MOVLP  08
139E:  MOVLB  00
139F:  CALL   257
13A0:  MOVLP  10
13A1:  MOVLW  20
13A2:  CLRWDT
13A3:  BTFSS  11.4
13A4:  GOTO   3A2
13A5:  MOVLB  03
13A6:  MOVWF  1A
13A7:  MOVLB  02
13A8:  MOVF   43,W
13A9:  MOVWF  58
13AA:  MOVLW  1B
13AB:  MOVWF  59
13AC:  MOVLP  00
13AD:  MOVLB  00
13AE:  CALL   73D
13AF:  MOVLP  10
13B0:  MOVLW  09
13B1:  CLRWDT
13B2:  BTFSS  11.4
13B3:  GOTO   3B1
13B4:  MOVLB  03
13B5:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
13B6:  MOVLB  02
13B7:  MOVF   34,W
13B8:  ANDLW  03
13B9:  MOVWF  43
13BA:  CLRF   44
13BB:  MOVF   43,W
13BC:  SUBLW  03
13BD:  BTFSS  03.2
13BE:  GOTO   3CC
13BF:  MOVF   44,F
13C0:  BTFSS  03.2
13C1:  GOTO   3CC
....................       putc('\n'); 
13C2:  MOVLW  0A
13C3:  MOVLP  00
13C4:  MOVLB  00
13C5:  CALL   2E4
13C6:  MOVLP  10
....................       putc('\r'); 
13C7:  MOVLW  0D
13C8:  MOVLP  00
13C9:  CALL   2E4
13CA:  MOVLP  10
13CB:  MOVLB  02
....................     } 
....................     restart_wdt(); 
13CC:  CLRWDT
....................   } 
13CD:  INCF   34,F
13CE:  BTFSC  03.2
13CF:  INCF   35,F
13D0:  GOTO   2CA
....................   for(y=0;y<3;y++) { 
13D1:  CLRF   36
13D2:  MOVF   36,W
13D3:  SUBLW  02
13D4:  BTFSS  03.0
13D5:  GOTO   3EC
....................     if(AuxInSW[y]==1) { 
13D6:  MOVLW  1F
13D7:  ADDWF  36,W
13D8:  MOVWF  04
13D9:  MOVLW  20
13DA:  MOVWF  05
13DB:  BTFSC  03.0
13DC:  INCF   05,F
13DD:  DECFSZ 00,W
13DE:  GOTO   3EA
....................       aux_in += 2<<y; 
13DF:  MOVLW  02
13E0:  MOVWF  77
13E1:  MOVF   36,W
13E2:  MOVWF  78
13E3:  BTFSC  03.2
13E4:  GOTO   3E8
13E5:  LSLF   77,F
13E6:  DECFSZ 78,F
13E7:  GOTO   3E5
13E8:  MOVF   77,W
13E9:  ADDWF  3C,F
....................     } 
....................   } 
13EA:  INCF   36,F
13EB:  GOTO   3D2
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u",COR_IN,COR_EMUL,aux_in); 
13EC:  MOVLW  F6
13ED:  MOVLB  03
13EE:  MOVWF  11
13EF:  MOVLW  03
13F0:  MOVWF  12
13F1:  BCF    03.0
13F2:  MOVLW  07
13F3:  MOVLB  02
13F4:  MOVWF  58
13F5:  MOVLP  00
13F6:  MOVLB  00
13F7:  CALL   6C9
13F8:  MOVLP  10
13F9:  MOVF   5F,W
13FA:  MOVLB  02
13FB:  MOVWF  58
13FC:  MOVLW  1B
13FD:  MOVWF  59
13FE:  MOVLP  00
13FF:  MOVLB  00
1400:  CALL   73D
1401:  MOVLP  10
1402:  MOVLW  FA
1403:  MOVLB  03
1404:  MOVWF  11
1405:  MOVLW  03
1406:  MOVWF  12
1407:  BSF    03.0
1408:  MOVLW  07
1409:  MOVLB  02
140A:  MOVWF  58
140B:  MOVLP  00
140C:  MOVLB  00
140D:  CALL   6C9
140E:  MOVLP  10
140F:  MOVF   69,W
1410:  MOVLB  02
1411:  MOVWF  58
1412:  MOVLW  1B
1413:  MOVWF  59
1414:  MOVLP  00
1415:  MOVLB  00
1416:  CALL   73D
1417:  MOVLP  10
1418:  MOVLW  FF
1419:  MOVLB  03
141A:  MOVWF  11
141B:  MOVLW  03
141C:  MOVWF  12
141D:  BCF    03.0
141E:  MOVLW  09
141F:  MOVLB  02
1420:  MOVWF  58
1421:  MOVLP  00
1422:  MOVLB  00
1423:  CALL   6C9
1424:  MOVLP  10
1425:  MOVLB  02
1426:  MOVF   3C,W
1427:  MOVWF  58
1428:  MOVLW  1B
1429:  MOVWF  59
142A:  MOVLP  00
142B:  MOVLB  00
142C:  CALL   73D
142D:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
142E:  MOVLW  05
142F:  MOVLB  03
1430:  MOVWF  11
1431:  MOVLW  04
1432:  MOVWF  12
1433:  BCF    03.0
1434:  MOVLW  10
1435:  MOVLB  02
1436:  MOVWF  58
1437:  MOVLP  00
1438:  MOVLB  00
1439:  CALL   6C9
143A:  MOVLP  10
143B:  MOVLB  02
143C:  MOVF   3B,W
143D:  MOVWF  58
143E:  MOVLW  1B
143F:  MOVWF  59
1440:  MOVLP  00
1441:  MOVLB  00
1442:  CALL   73D
1443:  MOVLP  10
1444:  MOVLW  0A
1445:  CLRWDT
1446:  BTFSS  11.4
1447:  GOTO   445
1448:  MOVLB  03
1449:  MOVWF  1A
144A:  MOVLW  0D
144B:  CLRWDT
144C:  MOVLB  00
144D:  BTFSC  11.4
144E:  GOTO   451
144F:  MOVLB  03
1450:  GOTO   44B
1451:  MOVLB  03
1452:  MOVWF  1A
....................   pot_values_to_lcd(); 
1453:  MOVLP  08
1454:  MOVLB  00
1455:  CALL   271
1456:  MOVLP  10
....................   PROMPT_FLAG=1; 
1457:  MOVLB  01
1458:  BSF    5D.6
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0A71:  MOVLW  20
0A72:  MOVLB  02
0A73:  MOVWF  4A
0A74:  MOVWF  4B
0A75:  MOVWF  4C
0A76:  MOVWF  4D
....................   unsigned pval[4]={0,0,0,0}; 
0A77:  CLRF   4E
0A78:  CLRF   4F
0A79:  CLRF   50
0A7A:  CLRF   51
....................   delay_ms(40); 
0A7B:  MOVLW  28
0A7C:  MOVWF  52
0A7D:  MOVLB  00
0A7E:  CALL   000
....................   i2c_start(); 
0A7F:  MOVLB  04
0A80:  BSF    16.0
0A81:  BTFSC  16.0
0A82:  GOTO   281
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0A83:  MOVLW  51
0A84:  MOVLB  02
0A85:  MOVWF  58
0A86:  MOVLP  00
0A87:  MOVLB  00
0A88:  CALL   6B4
0A89:  MOVLP  08
0A8A:  MOVF   78,W
0A8B:  MOVLB  02
0A8C:  BCF    49.1
0A8D:  BTFSC  78.0
0A8E:  BSF    49.1
....................   for(x=0;x<4;x++) { 
0A8F:  CLRF   47
0A90:  MOVF   47,W
0A91:  SUBLW  03
0A92:  BTFSS  03.0
0A93:  GOTO   2CD
....................     if(x==3) { 
0A94:  MOVF   47,W
0A95:  SUBLW  03
0A96:  BTFSS  03.2
0A97:  GOTO   29A
....................       ack=0; 
0A98:  BCF    49.0
....................     } else { 
0A99:  GOTO   29B
....................       ack=1; 
0A9A:  BSF    49.0
....................     } 
....................     pot_val=i2c_read(ack); 
0A9B:  MOVLW  00
0A9C:  BTFSC  49.0
0A9D:  MOVLW  01
0A9E:  MOVWF  52
0A9F:  MOVF   52,W
0AA0:  MOVWF  77
*
0AAF:  MOVF   78,W
0AB0:  MOVLB  02
0AB1:  MOVWF  48
....................     pot_val=pot_val&0x3F; 
0AB2:  MOVLW  3F
0AB3:  ANDWF  48,F
....................     pval[x]=pot_val; 
0AB4:  MOVLW  CE
0AB5:  ADDWF  47,W
0AB6:  MOVWF  04
0AB7:  MOVLW  20
0AB8:  MOVWF  05
0AB9:  BTFSC  03.0
0ABA:  INCF   05,F
0ABB:  MOVF   48,W
0ABC:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0ABD:  MOVF   74,W
0ABE:  ANDLW  03
0ABF:  SUBWF  47,W
0AC0:  BTFSS  03.2
0AC1:  GOTO   2CB
....................       c[x] = '*'; 
0AC2:  MOVLW  CA
0AC3:  ADDWF  47,W
0AC4:  MOVWF  04
0AC5:  MOVLW  20
0AC6:  MOVWF  05
0AC7:  BTFSC  03.0
0AC8:  INCF   05,F
0AC9:  MOVLW  2A
0ACA:  MOVWF  00
....................     } 
....................   } 
0ACB:  INCF   47,F
0ACC:  GOTO   290
....................   i2c_stop(); 
0ACD:  MOVLB  04
0ACE:  BSF    16.2
0ACF:  BTFSC  16.2
0AD0:  GOTO   2CF
....................   delay_ms(50); 
0AD1:  MOVLW  32
0AD2:  MOVLB  02
0AD3:  MOVWF  52
0AD4:  MOVLB  00
0AD5:  CALL   000
....................   if ( ack_in!=0 ) { 
0AD6:  MOVLB  02
0AD7:  BTFSS  49.1
0AD8:  GOTO   2F4
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0AD9:  MOVLW  00
0ADA:  BTFSC  49.0
0ADB:  MOVLW  01
0ADC:  MOVWF  52
0ADD:  MOVLW  10
0ADE:  MOVLB  03
0ADF:  MOVWF  11
0AE0:  MOVLW  04
0AE1:  MOVWF  12
0AE2:  BCF    03.0
0AE3:  MOVLW  25
0AE4:  MOVLB  02
0AE5:  MOVWF  58
0AE6:  MOVLP  00
0AE7:  MOVLB  00
0AE8:  CALL   6C9
0AE9:  MOVLP  08
0AEA:  MOVLB  02
0AEB:  MOVF   52,W
0AEC:  MOVWF  58
0AED:  MOVLW  1B
0AEE:  MOVWF  59
0AEF:  MOVLP  00
0AF0:  MOVLB  00
0AF1:  CALL   73D
0AF2:  MOVLP  08
0AF3:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0AF4:  MOVLW  20
0AF5:  MOVLB  01
0AF6:  MOVWF  64
0AF7:  MOVLW  76
0AF8:  MOVWF  63
0AF9:  MOVLW  24
0AFA:  MOVLB  03
0AFB:  MOVWF  11
0AFC:  MOVLW  04
0AFD:  MOVWF  12
0AFE:  BCF    03.0
0AFF:  MOVLW  04
0B00:  MOVLB  02
0B01:  MOVWF  52
0B02:  MOVLB  00
0B03:  CALL   124
0B04:  MOVLB  02
0B05:  MOVF   4A,W
0B06:  MOVWF  58
0B07:  MOVLB  00
0B08:  CALL   115
0B09:  MOVLB  02
0B0A:  MOVF   4E,W
0B0B:  MOVWF  52
0B0C:  MOVLW  18
0B0D:  MOVWF  53
0B0E:  MOVLB  00
0B0F:  CALL   1F0
0B10:  MOVLW  20
0B11:  MOVLB  02
0B12:  MOVWF  58
0B13:  MOVLB  00
0B14:  CALL   115
0B15:  MOVLB  02
0B16:  MOVF   4B,W
0B17:  MOVWF  58
0B18:  MOVLB  00
0B19:  CALL   115
0B1A:  MOVLB  02
0B1B:  MOVF   4F,W
0B1C:  MOVWF  52
0B1D:  MOVLW  18
0B1E:  MOVWF  53
0B1F:  MOVLB  00
0B20:  CALL   1F0
0B21:  MOVLW  20
0B22:  MOVLB  02
0B23:  MOVWF  58
0B24:  MOVLB  00
0B25:  CALL   115
0B26:  MOVLB  02
0B27:  MOVF   4C,W
0B28:  MOVWF  58
0B29:  MOVLB  00
0B2A:  CALL   115
0B2B:  MOVLB  02
0B2C:  MOVF   50,W
0B2D:  MOVWF  52
0B2E:  MOVLW  18
0B2F:  MOVWF  53
0B30:  MOVLB  00
0B31:  CALL   1F0
0B32:  MOVLW  20
0B33:  MOVLB  02
0B34:  MOVWF  58
0B35:  MOVLB  00
0B36:  CALL   115
0B37:  MOVLB  02
0B38:  MOVF   4D,W
0B39:  MOVWF  58
0B3A:  MOVLB  00
0B3B:  CALL   115
0B3C:  MOVLB  02
0B3D:  MOVF   51,W
0B3E:  MOVWF  52
0B3F:  MOVLW  18
0B40:  MOVWF  53
0B41:  MOVLB  00
0B42:  CALL   1F0
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0B43:  MOVLB  02
0B44:  CLRF   52
0B45:  MOVLW  20
0B46:  MOVWF  54
0B47:  MOVLW  76
0B48:  MOVWF  53
0B49:  MOVLB  00
0B4A:  CALL   18C
....................   printf("\n\r%s",LCD_str); 
0B4B:  MOVLW  0A
0B4C:  CLRWDT
0B4D:  BTFSS  11.4
0B4E:  GOTO   34C
0B4F:  MOVLB  03
0B50:  MOVWF  1A
0B51:  MOVLW  0D
0B52:  CLRWDT
0B53:  MOVLB  00
0B54:  BTFSC  11.4
0B55:  GOTO   358
0B56:  MOVLB  03
0B57:  GOTO   352
0B58:  MOVLB  03
0B59:  MOVWF  1A
0B5A:  MOVLW  20
0B5B:  MOVWF  05
0B5C:  MOVLW  76
0B5D:  MOVWF  04
0B5E:  MOVLB  00
0B5F:  CALL   257
....................  
.................... } // }}} 
0B60:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
1000:  MOVLB  01
1001:  BTFSS  5D.7
1002:  GOTO   00E
....................     printf("\n\n\rADMIN> "); 
1003:  MOVLW  30
1004:  MOVLB  03
1005:  MOVWF  11
1006:  MOVLW  04
1007:  MOVWF  12
1008:  MOVLP  00
1009:  MOVLB  00
100A:  CALL   4D8
100B:  MOVLP  10
....................   } else { 
100C:  GOTO   017
100D:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
100E:  MOVLW  36
100F:  MOVLB  03
1010:  MOVWF  11
1011:  MOVLW  04
1012:  MOVWF  12
1013:  MOVLP  00
1014:  MOVLB  00
1015:  CALL   4D8
1016:  MOVLP  10
....................   } 
.................... } // }}} 
1017:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
04BE:  MOVLW  10
04BF:  MOVLB  01
04C0:  MOVWF  6F
....................   for (x=0;x<char_num;x++) { 
04C1:  CLRF   6E
04C2:  MOVF   6F,W
04C3:  SUBWF  6E,W
04C4:  BTFSC  03.0
04C5:  GOTO   4D0
....................     sBuffer[x]='\0'; 
04C6:  MOVLW  50
04C7:  ADDWF  6E,W
04C8:  MOVWF  04
04C9:  MOVLW  20
04CA:  MOVWF  05
04CB:  BTFSC  03.0
04CC:  INCF   05,F
04CD:  CLRF   00
....................   } 
04CE:  INCF   6E,F
04CF:  GOTO   4C2
....................   sBufferIndex=0; 
04D0:  CLRF   71
....................   sBufferFlag=0;   
04D1:  BCF    72.0
....................   argument=-1; 
04D2:  MOVLW  FF
04D3:  MOVWF  75
....................   argument_name[0]='\0'; 
04D4:  CLRF   40
....................   command=0; 
04D5:  CLRF   70
.................... } // }}} 
04D6:  MOVLB  00
04D7:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
065B:  MOVLW  00
065C:  MOVLB  01
065D:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
065E:  MOVLB  02
065F:  BCF    4D.0
0660:  MOVF   4B,W
0661:  ANDLW  0F
0662:  ANDLW  01
0663:  BTFSS  03.2
0664:  BSF    4D.0
....................   output_bit(DTMF_D0,dbit); 
0665:  BTFSC  4D.0
0666:  GOTO   669
0667:  BCF    0F.0
0668:  GOTO   66A
0669:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
066A:  BCF    4D.0
066B:  MOVF   4B,W
066C:  ANDLW  0F
066D:  ANDLW  02
066E:  BTFSS  03.2
066F:  BSF    4D.0
....................   output_bit(DTMF_D1,dbit); 
0670:  BTFSC  4D.0
0671:  GOTO   674
0672:  BCF    0F.1
0673:  GOTO   675
0674:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
0675:  BCF    4D.0
0676:  MOVF   4B,W
0677:  ANDLW  0F
0678:  ANDLW  04
0679:  BTFSS  03.2
067A:  BSF    4D.0
....................   output_bit(DTMF_D2,dbit); 
067B:  BTFSC  4D.0
067C:  GOTO   67F
067D:  BCF    0F.2
067E:  GOTO   680
067F:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
0680:  BCF    4D.0
0681:  MOVF   4B,W
0682:  ANDLW  0F
0683:  ANDLW  08
0684:  BTFSS  03.2
0685:  BSF    4D.0
....................   output_bit(DTMF_D3,dbit); 
0686:  BTFSC  4D.0
0687:  GOTO   68A
0688:  BCF    0F.3
0689:  GOTO   68B
068A:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
068B:  MOVF   4C,F
068C:  BTFSS  03.2
068D:  GOTO   690
068E:  BCF    0F.6
068F:  GOTO   691
0690:  BSF    0F.6
....................   delay_cycles(2); 
0691:  GOTO   692
....................   output_bit(DTMF_WEB,0); 
0692:  BCF    0F.5
....................   delay_cycles(2); 
0693:  GOTO   694
....................   output_bit(DTMF_WEB,1);   
0694:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
0695:  GOTO   696
....................   set_tris_d(0x0F); 
0696:  MOVLW  0F
0697:  MOVLB  01
0698:  MOVWF  0F
.................... } // }}} 
0699:  MOVLB  00
069A:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
069B:  MOVLW  0F
069C:  MOVLB  01
069D:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
069E:  MOVLB  02
069F:  MOVF   43,F
06A0:  BTFSS  03.2
06A1:  GOTO   6A4
06A2:  BCF    0F.6
06A3:  GOTO   6A5
06A4:  BSF    0F.6
....................   delay_cycles(1); 
06A5:  NOP
....................   output_bit(DTMF_REB,0); 
06A6:  BCF    0F.4
....................   delay_cycles(1); 
06A7:  NOP
....................   value=input_d(); 
06A8:  MOVLB  00
06A9:  MOVF   0F,W
06AA:  MOVLB  02
06AB:  MOVWF  44
....................   value&=0x0F; 
06AC:  MOVLW  0F
06AD:  ANDWF  44,F
....................   output_bit(DTMF_REB,1); 
06AE:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
06AF:  NOP
....................   return(value); 
06B0:  MOVF   44,W
06B1:  MOVWF  78
.................... } // }}} 
06B2:  MOVLB  00
06B3:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0CFB:  MOVLB  02
0CFC:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0CFD:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0CFE:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0CFF:  CLRF   4B
0D00:  MOVLW  01
0D01:  MOVWF  4C
0D02:  MOVLP  00
0D03:  MOVLB  00
0D04:  CALL   65B
0D05:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0D06:  MOVLB  02
0D07:  CLRF   4B
0D08:  MOVLW  01
0D09:  MOVWF  4C
0D0A:  MOVLP  00
0D0B:  MOVLB  00
0D0C:  CALL   65B
0D0D:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0D0E:  MOVLW  0C
0D0F:  MOVLB  02
0D10:  MOVWF  4B
0D11:  MOVLW  01
0D12:  MOVWF  4C
0D13:  MOVLP  00
0D14:  MOVLB  00
0D15:  CALL   65B
0D16:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0D17:  MOVLW  01
0D18:  MOVLB  02
0D19:  MOVWF  4B
0D1A:  MOVWF  4C
0D1B:  MOVLP  00
0D1C:  MOVLB  00
0D1D:  CALL   65B
0D1E:  MOVLP  08
....................     dtmf_read(CONTROL_REG); 
0D1F:  MOVLW  01
0D20:  MOVLB  02
0D21:  MOVWF  43
0D22:  MOVLP  00
0D23:  MOVLB  00
0D24:  CALL   69B
0D25:  MOVLP  08
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19EC:  MOVF   48,W
19ED:  MOVWF  4B
19EE:  CLRF   4C
19EF:  MOVLP  00
19F0:  MOVLB  00
19F1:  CALL   65B
19F2:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19F3:  MOVLW  0C
19F4:  MOVLB  02
19F5:  MOVWF  4B
19F6:  MOVLW  01
19F7:  MOVWF  4C
19F8:  MOVLP  00
19F9:  MOVLB  00
19FA:  CALL   65B
19FB:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
19FC:  MOVLW  01
19FD:  MOVLB  02
19FE:  MOVWF  4B
19FF:  MOVWF  4C
1A00:  MOVLP  00
1A01:  MOVLB  00
1A02:  CALL   65B
1A03:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A04:  MOVLW  05
1A05:  MOVLB  02
1A06:  MOVWF  4B
1A07:  MOVLW  01
1A08:  MOVWF  4C
1A09:  MOVLP  00
1A0A:  MOVLB  00
1A0B:  CALL   65B
1A0C:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A0D:  MOVLB  01
1A0E:  CLRF   33
1A0F:  MOVLW  10
1A10:  MOVWF  32
....................   while(aux_timer) { 
1A11:  MOVF   32,W
1A12:  IORWF  33,W
1A13:  BTFSC  03.2
1A14:  GOTO   217
....................     delay_cycles(1); 
1A15:  NOP
....................   } 
1A16:  GOTO   211
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A17:  MOVLW  04
1A18:  MOVLB  02
1A19:  MOVWF  4B
1A1A:  MOVLW  01
1A1B:  MOVWF  4C
1A1C:  MOVLP  00
1A1D:  MOVLB  00
1A1E:  CALL   65B
1A1F:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
082C:  MOVLW  01
082D:  MOVLB  02
082E:  MOVWF  4B
082F:  CLRF   4C
0830:  MOVLP  00
0831:  MOVLB  00
0832:  CALL   65B
0833:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0834:  MOVLW  0C
0835:  MOVLB  02
0836:  MOVWF  4B
0837:  MOVLW  01
0838:  MOVWF  4C
0839:  MOVLP  00
083A:  MOVLB  00
083B:  CALL   65B
083C:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
083D:  MOVLW  05
083E:  MOVLB  02
083F:  MOVWF  4B
0840:  MOVLW  01
0841:  MOVWF  4C
0842:  MOVLP  00
0843:  MOVLB  00
0844:  CALL   65B
0845:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0846:  MOVLW  05
0847:  MOVLB  02
0848:  MOVWF  4B
0849:  MOVLW  01
084A:  MOVWF  4C
084B:  MOVLP  00
084C:  MOVLB  00
084D:  CALL   65B
084E:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
084F:  MOVLB  01
0850:  CLRF   33
0851:  MOVLW  02
0852:  MOVWF  32
....................   while(aux_timer) { 
0853:  MOVF   32,W
0854:  IORWF  33,W
0855:  BTFSC  03.2
0856:  GOTO   059
....................     delay_cycles(1); 
0857:  NOP
....................   } 
0858:  GOTO   053
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0859:  MOVLW  04
085A:  MOVLB  02
085B:  MOVWF  4B
085C:  MOVLW  01
085D:  MOVWF  4C
085E:  MOVLP  00
085F:  MOVLB  00
0860:  CALL   65B
0861:  MOVLP  08
....................   restart_wdt(); 
0862:  CLRWDT
.................... } // }}} 
0863:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
0864:  MOVLW  01
0865:  MOVLB  02
0866:  MOVWF  4B
0867:  CLRF   4C
0868:  MOVLP  00
0869:  MOVLB  00
086A:  CALL   65B
086B:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
086C:  MOVLW  0C
086D:  MOVLB  02
086E:  MOVWF  4B
086F:  MOVLW  01
0870:  MOVWF  4C
0871:  MOVLP  00
0872:  MOVLB  00
0873:  CALL   65B
0874:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0875:  MOVLW  05
0876:  MOVLB  02
0877:  MOVWF  4B
0878:  MOVLW  01
0879:  MOVWF  4C
087A:  MOVLP  00
087B:  MOVLB  00
087C:  CALL   65B
087D:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
087E:  MOVLW  05
087F:  MOVLB  02
0880:  MOVWF  4B
0881:  MOVLW  01
0882:  MOVWF  4C
0883:  MOVLP  00
0884:  MOVLB  00
0885:  CALL   65B
0886:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
0887:  MOVLB  01
0888:  CLRF   33
0889:  MOVLW  06
088A:  MOVWF  32
....................   while(aux_timer) { 
088B:  MOVF   32,W
088C:  IORWF  33,W
088D:  BTFSC  03.2
088E:  GOTO   091
....................     delay_cycles(1); 
088F:  NOP
....................   } 
0890:  GOTO   08B
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0891:  MOVLW  04
0892:  MOVLB  02
0893:  MOVWF  4B
0894:  MOVLW  01
0895:  MOVWF  4C
0896:  MOVLP  00
0897:  MOVLB  00
0898:  CALL   65B
0899:  MOVLP  08
....................   restart_wdt(); 
089A:  CLRWDT
.................... } // }}} 
089B:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
052D:  MOVLB  02
052E:  MOVF   40,W
052F:  MOVWF  04
0530:  MOVF   41,W
0531:  MOVWF  05
0532:  MOVF   00,W
0533:  MOVWF  43
....................   if ( tmp > 127 ) { 
0534:  MOVF   43,W
0535:  SUBLW  7F
0536:  BTFSS  03.0
....................     tmp++; 
0537:  INCF   43,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
0538:  BCF    03.0
0539:  RLF    43,W
053A:  XORLW  09
053B:  ADDWF  42,W
053C:  MOVWF  43
....................   *cksum=tmp; 
053D:  MOVF   40,W
053E:  MOVWF  04
053F:  MOVF   41,W
0540:  MOVWF  05
0541:  MOVF   43,W
0542:  MOVWF  00
.................... } // }}} 
0543:  MOVLB  00
0544:  RETURN
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
0545:  MOVLW  01
0546:  MOVLB  02
0547:  MOVWF  3A
....................   eeprom_index=0; 
0548:  CLRF   3B
....................   retVal = 1; 
0549:  MOVWF  3D
....................   if ( source == USE_EEPROM_VARS ) { 
054A:  DECFSZ 36,W
054B:  GOTO   555
....................     printf("\n\rInitializing RAM variables from EEPROM"); 
054C:  MOVLW  3D
054D:  MOVLB  03
054E:  MOVWF  11
054F:  MOVLW  04
0550:  MOVWF  12
0551:  MOVLB  00
0552:  CALL   4D8
....................   } else { 
0553:  GOTO   55C
0554:  MOVLB  02
....................     printf("\n\rInitializing RAM variables with firmware default values"); 
0555:  MOVLW  52
0556:  MOVLB  03
0557:  MOVWF  11
0558:  MOVLW  04
0559:  MOVWF  12
055A:  MOVLB  00
055B:  CALL   4D8
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
055C:  MOVLB  02
055D:  CLRF   37
055E:  MOVF   37,W
055F:  SUBLW  38
0560:  BTFSS  03.0
0561:  GOTO   5BB
....................     regPtr=RegMap[x].reg_ptr; 
0562:  RLF    37,W
0563:  MOVWF  77
0564:  RLF    77,F
0565:  MOVLW  FC
0566:  ANDWF  77,F
0567:  MOVF   77,W
0568:  MOVWF  3F
0569:  INCF   3F,W
056A:  MOVLB  00
056B:  CALL   043
056C:  MOVWF  7A
056D:  MOVLB  02
056E:  MOVF   3F,W
056F:  MOVLB  00
0570:  CALL   043
0571:  MOVLB  02
0572:  MOVWF  38
0573:  MOVF   7A,W
0574:  MOVWF  39
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
0575:  DECFSZ 36,W
0576:  GOTO   5A7
0577:  RLF    37,W
0578:  MOVWF  77
0579:  RLF    77,F
057A:  MOVLW  FC
057B:  ANDWF  77,F
057C:  MOVF   77,W
057D:  ADDLW  03
057E:  MOVLB  00
057F:  CALL   043
0580:  MOVWF  78
0581:  BTFSC  78.0
0582:  GOTO   585
0583:  MOVLB  02
0584:  GOTO   5A7
....................     eeprom_val=read_eeprom(eeprom_index); 
0585:  MOVLB  02
0586:  MOVF   3B,W
0587:  MOVLB  03
0588:  MOVWF  11
0589:  BCF    15.7
058A:  BSF    15.0
058B:  MOVF   13,W
058C:  MOVLB  02
058D:  MOVWF  3E
....................     *regPtr=eeprom_val; 
058E:  MOVF   38,W
058F:  MOVWF  04
0590:  MOVF   39,W
0591:  MOVWF  05
0592:  MOVF   3E,W
0593:  MOVWF  00
....................     update_checksum(&cksum,*regPtr);     
0594:  MOVF   39,W
0595:  MOVWF  7A
0596:  MOVF   38,W
0597:  MOVWF  04
0598:  MOVF   39,W
0599:  MOVWF  05
059A:  MOVF   00,W
059B:  MOVWF  3F
059C:  MOVLW  20
059D:  MOVWF  41
059E:  MOVLW  BA
059F:  MOVWF  40
05A0:  MOVF   3F,W
05A1:  MOVWF  42
05A2:  MOVLB  00
05A3:  CALL   52D
....................       eeprom_index++; 
05A4:  MOVLB  02
05A5:  INCF   3B,F
....................     } else { 
05A6:  GOTO   5B9
....................       default_value=(int8)RegMap[x].default_value; 
05A7:  RLF    37,W
05A8:  MOVWF  77
05A9:  RLF    77,F
05AA:  MOVLW  FC
05AB:  ANDWF  77,F
05AC:  MOVF   77,W
05AD:  ADDLW  02
05AE:  MOVLB  00
05AF:  CALL   043
05B0:  MOVWF  78
05B1:  MOVLB  02
05B2:  MOVWF  3C
....................       *regPtr=default_value; 
05B3:  MOVF   38,W
05B4:  MOVWF  04
05B5:  MOVF   39,W
05B6:  MOVWF  05
05B7:  MOVF   3C,W
05B8:  MOVWF  00
....................     } 
....................   } 
05B9:  INCF   37,F
05BA:  GOTO   55E
....................   if ( source == USE_EEPROM_VARS ) { 
05BB:  DECFSZ 36,W
05BC:  GOTO   5C7
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
05BD:  MOVF   3B,W
05BE:  MOVLB  03
05BF:  MOVWF  11
05C0:  BCF    15.7
05C1:  BSF    15.0
05C2:  MOVF   13,W
05C3:  MOVLB  02
05C4:  SUBWF  3A,W
05C5:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
05C6:  CLRF   3D
....................     } 
....................   } 
....................   return (retVal); 
05C7:  MOVF   3D,W
05C8:  MOVWF  78
.................... } // }}} 
05C9:  MOVLB  00
05CA:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
05CB:  MOVLW  01
05CC:  MOVLB  02
05CD:  MOVWF  3A
....................  
....................   eeprom_index=0; 
05CE:  CLRF   37
....................   for(x=0;x<RegMapNum;x++) { 
05CF:  CLRF   36
05D0:  MOVF   36,W
05D1:  SUBLW  38
05D2:  BTFSS  03.0
05D3:  GOTO   629
....................     regPtr=RegMap[x].reg_ptr; 
05D4:  RLF    36,W
05D5:  MOVWF  77
05D6:  RLF    77,F
05D7:  MOVLW  FC
05D8:  ANDWF  77,F
05D9:  MOVF   77,W
05DA:  MOVWF  3C
05DB:  INCF   3C,W
05DC:  MOVLB  00
05DD:  CALL   043
05DE:  MOVWF  7A
05DF:  MOVLB  02
05E0:  MOVF   3C,W
05E1:  MOVLB  00
05E2:  CALL   043
05E3:  MOVLB  02
05E4:  MOVWF  38
05E5:  MOVF   7A,W
05E6:  MOVWF  39
....................     if ( RegMap[x].non_volatile ) { 
05E7:  RLF    36,W
05E8:  MOVWF  77
05E9:  RLF    77,F
05EA:  MOVLW  FC
05EB:  ANDWF  77,F
05EC:  MOVF   77,W
05ED:  ADDLW  03
05EE:  MOVLB  00
05EF:  CALL   043
05F0:  MOVWF  78
05F1:  BTFSS  78.0
05F2:  GOTO   626
....................      value=*regPtr; 
05F3:  MOVLB  02
05F4:  MOVF   38,W
05F5:  MOVWF  04
05F6:  MOVF   39,W
05F7:  MOVWF  05
05F8:  MOVF   00,W
05F9:  MOVWF  3B
....................      if ( read_eeprom(eeprom_index) != value ) { 
05FA:  MOVF   37,W
05FB:  MOVLB  03
05FC:  MOVWF  11
05FD:  BCF    15.7
05FE:  BSF    15.0
05FF:  MOVF   13,W
0600:  MOVLB  02
0601:  SUBWF  3B,W
0602:  BTFSC  03.2
0603:  GOTO   61B
....................        write_eeprom(eeprom_index,value); 
0604:  MOVF   0B,W
0605:  MOVWF  77
0606:  BCF    0B.7
0607:  MOVF   37,W
0608:  MOVLB  03
0609:  MOVWF  11
060A:  MOVLB  02
060B:  MOVF   3B,W
060C:  MOVLB  03
060D:  MOVWF  13
060E:  BCF    15.7
060F:  BSF    15.2
0610:  MOVLW  55
0611:  MOVWF  16
0612:  MOVLW  AA
0613:  MOVWF  16
0614:  BSF    15.1
0615:  BTFSC  15.1
0616:  GOTO   615
0617:  BCF    15.2
0618:  MOVF   77,W
0619:  IORWF  0B,F
061A:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
061B:  MOVLW  20
061C:  MOVWF  41
061D:  MOVLW  BA
061E:  MOVWF  40
061F:  MOVF   3B,W
0620:  MOVWF  42
0621:  MOVLB  00
0622:  CALL   52D
....................      eeprom_index++; 
0623:  MOVLB  02
0624:  INCF   37,F
0625:  MOVLB  00
....................     } 
....................   } 
0626:  MOVLB  02
0627:  INCF   36,F
0628:  GOTO   5D0
....................   write_eeprom(eeprom_index,cksum); 
0629:  MOVF   0B,W
062A:  MOVWF  77
062B:  BCF    0B.7
062C:  MOVF   37,W
062D:  MOVLB  03
062E:  MOVWF  11
062F:  MOVLB  02
0630:  MOVF   3A,W
0631:  MOVLB  03
0632:  MOVWF  13
0633:  BCF    15.7
0634:  BSF    15.2
0635:  MOVLW  55
0636:  MOVWF  16
0637:  MOVLW  AA
0638:  MOVWF  16
0639:  BSF    15.1
063A:  BTFSC  15.1
063B:  GOTO   63A
063C:  BCF    15.2
063D:  MOVF   77,W
063E:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
063F:  MOVLW  6F
0640:  MOVWF  11
0641:  MOVLW  04
0642:  MOVWF  12
0643:  MOVLB  00
0644:  CALL   4D8
.................... } // }}} 
0645:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
0646:  MOVLB  02
0647:  MOVF   35,W
0648:  MOVWF  36
0649:  MOVLB  00
064A:  CALL   545
064B:  MOVF   78,F
064C:  BTFSS  03.2
064D:  GOTO   65A
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
064E:  MOVLW  82
064F:  MOVLB  03
0650:  MOVWF  11
0651:  MOVLW  04
0652:  MOVWF  12
0653:  MOVLB  00
0654:  CALL   4D8
....................         _init_variables(USE_DEFAULT_VARS); 
0655:  MOVLB  02
0656:  CLRF   36
0657:  MOVLB  00
0658:  CALL   545
....................     store_variables(); 
0659:  CALL   5CB
....................     } 
.................... } // }}} 
065A:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0D3A:  MOVLB  02
0D3B:  CLRF   47
0D3C:  CLRF   48
0D3D:  MOVLP  00
0D3E:  MOVLB  00
0D3F:  CALL   78C
0D40:  MOVLP  08
....................   set_trimpot(1,0); 
0D41:  MOVLW  01
0D42:  MOVLB  02
0D43:  MOVWF  47
0D44:  CLRF   48
0D45:  MOVLP  00
0D46:  MOVLB  00
0D47:  CALL   78C
0D48:  MOVLP  08
....................   set_trimpot(2,0); 
0D49:  MOVLW  02
0D4A:  MOVLB  02
0D4B:  MOVWF  47
0D4C:  CLRF   48
0D4D:  MOVLP  00
0D4E:  MOVLB  00
0D4F:  CALL   78C
0D50:  MOVLP  08
....................   set_trimpot(3,0); 
0D51:  MOVLW  03
0D52:  MOVLB  02
0D53:  MOVWF  47
0D54:  CLRF   48
0D55:  MOVLP  00
0D56:  MOVLB  00
0D57:  CALL   78C
0D58:  MOVLP  08
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0CC4:  MOVLP  00
0CC5:  CALL   4BE
0CC6:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0CC7:  MOVLB  02
0CC8:  CLRF   12
0CC9:  CLRF   11
0CCA:  CLRF   14
0CCB:  CLRF   13
....................   setup_wdt(WDT_2S); 
0CCC:  MOVLW  17
0CCD:  MOVLB  01
0CCE:  MOVWF  17
....................   COR_IN=0; 
0CCF:  MOVLB  00
0CD0:  CLRF   5F
....................   COR_DROP_FLAG=0; 
0CD1:  BCF    72.7
....................   DTMF_IN_FLAG=0; 
0CD2:  MOVLB  01
0CD3:  BCF    5D.3
....................   DTMF_INTERRUPT_FLAG=0; 
0CD4:  BCF    5D.4
....................   LastRegisterIndexValid=0; 
0CD5:  CLRF   7D
....................   LastRegisterIndex=0; 
0CD6:  CLRF   7C
....................   CurrentCorMask=0; 
0CD7:  MOVLB  00
0CD8:  CLRF   6C
....................   CurrentCorPriority=0; 
0CD9:  CLRF   6E
....................   CurrentCorIndex=0; 
0CDA:  CLRF   6D
....................   CurrentTrimPot=0; 
0CDB:  CLRF   74
....................   set_tris_b(0xFF); 
0CDC:  MOVLW  FF
0CDD:  TRIS   6
....................   set_tris_d(0x00); 
0CDE:  MOVLW  00
0CDF:  MOVLB  01
0CE0:  MOVWF  0F
....................   // 0b11111000 
....................   set_tris_e(0xF8); 
0CE1:  BCF    10.0
0CE2:  BCF    10.1
0CE3:  BCF    10.2
0CE4:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0CE5:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0CE6:  BSF    0B.3
0CE7:  MOVLW  CF
0CE8:  MOVLB  07
0CE9:  IORWF  14,F
0CEA:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0CEB:  BSF    0B.3
0CEC:  BSF    15.4
0CED:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0CEE:  MOVLW  C0
0CEF:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0CF0:  MOVLB  02
0CF1:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0CF2:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0CF3:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0CF4:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0CF5:  MOVLW  01
0CF6:  MOVWF  35
0CF7:  MOVLP  00
0CF8:  MOVLB  00
0CF9:  CALL   646
0CFA:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D26:  MOVLB  01
0D27:  BSF    5D.5
....................   Enable_Mask = 0x0F; 
0D28:  MOVLW  0F
0D29:  MOVLB  00
0D2A:  MOVWF  61
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D2B:  MOVF   62,W
0D2C:  ANDLW  0F
0D2D:  IORLW  C0
0D2E:  MOVLB  04
0D2F:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D30:  MOVLB  01
0D31:  BCF    15.7
....................   // }}} 
....................   header(); 
0D32:  MOVLP  00
0D33:  MOVLB  00
0D34:  CALL   003
0D35:  MOVLP  08
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D36:  MOVLW  9D
0D37:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0D38:  MOVLW  80
0D39:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0D59:  MOVLB  01
0D5A:  CLRF   31
0D5B:  MOVLW  1E
0D5C:  MOVWF  30
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0D5D:  MOVF   15,W
0D5E:  ANDLW  C0
0D5F:  IORLW  07
0D60:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0D61:  BSF    0B.5
....................   update_ptt(0); 
0D62:  MOVLB  02
0D63:  CLRF   36
0D64:  MOVLB  00
0D65:  CALL   361
....................   MinuteCounter=MIN_COUNTER; 
0D66:  MOVLW  1D
0D67:  MOVLB  01
0D68:  MOVWF  5F
....................   SecondCounter=SEC_COUNTER; 
0D69:  MOVLW  3B
0D6A:  MOVWF  5E
....................   THIRTY_MIN_FLAG=0; 
0D6B:  BCF    72.6
....................   MINUTE_FLAG=0; 
0D6C:  BCF    72.5
....................   PROMPT_FLAG=1; 
0D6D:  BSF    5D.6
....................   TailChar=Tail; 
0D6E:  MOVLB  00
0D6F:  MOVF   65,W
0D70:  MOVWF  6A
....................   ConfirmChar=0; 
0D71:  CLRF   6B
....................   AuxOut[0] = PO_AUX_OUT0; 
0D72:  MOVLW  01
0D73:  MOVWF  42
....................   AuxOut[1] = PO_AUX_OUT1; 
0D74:  MOVWF  43
....................   AuxOut[2] = PO_AUX_OUT2; 
0D75:  MOVWF  44
....................   AuxInSW[0] = 0; 
0D76:  CLRF   3F
....................   AuxInSW[1] = 0; 
0D77:  CLRF   40
....................   AuxInSW[2] = 0; 
0D78:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0D79:  MOVLB  01
0D7A:  BCF    5D.0
....................   COR_IN_EFFECTIVE=0; 
0D7B:  MOVLB  00
0D7C:  CLRF   6F
....................   set_admin_mode(0); 
0D7D:  MOVLB  02
0D7E:  CLRF   48
0D7F:  MOVLB  00
0D80:  CALL   4AD
....................   rs232_mode=0; 
0D81:  MOVLB  01
0D82:  BCF    62.0
....................   button_state=0; 
0D83:  CLRF   5C
.................... //  setup_adc_ports(ADJ_POT); 
.................... //  set_adc_channel(13); 
.................... //  printf("\n\rInitialization complete"); 
.................... } // }}} 
0D84:  MOVLP  18
0D85:  MOVLB  00
0D86:  GOTO   5D8 (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180D:  MOVLB  02
180E:  BCF    30.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
180F:  CLRF   47
1810:  CLRF   48
1811:  MOVLW  20
1812:  MOVWF  05
1813:  MOVLW  B3
1814:  MOVWF  04
1815:  MOVF   47,W
1816:  ADDWF  04,F
1817:  MOVLW  00
1818:  ADDWFC 05,F
1819:  MOVF   48,W
181A:  MOVLP  00
181B:  MOVLB  00
181C:  CALL   139
181D:  MOVLP  18
181E:  MOVWF  00
181F:  IORLW  00
1820:  BTFSC  03.2
1821:  GOTO   027
1822:  MOVLB  02
1823:  INCF   48,F
1824:  INCF   47,F
1825:  GOTO   011
1826:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1827:  MOVLW  20
1828:  MOVLB  02
1829:  MOVWF  48
182A:  MOVLW  50
182B:  MOVWF  47
182C:  MOVLW  20
182D:  MOVWF  4A
182E:  MOVLW  B3
182F:  MOVWF  49
1830:  MOVLP  08
1831:  MOVLB  00
1832:  CALL   5B1
1833:  MOVLP  18
1834:  MOVF   79,W
1835:  MOVLB  02
1836:  MOVWF  32
1837:  MOVF   78,W
1838:  MOVWF  31
....................   if (sptr!=0) {; 
1839:  MOVF   31,F
183A:  BTFSS  03.2
183B:  GOTO   03F
183C:  MOVF   32,F
183D:  BTFSC  03.2
183E:  GOTO   059
....................     strcpy(verb,sptr); 
183F:  MOVF   32,W
1840:  MOVWF  4A
1841:  MOVF   31,W
1842:  MOVWF  49
1843:  MOVLW  20
1844:  MOVWF  48
1845:  MOVLW  A8
1846:  MOVWF  47
1847:  MOVF   4A,W
1848:  MOVWF  05
1849:  MOVF   49,W
184A:  MOVWF  04
184B:  MOVF   00,W
184C:  MOVWF  4B
184D:  MOVF   48,W
184E:  MOVWF  05
184F:  MOVF   47,W
1850:  MOVWF  04
1851:  MOVF   4B,W
1852:  MOVWF  00
1853:  MOVF   00,F
1854:  BTFSC  03.2
1855:  GOTO   059
1856:  INCF   47,F
1857:  INCF   49,F
1858:  GOTO   047
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
1859:  CLRF   48
185A:  CLRF   47
185B:  MOVLW  20
185C:  MOVWF  4A
185D:  MOVLW  B3
185E:  MOVWF  49
185F:  MOVLP  08
1860:  MOVLB  00
1861:  CALL   5B1
1862:  MOVLP  18
1863:  MOVF   79,W
1864:  MOVLB  02
1865:  MOVWF  32
1866:  MOVF   78,W
1867:  MOVWF  31
....................   if (sptr!=0) {; 
1868:  MOVF   31,F
1869:  BTFSS  03.2
186A:  GOTO   06E
186B:  MOVF   32,F
186C:  BTFSC  03.2
186D:  GOTO   088
....................     strcpy(argument_name,sptr); 
186E:  MOVF   32,W
186F:  MOVWF  4A
1870:  MOVF   31,W
1871:  MOVWF  49
1872:  MOVLW  20
1873:  MOVWF  48
1874:  MOVLW  70
1875:  MOVWF  47
1876:  MOVF   4A,W
1877:  MOVWF  05
1878:  MOVF   49,W
1879:  MOVWF  04
187A:  MOVF   00,W
187B:  MOVWF  4B
187C:  MOVF   48,W
187D:  MOVWF  05
187E:  MOVF   47,W
187F:  MOVWF  04
1880:  MOVF   4B,W
1881:  MOVWF  00
1882:  MOVF   00,F
1883:  BTFSC  03.2
1884:  GOTO   088
1885:  INCF   47,F
1886:  INCF   49,F
1887:  GOTO   076
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1888:  CLRF   48
1889:  CLRF   47
188A:  MOVLW  20
188B:  MOVWF  4A
188C:  MOVLW  B3
188D:  MOVWF  49
188E:  MOVLP  08
188F:  MOVLB  00
1890:  CALL   5B1
1891:  MOVLP  18
1892:  MOVF   79,W
1893:  MOVLB  02
1894:  MOVWF  32
1895:  MOVF   78,W
1896:  MOVWF  31
....................   if (sptr!=0) {; 
1897:  MOVF   31,F
1898:  BTFSS  03.2
1899:  GOTO   09D
189A:  MOVF   32,F
189B:  BTFSC  03.2
189C:  GOTO   0C3
....................     strcpy(match_val,sptr); 
189D:  MOVF   32,W
189E:  MOVWF  4A
189F:  MOVF   31,W
18A0:  MOVWF  49
18A1:  MOVLW  20
18A2:  MOVWF  48
18A3:  MOVLW  BB
18A4:  MOVWF  47
18A5:  MOVF   4A,W
18A6:  MOVWF  05
18A7:  MOVF   49,W
18A8:  MOVWF  04
18A9:  MOVF   00,W
18AA:  MOVWF  4B
18AB:  MOVF   48,W
18AC:  MOVWF  05
18AD:  MOVF   47,W
18AE:  MOVWF  04
18AF:  MOVF   4B,W
18B0:  MOVWF  00
18B1:  MOVF   00,F
18B2:  BTFSC  03.2
18B3:  GOTO   0B7
18B4:  INCF   47,F
18B5:  INCF   49,F
18B6:  GOTO   0A5
....................     value = str_to_decimal(match_val); 
18B7:  MOVLW  20
18B8:  MOVWF  48
18B9:  MOVLW  BB
18BA:  MOVWF  47
18BB:  MOVLP  08
18BC:  MOVLB  00
18BD:  CALL   6B7
18BE:  MOVLP  18
18BF:  MOVF   78,W
18C0:  MOVWF  76
....................   } else { 
18C1:  GOTO   0C6
18C2:  MOVLB  02
....................     value = 0; 
18C3:  CLRF   76
....................     do_get_var = 1; 
18C4:  BSF    30.0
18C5:  MOVLB  00
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18C6:  MOVLB  02
18C7:  CLRF   47
18C8:  CLRF   48
18C9:  MOVLW  20
18CA:  MOVWF  05
18CB:  MOVLW  BF
18CC:  MOVWF  04
18CD:  MOVF   47,W
18CE:  ADDWF  04,F
18CF:  MOVLW  00
18D0:  ADDWFC 05,F
18D1:  MOVF   48,W
18D2:  MOVLP  00
18D3:  MOVLB  00
18D4:  CALL   13F
18D5:  MOVLP  18
18D6:  MOVWF  00
18D7:  IORLW  00
18D8:  BTFSC  03.2
18D9:  GOTO   0DF
18DA:  MOVLB  02
18DB:  INCF   48,F
18DC:  INCF   47,F
18DD:  GOTO   0C9
18DE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
18DF:  MOVLW  20
18E0:  MOVLB  02
18E1:  MOVWF  48
18E2:  MOVLW  BF
18E3:  MOVWF  47
18E4:  MOVLW  20
18E5:  MOVWF  4A
18E6:  MOVLW  A8
18E7:  MOVWF  49
18E8:  MOVLP  08
18E9:  MOVLB  00
18EA:  CALL   6F0
18EB:  MOVLP  18
18EC:  MOVF   78,F
18ED:  BTFSS  03.2
18EE:  GOTO   0F8
....................     if ( do_get_var ) { 
18EF:  MOVLB  02
18F0:  BTFSS  30.0
18F1:  GOTO   0F5
....................       command=GET_REG; 
18F2:  MOVLW  03
18F3:  MOVWF  70
....................     } else { 
18F4:  GOTO   0F7
....................       command=SET_REG; 
18F5:  MOVLW  02
18F6:  MOVWF  70
18F7:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18F8:  MOVLB  02
18F9:  CLRF   47
18FA:  CLRF   48
18FB:  MOVLW  20
18FC:  MOVWF  05
18FD:  MOVLW  BF
18FE:  MOVWF  04
18FF:  MOVF   47,W
1900:  ADDWF  04,F
1901:  MOVLW  00
1902:  ADDWFC 05,F
1903:  MOVF   48,W
1904:  MOVLP  00
1905:  MOVLB  00
1906:  CALL   144
1907:  MOVLP  18
1908:  MOVWF  00
1909:  IORLW  00
190A:  BTFSC  03.2
190B:  GOTO   111
190C:  MOVLB  02
190D:  INCF   48,F
190E:  INCF   47,F
190F:  GOTO   0FB
1910:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1911:  MOVLW  20
1912:  MOVLB  02
1913:  MOVWF  48
1914:  MOVLW  BF
1915:  MOVWF  47
1916:  MOVLW  20
1917:  MOVWF  4A
1918:  MOVLW  A8
1919:  MOVWF  49
191A:  MOVLP  08
191B:  MOVLB  00
191C:  CALL   6F0
191D:  MOVLP  18
191E:  MOVF   78,F
191F:  BTFSS  03.2
1920:  GOTO   123
....................       command=SAVE_SETTINGS; 
1921:  MOVLW  04
1922:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1923:  MOVLB  02
1924:  CLRF   47
1925:  CLRF   48
1926:  MOVLW  20
1927:  MOVWF  05
1928:  MOVLW  BF
1929:  MOVWF  04
192A:  MOVF   47,W
192B:  ADDWF  04,F
192C:  MOVLW  00
192D:  ADDWFC 05,F
192E:  MOVF   48,W
192F:  MOVLP  00
1930:  MOVLB  00
1931:  CALL   14A
1932:  MOVLP  18
1933:  MOVWF  00
1934:  IORLW  00
1935:  BTFSC  03.2
1936:  GOTO   13C
1937:  MOVLB  02
1938:  INCF   48,F
1939:  INCF   47,F
193A:  GOTO   126
193B:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
193C:  MOVLW  20
193D:  MOVLB  02
193E:  MOVWF  48
193F:  MOVLW  BF
1940:  MOVWF  47
1941:  MOVLW  20
1942:  MOVWF  4A
1943:  MOVLW  A8
1944:  MOVWF  49
1945:  MOVLP  08
1946:  MOVLB  00
1947:  CALL   6F0
1948:  MOVLP  18
1949:  MOVF   78,F
194A:  BTFSS  03.2
194B:  GOTO   14E
....................       command=RESTORE_SETTINGS; 
194C:  MOVLW  05
194D:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
194E:  MOVLB  02
194F:  CLRF   47
1950:  CLRF   48
1951:  MOVLW  20
1952:  MOVWF  05
1953:  MOVLW  BF
1954:  MOVWF  04
1955:  MOVF   47,W
1956:  ADDWF  04,F
1957:  MOVLW  00
1958:  ADDWFC 05,F
1959:  MOVF   48,W
195A:  MOVLP  00
195B:  MOVLB  00
195C:  CALL   153
195D:  MOVLP  18
195E:  MOVWF  00
195F:  IORLW  00
1960:  BTFSC  03.2
1961:  GOTO   167
1962:  MOVLB  02
1963:  INCF   48,F
1964:  INCF   47,F
1965:  GOTO   151
1966:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1967:  MOVLW  20
1968:  MOVLB  02
1969:  MOVWF  48
196A:  MOVLW  BF
196B:  MOVWF  47
196C:  MOVLW  20
196D:  MOVWF  4A
196E:  MOVLW  A8
196F:  MOVWF  49
1970:  MOVLP  08
1971:  MOVLB  00
1972:  CALL   6F0
1973:  MOVLP  18
1974:  MOVF   78,F
1975:  BTFSS  03.2
1976:  GOTO   179
....................     command=STATUS; 
1977:  MOVLW  08
1978:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
1979:  MOVLB  02
197A:  CLRF   47
197B:  CLRF   48
197C:  MOVLW  20
197D:  MOVWF  05
197E:  MOVLW  BF
197F:  MOVWF  04
1980:  MOVF   47,W
1981:  ADDWF  04,F
1982:  MOVLW  00
1983:  ADDWFC 05,F
1984:  MOVF   48,W
1985:  MOVLP  00
1986:  MOVLB  00
1987:  CALL   15B
1988:  MOVLP  18
1989:  MOVWF  00
198A:  IORLW  00
198B:  BTFSC  03.2
198C:  GOTO   192
198D:  MOVLB  02
198E:  INCF   48,F
198F:  INCF   47,F
1990:  GOTO   17C
1991:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1992:  MOVLW  20
1993:  MOVLB  02
1994:  MOVWF  48
1995:  MOVLW  BF
1996:  MOVWF  47
1997:  MOVLW  20
1998:  MOVWF  4A
1999:  MOVLW  A8
199A:  MOVWF  49
199B:  MOVLP  08
199C:  MOVLB  00
199D:  CALL   6F0
199E:  MOVLP  18
199F:  MOVF   78,F
19A0:  BTFSS  03.2
19A1:  GOTO   1A6
....................     command=ADMIN; 
19A2:  MOVLW  09
19A3:  MOVWF  70
....................     argument=REBOOT; 
19A4:  MOVLW  02
19A5:  MOVWF  75
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19A6:  MOVLB  02
19A7:  CLRF   47
19A8:  CLRF   48
19A9:  MOVLW  20
19AA:  MOVWF  05
19AB:  MOVLW  BF
19AC:  MOVWF  04
19AD:  MOVF   47,W
19AE:  ADDWF  04,F
19AF:  MOVLW  00
19B0:  ADDWFC 05,F
19B1:  MOVF   48,W
19B2:  MOVLP  00
19B3:  MOVLB  00
19B4:  CALL   163
19B5:  MOVLP  18
19B6:  MOVWF  00
19B7:  IORLW  00
19B8:  BTFSC  03.2
19B9:  GOTO   1BF
19BA:  MOVLB  02
19BB:  INCF   48,F
19BC:  INCF   47,F
19BD:  GOTO   1A9
19BE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19BF:  MOVLW  20
19C0:  MOVLB  02
19C1:  MOVWF  48
19C2:  MOVLW  BF
19C3:  MOVWF  47
19C4:  MOVLW  20
19C5:  MOVWF  4A
19C6:  MOVLW  A8
19C7:  MOVWF  49
19C8:  MOVLP  08
19C9:  MOVLB  00
19CA:  CALL   6F0
19CB:  MOVLP  18
19CC:  MOVF   78,F
19CD:  BTFSS  03.2
19CE:  GOTO   220
....................     //command=DTMF_SEND; 
....................     command=0; 
19CF:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D0:  MOVLW  20
19D1:  MOVLB  02
19D2:  MOVWF  48
19D3:  MOVLW  70
19D4:  MOVWF  47
19D5:  MOVLP  08
19D6:  MOVLB  00
19D7:  CALL   6B7
19D8:  MOVLP  18
19D9:  MOVF   78,W
19DA:  MOVWF  76
....................     if ( value == d0 ) { 
19DB:  MOVF   76,W
19DC:  SUBLW  0A
19DD:  BTFSS  03.2
19DE:  GOTO   1E1
....................       value = dd; 
19DF:  CLRF   76
....................     } else if (value == dd) { 
19E0:  GOTO   1E6
19E1:  MOVF   76,F
19E2:  BTFSS  03.2
19E3:  GOTO   1E6
....................       value = d0; 
19E4:  MOVLW  0A
19E5:  MOVWF  76
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19E6:  MOVF   76,W
19E7:  ANDLW  0F
19E8:  MOVLB  02
19E9:  MOVWF  47
19EA:  MOVF   47,W
19EB:  MOVWF  48
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A20:  MOVLB  02
1A21:  CLRF   47
1A22:  CLRF   48
1A23:  MOVLW  20
1A24:  MOVWF  05
1A25:  MOVLW  BF
1A26:  MOVWF  04
1A27:  MOVF   47,W
1A28:  ADDWF  04,F
1A29:  MOVLW  00
1A2A:  ADDWFC 05,F
1A2B:  MOVF   48,W
1A2C:  MOVLP  00
1A2D:  MOVLB  00
1A2E:  CALL   166
1A2F:  MOVLP  18
1A30:  MOVWF  00
1A31:  IORLW  00
1A32:  BTFSC  03.2
1A33:  GOTO   239
1A34:  MOVLB  02
1A35:  INCF   48,F
1A36:  INCF   47,F
1A37:  GOTO   223
1A38:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A39:  MOVLW  20
1A3A:  MOVLB  02
1A3B:  MOVWF  48
1A3C:  MOVLW  BF
1A3D:  MOVWF  47
1A3E:  MOVLW  20
1A3F:  MOVWF  4A
1A40:  MOVLW  A8
1A41:  MOVWF  49
1A42:  MOVLP  08
1A43:  MOVLB  00
1A44:  CALL   6F0
1A45:  MOVLP  18
1A46:  MOVF   78,F
1A47:  BTFSS  03.2
1A48:  GOTO   24B
....................     command=I2C_SEND; 
1A49:  MOVLW  0C
1A4A:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A4B:  MOVLB  02
1A4C:  CLRF   47
1A4D:  CLRF   48
1A4E:  MOVLW  20
1A4F:  MOVWF  05
1A50:  MOVLW  BF
1A51:  MOVWF  04
1A52:  MOVF   47,W
1A53:  ADDWF  04,F
1A54:  MOVLW  00
1A55:  ADDWFC 05,F
1A56:  MOVF   48,W
1A57:  MOVLP  00
1A58:  MOVLB  00
1A59:  CALL   16B
1A5A:  MOVLP  18
1A5B:  MOVWF  00
1A5C:  IORLW  00
1A5D:  BTFSC  03.2
1A5E:  GOTO   264
1A5F:  MOVLB  02
1A60:  INCF   48,F
1A61:  INCF   47,F
1A62:  GOTO   24E
1A63:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A64:  MOVLW  20
1A65:  MOVLB  02
1A66:  MOVWF  48
1A67:  MOVLW  BF
1A68:  MOVWF  47
1A69:  MOVLW  20
1A6A:  MOVWF  4A
1A6B:  MOVLW  A8
1A6C:  MOVWF  49
1A6D:  MOVLP  08
1A6E:  MOVLB  00
1A6F:  CALL   6F0
1A70:  MOVLP  18
1A71:  MOVF   78,F
1A72:  BTFSS  03.2
1A73:  GOTO   28B
....................     value = str_to_decimal(argument_name); 
1A74:  MOVLW  20
1A75:  MOVLB  02
1A76:  MOVWF  48
1A77:  MOVLW  70
1A78:  MOVWF  47
1A79:  MOVLP  08
1A7A:  MOVLB  00
1A7B:  CALL   6B7
1A7C:  MOVLP  18
1A7D:  MOVF   78,W
1A7E:  MOVWF  76
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A7F:  MOVF   76,W
1A80:  SUBLW  24
1A81:  BTFSS  03.0
1A82:  GOTO   287
....................       argument = 0; 
1A83:  CLRF   75
....................       command  = MORSE_SEND; 
1A84:  MOVLW  0B
1A85:  MOVWF  70
....................     } else { 
1A86:  GOTO   28B
....................       command  = ADMIN; 
1A87:  MOVLW  09
1A88:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A89:  MOVLW  03
1A8A:  MOVWF  75
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A8B:  MOVLB  02
1A8C:  CLRF   47
1A8D:  CLRF   48
1A8E:  MOVLW  20
1A8F:  MOVWF  05
1A90:  MOVLW  BF
1A91:  MOVWF  04
1A92:  MOVF   47,W
1A93:  ADDWF  04,F
1A94:  MOVLW  00
1A95:  ADDWFC 05,F
1A96:  MOVF   48,W
1A97:  MOVLP  00
1A98:  MOVLB  00
1A99:  CALL   172
1A9A:  MOVLP  18
1A9B:  MOVWF  00
1A9C:  IORLW  00
1A9D:  BTFSC  03.2
1A9E:  GOTO   2A4
1A9F:  MOVLB  02
1AA0:  INCF   48,F
1AA1:  INCF   47,F
1AA2:  GOTO   28E
1AA3:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AA4:  MOVLW  20
1AA5:  MOVLB  02
1AA6:  MOVWF  48
1AA7:  MOVLW  BF
1AA8:  MOVWF  47
1AA9:  MOVLW  20
1AAA:  MOVWF  4A
1AAB:  MOVLW  A8
1AAC:  MOVWF  49
1AAD:  MOVLP  08
1AAE:  MOVLB  00
1AAF:  CALL   6F0
1AB0:  MOVLP  18
1AB1:  MOVF   78,F
1AB2:  BTFSS  03.2
1AB3:  GOTO   2B6
....................     command=INCREMENT_REG; 
1AB4:  MOVLW  06
1AB5:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1AB6:  MOVLB  02
1AB7:  CLRF   47
1AB8:  CLRF   48
1AB9:  MOVLW  20
1ABA:  MOVWF  05
1ABB:  MOVLW  BF
1ABC:  MOVWF  04
1ABD:  MOVF   47,W
1ABE:  ADDWF  04,F
1ABF:  MOVLW  00
1AC0:  ADDWFC 05,F
1AC1:  MOVF   48,W
1AC2:  MOVLP  00
1AC3:  MOVLB  00
1AC4:  CALL   175
1AC5:  MOVLP  18
1AC6:  MOVWF  00
1AC7:  IORLW  00
1AC8:  BTFSC  03.2
1AC9:  GOTO   2CF
1ACA:  MOVLB  02
1ACB:  INCF   48,F
1ACC:  INCF   47,F
1ACD:  GOTO   2B9
1ACE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1ACF:  MOVLW  20
1AD0:  MOVLB  02
1AD1:  MOVWF  48
1AD2:  MOVLW  BF
1AD3:  MOVWF  47
1AD4:  MOVLW  20
1AD5:  MOVWF  4A
1AD6:  MOVLW  A8
1AD7:  MOVWF  49
1AD8:  MOVLP  08
1AD9:  MOVLB  00
1ADA:  CALL   6F0
1ADB:  MOVLP  18
1ADC:  MOVF   78,F
1ADD:  BTFSS  03.2
1ADE:  GOTO   2E1
....................     command=DECREMENT_REG; 
1ADF:  MOVLW  07
1AE0:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AE1:  MOVLB  02
1AE2:  CLRF   47
1AE3:  CLRF   48
1AE4:  MOVLW  20
1AE5:  MOVWF  05
1AE6:  MOVLW  BF
1AE7:  MOVWF  04
1AE8:  MOVF   47,W
1AE9:  ADDWF  04,F
1AEA:  MOVLW  00
1AEB:  ADDWFC 05,F
1AEC:  MOVF   48,W
1AED:  MOVLP  00
1AEE:  MOVLB  00
1AEF:  CALL   178
1AF0:  MOVLP  18
1AF1:  MOVWF  00
1AF2:  IORLW  00
1AF3:  BTFSC  03.2
1AF4:  GOTO   2FA
1AF5:  MOVLB  02
1AF6:  INCF   48,F
1AF7:  INCF   47,F
1AF8:  GOTO   2E4
1AF9:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AFA:  MOVLW  20
1AFB:  MOVLB  02
1AFC:  MOVWF  48
1AFD:  MOVLW  BF
1AFE:  MOVWF  47
1AFF:  MOVLW  20
1B00:  MOVWF  4A
1B01:  MOVLW  A8
1B02:  MOVWF  49
1B03:  MOVLP  08
1B04:  MOVLB  00
1B05:  CALL   6F0
1B06:  MOVLP  18
1B07:  MOVF   78,F
1B08:  BTFSS  03.2
1B09:  GOTO   329
....................     command=SET_REG; 
1B0A:  MOVLW  02
1B0B:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B0C:  MOVLW  01
1B0D:  ADDWF  74,W
1B0E:  ANDLW  03
1B0F:  MOVWF  76
....................     strcpy(argument_name,"CPOT"); 
1B10:  MOVLB  02
1B11:  CLRF   47
1B12:  CLRF   48
1B13:  MOVLW  20
1B14:  MOVWF  05
1B15:  MOVLW  70
1B16:  MOVWF  04
1B17:  MOVF   47,W
1B18:  ADDWF  04,F
1B19:  MOVLW  00
1B1A:  ADDWFC 05,F
1B1B:  MOVF   48,W
1B1C:  MOVLP  00
1B1D:  MOVLB  00
1B1E:  CALL   17B
1B1F:  MOVLP  18
1B20:  MOVWF  00
1B21:  IORLW  00
1B22:  BTFSC  03.2
1B23:  GOTO   329
1B24:  MOVLB  02
1B25:  INCF   48,F
1B26:  INCF   47,F
1B27:  GOTO   313
1B28:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B29:  MOVLB  02
1B2A:  CLRF   47
1B2B:  CLRF   48
1B2C:  MOVLW  20
1B2D:  MOVWF  05
1B2E:  MOVLW  BF
1B2F:  MOVWF  04
1B30:  MOVF   47,W
1B31:  ADDWF  04,F
1B32:  MOVLW  00
1B33:  ADDWFC 05,F
1B34:  MOVF   48,W
1B35:  MOVLP  00
1B36:  MOVLB  00
1B37:  CALL   181
1B38:  MOVLP  18
1B39:  MOVWF  00
1B3A:  IORLW  00
1B3B:  BTFSC  03.2
1B3C:  GOTO   342
1B3D:  MOVLB  02
1B3E:  INCF   48,F
1B3F:  INCF   47,F
1B40:  GOTO   32C
1B41:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B42:  MOVLW  20
1B43:  MOVLB  02
1B44:  MOVWF  48
1B45:  MOVLW  BF
1B46:  MOVWF  47
1B47:  MOVLW  20
1B48:  MOVWF  4A
1B49:  MOVLW  A8
1B4A:  MOVWF  49
1B4B:  MOVLP  08
1B4C:  MOVLB  00
1B4D:  CALL   6F0
1B4E:  MOVLP  18
1B4F:  MOVF   78,F
1B50:  BTFSS  03.2
1B51:  GOTO   362
....................     AdminMode = ~AdminMode; 
1B52:  MOVLW  80
1B53:  MOVLB  01
1B54:  XORWF  5D,F
....................     set_admin_mode(AdminMode); 
1B55:  MOVLW  00
1B56:  BTFSC  5D.7
1B57:  MOVLW  01
1B58:  MOVLB  02
1B59:  MOVWF  47
1B5A:  MOVWF  48
1B5B:  MOVLP  08
1B5C:  MOVLB  00
1B5D:  CALL   4AD
1B5E:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B5F:  MOVLB  01
1B60:  BSF    5D.6
1B61:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
10C5:  MOVF   76,W
10C6:  SUBLW  FF
10C7:  BTFSS  03.2
10C8:  GOTO   0EF
....................     printf ("\n\r%s %u",argument,value); 
10C9:  MOVLW  0A
10CA:  CLRWDT
10CB:  BTFSS  11.4
10CC:  GOTO   0CA
10CD:  MOVLB  03
10CE:  MOVWF  1A
10CF:  MOVLW  0D
10D0:  CLRWDT
10D1:  MOVLB  00
10D2:  BTFSC  11.4
10D3:  GOTO   0D6
10D4:  MOVLB  03
10D5:  GOTO   0D0
10D6:  MOVLB  03
10D7:  MOVWF  1A
10D8:  CLRF   05
10D9:  MOVF   75,W
10DA:  MOVWF  04
10DB:  MOVLP  08
10DC:  MOVLB  00
10DD:  CALL   257
10DE:  MOVLP  10
10DF:  MOVLW  20
10E0:  CLRWDT
10E1:  BTFSS  11.4
10E2:  GOTO   0E0
10E3:  MOVLB  03
10E4:  MOVWF  1A
10E5:  MOVF   76,W
10E6:  MOVLB  02
10E7:  MOVWF  58
10E8:  MOVLW  1B
10E9:  MOVWF  59
10EA:  MOVLP  00
10EB:  MOVLB  00
10EC:  CALL   73D
10ED:  MOVLP  10
....................   } else { 
10EE:  GOTO   18D
....................     pObj=RegMap[argument].reg_ptr; 
10EF:  RLF    75,W
10F0:  MOVWF  77
10F1:  RLF    77,F
10F2:  MOVLW  FC
10F3:  ANDWF  77,F
10F4:  MOVF   77,W
10F5:  MOVLB  02
10F6:  MOVWF  37
10F7:  INCF   37,W
10F8:  MOVLP  00
10F9:  MOVLB  00
10FA:  CALL   043
10FB:  MOVLP  10
10FC:  MOVWF  7A
10FD:  MOVLB  02
10FE:  MOVF   37,W
10FF:  MOVLP  00
1100:  MOVLB  00
1101:  CALL   043
1102:  MOVLP  10
1103:  MOVLB  02
1104:  MOVWF  34
1105:  MOVF   7A,W
1106:  MOVWF  35
....................     // Consider allowing some registers to be updated outside AdminMode. 
....................     // Example : AuxOut registers, Enable 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
1107:  MOVLP  08
1108:  MOVLB  00
1109:  CALL   758
110A:  MOVLP  10
110B:  MOVF   78,F
110C:  BTFSS  03.2
110D:  GOTO   11B
110E:  RLF    75,W
110F:  MOVWF  77
1110:  RLF    77,F
1111:  MOVLW  FC
1112:  ANDWF  77,F
1113:  MOVF   77,W
1114:  ADDLW  03
1115:  MOVLP  00
1116:  CALL   043
1117:  MOVLP  10
1118:  MOVWF  78
1119:  BTFSC  78.1
111A:  GOTO   123
....................       *pObj=value; 
111B:  MOVLB  02
111C:  MOVF   34,W
111D:  MOVWF  04
111E:  MOVF   35,W
111F:  MOVWF  05
1120:  MOVF   76,W
1121:  MOVWF  00
1122:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
1123:  MOVLB  02
1124:  MOVF   34,W
1125:  MOVWF  04
1126:  MOVF   35,W
1127:  MOVWF  05
1128:  MOVF   00,W
1129:  MOVWF  36
....................     LastRegisterIndex = argument; 
112A:  MOVF   75,W
112B:  MOVWF  7C
....................     LastRegisterIndexValid=1; 
112C:  MOVLW  01
112D:  MOVWF  7D
....................     printf ("\n\rSetting %s(%u) to %u",argument_name,argument,lVar); 
112E:  MOVLW  9B
112F:  MOVLB  03
1130:  MOVWF  11
1131:  MOVLW  04
1132:  MOVWF  12
1133:  BCF    03.0
1134:  MOVLW  0A
1135:  MOVLB  02
1136:  MOVWF  58
1137:  MOVLP  00
1138:  MOVLB  00
1139:  CALL   6C9
113A:  MOVLP  10
113B:  MOVLW  20
113C:  MOVWF  05
113D:  MOVLW  70
113E:  MOVWF  04
113F:  MOVLP  08
1140:  CALL   257
1141:  MOVLP  10
1142:  MOVLW  28
1143:  CLRWDT
1144:  BTFSS  11.4
1145:  GOTO   143
1146:  MOVLB  03
1147:  MOVWF  1A
1148:  MOVF   75,W
1149:  MOVLB  02
114A:  MOVWF  58
114B:  MOVLW  1B
114C:  MOVWF  59
114D:  MOVLP  00
114E:  MOVLB  00
114F:  CALL   73D
1150:  MOVLP  10
1151:  MOVLW  A2
1152:  MOVLB  03
1153:  MOVWF  11
1154:  MOVLW  04
1155:  MOVWF  12
1156:  BSF    03.0
1157:  MOVLW  05
1158:  MOVLB  02
1159:  MOVWF  58
115A:  MOVLP  00
115B:  MOVLB  00
115C:  CALL   6C9
115D:  MOVLP  10
115E:  MOVLB  02
115F:  MOVF   36,W
1160:  MOVWF  58
1161:  MOVLW  1B
1162:  MOVWF  59
1163:  MOVLP  00
1164:  MOVLB  00
1165:  CALL   73D
1166:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
1167:  MOVLB  02
1168:  MOVF   35,W
1169:  SUBLW  1F
116A:  BTFSC  03.0
116B:  GOTO   17D
116C:  XORLW  FF
116D:  BTFSS  03.2
116E:  GOTO   173
116F:  MOVF   34,W
1170:  SUBLW  0B
1171:  BTFSC  03.0
1172:  GOTO   17D
1173:  MOVF   35,W
1174:  SUBLW  20
1175:  BTFSS  03.0
1176:  GOTO   17D
1177:  BTFSS  03.2
1178:  GOTO   184
1179:  MOVF   34,W
117A:  SUBLW  1B
117B:  BTFSC  03.0
117C:  GOTO   184
117D:  MOVF   34,W
117E:  SUBLW  74
117F:  BTFSS  03.2
1180:  GOTO   18A
1181:  MOVF   35,F
1182:  BTFSS  03.2
1183:  GOTO   18A
....................       increment(0); // Increment is done in this function. Only update trim pot. 
1184:  CLRF   37
1185:  MOVLP  08
1186:  MOVLB  00
1187:  CALL   767
1188:  MOVLP  10
1189:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
118A:  MOVLB  01
118B:  BSF    5D.6
118C:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
0F67:  MOVF   74,W
0F68:  ANDLW  03
0F69:  MOVLB  02
0F6A:  MOVWF  3B
....................   if ( CurrentCorIndex ) { 
0F6B:  MOVLB  00
0F6C:  MOVF   6D,F
0F6D:  BTFSC  03.2
0F6E:  GOTO   7A6
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
0F6F:  MOVLW  01
0F70:  SUBWF  6D,W
0F71:  MOVWF  77
0F72:  RLF    77,F
0F73:  RLF    77,F
0F74:  MOVLW  FC
0F75:  ANDWF  77,F
0F76:  MOVF   77,W
0F77:  MOVLB  02
0F78:  ADDWF  3B,W
0F79:  ADDLW  0C
0F7A:  MOVWF  78
0F7B:  MOVLW  20
0F7C:  MOVWF  7A
0F7D:  BTFSC  03.0
0F7E:  INCF   7A,F
0F7F:  MOVF   78,W
0F80:  MOVWF  38
0F81:  MOVF   7A,W
0F82:  MOVWF  39
....................     value = *pot_ptr; 
0F83:  MOVF   38,W
0F84:  MOVWF  04
0F85:  MOVF   39,W
0F86:  MOVWF  05
0F87:  MOVF   00,W
0F88:  MOVWF  3A
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
0F89:  MOVF   38,W
0F8A:  MOVWF  04
0F8B:  MOVF   39,W
0F8C:  MOVWF  05
0F8D:  MOVF   37,W
0F8E:  ADDWF  3A,W
0F8F:  MOVWF  00
....................     if ( in_admin_mode() ) { 
0F90:  MOVLB  00
0F91:  CALL   758
0F92:  MOVF   78,F
0F93:  BTFSC  03.2
0F94:  GOTO   7A6
....................       set_trimpot(CPotPtr,*pot_ptr); 
0F95:  MOVLB  02
0F96:  MOVF   39,W
0F97:  MOVWF  7A
0F98:  MOVF   38,W
0F99:  MOVWF  04
0F9A:  MOVF   39,W
0F9B:  MOVWF  05
0F9C:  MOVF   00,W
0F9D:  MOVWF  3C
0F9E:  MOVF   3B,W
0F9F:  MOVWF  47
0FA0:  MOVF   3C,W
0FA1:  MOVWF  48
0FA2:  MOVLP  00
0FA3:  MOVLB  00
0FA4:  CALL   78C
0FA5:  MOVLP  08
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
0FA6:  CALL   271
.................... } // }}} 
0FA7:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
0F2F:  MOVLB  02
0F30:  CLRF   47
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
0F31:  MOVF   47,W
0F32:  SUBLW  05
0F33:  BTFSS  03.0
0F34:  GOTO   756
....................     dest[c]=src[c]; 
0F35:  MOVF   47,W
0F36:  ADDWF  43,W
0F37:  MOVWF  78
0F38:  MOVLW  00
0F39:  ADDWFC 44,W
0F3A:  MOVWF  7A
0F3B:  MOVF   78,W
0F3C:  MOVWF  48
0F3D:  MOVF   7A,W
0F3E:  MOVWF  49
0F3F:  MOVF   47,W
0F40:  ADDWF  45,W
0F41:  MOVWF  78
0F42:  MOVLW  00
0F43:  ADDWFC 46,W
0F44:  MOVWF  7A
0F45:  MOVF   78,W
0F46:  MOVLB  03
0F47:  MOVWF  11
0F48:  MOVF   7A,W
0F49:  MOVWF  12
0F4A:  MOVLB  02
0F4B:  MOVF   49,W
0F4C:  MOVWF  05
0F4D:  MOVF   48,W
0F4E:  MOVWF  04
0F4F:  MOVLW  01
0F50:  MOVWF  4D
0F51:  MOVLB  00
0F52:  CALL   019
....................   c++; 
0F53:  MOVLB  02
0F54:  INCF   47,F
....................   } 
0F55:  GOTO   731
.................... } // }}} 
0F56:  MOVLB  00
0F57:  RETURN
.................... void ExecAuxOutOp(int op,int arg,int ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
1634:  MOVF   32,W
1635:  ANDLW  0F
1636:  MOVWF  34
....................   uarg = (arg & 0xF0) >> 4; 
1637:  MOVF   32,W
1638:  ANDLW  F0
1639:  MOVWF  77
163A:  SWAPF  77,W
163B:  MOVWF  35
163C:  MOVLW  0F
163D:  ANDWF  35,F
....................   switch(op) { 
163E:  MOVF   31,W
163F:  XORLW  01
1640:  MOVLB  00
1641:  BTFSC  03.2
1642:  GOTO   647
1643:  XORLW  03
1644:  BTFSC  03.2
1645:  GOTO   65C
1646:  GOTO   675
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       AuxOut[ID] = ((COR_IN_EFFECTIVE ^ uarg) & larg) != 0; 
1647:  MOVLW  22
1648:  MOVLB  02
1649:  ADDWF  33,W
164A:  MOVWF  04
164B:  MOVLW  20
164C:  MOVWF  05
164D:  BTFSC  03.0
164E:  INCF   05,F
164F:  MOVLB  00
1650:  MOVF   6F,W
1651:  MOVLB  02
1652:  XORWF  35,W
1653:  ANDWF  34,W
1654:  BTFSS  03.2
1655:  GOTO   658
1656:  MOVLW  00
1657:  GOTO   659
1658:  MOVLW  01
1659:  MOVWF  00
....................     break; 
165A:  MOVLB  00
165B:  GOTO   675
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
165C:  MOVLW  22
165D:  MOVLB  02
165E:  ADDWF  33,W
165F:  MOVWF  04
1660:  MOVLW  20
1661:  MOVWF  05
1662:  BTFSC  03.0
1663:  INCF   05,F
1664:  MOVF   34,W
1665:  ANDLW  1F
1666:  MOVWF  38
1667:  MOVF   7A,W
1668:  MOVWF  39
1669:  MOVF   35,W
166A:  XORWF  38,F
166B:  BTFSS  03.2
166C:  GOTO   672
166D:  MOVF   39,F
166E:  BTFSS  03.2
166F:  GOTO   672
1670:  MOVLW  00
1671:  GOTO   673
1672:  MOVLW  01
1673:  MOVWF  00
....................     break; 
1674:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0EB7:  MOVLB  02
0EB8:  CLRF   49
0EB9:  CLRF   4A
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0EBA:  MOVF   49,W
0EBB:  ADDWF  47,W
0EBC:  MOVWF  04
0EBD:  MOVLW  00
0EBE:  ADDWFC 48,W
0EBF:  MOVWF  05
0EC0:  MOVF   00,F
0EC1:  BTFSC  03.2
0EC2:  GOTO   6EC
0EC3:  MOVF   49,W
0EC4:  ADDWF  47,W
0EC5:  MOVWF  04
0EC6:  MOVLW  00
0EC7:  ADDWFC 48,W
0EC8:  MOVWF  05
0EC9:  MOVF   00,W
0ECA:  SUBLW  2F
0ECB:  BTFSC  03.0
0ECC:  GOTO   6EC
0ECD:  MOVF   49,W
0ECE:  ADDWF  47,W
0ECF:  MOVWF  04
0ED0:  MOVLW  00
0ED1:  ADDWFC 48,W
0ED2:  MOVWF  05
0ED3:  MOVF   00,W
0ED4:  SUBLW  39
0ED5:  BTFSS  03.0
0ED6:  GOTO   6EC
....................     value = (value * 10) + (str[x]-'0'); 
0ED7:  MOVF   4A,W
0ED8:  MOVWF  4B
0ED9:  MOVLW  0A
0EDA:  MOVWF  4C
0EDB:  MOVLB  00
0EDC:  CALL   690
0EDD:  MOVF   78,W
0EDE:  MOVLB  02
0EDF:  MOVWF  4B
0EE0:  MOVF   49,W
0EE1:  ADDWF  47,W
0EE2:  MOVWF  04
0EE3:  MOVLW  00
0EE4:  ADDWFC 48,W
0EE5:  MOVWF  05
0EE6:  MOVLW  30
0EE7:  SUBWF  00,W
0EE8:  ADDWF  4B,W
0EE9:  MOVWF  4A
....................     x++; 
0EEA:  INCF   49,F
....................   } 
0EEB:  GOTO   6BA
....................   return(value); 
0EEC:  MOVF   4A,W
0EED:  MOVWF  78
.................... } // }}} 
0EEE:  MOVLB  00
0EEF:  RETURN
.................... void ExecAuxInOp(int op,int arg,int ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
1555:  MOVLB  02
1556:  BCF    34.0
1557:  MOVLW  1F
1558:  ADDWF  33,W
1559:  MOVWF  04
155A:  MOVLW  20
155B:  MOVWF  05
155C:  BTFSC  03.0
155D:  INCF   05,F
155E:  MOVF   00,F
155F:  BTFSS  03.2
1560:  BSF    34.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   // Include arg[4] for COR4 emulation 
....................   larg = arg & 0x1F; 
1561:  MOVF   32,W
1562:  ANDLW  1F
1563:  MOVWF  35
....................   uarg = (arg & 0xF0) >> 4; 
1564:  MOVF   32,W
1565:  ANDLW  F0
1566:  MOVWF  77
1567:  SWAPF  77,W
1568:  MOVWF  36
1569:  MOVLW  0F
156A:  ANDWF  36,F
....................   switch(op) { 
156B:  MOVLW  01
156C:  SUBWF  31,W
156D:  ADDLW  FC
156E:  BTFSC  03.0
156F:  GOTO   5B6
1570:  ADDLW  04
1571:  MOVLB  00
1572:  GOTO   5B9
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
1573:  MOVLB  02
1574:  BTFSS  34.0
1575:  GOTO   57B
....................         Enable_Mask &= arg; 
1576:  MOVF   32,W
1577:  MOVLB  00
1578:  ANDWF  61,F
....................       } else { // AuxIn is not enabled 
1579:  GOTO   580
157A:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
157B:  MOVF   32,W
157C:  XORLW  FF
157D:  ANDLW  0F
157E:  MOVLB  00
157F:  IORWF  61,F
....................       } 
....................       break; 
1580:  MOVLB  02
1581:  GOTO   5B6
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
1582:  MOVLB  02
1583:  BTFSS  34.0
1584:  GOTO   58B
....................         COR_DROP_FLAG=1; 
1585:  BSF    72.7
....................         TailChar=arg; 
1586:  MOVF   32,W
1587:  MOVLB  00
1588:  MOVWF  6A
....................       } else { 
1589:  GOTO   58D
158A:  MOVLB  02
....................         TailChar=0; 
158B:  MOVLB  00
158C:  CLRF   6A
....................       } 
....................     break; 
158D:  MOVLB  02
158E:  GOTO   5B6
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
158F:  MOVLB  02
1590:  BTFSC  34.0
1591:  GOTO   598
....................         COR_DROP_FLAG=1; 
1592:  BSF    72.7
....................         TailChar=arg; 
1593:  MOVF   32,W
1594:  MOVLB  00
1595:  MOVWF  6A
....................       } else { 
1596:  GOTO   59A
1597:  MOVLB  02
....................         TailChar=0; 
1598:  MOVLB  00
1599:  CLRF   6A
....................       } 
....................     break; 
159A:  MOVLB  02
159B:  GOTO   5B6
....................     case AUXI_EMULATE_COR: 
....................       if ( (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0 ) { 
159C:  MOVLB  02
159D:  MOVF   32,W
159E:  ANDLW  20
159F:  BTFSC  03.2
15A0:  GOTO   5A5
....................         tmp_bit = ~in_bit; 
15A1:  BCF    34.1
15A2:  BTFSS  34.0
15A3:  BSF    34.1
....................       } else { 
15A4:  GOTO   5A8
....................         tmp_bit = in_bit; 
15A5:  BCF    34.1
15A6:  BTFSC  34.0
15A7:  BSF    34.1
....................       } 
....................       if ( tmp_bit ) { 
15A8:  BTFSS  34.1
15A9:  GOTO   5AF
....................         COR_EMUL |= larg; 
15AA:  MOVF   35,W
15AB:  MOVLB  00
15AC:  IORWF  69,F
....................       } else { 
15AD:  GOTO   5B3
15AE:  MOVLB  02
....................         COR_EMUL &= ~larg; 
15AF:  MOVF   35,W
15B0:  XORLW  FF
15B1:  MOVLB  00
15B2:  ANDWF  69,F
....................       } 
....................     break; 
15B3:  MOVLB  02
15B4:  GOTO   5B6
15B5:  MOVLB  02
....................   } 
.................... } // }}} 
15B6:  MOVLP  10
15B7:  MOVLB  00
15B8:  GOTO   6E6 (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
1508:  MOVLB  01
1509:  CLRF   6E
150A:  MOVF   6E,W
150B:  SUBLW  02
150C:  BTFSS  03.0
150D:  GOTO   552
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = (input(AUX_IN_PIN[x])!=0) || (AuxIn[x]!=0); 
150E:  MOVLW  1F
150F:  ADDWF  6E,W
1510:  MOVWF  78
1511:  MOVLW  20
1512:  MOVWF  7A
1513:  BTFSC  03.0
1514:  INCF   7A,F
1515:  MOVF   78,W
1516:  MOVLB  02
1517:  MOVWF  20
1518:  MOVF   7A,W
1519:  MOVWF  21
151A:  MOVLB  01
151B:  MOVF   6E,W
151C:  MOVLP  00
151D:  MOVLB  00
151E:  CALL   03F
151F:  MOVLP  10
1520:  MOVLB  02
1521:  MOVWF  22
1522:  MOVWF  48
1523:  MOVLW  01
1524:  MOVWF  49
1525:  CLRF   4B
1526:  MOVLW  80
1527:  MOVWF  4A
1528:  MOVLP  08
1529:  MOVLB  00
152A:  CALL   0F3
152B:  MOVLP  10
152C:  MOVLB  02
152D:  MOVF   22,W
152E:  MOVWF  23
152F:  CLRF   25
1530:  CLRF   24
1531:  MOVLB  00
1532:  GOTO   4EE
1533:  BTFSC  78.0
1534:  GOTO   545
1535:  MOVLW  1C
1536:  MOVLB  01
1537:  ADDWF  6E,W
1538:  MOVWF  04
1539:  MOVLW  20
153A:  MOVWF  05
153B:  BTFSC  03.0
153C:  INCF   05,F
153D:  MOVF   00,F
153E:  BTFSC  03.2
153F:  GOTO   542
1540:  MOVLB  00
1541:  GOTO   545
1542:  MOVLW  00
1543:  GOTO   547
1544:  MOVLB  00
1545:  MOVLW  01
1546:  MOVLB  01
1547:  MOVLB  02
1548:  MOVWF  23
1549:  MOVF   21,W
154A:  MOVWF  05
154B:  MOVF   20,W
154C:  MOVWF  04
154D:  MOVF   23,W
154E:  MOVWF  00
....................   } 
154F:  MOVLB  01
1550:  INCF   6E,F
1551:  GOTO   50A
.................... } // }}} 
1552:  MOVLP  18
1553:  MOVLB  00
1554:  GOTO   68E (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
15FA:  MOVLW  30
15FB:  MOVLB  02
15FC:  MOVWF  21
15FD:  MOVWF  22
15FE:  MOVWF  23
15FF:  CLRF   24
....................   char AuxOut_s[4]={'0','0','0',0}; 
1600:  MOVWF  25
1601:  MOVWF  26
1602:  MOVWF  27
1603:  CLRF   28
....................   char ADM[]=" ADMIN"; 
1604:  MOVLW  20
1605:  MOVWF  29
1606:  MOVLW  41
1607:  MOVWF  2A
1608:  MOVLW  44
1609:  MOVWF  2B
160A:  MOVLW  4D
160B:  MOVWF  2C
160C:  MOVLW  49
160D:  MOVWF  2D
160E:  MOVLW  4E
160F:  MOVWF  2E
1610:  CLRF   2F
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
1611:  MOVLB  01
1612:  CLRF   6E
1613:  MOVF   6E,W
1614:  SUBLW  02
1615:  BTFSS  03.0
1616:  GOTO   6E9
....................     AuxOp = AuxOutOp[x]; 
1617:  MOVLW  33
1618:  ADDWF  6E,W
1619:  MOVWF  04
161A:  MOVLW  20
161B:  MOVWF  05
161C:  BTFSC  03.0
161D:  INCF   05,F
161E:  MOVF   00,W
161F:  MOVWF  6F
....................     AuxArg = AuxOutArg[x]; 
1620:  MOVLW  36
1621:  ADDWF  6E,W
1622:  MOVWF  04
1623:  MOVLW  20
1624:  MOVWF  05
1625:  BTFSC  03.0
1626:  INCF   05,F
1627:  MOVF   00,W
1628:  MOVLB  02
1629:  MOVWF  20
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
162A:  MOVLB  01
162B:  MOVF   6F,W
162C:  MOVLB  02
162D:  MOVWF  31
162E:  MOVF   20,W
162F:  MOVWF  32
1630:  MOVLB  01
1631:  MOVF   6E,W
1632:  MOVLB  02
1633:  MOVWF  33
....................     out_bit = (AuxOut[x])==0; 
*
1675:  MOVLB  02
1676:  BCF    30.0
1677:  MOVLW  22
1678:  MOVLB  01
1679:  ADDWF  6E,W
167A:  MOVWF  04
167B:  MOVLW  20
167C:  MOVWF  05
167D:  BTFSC  03.0
167E:  INCF   05,F
167F:  MOVF   00,F
1680:  BTFSS  03.2
1681:  GOTO   685
1682:  MOVLB  02
1683:  BSF    30.0
1684:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
1685:  MOVF   6E,W
1686:  MOVLP  00
1687:  MOVLB  00
1688:  CALL   03B
1689:  MOVLP  10
168A:  MOVLB  02
168B:  MOVWF  31
168C:  MOVLW  00
168D:  BTFSC  30.0
168E:  MOVLW  01
168F:  MOVWF  77
1690:  MOVF   31,W
1691:  MOVWF  48
1692:  MOVF   77,W
1693:  MOVWF  49
1694:  MOVLW  01
1695:  MOVWF  4B
1696:  CLRF   4A
1697:  MOVLP  08
1698:  MOVLB  00
1699:  CALL   0F3
169A:  MOVLP  10
169B:  MOVLB  02
169C:  MOVF   31,W
169D:  MOVWF  48
169E:  CLRF   49
169F:  CLRF   4B
16A0:  MOVLW  80
16A1:  MOVWF  4A
16A2:  MOVLP  08
16A3:  MOVLB  00
16A4:  CALL   0F3
16A5:  MOVLP  10
....................     if(out_bit==0) { 
16A6:  MOVLB  02
16A7:  BTFSC  30.0
16A8:  GOTO   6B4
....................       AuxOut_s[x]='1'; 
16A9:  MOVLW  A5
16AA:  MOVLB  01
16AB:  ADDWF  6E,W
16AC:  MOVWF  04
16AD:  MOVLW  20
16AE:  MOVWF  05
16AF:  BTFSC  03.0
16B0:  INCF   05,F
16B1:  MOVLW  31
16B2:  MOVWF  00
16B3:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
16B4:  MOVLW  39
16B5:  MOVLB  01
16B6:  ADDWF  6E,W
16B7:  MOVWF  04
16B8:  MOVLW  20
16B9:  MOVWF  05
16BA:  BTFSC  03.0
16BB:  INCF   05,F
16BC:  MOVF   00,W
16BD:  MOVWF  6F
....................     AuxArg = AuxInArg[x]; 
16BE:  MOVLW  3C
16BF:  ADDWF  6E,W
16C0:  MOVWF  04
16C1:  MOVLW  20
16C2:  MOVWF  05
16C3:  BTFSC  03.0
16C4:  INCF   05,F
16C5:  MOVF   00,W
16C6:  MOVLB  02
16C7:  MOVWF  20
....................     if(AuxInSW[x]==1) { 
16C8:  MOVLW  1F
16C9:  MOVLB  01
16CA:  ADDWF  6E,W
16CB:  MOVWF  04
16CC:  MOVLW  20
16CD:  MOVWF  05
16CE:  BTFSC  03.0
16CF:  INCF   05,F
16D0:  DECFSZ 00,W
16D1:  GOTO   6DB
....................       AuxIn_s[x]='1'; 
16D2:  MOVLW  A1
16D3:  ADDWF  6E,W
16D4:  MOVWF  04
16D5:  MOVLW  20
16D6:  MOVWF  05
16D7:  BTFSC  03.0
16D8:  INCF   05,F
16D9:  MOVLW  31
16DA:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
16DB:  MOVF   6F,W
16DC:  MOVLB  02
16DD:  MOVWF  31
16DE:  MOVF   20,W
16DF:  MOVWF  32
16E0:  MOVLB  01
16E1:  MOVF   6E,W
16E2:  MOVLB  02
16E3:  MOVWF  33
16E4:  MOVLB  00
16E5:  GOTO   555
....................     // }}} 
....................   } 
16E6:  MOVLB  01
16E7:  INCF   6E,F
16E8:  GOTO   613
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
16E9:  MOVLW  20
16EA:  MOVWF  64
16EB:  MOVLW  76
16EC:  MOVWF  63
16ED:  MOVLW  49
16EE:  MOVLB  02
16EF:  MOVWF  58
16F0:  MOVLP  08
16F1:  MOVLB  00
16F2:  CALL   115
16F3:  MOVLP  10
16F4:  MOVLW  3A
16F5:  MOVLB  02
16F6:  MOVWF  58
16F7:  MOVLP  08
16F8:  MOVLB  00
16F9:  CALL   115
16FA:  MOVLP  10
16FB:  MOVLW  20
16FC:  MOVWF  05
16FD:  MOVLW  A1
16FE:  MOVWF  04
16FF:  MOVLP  08
1700:  CALL   177
1701:  MOVLP  10
1702:  MOVLW  20
1703:  MOVLB  02
1704:  MOVWF  58
1705:  MOVLP  08
1706:  MOVLB  00
1707:  CALL   115
1708:  MOVLP  10
1709:  MOVLW  4F
170A:  MOVLB  02
170B:  MOVWF  58
170C:  MOVLP  08
170D:  MOVLB  00
170E:  CALL   115
170F:  MOVLP  10
1710:  MOVLW  3A
1711:  MOVLB  02
1712:  MOVWF  58
1713:  MOVLP  08
1714:  MOVLB  00
1715:  CALL   115
1716:  MOVLP  10
1717:  MOVLW  20
1718:  MOVWF  05
1719:  MOVLW  A5
171A:  MOVWF  04
171B:  MOVLP  08
171C:  CALL   177
171D:  MOVLP  10
....................   if ( AdminMode ) { 
171E:  MOVLB  01
171F:  BTFSS  5D.7
1720:  GOTO   72D
....................     strcat(LCD_str,ADM); 
1721:  MOVLW  20
1722:  MOVLB  02
1723:  MOVWF  32
1724:  MOVLW  76
1725:  MOVWF  31
1726:  MOVLW  20
1727:  MOVWF  34
1728:  MOVLW  A9
1729:  MOVWF  33
172A:  MOVLB  00
172B:  CALL   5C1
172C:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
172D:  MOVLW  03
172E:  MOVLB  02
172F:  MOVWF  52
1730:  MOVLW  20
1731:  MOVWF  54
1732:  MOVLW  76
1733:  MOVWF  53
1734:  MOVLP  08
1735:  MOVLB  00
1736:  CALL   18C
1737:  MOVLP  10
.................... } // }}} 
1738:  RETURN
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
1018:  MOVLW  01
1019:  MOVLB  02
101A:  MOVWF  36
101B:  MOVLP  08
101C:  MOVLB  00
101D:  CALL   361
101E:  MOVLP  10
....................   delay_ms(1000); 
101F:  MOVLW  04
1020:  MOVLB  02
1021:  MOVWF  36
1022:  MOVLW  FA
1023:  MOVWF  52
1024:  MOVLP  08
1025:  MOVLB  00
1026:  CALL   000
1027:  MOVLP  10
1028:  MOVLB  02
1029:  DECFSZ 36,F
102A:  GOTO   022
....................   for(x=0;x<6;x++) { 
102B:  CLRF   34
102C:  MOVF   34,W
102D:  SUBLW  05
102E:  BTFSS  03.0
102F:  GOTO   04C
....................     mchar=Morse[x]; 
1030:  MOVLW  2D
1031:  ADDWF  34,W
1032:  MOVWF  04
1033:  MOVLW  20
1034:  MOVWF  05
1035:  BTFSC  03.0
1036:  INCF   05,F
1037:  MOVF   00,W
1038:  MOVWF  35
....................     morse(mchar); 
1039:  MOVF   35,W
103A:  MOVWF  47
103B:  MOVLP  08
103C:  MOVLB  00
103D:  CALL   09C
103E:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
103F:  MOVLB  01
1040:  CLRF   33
1041:  MOVLW  06
1042:  MOVWF  32
....................     while(aux_timer) { 
1043:  MOVF   32,W
1044:  IORWF  33,W
1045:  BTFSC  03.2
1046:  GOTO   049
....................       delay_cycles(1); 
1047:  NOP
....................     } 
1048:  GOTO   043
....................   } 
1049:  MOVLB  02
104A:  INCF   34,F
104B:  GOTO   02C
....................   delay_ms(1000); 
104C:  MOVLW  04
104D:  MOVWF  36
104E:  MOVLW  FA
104F:  MOVWF  52
1050:  MOVLP  08
1051:  MOVLB  00
1052:  CALL   000
1053:  MOVLP  10
1054:  MOVLB  02
1055:  DECFSZ 36,F
1056:  GOTO   04E
....................   COR_FLAG=1; 
1057:  BSF    72.3
.................... } // }}} 
1058:  MOVLB  00
1059:  RETURN
.................... void main (void) { // {{{ 
*
1DA5:  CLRF   05
1DA6:  CLRF   04
1DA7:  MOVLW  1F
1DA8:  ANDWF  03,F
1DA9:  MOVLW  72
1DAA:  MOVLB  01
1DAB:  MOVWF  19
1DAC:  BSF    0E.3
1DAD:  BSF    0E.4
1DAE:  MOVLB  04
1DAF:  BCF    17.0
1DB0:  BCF    17.1
1DB1:  BCF    17.3
1DB2:  MOVLW  13
1DB3:  MOVWF  12
1DB4:  MOVLW  28
1DB5:  MOVWF  15
1DB6:  BSF    14.7
1DB7:  BCF    14.6
1DB8:  MOVLW  0C
1DB9:  MOVLB  03
1DBA:  MOVWF  1B
1DBB:  MOVLW  A2
1DBC:  MOVWF  1E
1DBD:  MOVLW  90
1DBE:  MOVWF  1D
1DBF:  MOVLB  01
1DC0:  BSF    62.1
1DC1:  CLRF   64
1DC2:  CLRF   63
1DC3:  MOVLB  0F
1DC4:  CLRF   11
1DC5:  CLRF   12
1DC6:  CLRF   18
1DC7:  CLRF   19
1DC8:  CLRF   1A
1DC9:  MOVLB  03
1DCA:  CLRF   0C
1DCB:  CLRF   0D
1DCC:  CLRF   0F
1DCD:  CLRF   10
1DCE:  MOVLB  02
1DCF:  CLRF   12
1DD0:  CLRF   11
1DD1:  CLRF   14
1DD2:  CLRF   13
....................   int x,dtmf; 
....................   char tmp[5]; 
....................   initialize(); 
*
1DD6:  MOVLP  08
1DD7:  GOTO   4C4
1DD8:  MOVLP  18
....................   char enter_b,select_b; 
....................  
....................   setup_adc(ADC_CLOCK_INTERNAL); 
1DD9:  MOVLB  01
1DDA:  BSF    1E.4
1DDB:  BSF    1E.5
1DDC:  BCF    1E.6
1DDD:  BCF    1E.7
1DDE:  BSF    1D.0
....................   setup_adc_ports(ADJ_POT|VSS_VDD); 
1DDF:  BCF    1E.0
1DE0:  BCF    1E.1
1DE1:  BCF    1E.2
1DE2:  MOVLW  00
1DE3:  MOVLB  03
1DE4:  MOVWF  0C
1DE5:  MOVWF  10
1DE6:  MOVLW  20
1DE7:  MOVWF  0D
1DE8:  MOVLW  00
1DE9:  MOVWF  0F
....................   set_adc_channel(13); 
1DEA:  MOVLW  34
1DEB:  MOVWF  78
1DEC:  MOVLB  01
1DED:  MOVF   1D,W
1DEE:  ANDLW  83
1DEF:  IORWF  78,W
1DF0:  MOVWF  1D
....................  
.................... #ignore_warnings 203 
....................   while(1) { // {{{ 
.................... #ignore_warnings none 
....................     restart_wdt(); 
1DF1:  CLRWDT
.................... #ifdef BUTTON_STATES 
....................   // Process Enter / select buttons {{{ 
....................   if ( input(ENTER_BUTTON)==0 ) { 
1DF2:  BSF    0C.7
1DF3:  MOVLB  00
1DF4:  BTFSC  0C.7
1DF5:  GOTO   602
....................     ENTER_PRESSED = (enter_b == DEBOUNCE_COUNT); 
1DF6:  BCF    72.1
1DF7:  MOVLB  01
1DF8:  MOVF   6C,W
1DF9:  SUBLW  08
1DFA:  BTFSC  03.2
1DFB:  BSF    72.1
....................     if ( enter_b < DEBOUNCE_COUNT+ 1 ) { 
1DFC:  MOVF   6C,W
1DFD:  SUBLW  08
1DFE:  BTFSC  03.0
....................       enter_b++;  
1DFF:  INCF   6C,F
....................     } 
....................   } else { 
1E00:  GOTO   605
1E01:  MOVLB  00
....................     enter_b = 0; 
1E02:  MOVLB  01
1E03:  CLRF   6C
....................     ENTER_PRESSED = 0; 
1E04:  BCF    72.1
....................   } 
....................   if ( input(SELECT_BUTTON)==0 ) { 
1E05:  MOVLB  00
1E06:  BTFSC  10.3
1E07:  GOTO   614
....................     SELECT_PRESSED = (select_b == DEBOUNCE_COUNT); 
1E08:  BCF    72.2
1E09:  MOVLB  01
1E0A:  MOVF   6D,W
1E0B:  SUBLW  08
1E0C:  BTFSC  03.2
1E0D:  BSF    72.2
....................     if ( select_b < DEBOUNCE_COUNT + 1 ) { 
1E0E:  MOVF   6D,W
1E0F:  SUBLW  08
1E10:  BTFSC  03.0
....................       select_b++; 
1E11:  INCF   6D,F
....................     } 
....................   } else { 
1E12:  GOTO   617
1E13:  MOVLB  00
....................     select_b = 0; 
1E14:  MOVLB  01
1E15:  CLRF   6D
....................     SELECT_PRESSED = 0; 
1E16:  BCF    72.2
....................   } 
....................   // Define Button States 
....................   // IDLE + ENTER --> TRIM 
....................   // TRIM + ENTER --> Exit 
....................   // TRIM + SELECT --> NextPot 
....................   switch (button_state) { 
1E17:  MOVF   5C,W
1E18:  XORLW  00
1E19:  MOVLB  00
1E1A:  BTFSC  03.2
1E1B:  GOTO   623
1E1C:  XORLW  10
1E1D:  BTFSC  03.2
1E1E:  GOTO   62A
1E1F:  XORLW  1F
1E20:  BTFSC  03.2
1E21:  GOTO   63C
1E22:  GOTO   67C
....................     case BUTTON_IDLE:   
....................       if ( ENTER_PRESSED == 1 ) { 
1E23:  BTFSS  72.1
1E24:  GOTO   629
....................         button_state=CALIB; 
1E25:  MOVLW  10
1E26:  MOVLB  01
1E27:  MOVWF  5C
1E28:  MOVLB  00
....................       } 
....................     break; 
1E29:  GOTO   67F
....................     case CALIB: 
....................       adj_value_a = read_adc() >> 2; 
1E2A:  MOVLB  01
1E2B:  BSF    1D.1
1E2C:  BTFSC  1D.1
1E2D:  GOTO   62C
1E2E:  RRF    1C,W
1E2F:  MOVWF  7E
1E30:  RRF    7E,F
1E31:  MOVLW  3F
1E32:  ANDWF  7E,F
....................       adj_value_b = adj_value_a; 
1E33:  MOVF   7E,W
1E34:  MOVWF  5B
....................       button_state=TRIM; 
1E35:  MOVLW  0F
1E36:  MOVWF  5C
....................       pot_values_to_lcd(); 
1E37:  MOVLP  08
1E38:  MOVLB  00
1E39:  CALL   271
1E3A:  MOVLP  18
....................       break; 
1E3B:  GOTO   67F
....................     case TRIM: 
....................        if ( ((COR_IN|COR_EMUL)&0x0F) != 0 ) { 
1E3C:  MOVF   5F,W
1E3D:  IORWF  69,W
1E3E:  ANDLW  0F
1E3F:  BTFSC  03.2
1E40:  GOTO   665
....................          adj_value_a = read_adc() >> 2; 
1E41:  MOVLB  01
1E42:  BSF    1D.1
1E43:  BTFSC  1D.1
1E44:  GOTO   643
1E45:  RRF    1C,W
1E46:  MOVWF  7E
1E47:  RRF    7E,F
1E48:  MOVLW  3F
1E49:  ANDWF  7E,F
....................          if ( adj_value_a != adj_value_b ) { 
1E4A:  MOVF   5B,W
1E4B:  SUBWF  7E,W
1E4C:  BTFSC  03.2
1E4D:  GOTO   662
....................            rs232_mode = 1; 
1E4E:  BSF    62.0
....................            set_trimpot(CurrentTrimPot, 63-adj_value_a); 
1E4F:  MOVF   7E,W
1E50:  SUBLW  3F
1E51:  MOVWF  6E
1E52:  MOVF   74,W
1E53:  MOVLB  02
1E54:  MOVWF  47
1E55:  MOVLB  01
1E56:  MOVF   6E,W
1E57:  MOVLB  02
1E58:  MOVWF  48
1E59:  MOVLP  00
1E5A:  MOVLB  00
1E5B:  CALL   78C
1E5C:  MOVLP  18
....................            pot_values_to_lcd(); 
1E5D:  MOVLP  08
1E5E:  CALL   271
1E5F:  MOVLP  18
....................            rs232_mode = 0; 
1E60:  MOVLB  01
1E61:  BCF    62.0
....................          } 
....................          adj_value_b = adj_value_a; 
1E62:  MOVF   7E,W
1E63:  MOVWF  5B
1E64:  MOVLB  00
.................... 	     } 
....................        if ( SELECT_PRESSED == 1 ) { 
1E65:  BTFSS  72.2
1E66:  GOTO   66E
....................          CurrentTrimPot = (CurrentTrimPot + 1 ) & 0x03; 
1E67:  MOVLW  01
1E68:  ADDWF  74,W
1E69:  ANDLW  03
1E6A:  MOVWF  74
....................          pot_values_to_lcd(); 
1E6B:  MOVLP  08
1E6C:  CALL   271
1E6D:  MOVLP  18
....................        } 
....................        if ( ENTER_PRESSED == 1 ) { 
1E6E:  BTFSS  72.1
1E6F:  GOTO   678
....................          // Hold SELECT and press ENTER to store settings in EEPROM 
....................          if ( input(SELECT_BUTTON)==0 ) { 
1E70:  BTFSC  10.3
1E71:  GOTO   675
....................            store_variables(); 
1E72:  MOVLP  00
1E73:  CALL   5CB
1E74:  MOVLP  18
....................          } 
....................          button_state = BUTTON_IDLE; 
1E75:  MOVLB  01
1E76:  CLRF   5C
1E77:  MOVLB  00
.................... 	     }  
....................        status_led(); 
1E78:  MOVLP  08
1E79:  GOTO   587
1E7A:  MOVLP  18
....................     break; 
1E7B:  GOTO   67F
....................     default: 
....................   		button_state = BUTTON_IDLE; 
1E7C:  MOVLB  01
1E7D:  CLRF   5C
....................     break; 
1E7E:  MOVLB  00
....................   } 
....................   restart_wdt(); 
1E7F:  CLRWDT
....................   // }}} 
.................... #endif 
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "\r" or "+" or "-" is received. 
....................     if ( sBufferFlag ) { 
1E80:  BTFSS  72.0
1E81:  GOTO   687
....................       process_sBuffer(); 
1E82:  GOTO   000
....................       clear_sBuffer(); 
1E83:  MOVLP  00
1E84:  CALL   4BE
1E85:  MOVLP  18
....................       sBufferFlag=0; 
1E86:  BCF    72.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1E87:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1E88:  MOVLB  01
1E89:  BTFSS  5D.0
1E8A:  GOTO   691
....................       update_aux_in(); 
1E8B:  MOVLP  10
1E8C:  MOVLB  00
1E8D:  GOTO   508
1E8E:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1E8F:  MOVLB  01
1E90:  BCF    5D.0
....................     } 
....................     // Second Flag {{{ 
....................     if ( SECOND_FLAG ) { 
1E91:  BTFSS  72.4
1E92:  GOTO   6D5
....................       update_aux_out(); 
1E93:  MOVLP  10
1E94:  MOVLB  00
1E95:  CALL   5FA
1E96:  MOVLP  18
....................       // Time Out PTT {{{ 
....................       if ( TOT_SecondCounter || TOT_Min == 0) { 
1E97:  MOVLB  01
1E98:  MOVF   60,W
1E99:  IORWF  61,W
1E9A:  BTFSS  03.2
1E9B:  GOTO   6A1
1E9C:  MOVLB  00
1E9D:  MOVF   66,F
1E9E:  BTFSS  03.2
1E9F:  GOTO   6A7
1EA0:  MOVLB  01
....................         TOT_SecondCounter--; 
1EA1:  MOVF   60,W
1EA2:  BTFSC  03.2
1EA3:  DECF   61,F
1EA4:  DECF   60,F
....................       } else if ( COR_IN != 0x00 ) { 
1EA5:  GOTO   6BB
1EA6:  MOVLB  00
1EA7:  MOVF   5F,F
1EA8:  BTFSC  03.2
1EA9:  GOTO   6BC
....................         update_ptt(0); 
1EAA:  MOVLB  02
1EAB:  CLRF   36
1EAC:  MOVLP  08
1EAD:  MOVLB  00
1EAE:  CALL   361
1EAF:  MOVLP  18
....................         printf("\n\r# PTT Timeout!\n"); 
1EB0:  MOVLW  A7
1EB1:  MOVLB  03
1EB2:  MOVWF  11
1EB3:  MOVLW  04
1EB4:  MOVWF  12
1EB5:  MOVLP  00
1EB6:  MOVLB  00
1EB7:  CALL   4D8
1EB8:  MOVLP  18
....................         PROMPT_FLAG=1; 
1EB9:  MOVLB  01
1EBA:  BSF    5D.6
1EBB:  MOVLB  00
....................       } 
....................       // }}} 
....................       // Admin mode timeout {{{ 
....................       if ( admin_timer ) { 
1EBC:  MOVF   73,F
1EBD:  BTFSC  03.2
1EBE:  GOTO   6C1
....................         admin_timer--; 
1EBF:  DECF   73,F
....................       } else { 
1EC0:  GOTO   6CA
....................         // Exit admin mode. 
....................         if ( AdminMode ) { 
1EC1:  MOVLB  01
1EC2:  BTFSS  5D.7
1EC3:  GOTO   6CB
....................           set_admin_mode(0); 
1EC4:  MOVLB  02
1EC5:  CLRF   48
1EC6:  MOVLP  08
1EC7:  MOVLB  00
1EC8:  CALL   4AD
1EC9:  MOVLP  18
1ECA:  MOVLB  01
....................         } 
....................       } 
....................       // }}} 
....................       restart_wdt(); 
1ECB:  CLRWDT
....................       if ( SecondCounter ) { 
1ECC:  MOVF   5E,F
1ECD:  BTFSC  03.2
1ECE:  GOTO   6D1
....................         SecondCounter--; 
1ECF:  DECF   5E,F
....................       } else { 
1ED0:  GOTO   6D4
....................         SecondCounter=SEC_COUNTER; 
1ED1:  MOVLW  3B
1ED2:  MOVWF  5E
....................         MINUTE_FLAG = 1; 
1ED3:  BSF    72.5
....................       } 
....................       SECOND_FLAG=0; 
1ED4:  BCF    72.4
....................     } 
....................     // Second Flag }}} 
....................     // Minute flag {{{ 
....................     if ( MINUTE_FLAG ) { 
1ED5:  BTFSS  72.5
1ED6:  GOTO   6F4
....................       if ( MinuteCounter ) { 
1ED7:  MOVF   5F,F
1ED8:  BTFSC  03.2
1ED9:  GOTO   6DC
....................         MinuteCounter--; 
1EDA:  DECF   5F,F
....................       } else { 
1EDB:  GOTO   6DF
....................         THIRTY_MIN_FLAG=1; 
1EDC:  BSF    72.6
....................         MinuteCounter = MIN_COUNTER; 
1EDD:  MOVLW  1D
1EDE:  MOVWF  5F
....................       } 
....................       MINUTE_FLAG = 0; 
1EDF:  BCF    72.5
....................       // Link timeout timer {{{ 
....................       if ( Link_TOT != 0 ) { 
1EE0:  MOVLB  00
1EE1:  MOVF   67,F
1EE2:  BTFSC  03.2
1EE3:  GOTO   6F3
....................         if ( LinkDurationTimer ) { 
1EE4:  MOVF   68,F
1EE5:  BTFSC  03.2
1EE6:  GOTO   6E9
....................           LinkDurationTimer--; 
1EE7:  DECF   68,F
....................         } else { 
1EE8:  GOTO   6F3
....................           // Disable Link 
....................           printf("\n\r# Link Timeout!\n"); 
1EE9:  MOVLW  B0
1EEA:  MOVLB  03
1EEB:  MOVWF  11
1EEC:  MOVLW  04
1EED:  MOVWF  12
1EEE:  MOVLP  00
1EEF:  MOVLB  00
1EF0:  CALL   4D8
1EF1:  MOVLP  18
....................           Enable&=0xFE; 
1EF2:  BCF    60.0
1EF3:  MOVLB  01
....................         } 
....................       } 
....................       // Link timeout timer }}} 
....................     } 
....................     // Minute flag }}} 
....................     if ( THIRTY_MIN_FLAG ) { 
1EF4:  BTFSS  72.6
1EF5:  GOTO   712
....................       if ( (TXSiteID&0x03) !=0 ) { 
1EF6:  MOVLB  00
1EF7:  MOVF   64,W
1EF8:  ANDLW  03
1EF9:  BTFSC  03.2
1EFA:  GOTO   70F
....................         // Transmit Site ID every 30 mins when: 
....................         // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................         // E = Transmit every 30 mins 
....................         // M = Transmit only if EnableMask is off 
....................         if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
1EFB:  MOVF   64,W
1EFC:  ANDLW  01
1EFD:  BTFSS  03.2
1EFE:  GOTO   70C
1EFF:  MOVF   64,W
1F00:  ANDLW  02
1F01:  BTFSC  03.2
1F02:  GOTO   70F
1F03:  SWAPF  64,W
1F04:  MOVWF  77
1F05:  MOVLW  0F
1F06:  ANDWF  77,F
1F07:  MOVF   77,W
1F08:  ANDLW  0F
1F09:  ANDWF  60,W
1F0A:  BTFSS  03.2
1F0B:  GOTO   70F
....................           send_morse_id(); 
1F0C:  MOVLP  10
1F0D:  CALL   018
1F0E:  MOVLP  18
....................         } 
....................       } 
....................       THIRTY_MIN_FLAG=0; 
1F0F:  BCF    72.6
....................       restart_wdt(); 
1F10:  CLRWDT
1F11:  MOVLB  01
....................     } 
....................     if ( COR_FLAG ) { 
1F12:  BTFSS  72.3
1F13:  GOTO   71E
....................       process_cor(); 
1F14:  MOVLP  10
1F15:  MOVLB  00
1F16:  GOTO   739
1F17:  MOVLP  18
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       update_aux_out();  
1F18:  MOVLP  10
1F19:  CALL   5FA
1F1A:  MOVLP  18
....................       COR_FLAG=0; 
1F1B:  BCF    72.3
....................       restart_wdt(); 
1F1C:  CLRWDT
1F1D:  MOVLB  01
....................     } 
....................     if ( DTMF_INTERRUPT_FLAG ) { 
1F1E:  BTFSS  5D.4
1F1F:  GOTO   724
....................       // Extract data from DTMF device 
....................       process_dtmf_interrupt(); 
1F20:  MOVLB  00
1F21:  GOTO   428
....................       DTMF_INTERRUPT_FLAG=0; 
1F22:  MOVLB  01
1F23:  BCF    5D.4
....................     } 
....................     if ( DTMF_IN_FLAG ) { 
1F24:  BTFSS  5D.3
1F25:  GOTO   7B7
....................       strcpy(LCD_str,"DTMF:"); 
1F26:  CLRF   6E
1F27:  CLRF   6F
1F28:  MOVLW  20
1F29:  MOVWF  05
1F2A:  MOVLW  76
1F2B:  MOVWF  04
1F2C:  MOVF   6E,W
1F2D:  ADDWF  04,F
1F2E:  MOVLW  00
1F2F:  ADDWFC 05,F
1F30:  MOVF   6F,W
1F31:  MOVLP  00
1F32:  MOVLB  00
1F33:  CALL   188
1F34:  MOVLP  18
1F35:  MOVWF  00
1F36:  IORLW  00
1F37:  BTFSC  03.2
1F38:  GOTO   73E
1F39:  MOVLB  01
1F3A:  INCF   6F,F
1F3B:  INCF   6E,F
1F3C:  GOTO   728
1F3D:  MOVLB  00
....................       printf("\n\rDTMF="); 
1F3E:  MOVLW  BA
1F3F:  MOVLB  03
1F40:  MOVWF  11
1F41:  MOVLW  04
1F42:  MOVWF  12
1F43:  MOVLP  00
1F44:  MOVLB  00
1F45:  CALL   4D8
1F46:  MOVLP  18
....................       for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1F47:  MOVLB  01
1F48:  CLRF   65
1F49:  MOVF   65,W
1F4A:  SUBLW  09
1F4B:  BTFSS  03.0
1F4C:  GOTO   795
....................         if(DTMF_ARRAY[x].Strobe) { 
1F4D:  MOVLW  64
1F4E:  ADDWF  65,W
1F4F:  MOVWF  04
1F50:  MOVLW  20
1F51:  MOVWF  05
1F52:  BTFSC  03.0
1F53:  INCF   05,F
1F54:  BTFSS  00.4
1F55:  GOTO   792
....................           dtmf=(int)DTMF_ARRAY[x].Key; 
1F56:  MOVLW  64
1F57:  ADDWF  65,W
1F58:  MOVWF  04
1F59:  MOVLW  20
1F5A:  MOVWF  05
1F5B:  BTFSC  03.0
1F5C:  INCF   05,F
1F5D:  MOVF   00,W
1F5E:  ANDLW  0F
1F5F:  MOVWF  66
....................           sprintf(tmp,"%d ",dtmf); 
1F60:  MOVLW  20
1F61:  MOVWF  64
1F62:  MOVLW  97
1F63:  MOVWF  63
1F64:  MOVF   66,W
1F65:  MOVLB  02
1F66:  MOVWF  52
1F67:  MOVLW  18
1F68:  MOVWF  53
1F69:  MOVLP  08
1F6A:  MOVLB  00
1F6B:  CALL   1F0
1F6C:  MOVLP  18
1F6D:  MOVLW  20
1F6E:  MOVLB  02
1F6F:  MOVWF  58
1F70:  MOVLP  08
1F71:  MOVLB  00
1F72:  CALL   115
1F73:  MOVLP  18
....................           strcat(LCD_str,tmp); 
1F74:  MOVLW  20
1F75:  MOVLB  02
1F76:  MOVWF  32
1F77:  MOVLW  76
1F78:  MOVWF  31
1F79:  MOVLW  20
1F7A:  MOVWF  34
1F7B:  MOVLW  97
1F7C:  MOVWF  33
1F7D:  MOVLP  10
1F7E:  MOVLB  00
1F7F:  CALL   5C1
1F80:  MOVLP  18
....................           printf(" %u",dtmf); 
1F81:  MOVLW  20
1F82:  CLRWDT
1F83:  BTFSS  11.4
1F84:  GOTO   782
1F85:  MOVLB  03
1F86:  MOVWF  1A
1F87:  MOVLB  01
1F88:  MOVF   66,W
1F89:  MOVLB  02
1F8A:  MOVWF  58
1F8B:  MOVLW  1B
1F8C:  MOVWF  59
1F8D:  MOVLP  00
1F8E:  MOVLB  00
1F8F:  CALL   73D
1F90:  MOVLP  18
1F91:  MOVLB  01
....................         } 
....................       restart_wdt(); 
1F92:  CLRWDT
....................       } 
1F93:  INCF   65,F
1F94:  GOTO   749
....................       printf("\n\r"); 
1F95:  MOVLW  0A
1F96:  CLRWDT
1F97:  MOVLB  00
1F98:  BTFSC  11.4
1F99:  GOTO   79C
1F9A:  MOVLB  01
1F9B:  GOTO   796
1F9C:  MOVLB  03
1F9D:  MOVWF  1A
1F9E:  MOVLW  0D
1F9F:  CLRWDT
1FA0:  MOVLB  00
1FA1:  BTFSC  11.4
1FA2:  GOTO   7A5
1FA3:  MOVLB  03
1FA4:  GOTO   79F
1FA5:  MOVLB  03
1FA6:  MOVWF  1A
....................       DTMF_IN_FLAG=0; 
1FA7:  MOVLB  01
1FA8:  BCF    5D.3
....................       PROMPT_FLAG=1; 
1FA9:  BSF    5D.6
....................       lcd_send(2,LCD_str); // Send DTMF on line 3 
1FAA:  MOVLW  02
1FAB:  MOVLB  02
1FAC:  MOVWF  52
1FAD:  MOVLW  20
1FAE:  MOVWF  54
1FAF:  MOVLW  76
1FB0:  MOVWF  53
1FB1:  MOVLP  08
1FB2:  MOVLB  00
1FB3:  CALL   18C
1FB4:  MOVLP  18
....................     restart_wdt(); 
1FB5:  CLRWDT
1FB6:  MOVLB  01
....................     } 
....................     if ( DTMF_FLAG ) { 
1FB7:  BTFSS  5D.2
1FB8:  GOTO   7BE
....................       process_dtmf(); 
1FB9:  MOVLB  00
1FBA:  GOTO   4AB
....................       DTMF_FLAG=0; 
1FBB:  MOVLB  01
1FBC:  BCF    5D.2
....................     restart_wdt(); 
1FBD:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1FBE:  BTFSS  5D.5
1FBF:  GOTO   7C6
....................       clear_dtmf_array(); 
1FC0:  MOVLP  10
1FC1:  MOVLB  00
1FC2:  GOTO   7D2
1FC3:  MOVLP  18
....................       CLEAR_DTMF_FLAG=0; 
1FC4:  MOVLB  01
1FC5:  BCF    5D.5
....................     } 
....................     if ( PROMPT_FLAG ) { 
1FC6:  BTFSS  5D.6
1FC7:  GOTO   7CF
....................       prompt(); 
1FC8:  MOVLP  10
1FC9:  MOVLB  00
1FCA:  CALL   000
1FCB:  MOVLP  18
....................       PROMPT_FLAG=0; 
1FCC:  MOVLB  01
1FCD:  BCF    5D.6
....................     restart_wdt(); 
1FCE:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1FCF:  GOTO   5F1
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0B90:  CLRWDT
*
1FD0:  SLEEP
....................   delay_ms(1000); 
*
0B91:  MOVLW  04
0B92:  MOVLB  02
0B93:  MOVWF  47
0B94:  MOVLW  FA
0B95:  MOVWF  52
0B96:  MOVLB  00
0B97:  CALL   000
0B98:  MOVLB  02
0B99:  DECFSZ 47,F
0B9A:  GOTO   394
....................   if ( ConfirmChar!=0 ) { 
0B9B:  MOVLB  00
0B9C:  MOVF   6B,F
0B9D:  BTFSC  03.2
0B9E:  GOTO   3B1
....................     morse(ConfirmChar); 
0B9F:  MOVF   6B,W
0BA0:  MOVLB  02
0BA1:  MOVWF  47
0BA2:  MOVLB  00
0BA3:  CALL   09C
....................     ConfirmChar=0; 
0BA4:  CLRF   6B
....................     restart_wdt(); 
0BA5:  CLRWDT
....................     delay_ms(500); 
0BA6:  MOVLW  02
0BA7:  MOVLB  02
0BA8:  MOVWF  47
0BA9:  MOVLW  FA
0BAA:  MOVWF  52
0BAB:  MOVLB  00
0BAC:  CALL   000
0BAD:  MOVLB  02
0BAE:  DECFSZ 47,F
0BAF:  GOTO   3A9
0BB0:  MOVLB  00
....................   } 
....................   if (TailChar != 0) { 
0BB1:  MOVF   6A,F
0BB2:  BTFSC  03.2
0BB3:  GOTO   3C6
....................     morse(TailChar); 
0BB4:  MOVF   6A,W
0BB5:  MOVLB  02
0BB6:  MOVWF  47
0BB7:  MOVLB  00
0BB8:  CALL   09C
....................     TailChar=0; 
0BB9:  CLRF   6A
....................     restart_wdt(); 
0BBA:  CLRWDT
....................     delay_ms(500); 
0BBB:  MOVLW  02
0BBC:  MOVLB  02
0BBD:  MOVWF  47
0BBE:  MOVLW  FA
0BBF:  MOVWF  52
0BC0:  MOVLB  00
0BC1:  CALL   000
0BC2:  MOVLB  02
0BC3:  DECFSZ 47,F
0BC4:  GOTO   3BE
0BC5:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0BC6:  CLRWDT
0BC7:  MOVLB  02
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
0F58:  MOVLB  01
0F59:  BTFSS  5D.7
0F5A:  GOTO   75D
....................     admin_timer = ADMIN_TIMEOUT; 
0F5B:  MOVLW  FF
0F5C:  MOVWF  73
....................   } 
....................   return(AdminMode||rs232_mode); 
0F5D:  BTFSC  5D.7
0F5E:  GOTO   763
0F5F:  BTFSC  62.0
0F60:  GOTO   763
0F61:  MOVLW  00
0F62:  GOTO   764
0F63:  MOVLW  01
0F64:  MOVWF  78
.................... } // }}} 
0F65:  MOVLB  00
0F66:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0CAD:  MOVLB  01
0CAE:  BCF    5D.7
0CAF:  MOVLB  02
0CB0:  MOVF   48,F
0CB1:  BTFSC  03.2
0CB2:  GOTO   4B6
0CB3:  MOVLB  01
0CB4:  BSF    5D.7
0CB5:  MOVLB  02
....................   if (AdminMode) { 
0CB6:  MOVLB  01
0CB7:  BTFSS  5D.7
0CB8:  GOTO   4C0
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0CB9:  MOVLW  0A
0CBA:  MOVLB  00
0CBB:  MOVWF  6B
....................     admin_timer = ADMIN_TIMEOUT; 
0CBC:  MOVLW  FF
0CBD:  MOVWF  73
....................   } else { 
0CBE:  GOTO   4C3
0CBF:  MOVLB  01
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0CC0:  MOVLW  18
0CC1:  MOVLB  00
0CC2:  MOVWF  6B
....................   }  
.................... } // }}} 
0CC3:  RETURN
....................  
.................... // string matchnig function with case insensitive match. 
.................... int1 my_stricmp(char *s1,char *s2) { // {{{ 
*
0EF0:  MOVLB  02
0EF1:  CLRF   4B
....................   unsigned int x=0; 
....................   const char AMASK=0xDF; 
....................   while((AMASK&s1[x])==(AMASK&s2[x])) { 
0EF2:  MOVF   4B,W
0EF3:  ADDWF  47,W
0EF4:  MOVWF  04
0EF5:  MOVLW  00
0EF6:  ADDWFC 48,W
0EF7:  MOVWF  05
0EF8:  MOVF   00,W
0EF9:  ANDLW  DF
0EFA:  MOVWF  4C
0EFB:  MOVF   4B,W
0EFC:  ADDWF  49,W
0EFD:  MOVWF  04
0EFE:  MOVLW  00
0EFF:  ADDWFC 4A,W
0F00:  MOVWF  05
0F01:  MOVF   00,W
0F02:  ANDLW  DF
0F03:  SUBWF  4C,W
0F04:  BTFSS  03.2
0F05:  GOTO   714
....................     if(s1[x]==0) { 
0F06:  MOVF   4B,W
0F07:  ADDWF  47,W
0F08:  MOVWF  04
0F09:  MOVLW  00
0F0A:  ADDWFC 48,W
0F0B:  MOVWF  05
0F0C:  MOVF   00,F
0F0D:  BTFSS  03.2
0F0E:  GOTO   712
....................       return 0; 
0F0F:  MOVLW  00
0F10:  MOVWF  78
0F11:  GOTO   716
....................     } 
....................     x++; 
0F12:  INCF   4B,F
....................   } 
0F13:  GOTO   6F2
....................   // Strings don't match. Return 1. 
....................   return 1; 
0F14:  MOVLW  01
0F15:  MOVWF  78
.................... } // }}} 
0F16:  MOVLB  00
0F17:  RETURN
.................... // Fetches data from MC8888 device upon interrupt 
.................... void process_dtmf_interrupt(void) { // {{{ 
....................   int value,dtmf_status; 
....................   dtmf_status = dtmf_read(CONTROL_REG); 
*
1C28:  MOVLW  01
1C29:  MOVLB  02
1C2A:  MOVWF  43
1C2B:  MOVLP  00
1C2C:  MOVLB  00
1C2D:  CALL   69B
1C2E:  MOVLP  18
1C2F:  MOVF   78,W
1C30:  MOVLB  01
1C31:  MOVWF  6F
....................   if ( dtmf_status & DTMF_BUFFER_FULL) { 
1C32:  BTFSS  6F.2
1C33:  GOTO   477
....................     value=dtmf_read(DATA_REG); 
1C34:  MOVLB  02
1C35:  CLRF   43
1C36:  MOVLP  00
1C37:  MOVLB  00
1C38:  CALL   69B
1C39:  MOVLP  18
1C3A:  MOVF   78,W
1C3B:  MOVLB  01
1C3C:  MOVWF  6E
....................     DTMF_IN_FLAG=1; 
1C3D:  BSF    5D.3
....................     if ( value == dd ) { 
1C3E:  MOVF   6E,F
1C3F:  BTFSS  03.2
1C40:  GOTO   444
....................       value=d0; 
1C41:  MOVLW  0A
1C42:  MOVWF  6E
....................     } else if ( value == d0 ) { 
1C43:  GOTO   448
1C44:  MOVF   6E,W
1C45:  SUBLW  0A
1C46:  BTFSC  03.2
....................       value=dd; 
1C47:  CLRF   6E
....................     } 
....................     if ( value == ds ) { 
1C48:  MOVF   6E,W
1C49:  SUBLW  0B
1C4A:  BTFSC  03.2
....................       CLEAR_DTMF_FLAG=1; 
1C4B:  BSF    5D.5
....................     } 
....................     // Check for '#' 
....................     if ( value == dp ) { 
1C4C:  MOVF   6E,W
1C4D:  SUBLW  0C
1C4E:  BTFSS  03.2
1C4F:  GOTO   458
....................       DTMF_FLAG = 1; 
1C50:  BSF    5D.2
....................       DTMF_ptr->Last=1; 
1C51:  MOVF   3E,W
1C52:  MOVWF  04
1C53:  MOVF   3F,W
1C54:  MOVWF  05
1C55:  ADDFSR 00,FSR0
1C56:  BSF    00.5
....................     } else { 
1C57:  GOTO   477
....................       if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
1C58:  MOVF   3F,W
1C59:  SUBLW  20
1C5A:  BTFSS  03.0
1C5B:  GOTO   477
1C5C:  BTFSS  03.2
1C5D:  GOTO   462
1C5E:  MOVF   3E,W
1C5F:  SUBLW  6D
1C60:  BTFSS  03.0
1C61:  GOTO   477
....................         DTMF_ptr->Key=value; 
1C62:  MOVF   3E,W
1C63:  MOVWF  04
1C64:  MOVF   3F,W
1C65:  MOVWF  05
1C66:  ADDFSR 00,FSR0
1C67:  MOVF   6E,W
1C68:  ANDLW  0F
1C69:  MOVWF  77
1C6A:  MOVLW  F0
1C6B:  ANDWF  00,W
1C6C:  IORWF  77,W
1C6D:  MOVWF  00
....................         DTMF_ptr->Strobe=1; 
1C6E:  MOVF   3E,W
1C6F:  MOVWF  04
1C70:  MOVF   3F,W
1C71:  MOVWF  05
1C72:  ADDFSR 00,FSR0
1C73:  BSF    00.4
....................         DTMF_ptr++; 
1C74:  INCF   3E,F
1C75:  BTFSC  03.2
1C76:  INCF   3F,F
....................       } 
....................     } 
....................   } 
.................... } // }}} 
1C77:  MOVLP  18
1C78:  MOVLB  00
1C79:  GOTO   722 (RETURN)

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
