CCS PCM C Compiler, Version 4.140, 64991               17-Mar-24 18:30

               Filename:   C:\Users\m3n2bn\Projects\MBPAB IDE\RC2Gb\66_RichardPrimeau\Firmware.lst

               ROM used:   8522 words (52%)
                           Largest free fragment is 2048
               RAM used:   168 (16%) at main() level
                           235 (23%) worst case
               Stack:     11 worst case (9 in main + 2 for interrupts)

*
0000:  MOVLP  20
0001:  GOTO   0FF
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   354
002D:  MOVLP  00
002E:  GOTO   36D
002F:  MOVLP  00
0030:  GOTO   2F7
.................... #include "Firmware.h" 
.................... #include <16F1939.h> 
.................... //////// Standard Header file for the PIC16F1939 device //////////////// 
.................... #device PIC16F1939 
.................... #list 
....................  
....................  
.................... #device ADC=8; 
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
1D06:  MOVLB  02
1D07:  MOVF   2C,W
1D08:  MOVWF  30
1D09:  MOVF   2B,W
1D0A:  MOVWF  2F
1D0B:  MOVF   30,W
1D0C:  MOVWF  7A
1D0D:  MOVF   2F,W
1D0E:  MOVWF  04
1D0F:  MOVF   7A,W
1D10:  MOVWF  05
1D11:  MOVF   00,F
1D12:  BTFSC  03.2
1D13:  GOTO   518
1D14:  INCF   2F,F
1D15:  BTFSC  03.2
1D16:  INCF   30,F
1D17:  GOTO   50B
....................    while(*s2 != '\0') 
....................    { 
1D18:  MOVF   2E,W
1D19:  MOVWF  7A
1D1A:  MOVF   2D,W
1D1B:  MOVWF  04
1D1C:  MOVF   7A,W
1D1D:  MOVWF  05
1D1E:  MOVF   00,F
1D1F:  BTFSC  03.2
1D20:  GOTO   534
....................       *s = *s2; 
1D21:  MOVF   2D,W
1D22:  MOVWF  04
1D23:  MOVF   2E,W
1D24:  MOVWF  05
1D25:  MOVF   00,W
1D26:  MOVWF  33
1D27:  MOVF   30,W
1D28:  MOVWF  05
1D29:  MOVF   2F,W
1D2A:  MOVWF  04
1D2B:  MOVF   33,W
1D2C:  MOVWF  00
....................       ++s; 
1D2D:  INCF   2F,F
1D2E:  BTFSC  03.2
1D2F:  INCF   30,F
....................       ++s2; 
1D30:  INCF   2D,F
1D31:  BTFSC  03.2
1D32:  INCF   2E,F
....................    } 
1D33:  GOTO   518
....................  
....................    *s = '\0'; 
1D34:  MOVF   2F,W
1D35:  MOVWF  04
1D36:  MOVF   30,W
1D37:  MOVWF  05
1D38:  CLRF   00
....................    return(s1); 
1D39:  MOVF   2B,W
1D3A:  MOVWF  78
1D3B:  MOVF   2C,W
1D3C:  MOVWF  79
.................... } 
1D3D:  MOVLB  00
1D3E:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0F31:  MOVF   4A,W
0F32:  MOVWF  4E
0F33:  MOVF   49,W
0F34:  MOVWF  4D
0F35:  MOVF   4E,W
0F36:  MOVWF  7A
0F37:  MOVF   4D,W
0F38:  MOVWF  04
0F39:  MOVF   7A,W
0F3A:  MOVWF  05
0F3B:  MOVF   00,F
0F3C:  BTFSC  03.2
0F3D:  GOTO   76A
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0F3E:  MOVF   4C,W
0F3F:  MOVWF  50
0F40:  MOVF   4B,W
0F41:  MOVWF  4F
0F42:  MOVF   50,W
0F43:  MOVWF  7A
0F44:  MOVF   4F,W
0F45:  MOVWF  04
0F46:  MOVF   7A,W
0F47:  MOVWF  05
0F48:  MOVF   00,F
0F49:  BTFSC  03.2
0F4A:  GOTO   766
....................          if (*sc1 == *sc2) 
0F4B:  MOVF   4E,W
0F4C:  MOVWF  7A
0F4D:  MOVF   4D,W
0F4E:  MOVWF  04
0F4F:  MOVF   7A,W
0F50:  MOVWF  05
0F51:  MOVF   00,W
0F52:  MOVWF  51
0F53:  MOVF   50,W
0F54:  MOVWF  7A
0F55:  MOVF   4F,W
0F56:  MOVWF  04
0F57:  MOVF   7A,W
0F58:  MOVWF  05
0F59:  MOVF   00,W
0F5A:  SUBWF  51,W
0F5B:  BTFSS  03.2
0F5C:  GOTO   762
....................             return(sc1); 
0F5D:  MOVF   4D,W
0F5E:  MOVWF  78
0F5F:  MOVF   4E,W
0F60:  MOVWF  79
0F61:  GOTO   76D
0F62:  INCF   4F,F
0F63:  BTFSC  03.2
0F64:  INCF   50,F
0F65:  GOTO   742
0F66:  INCF   4D,F
0F67:  BTFSC  03.2
0F68:  INCF   4E,F
0F69:  GOTO   735
....................    return(0); 
0F6A:  MOVLW  00
0F6B:  MOVWF  78
0F6C:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0ECA:  MOVF   4A,W
0ECB:  MOVWF  4E
0ECC:  MOVF   49,W
0ECD:  MOVWF  4D
0ECE:  MOVF   4E,W
0ECF:  MOVWF  7A
0ED0:  MOVF   4D,W
0ED1:  MOVWF  04
0ED2:  MOVF   7A,W
0ED3:  MOVWF  05
0ED4:  MOVF   00,F
0ED5:  BTFSC  03.2
0ED6:  GOTO   708
....................       for (sc2 = s2; ; sc2++) 
0ED7:  MOVF   4C,W
0ED8:  MOVWF  50
0ED9:  MOVF   4B,W
0EDA:  MOVWF  4F
....................     if (*sc2 == '\0') 
0EDB:  MOVF   50,W
0EDC:  MOVWF  7A
0EDD:  MOVF   4F,W
0EDE:  MOVWF  04
0EDF:  MOVF   7A,W
0EE0:  MOVWF  05
0EE1:  MOVF   00,F
0EE2:  BTFSS  03.2
0EE3:  GOTO   6EE
....................        return(sc1 - s1); 
0EE4:  MOVF   49,W
0EE5:  SUBWF  4D,W
0EE6:  MOVWF  77
0EE7:  MOVF   4A,W
0EE8:  SUBWFC 4E,W
0EE9:  MOVWF  7A
0EEA:  MOVF   77,W
0EEB:  MOVWF  78
0EEC:  GOTO   710
....................          else if (*sc1 == *sc2) 
0EED:  GOTO   700
0EEE:  MOVF   4E,W
0EEF:  MOVWF  7A
0EF0:  MOVF   4D,W
0EF1:  MOVWF  04
0EF2:  MOVF   7A,W
0EF3:  MOVWF  05
0EF4:  MOVF   00,W
0EF5:  MOVWF  51
0EF6:  MOVF   50,W
0EF7:  MOVWF  7A
0EF8:  MOVF   4F,W
0EF9:  MOVWF  04
0EFA:  MOVF   7A,W
0EFB:  MOVWF  05
0EFC:  MOVF   00,W
0EFD:  SUBWF  51,W
0EFE:  BTFSC  03.2
....................             break; 
0EFF:  GOTO   704
0F00:  INCF   4F,F
0F01:  BTFSC  03.2
0F02:  INCF   50,F
0F03:  GOTO   6DB
0F04:  INCF   4D,F
0F05:  BTFSC  03.2
0F06:  INCF   4E,F
0F07:  GOTO   6CE
....................    return(sc1 - s1); 
0F08:  MOVF   49,W
0F09:  SUBWF  4D,W
0F0A:  MOVWF  77
0F0B:  MOVF   4A,W
0F0C:  SUBWFC 4E,W
0F0D:  MOVWF  7A
0F0E:  MOVF   77,W
0F0F:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
212D:  MOVLB  00
212E:  CLRF   26
212F:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0EB1:  MOVLB  02
0EB2:  MOVF   41,W
0EB3:  IORWF  42,W
0EB4:  BTFSC  03.2
0EB5:  GOTO   6BA
0EB6:  MOVF   42,W
0EB7:  MOVWF  7A
0EB8:  MOVF   41,W
0EB9:  GOTO   6BF
0EBA:  MOVLB  00
0EBB:  MOVF   27,W
0EBC:  MOVWF  7A
0EBD:  MOVF   26,W
0EBE:  MOVLB  02
0EBF:  MOVWF  45
0EC0:  MOVF   7A,W
0EC1:  MOVWF  46
....................    beg += strspn(beg, s2); 
0EC2:  MOVF   46,W
0EC3:  MOVWF  4A
0EC4:  MOVF   45,W
0EC5:  MOVWF  49
0EC6:  MOVF   44,W
0EC7:  MOVWF  4C
0EC8:  MOVF   43,W
0EC9:  MOVWF  4B
*
0F10:  MOVF   78,W
0F11:  ADDWF  45,F
0F12:  MOVLW  00
0F13:  ADDWFC 46,F
....................    if (*beg == '\0') 
0F14:  MOVF   46,W
0F15:  MOVWF  7A
0F16:  MOVF   45,W
0F17:  MOVWF  04
0F18:  MOVF   7A,W
0F19:  MOVWF  05
0F1A:  MOVF   00,F
0F1B:  BTFSS  03.2
0F1C:  GOTO   729
....................    { 
....................       *save = ' '; 
0F1D:  MOVLB  00
0F1E:  MOVF   26,W
0F1F:  MOVWF  04
0F20:  MOVF   27,W
0F21:  MOVWF  05
0F22:  MOVLW  20
0F23:  MOVWF  00
....................       return(0); 
0F24:  MOVLW  00
0F25:  MOVWF  78
0F26:  MOVWF  79
0F27:  GOTO   78E
0F28:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0F29:  MOVF   46,W
0F2A:  MOVWF  4A
0F2B:  MOVF   45,W
0F2C:  MOVWF  49
0F2D:  MOVF   44,W
0F2E:  MOVWF  4C
0F2F:  MOVF   43,W
0F30:  MOVWF  4B
*
0F6D:  MOVF   79,W
0F6E:  MOVWF  48
0F6F:  MOVF   78,W
0F70:  MOVWF  47
....................    if (*end != '\0') 
0F71:  MOVF   48,W
0F72:  MOVWF  7A
0F73:  MOVF   47,W
0F74:  MOVWF  04
0F75:  MOVF   7A,W
0F76:  MOVWF  05
0F77:  MOVF   00,F
0F78:  BTFSC  03.2
0F79:  GOTO   782
....................    { 
....................       *end = '\0'; 
0F7A:  MOVF   47,W
0F7B:  MOVWF  04
0F7C:  MOVF   48,W
0F7D:  MOVWF  05
0F7E:  CLRF   00
....................       end++; 
0F7F:  INCF   47,F
0F80:  BTFSC  03.2
0F81:  INCF   48,F
....................    } 
....................    save = end; 
0F82:  MOVF   48,W
0F83:  MOVLB  00
0F84:  MOVWF  27
0F85:  MOVLB  02
0F86:  MOVF   47,W
0F87:  MOVLB  00
0F88:  MOVWF  26
....................    return(beg); 
0F89:  MOVLB  02
0F8A:  MOVF   45,W
0F8B:  MOVWF  78
0F8C:  MOVF   46,W
0F8D:  MOVWF  79
0F8E:  MOVLB  00
.................... } 
0F8F:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
.................... #define BUTTON_STATES 
.................... #define POT_MAX 63 
....................  
.................... #define RS 0x01 
.................... #define LCD_READ 0x02   
.................... #define LCD_WRITE 0x00   
.................... #define E 0x04 
.................... #define BT 0x08 
.................... #define CHANGE_LINE 0x80 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
0785:  MOVLW  20
0786:  MOVWF  05
0787:  MOVLW  CB
0788:  MOVWF  04
0789:  MOVF   00,W
078A:  BTFSC  03.2
078B:  GOTO   79D
078C:  MOVLW  02
078D:  MOVWF  78
078E:  MOVLW  BF
078F:  MOVWF  77
0790:  CLRWDT
0791:  DECFSZ 77,F
0792:  GOTO   790
0793:  DECFSZ 78,F
0794:  GOTO   78E
0795:  MOVLW  96
0796:  MOVWF  77
0797:  DECFSZ 77,F
0798:  GOTO   797
0799:  GOTO   79A
079A:  CLRWDT
079B:  DECFSZ 00,F
079C:  GOTO   78C
079D:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
064D:  MOVLB  04
064E:  BCF    15.7
064F:  MOVLB  00
0650:  BCF    11.3
0651:  MOVLB  02
0652:  MOVF   56,W
0653:  MOVLB  04
0654:  MOVWF  11
0655:  MOVLW  02
0656:  BTFSC  15.7
0657:  GOTO   65F
0658:  MOVLB  00
0659:  BTFSS  11.3
065A:  GOTO   659
065B:  MOVLW  00
065C:  MOVLB  04
065D:  BTFSC  16.6
065E:  MOVLW  01
065F:  MOVWF  78
0660:  MOVLB  00
0661:  RETURN
*
0AB2:  MOVLB  04
0AB3:  BCF    15.6
0AB4:  BSF    16.3
0AB5:  BTFSC  16.3
0AB6:  GOTO   2B5
0AB7:  BTFSC  77.0
0AB8:  BCF    16.5
0AB9:  BTFSS  77.0
0ABA:  BSF    16.5
0ABB:  BSF    16.4
0ABC:  BTFSC  16.4
0ABD:  GOTO   2BC
0ABE:  MOVF   11,W
0ABF:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02F0:  CLRWDT
02F1:  BTFSS  11.4
02F2:  GOTO   2F0
02F3:  MOVLB  03
02F4:  MOVWF  1A
02F5:  MOVLB  00
02F6:  RETURN
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void process_dtmf_interrupt(void); 
.................... void crlf (void); 
.................... void init_lcd(void); 
.................... int1 read_cor_in_ports(void); 
.................... void send_tail(void); 
.................... void status_led(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... #if __DEVICE__==1939 
.................... void set_bit(void); 
.................... void clear_bit(void); 
.................... #endif 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
.................... void print_dfmf_info(void); 
.................... void do_delay_counters(void); 
.................... void process_buttons(void); 
.................... int1 my_stricmp(char *, char *); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN_HW; 
.................... unsigned int COR_IN; 
.................... unsigned int COR_IN_EFFECTIVE; 
.................... unsigned int Enable; 
.................... unsigned int Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned long TOT_Min; 
.................... unsigned int TOT_FLAG_Mask; 
.................... unsigned long QSO_Duration; 
.................... unsigned int Link_TOT,LinkDurationTimer; 
.................... unsigned int COR_EMUL; 
.................... unsigned int COR_AUX; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... // 
.................... // Button calibration states 
.................... // 
.................... #define BUTTON_IDLE 0 
.................... #define CALIB 16 
.................... #define TRIM 15  
.................... // 
.................... // Command settings 
.................... // 
.................... #define LINK_CMD 1 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define DEBOUNCE_COUNT 8 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
.................... #define SET_BIT 14 
.................... #define CLEAR_BIT 15 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... #define QSO_DURATION_DELAY 5 
.................... // This command operates the same way as AUX_OUT_FOLLOW_COR but 
.................... // it extends the aux output by 1 minute. 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT_OUTPUT 0x10 
.................... #define AUX_OUT_FOLLOW_COR_OFF_DELAY     0x20 
.................... #define AUX_OUT_FOLLOW_COR_ON_DELAY      0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... // Arguments 
.................... #define AUXI_EMULATE_COR1 0x01 
.................... #define AUXI_EMULATE_COR2 0x02 
.................... #define AUXI_EMULATE_COR3 0x04 
.................... #define AUXI_EMULATE_COR4 0x08 
.................... #define AUXI_EMULATE_COR5 0x10 // COR from AUX only for DTMF control (No audio feed-thru) 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x20 
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... unsigned int AuxOutDelayCnt; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... unsigned int command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
....................   int  usage : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1 PROCESS_COR_FLAG; 
.................... int1 COR_IN_FLAG; 
.................... int1 ENTER_PRESSED; 
.................... int1 SELECT_PRESSED; 
.................... int  adj_value_a,adj_value_b; 
.................... char button_state; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int1 	   AUX_OUT_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... int1       STATUS_LED; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1       DTMF_INTERRUPT_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... // PROTECTED -- Must be in admin mode to set value 
.................... // PUBLIC    -- Register can be set in any mode 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
.................... #define PROTECTED 1 
.................... #define PUBLIC    0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 AuxIn[0] 
.................... 	{"XI2"},	  // 19 AuxIn[1] 
.................... 	{"XI3"},	  // 20 AuxIn[2] 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"LTO"},  // 54 
....................     {"COR"},  // 55 
....................     {"CPOT"}  // 56 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
.................... #define SITE_ID_VAL  	66 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... #define ENABLE_DEFAULT 15 
.................... #define TOT_MIN 5 
.................... #define LINK_TOT 0 
.................... #define DEFAULT_GAIN 32 
.................... #define LCD_TYPE_PI 1 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('v') 
.................... #define MORSEID4	MCHAR('a') 
.................... #define MORSEID5	MCHAR('r') 
....................  
.................... #define AUXOUTOP0 0 
.................... #define AUXOUTARG0 0 
.................... #define AUXOUTOP1 0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2 0 
.................... #define AUXOUTARG2 0 
....................  
.................... //#define AUXINOP0 AUXI_ENABLE 
.................... //#define AUXINARG0 AUXI_ENABLE2|AUXI_ENABLE3|AUXI_ENABLE4 
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  0 
.................... #define AUXINARG0 0 
.................... #define AUXINOP1 AUXI_TAIL_WHEN_HI 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
.................... #define RX1_PTT 0x0E 
.................... #define RX2_PTT 0x0D 
.................... #define RX3_PTT 0x0B 
.................... #define RX4_PTT 0x07 
....................  
.................... // Define default variables {{{ 
.................... #ifdef LCD_TYPE_PI 
....................   #define LCD_I2C_ADD 0x27 
.................... #else 
....................   #define LCD_I2C_ADD 0x60 
.................... #endif 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... #ifndef RX1_PTT 
....................   #define RX1_PTT 0x0E 
.................... #endif 
.................... #ifndef RX2_PTT 
....................   #define RX2_PTT 0x0D 
.................... #endif 
.................... #ifndef RX3_PTT 
....................   #define RX3_PTT 0x0B  
.................... #endif 
.................... #ifndef RX4_PTT 
....................   #define RX4_PTT 0x07 
.................... #endif 
.................... #ifndef DEFAULT_GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... // }}} 
....................  
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  , EEPROM,PUBLIC}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL, EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&AuxIn[0]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[1]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[2]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[0]     ,PO_AUX_OUT0     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[1]     ,PO_AUX_OUT1     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[2]     ,PO_AUX_OUT2     , EEPROM,PUBLIC}, 
.................... 	{&RXPriority[0] ,4               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[1] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[2] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[3] ,2               , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[0]     ,RX1_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[1]     ,RX2_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[2]     ,RX3_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[3]     ,RX4_PTT         , EEPROM,PROTECTED}, 
.................... 	{&SiteID        ,SITE_ID_VAL     , EEPROM,PROTECTED}, 
.................... 	{&TXSiteID      ,0x12            , EEPROM,PROTECTED}, 
....................   {&Morse[0]      ,MORSEID0        , EEPROM,PROTECTED}, 
....................   {&Morse[1]      ,MORSEID1        , EEPROM,PROTECTED}, 
....................   {&Morse[2]      ,MORSEID2        , EEPROM,PROTECTED}, 
....................   {&Morse[3]      ,MORSEID3        , EEPROM,PROTECTED}, 
....................   {&Morse[4]      ,MORSEID4        , EEPROM,PROTECTED}, 
....................   {&Morse[5]      ,MORSEID5        , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2      , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2        , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2       , EEPROM,PROTECTED}, 
....................   {&Tail          ,TAIL_CHAR       , EEPROM,PROTECTED}, 
....................   {&TOT_Min       ,TOT_MIN         , EEPROM,PROTECTED}, 
....................   {&Link_TOT      ,LINK_TOT        , EEPROM,PROTECTED}, 
.................... 	{&COR_EMUL      ,0x00            , RAM   ,PUBLIC}, 
.................... 	{&CurrentTrimPot,0x00            , RAM   ,PROTECTED}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02F7:  BTFSS  11.5
02F8:  GOTO   34E
....................     c = getc(); 
02F9:  CLRWDT
02FA:  BTFSS  11.5
02FB:  GOTO   2F9
02FC:  MOVLB  03
02FD:  MOVF   19,W
02FE:  MOVLB  02
02FF:  MOVWF  58
....................     if ( c == '\b' ) { 
0300:  MOVF   58,W
0301:  SUBLW  08
0302:  BTFSS  03.2
0303:  GOTO   32C
....................       if ( sBufferIndex > 0 ) { 
0304:  MOVF   7C,F
0305:  BTFSC  03.2
0306:  GOTO   326
....................         sBufferIndex--; 
0307:  DECF   7C,F
....................         sBuffer[sBufferIndex]='\0'; 
0308:  MOVLW  50
0309:  ADDWF  7C,W
030A:  MOVWF  04
030B:  MOVLW  20
030C:  MOVWF  05
030D:  BTFSC  03.0
030E:  INCF   05,F
030F:  CLRF   00
....................         putc('\b'); 
0310:  MOVLW  08
0311:  MOVLB  00
0312:  CALL   2F0
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
0313:  MOVLW  1B
0314:  CALL   2F0
....................   printf("[K"); 
0315:  MOVLW  5B
0316:  CLRWDT
0317:  BTFSS  11.4
0318:  GOTO   316
0319:  MOVLB  03
031A:  MOVWF  1A
031B:  MOVLW  4B
031C:  CLRWDT
031D:  MOVLB  00
031E:  BTFSC  11.4
031F:  GOTO   322
0320:  MOVLB  03
0321:  GOTO   31C
0322:  MOVLB  03
0323:  MOVWF  1A
....................       } else { 
0324:  GOTO   32A
0325:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
0326:  MOVLW  07
0327:  MOVLB  00
0328:  CALL   2F0
0329:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
032A:  GOTO   350
032B:  MOVLB  02
032C:  MOVF   7C,W
032D:  SUBLW  0F
032E:  BTFSS  03.0
032F:  GOTO   34B
....................       putc(c); // echo the character 
0330:  MOVF   58,W
0331:  MOVLB  00
0332:  CALL   2F0
....................       sBuffer[sBufferIndex++] = c; 
0333:  MOVF   7C,W
0334:  INCF   7C,F
0335:  ADDLW  50
0336:  MOVWF  04
0337:  MOVLW  20
0338:  MOVWF  05
0339:  BTFSC  03.0
033A:  INCF   05,F
033B:  MOVLB  02
033C:  MOVF   58,W
033D:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
033E:  MOVF   58,W
033F:  SUBLW  0D
0340:  BTFSC  03.2
0341:  GOTO   349
0342:  MOVF   58,W
0343:  SUBLW  2B
0344:  BTFSC  03.2
0345:  GOTO   349
0346:  MOVF   58,W
0347:  SUBLW  2D
0348:  BTFSC  03.2
....................         sBufferFlag=1; 
0349:  BSF    7D.0
....................       } 
....................     } else { 
034A:  GOTO   34F
....................       putc('\a'); // Send alert. Avoid buffer overflow 
034B:  MOVLW  07
034C:  MOVLB  00
034D:  CALL   2F0
034E:  MOVLB  02
034F:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
0350:  MOVLB  00
0351:  BCF    11.5
0352:  MOVLP  00
0353:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if( IOCBF & 0x0F ) { // Check for interrupts on RB[3:0] only 
0354:  MOVLB  07
0355:  MOVF   16,W
0356:  ANDLW  0F
0357:  BTFSC  03.2
0358:  GOTO   35C
....................     // COR_IN_HW = actual COR_IN values from controller input ports. 
....................     COR_IN_FLAG=1; 
0359:  BSF    7D.2
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
035A:  MOVLW  F0
035B:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
035C:  BTFSS  0B.0
035D:  GOTO   362
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     DTMF_INTERRUPT_FLAG = 1; 
035E:  MOVLB  01
035F:  BSF    62.6
....................     clear_interrupt(INT_RB4_H2L); 
0360:  MOVLB  07
0361:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
0362:  BTFSS  0B.0
0363:  GOTO   369
....................     AUX_IN_FLAG=1; 
0364:  MOVLB  01
0365:  BSF    62.1
....................     clear_interrupt(INT_RB6|INT_RB7); 
0366:  MOVLW  3F
0367:  MOVLB  07
0368:  ANDWF  16,F
....................   } 
.................... } // }}} 
0369:  BCF    0B.0
036A:  MOVLP  00
036B:  MOVLB  00
036C:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
036D:  MOVLB  01
036E:  MOVF   31,W
036F:  IORWF  32,W
0370:  BTFSC  03.2
0371:  GOTO   377
....................     rtcc_cnt--; 
0372:  MOVF   31,W
0373:  BTFSC  03.2
0374:  DECF   32,F
0375:  DECF   31,F
....................   } else { 
0376:  GOTO   37D
....................     COR_IN_FLAG = 1; 
0377:  BSF    7D.2
....................     SECOND_FLAG=1; 
0378:  BSF    7D.5
....................     AUX_IN_FLAG=1; 
0379:  BSF    62.1
....................     rtcc_cnt=30; 
037A:  CLRF   32
037B:  MOVLW  1E
037C:  MOVWF  31
....................   } 
....................   if (aux_timer ) { 
037D:  MOVF   33,W
037E:  IORWF  34,W
037F:  BTFSC  03.2
0380:  GOTO   385
....................     aux_timer--; 
0381:  MOVF   33,W
0382:  BTFSC  03.2
0383:  DECF   34,F
0384:  DECF   33,F
....................   } 
.................... } // }}} 
....................  
0385:  BCF    0B.2
0386:  MOVLP  00
0387:  MOVLB  00
0388:  GOTO   020
.................... int1 read_cor_in_ports (void) { // {{{ 
....................   // Updates COR_IN_HW and COR_IN variables 
....................   // Returns a 1 if a new COR is detected. 
....................   unsigned int LAST_COR_IN; 
....................   LAST_COR_IN = COR_IN; 
*
172D:  MOVF   60,W
172E:  MOVLB  01
172F:  MOVWF  68
....................   COR_IN_HW   = ((input_b() ^ Polarity)&0x0F); 
1730:  MOVLB  00
1731:  MOVF   0D,W
1732:  XORWF  64,W
1733:  ANDLW  0F
1734:  MOVWF  5F
....................   COR_IN      = COR_IN_HW | (COR_EMUL & 0x1F) | (COR_AUX&0x0F); 
1735:  MOVF   6F,W
1736:  ANDLW  1F
1737:  IORWF  5F,W
1738:  MOVLB  01
1739:  MOVWF  69
173A:  MOVF   71,W
173B:  ANDLW  0F
173C:  IORWF  69,W
173D:  MOVLB  00
173E:  MOVWF  60
....................   if ( LAST_COR_IN != COR_IN ) { 
173F:  MOVF   60,W
1740:  MOVLB  01
1741:  SUBWF  68,W
1742:  BTFSC  03.2
1743:  GOTO   748
....................     return(1); 
1744:  MOVLW  01
1745:  MOVWF  78
1746:  GOTO   74A
....................   } else { 
1747:  GOTO   74A
....................     return(0); 
1748:  MOVLW  00
1749:  MOVWF  78
....................   } 
.................... } // }}} 
174A:  MOVLP  20
174B:  MOVLB  00
174C:  GOTO   154 (RETURN)
.................... int1 warn_no_lcd = 1; 
....................  
.................... void lcd_strobe(char data) { // {{{ 
....................   i2c_write(data | E); 
*
0925:  MOVLB  02
0926:  MOVF   54,W
0927:  IORLW  04
0928:  MOVWF  55
0929:  MOVWF  56
092A:  MOVLP  00
092B:  MOVLB  00
092C:  CALL   64D
092D:  MOVLP  08
....................   i2c_write(data & ~E); 
092E:  MOVLB  02
092F:  MOVF   54,W
0930:  ANDLW  FB
0931:  MOVWF  55
0932:  MOVWF  56
0933:  MOVLP  00
0934:  MOVLB  00
0935:  CALL   64D
0936:  MOVLP  08
.................... } // }}} 
0937:  RETURN
....................  
.................... void lcd_write(char rs, char data) { // {{{ 
....................   char lcd_word_a,lcd_word_b; 
....................   lcd_word_a = LCD_WRITE | BT | (data&0xF0); 
0938:  MOVLB  02
0939:  MOVF   51,W
093A:  ANDLW  F0
093B:  IORLW  08
093C:  MOVWF  52
....................   lcd_word_b = LCD_WRITE | BT | ((data<<4)&0xF0); 
093D:  SWAPF  51,W
093E:  MOVWF  77
093F:  MOVLW  F0
0940:  ANDWF  77,F
0941:  MOVF   77,W
0942:  ANDLW  F0
0943:  IORLW  08
0944:  MOVWF  53
....................   if ( rs ) { 
0945:  MOVF   50,F
0946:  BTFSC  03.2
0947:  GOTO   14A
....................     lcd_word_a |= RS; 
0948:  BSF    52.0
....................     lcd_word_b |= RS; 
0949:  BSF    53.0
....................   }  
....................   lcd_strobe(lcd_word_a); 
094A:  MOVF   52,W
094B:  MOVWF  54
094C:  MOVLB  00
094D:  CALL   125
....................   lcd_strobe(lcd_word_b); 
094E:  MOVLB  02
094F:  MOVF   53,W
0950:  MOVWF  54
0951:  MOVLB  00
0952:  CALL   125
.................... } // }}} 
0953:  RETURN
....................  
.................... void lcd_send(char line,char * s) { // {{{ 
.................... #ifndef LCD_TYPE_PI 
....................   int lcd_cmd; 
.................... #endif 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   i2c_start(); 
0954:  MOVLB  04
0955:  BSF    16.0
0956:  BTFSC  16.0
0957:  GOTO   156
....................   #ifdef LCD_TYPE_PI 
....................   ack=i2c_write(LCD_I2C_ADD << 1); 
0958:  MOVLW  4E
0959:  MOVLB  02
095A:  MOVWF  56
095B:  MOVLP  00
095C:  MOVLB  00
095D:  CALL   64D
095E:  MOVLP  08
095F:  MOVF   78,W
0960:  MOVLB  02
0961:  BCF    4E.0
0962:  BTFSC  78.0
0963:  BSF    4E.0
.................... //  ack=i2c_write(line&0x03); 
.................... // Change line 
....................   switch(line&0x03) { 
0964:  MOVF   4B,W
0965:  ANDLW  03
0966:  ADDLW  FC
0967:  BTFSC  03.0
0968:  GOTO   18D
0969:  ADDLW  04
096A:  MOVLB  00
096B:  GOTO   1EF
....................     case 0x00: lcd_write(0,CHANGE_LINE);break; 
096C:  MOVLB  02
096D:  CLRF   50
096E:  MOVLW  80
096F:  MOVWF  51
0970:  MOVLB  00
0971:  CALL   138
0972:  MOVLB  02
0973:  GOTO   18D
....................     case 0x01: lcd_write(0,CHANGE_LINE+0x40);break; 
0974:  MOVLB  02
0975:  CLRF   50
0976:  MOVLW  C0
0977:  MOVWF  51
0978:  MOVLB  00
0979:  CALL   138
097A:  MOVLB  02
097B:  GOTO   18D
....................     case 0x02: lcd_write(0,CHANGE_LINE+0x14);break; 
097C:  MOVLB  02
097D:  CLRF   50
097E:  MOVLW  94
097F:  MOVWF  51
0980:  MOVLB  00
0981:  CALL   138
0982:  MOVLB  02
0983:  GOTO   18D
....................     case 0x03: lcd_write(0,CHANGE_LINE+0x54);break; 
0984:  MOVLB  02
0985:  CLRF   50
0986:  MOVLW  D4
0987:  MOVWF  51
0988:  MOVLB  00
0989:  CALL   138
098A:  MOVLB  02
098B:  GOTO   18D
098C:  MOVLB  02
....................   } 
....................   restart_wdt(); 
098D:  CLRWDT
....................   #else 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
....................   ack=i2c_write(lcd_cmd); 
....................   #endif 
....................   if ( ack!=0 ) { 
098E:  BTFSS  4E.0
098F:  GOTO   1B6
....................     if ( warn_no_lcd ) { 
0990:  MOVLB  01
0991:  BTFSS  65.3
0992:  GOTO   1B4
....................       crlf(); 
0993:  MOVLP  00
0994:  MOVLB  00
0995:  CALL   45E
0996:  MOVLP  08
....................       printf("I2C : No ACK from LCD : %u",ack); 
0997:  MOVLW  00
0998:  MOVLB  02
0999:  BTFSC  4E.0
099A:  MOVLW  01
099B:  MOVWF  4F
099C:  MOVLW  89
099D:  MOVLB  03
099E:  MOVWF  11
099F:  MOVLW  03
09A0:  MOVWF  12
09A1:  BCF    03.0
09A2:  MOVLW  18
09A3:  MOVLB  02
09A4:  MOVWF  50
09A5:  MOVLP  00
09A6:  MOVLB  00
09A7:  CALL   662
09A8:  MOVLP  08
09A9:  MOVLB  02
09AA:  MOVF   4F,W
09AB:  MOVWF  50
09AC:  MOVLW  1B
09AD:  MOVWF  51
09AE:  MOVLP  00
09AF:  MOVLB  00
09B0:  CALL   6D6
09B1:  MOVLP  08
....................       warn_no_lcd = 0; 
09B2:  MOVLB  01
09B3:  BCF    65.3
....................     } 
....................   } else { 
09B4:  GOTO   1B8
09B5:  MOVLB  02
....................     warn_no_lcd = 1; 
09B6:  MOVLB  01
09B7:  BSF    65.3
....................   } 
....................   while(*s) { 
09B8:  MOVLB  02
09B9:  MOVF   4D,W
09BA:  MOVWF  7A
09BB:  MOVF   4C,W
09BC:  MOVWF  04
09BD:  MOVF   7A,W
09BE:  MOVWF  05
09BF:  MOVF   00,F
09C0:  BTFSC  03.2
09C1:  GOTO   1E9
.................... #ifdef LCD_TYPE_PI 
....................     if ( *s != '\r' && *s != '\n') { 
09C2:  MOVF   4D,W
09C3:  MOVWF  7A
09C4:  MOVF   4C,W
09C5:  MOVWF  04
09C6:  MOVF   7A,W
09C7:  MOVWF  05
09C8:  MOVF   00,W
09C9:  SUBLW  0D
09CA:  BTFSC  03.2
09CB:  GOTO   1E5
09CC:  MOVF   4D,W
09CD:  MOVWF  7A
09CE:  MOVF   4C,W
09CF:  MOVWF  04
09D0:  MOVF   7A,W
09D1:  MOVWF  05
09D2:  MOVF   00,W
09D3:  SUBLW  0A
09D4:  BTFSC  03.2
09D5:  GOTO   1E5
....................       lcd_write(1,*s); 
09D6:  MOVF   4D,W
09D7:  MOVWF  7A
09D8:  MOVF   4C,W
09D9:  MOVWF  04
09DA:  MOVF   4D,W
09DB:  MOVWF  05
09DC:  MOVF   00,W
09DD:  MOVWF  4F
09DE:  MOVLW  01
09DF:  MOVWF  50
09E0:  MOVF   4F,W
09E1:  MOVWF  51
09E2:  MOVLB  00
09E3:  CALL   138
09E4:  MOVLB  02
....................     } 
....................     s++; 
09E5:  INCF   4C,F
09E6:  BTFSC  03.2
09E7:  INCF   4D,F
.................... #else 
....................    i2c_write(*s++); 
.................... #endif 
....................   } 
09E8:  GOTO   1B9
.................... #ifndef LCD_TYPE_PI 
....................   i2c_write(0); // EOL 
.................... #endif 
....................   i2c_stop(); 
09E9:  MOVLB  04
09EA:  BSF    16.2
09EB:  BTFSC  16.2
09EC:  GOTO   1EB
.................... #endif 
.................... } // }}} 
09ED:  MOVLB  00
09EE:  RETURN
.................... #ifdef BUTTON_STATES 
.................... void status_led(void) { // {{{ 
....................   char cnt_val; 
....................   STATUS_LED=0; 
*
0E83:  BCF    62.3
....................   cnt_val = rtcc_cnt>>3; 
0E84:  RRF    32,W
0E85:  MOVWF  7A
0E86:  RRF    31,W
0E87:  MOVWF  79
0E88:  RRF    7A,F
0E89:  RRF    79,F
0E8A:  RRF    7A,F
0E8B:  RRF    79,F
0E8C:  MOVF   79,W
0E8D:  MOVWF  6D
....................   if ( button_state!=0 ) { 
0E8E:  MOVF   61,F
0E8F:  BTFSC  03.2
0E90:  GOTO   69F
....................     if ( (rtcc_cnt & 0x04) ) { 
0E91:  MOVF   31,W
0E92:  ANDLW  04
0E93:  MOVWF  77
0E94:  CLRF   7A
0E95:  MOVF   77,W
0E96:  IORWF  7A,W
0E97:  BTFSC  03.2
0E98:  GOTO   69F
....................       STATUS_LED = (cnt_val < (CurrentTrimPot+1));  
0E99:  BCF    62.3
0E9A:  MOVLW  01
0E9B:  ADDWF  30,W
0E9C:  SUBWF  6D,W
0E9D:  BTFSS  03.0
0E9E:  BSF    62.3
....................     } 
....................   }  
....................   output_bit(STATUS_LED_PIN,STATUS_LED); 
0E9F:  BTFSC  62.3
0EA0:  GOTO   6A5
0EA1:  MOVLB  02
0EA2:  BCF    0C.6
0EA3:  GOTO   6A7
0EA4:  MOVLB  01
0EA5:  MOVLB  02
0EA6:  BSF    0C.6
0EA7:  MOVLB  01
0EA8:  BCF    0C.6
.................... } // }}} 
.................... #endif 
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
.................... #ifndef LCD_TYPE_PI 
....................   int lcd_cmd; 
.................... #endif 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................   crlf(); 
*
115F:  MOVLP  00
1160:  CALL   45E
1161:  MOVLP  10
....................   if ( command ) { 
1162:  MOVF   70,F
1163:  BTFSC  03.2
1164:  GOTO   1D7
....................     crlf(); printf("Processing Command:"); 
1165:  MOVLP  00
1166:  CALL   45E
1167:  MOVLP  10
1168:  MOVLW  97
1169:  MOVLB  03
116A:  MOVWF  11
116B:  MOVLW  03
116C:  MOVWF  12
116D:  MOVLP  00
116E:  MOVLB  00
116F:  CALL   463
1170:  MOVLP  10
....................     crlf(); printf("  SiteID   : %u",SiteID); 
1171:  MOVLP  00
1172:  CALL   45E
1173:  MOVLP  10
1174:  MOVLW  A1
1175:  MOVLB  03
1176:  MOVWF  11
1177:  MOVLW  03
1178:  MOVWF  12
1179:  BCF    03.0
117A:  MOVLW  0D
117B:  MOVLB  02
117C:  MOVWF  50
117D:  MOVLP  00
117E:  MOVLB  00
117F:  CALL   662
1180:  MOVLP  10
1181:  MOVF   65,W
1182:  MOVLB  02
1183:  MOVWF  50
1184:  MOVLW  1B
1185:  MOVWF  51
1186:  MOVLP  00
1187:  MOVLB  00
1188:  CALL   6D6
1189:  MOVLP  10
....................     crlf(); printf("  Command  : %02u",command); 
118A:  MOVLP  00
118B:  CALL   45E
118C:  MOVLP  10
118D:  MOVLW  A9
118E:  MOVLB  03
118F:  MOVWF  11
1190:  MOVLW  03
1191:  MOVWF  12
1192:  BCF    03.0
1193:  MOVLW  0D
1194:  MOVLB  02
1195:  MOVWF  50
1196:  MOVLP  00
1197:  MOVLB  00
1198:  CALL   662
1199:  MOVLP  10
119A:  MOVF   70,W
119B:  MOVLB  02
119C:  MOVWF  50
119D:  MOVLW  01
119E:  MOVWF  51
119F:  MOVLP  00
11A0:  MOVLB  00
11A1:  CALL   6D6
11A2:  MOVLP  10
....................     crlf(); printf("  Argument : %u",argument); 
11A3:  MOVLP  00
11A4:  CALL   45E
11A5:  MOVLP  10
11A6:  MOVLW  B2
11A7:  MOVLB  03
11A8:  MOVWF  11
11A9:  MOVLW  03
11AA:  MOVWF  12
11AB:  BCF    03.0
11AC:  MOVLW  0D
11AD:  MOVLB  02
11AE:  MOVWF  50
11AF:  MOVLP  00
11B0:  MOVLB  00
11B1:  CALL   662
11B2:  MOVLP  10
11B3:  MOVLB  01
11B4:  MOVF   42,W
11B5:  MOVLB  02
11B6:  MOVWF  50
11B7:  MOVLW  1B
11B8:  MOVWF  51
11B9:  MOVLP  00
11BA:  MOVLB  00
11BB:  CALL   6D6
11BC:  MOVLP  10
....................     crlf(); printf("  Value    : %u",value); 
11BD:  MOVLP  00
11BE:  CALL   45E
11BF:  MOVLP  10
11C0:  MOVLW  BA
11C1:  MOVLB  03
11C2:  MOVWF  11
11C3:  MOVLW  03
11C4:  MOVWF  12
11C5:  BCF    03.0
11C6:  MOVLW  0D
11C7:  MOVLB  02
11C8:  MOVWF  50
11C9:  MOVLP  00
11CA:  MOVLB  00
11CB:  CALL   662
11CC:  MOVLP  10
11CD:  MOVLB  01
11CE:  MOVF   43,W
11CF:  MOVLB  02
11D0:  MOVWF  50
11D1:  MOVLW  1B
11D2:  MOVWF  51
11D3:  MOVLP  00
11D4:  MOVLB  00
11D5:  CALL   6D6
11D6:  MOVLP  10
....................   } 
....................   switch(command) { 
11D7:  MOVLW  02
11D8:  SUBWF  70,W
11D9:  ADDLW  F2
11DA:  BTFSC  03.0
11DB:  GOTO   616
11DC:  ADDLW  0E
11DD:  GOTO   617
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
1295:  GOTO   616
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
1296:  MOVLB  01
1297:  RLF    42,W
1298:  MOVWF  77
1299:  RLF    77,F
129A:  MOVLW  FC
129B:  ANDWF  77,F
129C:  MOVF   77,W
129D:  MOVLB  02
129E:  MOVWF  2D
129F:  INCF   2D,W
12A0:  MOVLP  00
12A1:  MOVLB  00
12A2:  CALL   043
12A3:  MOVLP  10
12A4:  MOVWF  7A
12A5:  MOVLB  02
12A6:  MOVF   2D,W
12A7:  MOVLP  00
12A8:  MOVLB  00
12A9:  CALL   043
12AA:  MOVLP  10
12AB:  MOVLB  02
12AC:  MOVWF  22
12AD:  MOVF   7A,W
12AE:  MOVWF  23
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
12AF:  MOVLW  01
12B0:  MOVWF  7A
12B1:  MOVLW  9B
12B2:  MOVWF  2D
12B3:  MOVF   7A,W
12B4:  MOVWF  2E
12B5:  CLRF   30
12B6:  MOVLB  01
12B7:  MOVF   42,W
12B8:  MOVLB  02
12B9:  MOVWF  2F
12BA:  MOVF   30,W
12BB:  MOVWF  3F
12BC:  MOVF   2F,W
12BD:  MOVWF  3E
12BE:  CLRF   41
12BF:  MOVLW  06
12C0:  MOVWF  40
12C1:  MOVLB  00
12C2:  CALL   028
12C3:  MOVF   78,W
12C4:  MOVLB  02
12C5:  ADDWF  2D,W
12C6:  MOVWF  25
12C7:  MOVF   79,W
12C8:  ADDWFC 2E,W
12C9:  MOVWF  26
....................       romstrcpy(rname,cPtr); 
12CA:  MOVLW  20
12CB:  MOVWF  3D
12CC:  MOVLW  A7
12CD:  MOVWF  3C
12CE:  MOVF   26,W
12CF:  MOVWF  3F
12D0:  MOVF   25,W
12D1:  MOVWF  3E
12D2:  MOVLB  00
12D3:  CALL   03F
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
12D4:  MOVLB  02
12D5:  MOVF   23,W
12D6:  MOVWF  7A
12D7:  MOVF   22,W
12D8:  MOVWF  04
12D9:  MOVF   23,W
12DA:  MOVWF  05
12DB:  MOVF   00,W
12DC:  MOVWF  2D
12DD:  MOVLW  20
12DE:  MOVLB  01
12DF:  MOVWF  67
12E0:  MOVLW  7A
12E1:  MOVWF  66
12E2:  MOVLW  5B
12E3:  MOVLB  02
12E4:  MOVWF  51
12E5:  MOVLP  00
12E6:  MOVLB  00
12E7:  CALL   7DF
12E8:  MOVLP  10
12E9:  MOVLB  01
12EA:  MOVF   42,W
12EB:  MOVLB  02
12EC:  MOVWF  2E
12ED:  MOVLW  01
12EE:  MOVWF  2F
12EF:  MOVLB  00
12F0:  CALL   0AC
12F1:  MOVLW  5D
12F2:  MOVLB  02
12F3:  MOVWF  51
12F4:  MOVLP  00
12F5:  MOVLB  00
12F6:  CALL   7DF
12F7:  MOVLP  10
12F8:  MOVLW  20
12F9:  MOVLB  02
12FA:  MOVWF  51
12FB:  MOVLP  00
12FC:  MOVLB  00
12FD:  CALL   7DF
12FE:  MOVLP  10
12FF:  MOVLW  20
1300:  MOVWF  05
1301:  MOVLW  A7
1302:  MOVWF  04
1303:  MOVLP  08
1304:  CALL   10E
1305:  MOVLP  10
1306:  MOVLW  20
1307:  MOVLB  02
1308:  MOVWF  51
1309:  MOVLP  00
130A:  MOVLB  00
130B:  CALL   7DF
130C:  MOVLP  10
130D:  MOVLB  02
130E:  MOVF   2D,W
130F:  MOVWF  2E
1310:  MOVLW  1B
1311:  MOVWF  2F
1312:  MOVLB  00
1313:  CALL   0AC
1314:  MOVLW  0A
1315:  MOVLB  02
1316:  MOVWF  51
1317:  MOVLP  00
1318:  MOVLB  00
1319:  CALL   7DF
131A:  MOVLP  10
131B:  MOVLW  0D
131C:  MOVLB  02
131D:  MOVWF  51
131E:  MOVLP  00
131F:  MOVLB  00
1320:  CALL   7DF
1321:  MOVLP  10
....................       crlf(); 
1322:  MOVLP  00
1323:  CALL   45E
1324:  MOVLP  10
....................       printf("%s",LCD_str); 
1325:  MOVLW  20
1326:  MOVWF  05
1327:  MOVLW  7A
1328:  MOVWF  04
1329:  MOVLP  08
132A:  CALL   266
132B:  MOVLP  10
....................       lcd_send(2,LCD_str); 
132C:  MOVLW  02
132D:  MOVLB  02
132E:  MOVWF  4B
132F:  MOVLW  20
1330:  MOVWF  4D
1331:  MOVLW  7A
1332:  MOVWF  4C
1333:  MOVLP  08
1334:  MOVLB  00
1335:  CALL   154
1336:  MOVLP  10
....................       prompt(); 
1337:  CALL   0F5
....................       break; 
1338:  GOTO   616
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
1339:  MOVLP  00
133A:  CALL   7EE
133B:  MOVLP  10
133C:  MOVF   78,F
133D:  BTFSC  03.2
133E:  GOTO   342
....................         store_variables(); 
133F:  MOVLP  00
1340:  CALL   560
1341:  MOVLP  10
....................       } 
....................       break; 
1342:  GOTO   616
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
1343:  MOVLB  01
1344:  DECFSZ 43,W
1345:  GOTO   34A
....................         init_src=USE_EEPROM_VARS; 
1346:  MOVLB  02
1347:  BSF    24.0
....................       } else { 
1348:  GOTO   34C
1349:  MOVLB  01
....................         init_src=USE_DEFAULT_VARS; 
134A:  MOVLB  02
134B:  BCF    24.0
....................       } 
....................       if ( in_admin_mode() ) { 
134C:  MOVLP  00
134D:  MOVLB  00
134E:  CALL   7EE
134F:  MOVLP  10
1350:  MOVF   78,F
1351:  BTFSC  03.2
1352:  GOTO   35D
....................         init_variables(init_src); 
1353:  MOVLW  00
1354:  MOVLB  02
1355:  BTFSC  24.0
1356:  MOVLW  01
1357:  MOVWF  2D
1358:  MOVWF  2E
1359:  MOVLP  00
135A:  MOVLB  00
135B:  CALL   5DE
135C:  MOVLP  10
....................       } 
....................       break; 
135D:  GOTO   616
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
135E:  MOVLB  01
135F:  MOVF   42,W
1360:  ANDLW  03
1361:  MOVWF  30
....................       increment(value); 
1362:  MOVF   43,W
1363:  MOVLB  02
1364:  MOVWF  30
1365:  MOVLB  00
1366:  CALL   06A
....................       PROMPT_FLAG=1; 
1367:  MOVLB  01
1368:  BSF    65.0
....................       break; 
1369:  MOVLB  00
136A:  GOTO   616
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
136B:  MOVLB  01
136C:  MOVF   42,W
136D:  ANDLW  03
136E:  MOVWF  30
....................       increment(-1*value); 
136F:  MOVLW  FF
1370:  MOVLB  02
1371:  MOVWF  45
1372:  MOVLB  01
1373:  MOVF   43,W
1374:  MOVLB  02
1375:  MOVWF  46
1376:  MOVLP  08
1377:  MOVLB  00
1378:  CALL   790
1379:  MOVLP  10
137A:  MOVF   78,W
137B:  MOVLB  02
137C:  MOVWF  2D
137D:  MOVWF  30
137E:  MOVLB  00
137F:  CALL   06A
....................       PROMPT_FLAG=1; 
1380:  MOVLB  01
1381:  BSF    65.0
....................       break; 
1382:  MOVLB  00
1383:  GOTO   616
....................     case STATUS: 
....................       status(); 
....................       break; 
*
1526:  MOVLB  00
1527:  GOTO   616
....................     case ADMIN: 
....................       switch(argument) { 
1528:  MOVLB  01
1529:  MOVF   42,W
152A:  XORLW  02
152B:  MOVLB  00
152C:  BTFSC  03.2
152D:  GOTO   535
152E:  XORLW  03
152F:  BTFSC  03.2
1530:  GOTO   53C
1531:  XORLW  02
1532:  BTFSC  03.2
1533:  GOTO   544
1534:  GOTO   546
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
1535:  MOVLP  00
1536:  CALL   7EE
1537:  MOVLP  10
1538:  MOVF   78,F
1539:  BTFSS  03.2
....................             reset_cpu(); 
153A:  RESET
....................           } 
....................           break; 
153B:  GOTO   54C
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
153C:  MOVLW  01
153D:  MOVLB  02
153E:  MOVWF  42
153F:  MOVLP  08
1540:  MOVLB  00
1541:  CALL   4BE
1542:  MOVLP  10
....................           break; 
1543:  GOTO   54C
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
1544:  CALL   11D
....................         break; 
1545:  GOTO   54C
....................         default: 
....................           set_admin_mode(0); 
1546:  MOVLB  02
1547:  CLRF   42
1548:  MOVLP  08
1549:  MOVLB  00
154A:  CALL   4BE
154B:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
154C:  GOTO   616
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
.................... #ifdef LCD_TYPE_PI 
....................       switch(value) { 
154D:  MOVLB  01
154E:  MOVF   43,W
154F:  XORLW  00
1550:  MOVLB  00
1551:  BTFSC  03.2
1552:  GOTO   557
1553:  XORLW  01
1554:  BTFSC  03.2
1555:  GOTO   55B
1556:  GOTO   563
....................         case 0 : init_lcd();break;   
1557:  MOVLP  08
1558:  CALL   4D3
1559:  MOVLP  10
155A:  GOTO   563
....................         case 1 : lcd_write(0,0x01); 
155B:  MOVLB  02
155C:  CLRF   50
155D:  MOVLW  01
155E:  MOVWF  51
155F:  MOVLP  08
1560:  MOVLB  00
1561:  CALL   138
1562:  MOVLP  10
....................       } 
.................... #else 
....................       lcd_cmd=4+(value&0x03); 
....................       sprintf(LCD_str,"I2C => %d",lcd_cmd); 
....................       crlf(); 
....................       printf("%s",LCD_str); 
....................       lcd_send(lcd_cmd,LCD_str); 
.................... #endif 
....................       break; 
1563:  GOTO   616
.................... #if __DEVICE__  == 1939 
....................     case SET_BIT: 
....................       set_bit(); 
....................       break; 
*
15B6:  GOTO   616
....................     case CLEAR_BIT: 
....................       clear_bit(); 
....................       break; 
*
160C:  MOVLB  00
160D:  GOTO   616
.................... #endif 
....................     case MORSE_SEND: 
....................       morse(value); 
160E:  MOVLB  01
160F:  MOVF   43,W
1610:  MOVLB  02
1611:  MOVWF  40
1612:  MOVLP  08
1613:  MOVLB  00
1614:  CALL   038
1615:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
1616:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  4B
1803:  MOVLW  20
1804:  MOVWF  4D
1805:  MOVLW  50
1806:  MOVWF  4C
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   154
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVLB  01
180D:  MOVWF  42
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1BC2:  MOVLB  01
1BC3:  CLRF   69
1BC4:  CLRF   68
1BC5:  MOVF   69,F
1BC6:  BTFSS  03.2
1BC7:  GOTO   416
1BC8:  MOVF   68,W
1BC9:  SUBLW  38
1BCA:  BTFSS  03.0
1BCB:  GOTO   416
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1BCC:  MOVLW  01
1BCD:  MOVWF  7A
1BCE:  MOVLW  9B
1BCF:  MOVLB  02
1BD0:  MOVWF  22
1BD1:  MOVF   7A,W
1BD2:  MOVWF  23
1BD3:  MOVLB  01
1BD4:  MOVF   69,W
1BD5:  MOVLB  02
1BD6:  MOVWF  3F
1BD7:  MOVLB  01
1BD8:  MOVF   68,W
1BD9:  MOVLB  02
1BDA:  MOVWF  3E
1BDB:  CLRF   41
1BDC:  MOVLW  06
1BDD:  MOVWF  40
1BDE:  MOVLP  10
1BDF:  MOVLB  00
1BE0:  CALL   028
1BE1:  MOVLP  18
1BE2:  MOVF   78,W
1BE3:  MOVLB  02
1BE4:  ADDWF  22,W
1BE5:  MOVLB  01
1BE6:  MOVWF  6A
1BE7:  MOVF   79,W
1BE8:  MOVLB  02
1BE9:  ADDWFC 23,W
1BEA:  MOVLB  01
1BEB:  MOVWF  6B
....................     romstrcpy(rname,cPtr); 
1BEC:  MOVLW  20
1BED:  MOVLB  02
1BEE:  MOVWF  3D
1BEF:  MOVLW  9C
1BF0:  MOVWF  3C
1BF1:  MOVLB  01
1BF2:  MOVF   6B,W
1BF3:  MOVLB  02
1BF4:  MOVWF  3F
1BF5:  MOVLB  01
1BF6:  MOVF   6A,W
1BF7:  MOVLB  02
1BF8:  MOVWF  3E
1BF9:  MOVLP  10
1BFA:  MOVLB  00
1BFB:  CALL   03F
1BFC:  MOVLP  18
....................     if(my_stricmp(argument_name,rname)==0) { 
1BFD:  MOVLW  20
1BFE:  MOVLB  02
1BFF:  MOVWF  42
1C00:  MOVLW  74
1C01:  MOVWF  41
1C02:  MOVLW  20
1C03:  MOVWF  44
1C04:  MOVLW  9C
1C05:  MOVWF  43
1C06:  MOVLP  10
1C07:  MOVLB  00
1C08:  CALL   000
1C09:  MOVLP  18
1C0A:  MOVF   78,F
1C0B:  BTFSS  03.2
1C0C:  GOTO   411
....................       argument=x; 
1C0D:  MOVLB  01
1C0E:  MOVF   68,W
1C0F:  MOVWF  42
1C10:  MOVLB  00
....................     } 
....................   } 
1C11:  MOVLB  01
1C12:  INCF   68,F
1C13:  BTFSC  03.2
1C14:  INCF   69,F
1C15:  GOTO   3C5
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1C16:  MOVF   42,W
1C17:  SUBLW  FF
1C18:  BTFSS  03.2
1C19:  GOTO   47E
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1C1A:  MOVLW  20
1C1B:  MOVLB  02
1C1C:  MOVWF  42
1C1D:  MOVLW  74
1C1E:  MOVWF  41
1C1F:  MOVLP  08
1C20:  MOVLB  00
1C21:  CALL   7B7
1C22:  MOVLP  18
1C23:  MOVF   78,W
1C24:  MOVLB  01
1C25:  MOVWF  43
....................     strcpy(rname,"eeprom"); 
1C26:  MOVLB  02
1C27:  CLRF   22
1C28:  CLRF   23
1C29:  MOVLW  20
1C2A:  MOVWF  05
1C2B:  MOVLW  9C
1C2C:  MOVWF  04
1C2D:  MOVF   22,W
1C2E:  ADDWF  04,F
1C2F:  MOVLW  00
1C30:  ADDWFC 05,F
1C31:  MOVF   23,W
1C32:  MOVLP  00
1C33:  MOVLB  00
1C34:  CALL   128
1C35:  MOVLP  18
1C36:  MOVWF  00
1C37:  IORLW  00
1C38:  BTFSC  03.2
1C39:  GOTO   43F
1C3A:  MOVLB  02
1C3B:  INCF   23,F
1C3C:  INCF   22,F
1C3D:  GOTO   429
1C3E:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C3F:  MOVLW  20
1C40:  MOVLB  02
1C41:  MOVWF  42
1C42:  MOVLW  74
1C43:  MOVWF  41
1C44:  MOVLW  20
1C45:  MOVWF  44
1C46:  MOVLW  9C
1C47:  MOVWF  43
1C48:  MOVLP  10
1C49:  MOVLB  00
1C4A:  CALL   000
1C4B:  MOVLP  18
1C4C:  MOVF   78,F
1C4D:  BTFSS  03.2
1C4E:  GOTO   453
....................       value=USE_EEPROM_VARS; 
1C4F:  MOVLW  01
1C50:  MOVLB  01
1C51:  MOVWF  43
1C52:  MOVLB  00
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1C53:  MOVLB  02
1C54:  CLRF   22
1C55:  CLRF   23
1C56:  MOVLW  20
1C57:  MOVWF  05
1C58:  MOVLW  9C
1C59:  MOVWF  04
1C5A:  MOVF   22,W
1C5B:  ADDWF  04,F
1C5C:  MOVLW  00
1C5D:  ADDWFC 05,F
1C5E:  MOVF   23,W
1C5F:  MOVLP  00
1C60:  MOVLB  00
1C61:  CALL   130
1C62:  MOVLP  18
1C63:  MOVWF  00
1C64:  IORLW  00
1C65:  BTFSC  03.2
1C66:  GOTO   46C
1C67:  MOVLB  02
1C68:  INCF   23,F
1C69:  INCF   22,F
1C6A:  GOTO   456
1C6B:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C6C:  MOVLW  20
1C6D:  MOVLB  02
1C6E:  MOVWF  42
1C6F:  MOVLW  74
1C70:  MOVWF  41
1C71:  MOVLW  20
1C72:  MOVWF  44
1C73:  MOVLW  9C
1C74:  MOVWF  43
1C75:  MOVLP  10
1C76:  MOVLB  00
1C77:  CALL   000
1C78:  MOVLP  18
1C79:  MOVF   78,F
1C7A:  BTFSS  03.2
1C7B:  GOTO   47F
....................       value=USE_DEFAULT_VARS; 
1C7C:  MOVLB  01
1C7D:  CLRF   43
1C7E:  MOVLB  00
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C7F:  MOVF   70,W
1C80:  SUBLW  06
1C81:  BTFSC  03.2
1C82:  GOTO   487
1C83:  MOVF   70,W
1C84:  SUBLW  07
1C85:  BTFSS  03.2
1C86:  GOTO   48D
....................     value = 1; 
1C87:  MOVLW  01
1C88:  MOVLB  01
1C89:  MOVWF  43
....................     argument = CurrentTrimPot; 
1C8A:  MOVF   30,W
1C8B:  MOVWF  42
1C8C:  MOVLB  00
....................   } 
....................   rs232_mode = 1; 
1C8D:  MOVLB  01
1C8E:  BSF    65.2
....................   execute_command(); 
1C8F:  MOVLP  10
1C90:  MOVLB  00
1C91:  CALL   15F
1C92:  MOVLP  18
....................   rs232_mode = 0; 
1C93:  MOVLB  01
1C94:  BCF    65.2
.................... } // }}} 
1C95:  MOVLP  20
1C96:  MOVLB  00
1C97:  GOTO   13B (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
1384:  MOVLW  1B
1385:  MOVLP  00
1386:  CALL   2F0
1387:  MOVLP  10
....................   printf("[2J"); 
1388:  MOVLW  5B
1389:  CLRWDT
138A:  BTFSS  11.4
138B:  GOTO   389
138C:  MOVLB  03
138D:  MOVWF  1A
138E:  MOVLW  32
138F:  CLRWDT
1390:  MOVLB  00
1391:  BTFSC  11.4
1392:  GOTO   395
1393:  MOVLB  03
1394:  GOTO   38F
1395:  MOVLB  03
1396:  MOVWF  1A
1397:  MOVLW  4A
1398:  CLRWDT
1399:  MOVLB  00
139A:  BTFSC  11.4
139B:  GOTO   39E
139C:  MOVLB  03
139D:  GOTO   398
139E:  MOVLB  03
139F:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
13A0:  MOVLW  1B
13A1:  MOVLP  00
13A2:  MOVLB  00
13A3:  CALL   2F0
13A4:  MOVLP  10
....................   printf("[0;0H"); 
13A5:  MOVLW  C2
13A6:  MOVLB  03
13A7:  MOVWF  11
13A8:  MOVLW  03
13A9:  MOVWF  12
13AA:  MOVLP  00
13AB:  MOVLB  00
13AC:  CALL   463
13AD:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
0725:  MOVLB  02
0726:  SWAPF  40,W
0727:  MOVWF  42
0728:  RLF    42,F
0729:  RLF    42,F
072A:  MOVLW  C0
072B:  ANDWF  42,F
....................   tx_value=tx_value + (value & 0x3F); 
072C:  MOVF   41,W
072D:  ANDLW  3F
072E:  ADDWF  42,F
....................   i2c_start(); 
072F:  MOVLB  04
0730:  BSF    16.0
0731:  BTFSC  16.0
0732:  GOTO   731
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
0733:  MOVLW  50
0734:  MOVLB  02
0735:  MOVWF  56
0736:  MOVLB  00
0737:  CALL   64D
0738:  MOVF   78,W
0739:  MOVLB  02
073A:  BCF    43.0
073B:  BTFSC  78.0
073C:  BSF    43.0
....................   if ( ack != 0) { 
073D:  BTFSS  43.0
073E:  GOTO   749
....................     crlf(); 
073F:  MOVLB  00
0740:  CALL   45E
....................     printf("I2C : !ACK"); 
0741:  MOVLW  C5
0742:  MOVLB  03
0743:  MOVWF  11
0744:  MOVLW  03
0745:  MOVWF  12
0746:  MOVLB  00
0747:  CALL   463
0748:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
0749:  MOVF   42,W
074A:  MOVWF  56
074B:  MOVLB  00
074C:  CALL   64D
....................   i2c_stop();   
074D:  MOVLB  04
074E:  BSF    16.2
074F:  BTFSC  16.2
0750:  GOTO   74F
....................   crlf(); 
0751:  MOVLB  00
0752:  CALL   45E
....................   printf("Pot(%u)<=%u",pot,value); 
0753:  MOVLW  CB
0754:  MOVLB  03
0755:  MOVWF  11
0756:  MOVLW  03
0757:  MOVWF  12
0758:  BCF    03.0
0759:  MOVLW  04
075A:  MOVLB  02
075B:  MOVWF  50
075C:  MOVLB  00
075D:  CALL   662
075E:  MOVLB  02
075F:  MOVF   40,W
0760:  MOVWF  50
0761:  MOVLW  1B
0762:  MOVWF  51
0763:  MOVLB  00
0764:  CALL   6D6
0765:  MOVLW  29
0766:  CLRWDT
0767:  BTFSS  11.4
0768:  GOTO   766
0769:  MOVLB  03
076A:  MOVWF  1A
076B:  MOVLW  3C
076C:  CLRWDT
076D:  MOVLB  00
076E:  BTFSC  11.4
076F:  GOTO   772
0770:  MOVLB  03
0771:  GOTO   76C
0772:  MOVLB  03
0773:  MOVWF  1A
0774:  MOVLW  3D
0775:  CLRWDT
0776:  MOVLB  00
0777:  BTFSC  11.4
0778:  GOTO   77B
0779:  MOVLB  03
077A:  GOTO   775
077B:  MOVLB  03
077C:  MOVWF  1A
077D:  MOVLB  02
077E:  MOVF   41,W
077F:  MOVWF  50
0780:  MOVLW  1B
0781:  MOVWF  51
0782:  MOVLB  00
0783:  CALL   6D6
....................  
.................... } // }}} 
0784:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
0838:  MOVLW  DB
0839:  MOVLB  02
083A:  ADDWF  40,W
083B:  MOVWF  44
083C:  MOVLW  3F
083D:  MOVWF  45
083E:  BTFSC  03.0
083F:  INCF   45,F
0840:  MOVF   45,W
0841:  MOVLB  03
0842:  MOVWF  12
0843:  MOVLB  02
0844:  MOVF   44,W
0845:  MOVLB  03
0846:  MOVWF  11
0847:  MOVLW  20
0848:  MOVWF  05
0849:  MOVLW  C1
084A:  MOVWF  04
084B:  MOVLW  01
084C:  MOVLB  02
084D:  MOVWF  46
084E:  MOVLP  00
084F:  MOVLB  00
0850:  CALL   79E
0851:  MOVLP  08
....................    
....................   PROMPT_FLAG=1; 
0852:  MOVLB  01
0853:  BSF    65.0
....................   for(x=0;x<4;x++) { 
0854:  MOVLB  02
0855:  CLRF   42
0856:  MOVF   42,W
0857:  SUBLW  03
0858:  BTFSS  03.0
0859:  GOTO   082
....................     do_delay=1; 
085A:  BSF    43.0
....................     switch(mc & 0xc0) { // Check two MSB's 
085B:  MOVF   41,W
085C:  ANDLW  C0
085D:  XORLW  40
085E:  MOVLB  00
085F:  BTFSC  03.2
0860:  GOTO   065
0861:  XORLW  C0
0862:  BTFSC  03.2
0863:  GOTO   069
0864:  GOTO   06B
....................       case(0x40): 
....................         dit(); 
0865:  MOVLP  00
0866:  CALL   7B1
0867:  MOVLP  08
....................         break; 
0868:  GOTO   06E
....................       case(0x80): 
....................         dah(); 
0869:  CALL   000
....................         break; 
086A:  GOTO   06E
....................       default: 
....................         do_delay=0; 
086B:  MOVLB  02
086C:  BCF    43.0
....................         break; 
086D:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
086E:  MOVLB  02
086F:  RLF    41,F
0870:  RLF    41,F
0871:  MOVLW  FC
0872:  ANDWF  41,F
....................     if ( do_delay ) { 
0873:  BTFSS  43.0
0874:  GOTO   080
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
0875:  MOVLB  01
0876:  CLRF   34
0877:  MOVLW  02
0878:  MOVWF  33
....................       while(aux_timer) { 
0879:  MOVF   33,W
087A:  IORWF  34,W
087B:  BTFSC  03.2
087C:  GOTO   07F
....................         delay_cycles(1); 
087D:  NOP
....................       } 
087E:  GOTO   079
087F:  MOVLB  02
....................     } 
....................   } 
0880:  INCF   42,F
0881:  GOTO   056
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
0882:  MOVF   40,W
0883:  SUBLW  09
0884:  BTFSS  03.0
0885:  GOTO   093
....................     if ( c < 5 ) { 
0886:  MOVF   40,W
0887:  SUBLW  04
0888:  BTFSS  03.0
0889:  GOTO   08E
....................       dah(); 
088A:  MOVLB  00
088B:  CALL   000
....................     } 
....................     else { 
088C:  GOTO   092
088D:  MOVLB  02
....................       dit(); 
088E:  MOVLP  00
088F:  MOVLB  00
0890:  CALL   7B1
0891:  MOVLP  08
0892:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
0893:  MOVLB  00
0894:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0B7C:  MOVLW  30
0B7D:  MOVLB  02
0B7E:  MOVWF  35
0B7F:  MOVWF  36
0B80:  MOVWF  37
0B81:  MOVWF  38
0B82:  CLRF   39
....................   char PTT_s[5]={'0','0','0','0',0}; 
0B83:  MOVWF  3A
0B84:  MOVWF  3B
0B85:  MOVWF  3C
0B86:  MOVWF  3D
0B87:  CLRF   3E
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0B88:  MOVF   2F,W
0B89:  MOVWF  75
....................  
....................   if ( cor ) { 
0B8A:  MOVF   2F,F
0B8B:  BTFSC  03.2
0B8C:  GOTO   39E
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0B8D:  MOVLW  01
0B8E:  SUBWF  2F,W
0B8F:  ADDLW  29
0B90:  MOVWF  04
0B91:  MOVLW  20
0B92:  MOVWF  05
0B93:  BTFSC  03.0
0B94:  INCF   05,F
0B95:  MOVF   00,W
0B96:  MOVWF  40
0B97:  MOVLB  00
0B98:  MOVF   62,W
0B99:  ANDWF  63,W
0B9A:  MOVLB  02
0B9B:  ANDWF  40,W
0B9C:  MOVWF  34
....................   } else { 
0B9D:  GOTO   3E1
....................     ptt=0; 
0B9E:  CLRF   34
....................     if ( COR_DROP_FLAG ) { 
0B9F:  MOVLB  01
0BA0:  BTFSS  62.0
0BA1:  GOTO   3E2
....................       COR_DROP_FLAG=0; 
0BA2:  BCF    62.0
....................       if ( ConfirmChar || TailChar ) { 
0BA3:  MOVF   73,F
0BA4:  BTFSS  03.2
0BA5:  GOTO   3A9
0BA6:  MOVF   72,F
0BA7:  BTFSC  03.2
0BA8:  GOTO   3E2
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0BE2:  MOVLW  01
0BE3:  MOVLB  02
0BE4:  MOVWF  33
....................   for(x=0;x<4;x++) { 
0BE5:  CLRF   30
0BE6:  MOVF   30,W
0BE7:  SUBLW  03
0BE8:  BTFSS  03.0
0BE9:  GOTO   44A
....................     if ( !cor ) { 
0BEA:  MOVF   2F,F
0BEB:  BTFSS  03.2
0BEC:  GOTO   3F0
....................       rx_bit=0; 
0BED:  BCF    3F.0
....................       ptt_bit=0; 
0BEE:  BCF    3F.1
....................     } else { 
0BEF:  GOTO   3FF
....................       if ( cor == (x+1) ) { 
0BF0:  MOVLW  01
0BF1:  ADDWF  30,W
0BF2:  SUBWF  2F,W
0BF3:  BTFSS  03.2
0BF4:  GOTO   3F9
....................         rx_bit=1; 
0BF5:  BSF    3F.0
....................         CurrentCorMask=mask; 
0BF6:  MOVF   33,W
0BF7:  MOVWF  74
....................       } else { 
0BF8:  GOTO   3FA
....................         rx_bit=0; 
0BF9:  BCF    3F.0
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0BFA:  BCF    3F.1
0BFB:  MOVF   34,W
0BFC:  ANDWF  33,W
0BFD:  BTFSS  03.2
0BFE:  BSF    3F.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0BFF:  MOVF   30,W
0C00:  MOVLP  00
0C01:  MOVLB  00
0C02:  CALL   031
0C03:  MOVLP  08
0C04:  MOVLB  02
0C05:  MOVWF  40
0C06:  MOVLW  00
0C07:  BTFSC  3F.0
0C08:  MOVLW  01
0C09:  MOVWF  77
0C0A:  MOVF   40,W
0C0B:  MOVWF  41
0C0C:  MOVF   77,W
0C0D:  MOVWF  42
0C0E:  MOVLW  01
0C0F:  MOVWF  44
0C10:  CLRF   43
0C11:  MOVLB  00
0C12:  CALL   095
0C13:  MOVLB  02
0C14:  MOVF   40,W
0C15:  MOVWF  41
0C16:  CLRF   42
0C17:  CLRF   44
0C18:  MOVLW  80
0C19:  MOVWF  43
0C1A:  MOVLB  00
0C1B:  CALL   095
....................     output_bit(PTT_PIN[x],ptt_bit); 
0C1C:  MOVLB  02
0C1D:  MOVF   30,W
0C1E:  MOVLP  00
0C1F:  MOVLB  00
0C20:  CALL   036
0C21:  MOVLP  08
0C22:  MOVLB  02
0C23:  MOVWF  40
0C24:  MOVLW  00
0C25:  BTFSC  3F.1
0C26:  MOVLW  01
0C27:  MOVWF  77
0C28:  MOVF   40,W
0C29:  MOVWF  41
0C2A:  MOVF   77,W
0C2B:  MOVWF  42
0C2C:  MOVLW  01
0C2D:  MOVWF  44
0C2E:  CLRF   43
0C2F:  MOVLB  00
0C30:  CALL   095
0C31:  MOVLB  02
0C32:  MOVF   40,W
0C33:  MOVWF  41
0C34:  CLRF   42
0C35:  CLRF   44
0C36:  MOVLW  80
0C37:  MOVWF  43
0C38:  MOVLB  00
0C39:  CALL   095
....................     if(ptt_bit) { 
0C3A:  MOVLB  02
0C3B:  BTFSS  3F.1
0C3C:  GOTO   446
....................       PTT_s[x]='1'; 
0C3D:  MOVLW  BA
0C3E:  ADDWF  30,W
0C3F:  MOVWF  04
0C40:  MOVLW  20
0C41:  MOVWF  05
0C42:  BTFSC  03.0
0C43:  INCF   05,F
0C44:  MOVLW  31
0C45:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C46:  BCF    03.0
0C47:  RLF    33,F
....................   }  
0C48:  INCF   30,F
0C49:  GOTO   3E6
....................   if(!cor) { 
0C4A:  MOVF   2F,F
0C4B:  BTFSS  03.2
0C4C:  GOTO   44F
....................     CurrentCorPriority=0; 
0C4D:  CLRF   76
....................   } else { 
0C4E:  GOTO   47D
....................     CurrentCorPriority=RXPriority[cor-1]; 
0C4F:  MOVLW  01
0C50:  SUBWF  2F,W
0C51:  ADDLW  25
0C52:  MOVWF  04
0C53:  MOVLW  20
0C54:  MOVWF  05
0C55:  BTFSC  03.0
0C56:  INCF   05,F
0C57:  MOVF   00,W
0C58:  MOVWF  76
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0C59:  CLRF   31
0C5A:  MOVF   31,W
0C5B:  SUBLW  03
0C5C:  BTFSS  03.0
0C5D:  GOTO   47A
....................       pot_val=RX_GAIN[cor-1][pot]; 
0C5E:  MOVLW  01
0C5F:  SUBWF  2F,W
0C60:  MOVWF  77
0C61:  RLF    77,F
0C62:  RLF    77,F
0C63:  MOVLW  FC
0C64:  ANDWF  77,F
0C65:  MOVF   77,W
0C66:  ADDWF  31,W
0C67:  ADDLW  0C
0C68:  MOVWF  04
0C69:  MOVLW  20
0C6A:  MOVWF  05
0C6B:  BTFSC  03.0
0C6C:  INCF   05,F
0C6D:  MOVF   00,W
0C6E:  MOVWF  32
....................       set_trimpot(pot,pot_val); 
0C6F:  MOVF   31,W
0C70:  MOVWF  40
0C71:  MOVF   32,W
0C72:  MOVWF  41
0C73:  MOVLP  00
0C74:  MOVLB  00
0C75:  CALL   725
0C76:  MOVLP  08
....................     } 
0C77:  MOVLB  02
0C78:  INCF   31,F
0C79:  GOTO   45A
....................     PROMPT_FLAG=1; 
0C7A:  MOVLB  01
0C7B:  BSF    65.0
0C7C:  MOVLB  02
....................   } 
....................   COR_s[cor-1]='1'; 
0C7D:  MOVLW  01
0C7E:  SUBWF  2F,W
0C7F:  ADDLW  B5
0C80:  MOVWF  04
0C81:  MOVLW  20
0C82:  MOVWF  05
0C83:  BTFSC  03.0
0C84:  INCF   05,F
0C85:  MOVLW  31
0C86:  MOVWF  00
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0C87:  MOVLW  20
0C88:  MOVLB  01
0C89:  MOVWF  67
0C8A:  MOVLW  7A
0C8B:  MOVWF  66
0C8C:  MOVLW  D1
0C8D:  MOVLB  03
0C8E:  MOVWF  11
0C8F:  MOVLW  03
0C90:  MOVWF  12
0C91:  BCF    03.0
0C92:  MOVLW  04
0C93:  MOVLB  02
0C94:  MOVWF  4B
0C95:  MOVLB  00
0C96:  CALL   0B7
0C97:  MOVLW  20
0C98:  MOVWF  05
0C99:  MOVLW  B5
0C9A:  MOVWF  04
0C9B:  CALL   10E
0C9C:  MOVLW  D4
0C9D:  MOVLB  03
0C9E:  MOVWF  11
0C9F:  MOVLW  03
0CA0:  MOVWF  12
0CA1:  BCF    03.0
0CA2:  MOVLW  05
0CA3:  MOVLB  02
0CA4:  MOVWF  4B
0CA5:  MOVLB  00
0CA6:  CALL   0B7
0CA7:  MOVLW  20
0CA8:  MOVWF  05
0CA9:  MOVLW  BA
0CAA:  MOVWF  04
0CAB:  CALL   10E
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0CAC:  MOVLW  01
0CAD:  MOVLB  02
0CAE:  MOVWF  4B
0CAF:  MOVLW  20
0CB0:  MOVWF  4D
0CB1:  MOVLW  7A
0CB2:  MOVWF  4C
0CB3:  MOVLB  00
0CB4:  CALL   154
....................   delay_ms(50); 
0CB5:  MOVLW  32
0CB6:  MOVLB  02
0CB7:  MOVWF  4B
0CB8:  MOVLP  00
0CB9:  MOVLB  00
0CBA:  CALL   785
0CBB:  MOVLP  08
....................   pot_values_to_lcd(); 
0CBC:  CALL   280
.................... }// }}} 
0CBD:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
2054:  MOVF   6A,W
2055:  SUBLW  0A
2056:  BTFSS  03.0
2057:  GOTO   072
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
2058:  MOVLW  66
2059:  ADDWF  6A,W
205A:  MOVWF  04
205B:  MOVLW  20
205C:  MOVWF  05
205D:  BTFSC  03.0
205E:  INCF   05,F
205F:  BTFSS  00.4
2060:  GOTO   070
2061:  MOVLW  66
2062:  ADDWF  6A,W
2063:  MOVWF  04
2064:  MOVLW  20
2065:  MOVWF  05
2066:  BTFSC  03.0
2067:  INCF   05,F
2068:  MOVF   00,W
2069:  ANDLW  0F
206A:  SUBLW  0C
206B:  BTFSC  03.2
206C:  GOTO   070
....................       strobe=1; 
206D:  MOVLW  01
206E:  MOVWF  6B
....................      } else { 
206F:  GOTO   071
....................       strobe = 0; 
2070:  CLRF   6B
....................     }  
....................   } else { 
2071:  GOTO   073
....................     strobe=0; 
2072:  CLRF   6B
....................   } 
....................   return(strobe); 
2073:  MOVF   6B,W
2074:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
1F89:  MOVLB  01
1F8A:  MOVF   6A,W
1F8B:  SUBWF  6B,W
1F8C:  BTFSS  03.0
1F8D:  GOTO   7B3
1F8E:  MOVF   6A,W
1F8F:  SUBLW  09
1F90:  BTFSS  03.0
1F91:  GOTO   7B3
....................     valid=1; 
1F92:  BSF    6E.0
....................     for(x=a;x<=b;x++) { 
1F93:  MOVF   6A,W
1F94:  MOVWF  6D
1F95:  MOVF   6D,W
1F96:  SUBWF  6B,W
1F97:  BTFSS  03.0
1F98:  GOTO   7B2
....................       key=(int)DTMF_ARRAY[x].Key; 
1F99:  MOVLW  66
1F9A:  ADDWF  6D,W
1F9B:  MOVWF  04
1F9C:  MOVLW  20
1F9D:  MOVWF  05
1F9E:  BTFSC  03.0
1F9F:  INCF   05,F
1FA0:  MOVF   00,W
1FA1:  ANDLW  0F
1FA2:  MOVWF  6C
....................       if(! DTMF_ARRAY[x].Strobe ) { 
1FA3:  MOVLW  66
1FA4:  ADDWF  6D,W
1FA5:  MOVWF  04
1FA6:  MOVLW  20
1FA7:  MOVWF  05
1FA8:  BTFSC  03.0
1FA9:  INCF   05,F
1FAA:  BTFSS  00.4
....................         valid=0; 
1FAB:  BCF    6E.0
....................       } 
....................      if(key==dp) { 
1FAC:  MOVF   6C,W
1FAD:  SUBLW  0C
1FAE:  BTFSC  03.2
....................         valid=0; 
1FAF:  BCF    6E.0
....................       } 
....................     } 
1FB0:  INCF   6D,F
1FB1:  GOTO   795
....................   } else { 
1FB2:  GOTO   7B4
....................     valid=0; 
1FB3:  BCF    6E.0
....................   } 
....................   return(valid); 
1FB4:  MOVLW  00
1FB5:  BTFSC  6E.0
1FB6:  MOVLW  01
1FB7:  MOVWF  78
.................... } // }}} 
1FB8:  MOVLB  00
1FB9:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   unsigned site_id; 
....................   unsigned digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 01 : Link commands 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : Disable Link Radio 
....................   // 11 : Enable Link Radio 
....................   // 12 : Send to I2C 
....................   // 14 : SetBit   (*52 14 <reg> <bit>) 
....................   // 15 : ClearBit (*52 15 <reg> <bit>) 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Save Settings	    : 52 04 00 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   // -- User Functions -- 
....................   // Disable AuxOut0        : 51 02 21 0 #  
....................   // Disable AuxOut0 (!Arg) : 51 02 21 #  
....................   // Enable  AuxOut1        : 51 02 22 1 # 
....................   command=0; 
*
2000:  CLRF   70
....................   value=0; 
2001:  MOVLB  01
2002:  CLRF   43
....................   if ( ValidKeyRange(0,3)) { 
2003:  CLRF   6A
2004:  MOVLW  03
2005:  MOVWF  6B
2006:  MOVLP  18
2007:  MOVLB  00
2008:  CALL   789
2009:  MOVLP  20
200A:  MOVF   78,F
200B:  BTFSC  03.2
200C:  GOTO   0C1
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
200D:  MOVLB  01
200E:  MOVF   36,W
200F:  ANDLW  0F
2010:  MOVWF  6B
2011:  MOVLB  02
2012:  MOVWF  45
2013:  MOVLW  0A
2014:  MOVWF  46
2015:  MOVLP  08
2016:  MOVLB  00
2017:  CALL   790
2018:  MOVLP  20
2019:  MOVF   78,W
201A:  MOVLB  01
201B:  MOVWF  6A
201C:  MOVF   37,W
201D:  ANDLW  0F
201E:  ADDWF  6A,W
201F:  MOVWF  68
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
2020:  MOVF   38,W
2021:  ANDLW  0F
2022:  MOVWF  6B
2023:  MOVLB  02
2024:  MOVWF  45
2025:  MOVLW  0A
2026:  MOVWF  46
2027:  MOVLP  08
2028:  MOVLB  00
2029:  CALL   790
202A:  MOVLP  20
202B:  MOVF   78,W
202C:  MOVLB  01
202D:  MOVWF  6A
202E:  MOVF   39,W
202F:  ANDLW  0F
2030:  ADDWF  6A,W
2031:  MOVWF  70
....................     if ( ValidKeyRange(4,5) ) { 
2032:  MOVLW  04
2033:  MOVWF  6A
2034:  MOVLW  05
2035:  MOVWF  6B
2036:  MOVLP  18
2037:  MOVLB  00
2038:  CALL   789
2039:  MOVLP  20
203A:  MOVF   78,F
203B:  BTFSC  03.2
203C:  GOTO   093
....................       // Admin mode {{{ 
....................       argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
203D:  MOVLB  01
203E:  MOVF   3A,W
203F:  ANDLW  0F
2040:  MOVWF  6B
2041:  MOVLB  02
2042:  MOVWF  45
2043:  MOVLW  0A
2044:  MOVWF  46
2045:  MOVLP  08
2046:  MOVLB  00
2047:  CALL   790
2048:  MOVLP  20
2049:  MOVF   78,W
204A:  MOVLB  01
204B:  MOVWF  6A
204C:  MOVF   3B,W
204D:  ANDLW  0F
204E:  ADDWF  6A,W
204F:  MOVWF  42
....................       digit=6; 
2050:  MOVLW  06
2051:  MOVWF  69
....................       while(ValidKey(digit)) { 
2052:  MOVF   69,W
2053:  MOVWF  6A
*
2075:  MOVF   78,F
2076:  BTFSC  03.2
2077:  GOTO   091
....................        value = value * 10 + DTMF_ARRAY[digit].Key; 
2078:  MOVF   43,W
2079:  MOVLB  02
207A:  MOVWF  45
207B:  MOVLW  0A
207C:  MOVWF  46
207D:  MOVLP  08
207E:  MOVLB  00
207F:  CALL   790
2080:  MOVLP  20
2081:  MOVF   78,W
2082:  MOVLB  01
2083:  MOVWF  6A
2084:  MOVLW  66
2085:  ADDWF  69,W
2086:  MOVWF  04
2087:  MOVLW  20
2088:  MOVWF  05
2089:  BTFSC  03.0
208A:  INCF   05,F
208B:  MOVF   00,W
208C:  ANDLW  0F
208D:  ADDWF  6A,W
208E:  MOVWF  43
....................        digit++; 
208F:  INCF   69,F
....................       } 
2090:  GOTO   052
....................       // Admin mode }}} 
....................     } else { 
2091:  GOTO   0AC
2092:  MOVLB  00
....................       // User function {{{ 
....................       // Only 4 digits were entered.  
....................       // Use 'command' value as user function. 
....................       switch(command) { 
2093:  MOVF   70,W
2094:  XORLW  0A
2095:  BTFSC  03.2
2096:  GOTO   09B
2097:  XORLW  01
2098:  BTFSC  03.2
2099:  GOTO   0A2
209A:  GOTO   0AA
....................         // Commands 10 (disable link) and 11 (enable link) 
....................         case(10): 
....................           argument = 0; 
209B:  MOVLB  01
209C:  CLRF   42
....................           value = 0x0E; 
209D:  MOVLW  0E
209E:  MOVWF  43
.................... 	  command=SET_REG; 
209F:  MOVLW  02
20A0:  MOVWF  70
....................   	      break; 
20A1:  GOTO   0AC
....................         case(11): 
....................           argument = 0; 
20A2:  MOVLB  01
20A3:  CLRF   42
....................           value = 0x0F; 
20A4:  MOVLW  0F
20A5:  MOVWF  43
.................... 	  command=SET_REG; 
20A6:  MOVLW  02
20A7:  MOVWF  70
....................    		    break; 
20A8:  GOTO   0AC
20A9:  MOVLB  00
.................... 	default: 
.................... 	  command=0; 
20AA:  CLRF   70
20AB:  MOVLB  01
....................       } 
....................       // User function }}} 
....................     } 
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
20AC:  MOVF   70,W
20AD:  XORLW  04
20AE:  MOVLB  00
20AF:  BTFSC  03.2
20B0:  GOTO   0B4
20B1:  XORLW  01
20B2:  BTFSS  03.2
20B3:  GOTO   0B8
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
20B4:  MOVLB  01
20B5:  MOVF   42,W
20B6:  MOVWF  43
....................         break; 
20B7:  MOVLB  00
....................     } 
....................     if ( site_id == SiteID ) { 
20B8:  MOVF   65,W
20B9:  MOVLB  01
20BA:  SUBWF  68,W
20BB:  BTFSS  03.2
20BC:  GOTO   0C2
....................       execute_command(); 
20BD:  MOVLP  10
20BE:  MOVLB  00
20BF:  CALL   15F
20C0:  MOVLP  20
20C1:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
20C2:  MOVF   36,W
20C3:  ANDLW  0F
20C4:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
20C5:  BTFSS  65.1
20C6:  GOTO   0FB
20C7:  CLRF   6A
20C8:  CLRF   6B
20C9:  MOVLP  18
20CA:  MOVLB  00
20CB:  CALL   789
20CC:  MOVLP  20
20CD:  MOVF   78,F
20CE:  BTFSS  03.2
20CF:  GOTO   0D2
20D0:  MOVLB  01
20D1:  GOTO   0FB
....................     restart_wdt(); 
20D2:  CLRWDT
....................     switch(command) { 
20D3:  MOVF   70,W
20D4:  XORLW  0E
20D5:  BTFSC  03.2
20D6:  GOTO   0DE
20D7:  XORLW  01
20D8:  BTFSC  03.2
20D9:  GOTO   0E8
20DA:  XORLW  05
20DB:  BTFSC  03.2
20DC:  GOTO   0F0
20DD:  GOTO   0F7
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
20DE:  MOVLW  01
20DF:  MOVLB  01
20E0:  ADDWF  30,W
20E1:  ANDLW  03
20E2:  MOVWF  30
....................         pot_values_to_lcd(); 
20E3:  MOVLP  08
20E4:  MOVLB  00
20E5:  CALL   280
20E6:  MOVLP  20
....................         break; 
20E7:  GOTO   0F7
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
20E8:  MOVLW  FF
20E9:  MOVLB  02
20EA:  MOVWF  30
20EB:  MOVLP  10
20EC:  MOVLB  00
20ED:  CALL   06A
20EE:  MOVLP  20
....................         break; 
20EF:  GOTO   0F7
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
20F0:  MOVLW  01
20F1:  MOVLB  02
20F2:  MOVWF  30
20F3:  MOVLP  10
20F4:  MOVLB  00
20F5:  CALL   06A
20F6:  MOVLP  20
....................         break; 
....................     } 
....................     in_admin_mode(); 
20F7:  MOVLP  00
20F8:  CALL   7EE
20F9:  MOVLP  20
20FA:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
20FB:  BSF    62.7
.................... } // }}} 
20FC:  MOVLP  20
20FD:  MOVLB  00
20FE:  GOTO   181 (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int cor_index; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
174D:  MOVLW  01
174E:  MOVLB  01
174F:  MOVWF  68
....................   do_update_ptt=0; 
1750:  CLRF   6B
....................   // Allow emulated COR[4] for DTMF control (No audio feed-thru) 
....................   cor_in = COR_IN ; 
1751:  MOVLB  00
1752:  MOVF   60,W
1753:  MOVLB  01
1754:  MOVWF  6A
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in & CurrentCorMask) ) { 
1755:  MOVF   76,F
1756:  BTFSC  03.2
1757:  GOTO   76F
1758:  MOVF   6A,W
1759:  ANDWF  74,W
175A:  BTFSS  03.2
175B:  GOTO   76F
....................     CurrentCorPriority=0; 
175C:  CLRF   76
....................     CurrentCorMask=0; 
175D:  CLRF   74
....................     do_update_ptt=1; 
175E:  MOVLW  01
175F:  MOVWF  6B
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
1760:  MOVF   6A,W
1761:  MOVLB  00
1762:  ANDWF  62,W
1763:  ANDWF  63,W
1764:  BTFSS  03.2
1765:  GOTO   76E
....................       COR_DROP_FLAG=1; 
1766:  MOVLB  01
1767:  BSF    62.0
....................       if ( Tail ) { 
1768:  MOVLB  00
1769:  MOVF   67,F
176A:  BTFSC  03.2
176B:  GOTO   76E
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
176C:  MOVF   67,W
176D:  MOVWF  72
176E:  MOVLB  01
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
176F:  CLRF   6C
....................   for(x=0;x<4;x++) { 
1770:  CLRF   6D
1771:  MOVF   6D,W
1772:  SUBLW  03
1773:  BTFSS  03.0
1774:  GOTO   7AD
....................     if ( cor_in & cor_mask & (~TOT_FLAG_Mask) ) { 
1775:  MOVF   6A,W
1776:  ANDWF  68,W
1777:  MOVWF  6E
1778:  MOVLB  00
1779:  MOVF   6A,W
177A:  XORLW  FF
177B:  MOVLB  01
177C:  ANDWF  6E,W
177D:  BTFSC  03.2
177E:  GOTO   7A9
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
177F:  MOVLB  00
1780:  MOVF   62,W
1781:  ANDWF  63,W
1782:  MOVLB  01
1783:  ANDWF  68,W
1784:  BTFSC  03.2
1785:  GOTO   790
....................         rx_priority=RXPriority[x]; 
1786:  MOVLW  25
1787:  ADDWF  6D,W
1788:  MOVWF  04
1789:  MOVLW  20
178A:  MOVWF  05
178B:  BTFSC  03.0
178C:  INCF   05,F
178D:  MOVF   00,W
178E:  MOVWF  69
....................       } else { 
178F:  GOTO   792
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
1790:  MOVLW  01
1791:  MOVWF  69
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1792:  MOVF   69,W
1793:  SUBWF  76,W
1794:  BTFSC  03.0
1795:  GOTO   7A9
....................         if ( ! CurrentCorPriority ) { 
1796:  MOVF   76,F
1797:  BTFSS  03.2
1798:  GOTO   79B
....................           CurrentCorPriority = rx_priority; 
1799:  MOVF   69,W
179A:  MOVWF  76
....................         } 
....................         cor_index=x+1; 
179B:  MOVLW  01
179C:  ADDWF  6D,W
179D:  MOVWF  6C
....................         do_update_ptt=1; 
179E:  MOVLW  01
179F:  MOVWF  6B
.................... 	TOT_FLAG_Mask=0; 
17A0:  MOVLB  00
17A1:  CLRF   6A
.................... 	QSO_Duration = 0; 
17A2:  CLRF   6C
17A3:  CLRF   6B
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
17A4:  MOVLB  01
17A5:  MOVF   68,W
17A6:  MOVLB  00
17A7:  MOVWF  61
17A8:  MOVLB  01
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
17A9:  BCF    03.0
17AA:  RLF    68,F
....................   } 
17AB:  INCF   6D,F
17AC:  GOTO   771
....................   if ( do_update_ptt ) { 
17AD:  MOVF   6B,F
17AE:  BTFSC  03.2
17AF:  GOTO   7B9
....................     update_ptt(cor_index); 
17B0:  MOVF   6C,W
17B1:  MOVLB  02
17B2:  MOVWF  2F
17B3:  MOVLP  08
17B4:  MOVLB  00
17B5:  CALL   37C
17B6:  MOVLP  10
....................     PROMPT_FLAG=1; 
17B7:  MOVLB  01
17B8:  BSF    65.0
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
17B9:  MOVF   6A,F
17BA:  BTFSS  03.2
17BB:  GOTO   7C1
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
17BC:  BSF    62.7
....................     COR_IN_EFFECTIVE=0; 
17BD:  MOVLB  00
17BE:  CLRF   61
....................     TOT_FLAG_Mask=0; 
17BF:  CLRF   6A
17C0:  MOVLB  01
....................   } 
....................   // Refresh Link Time-out timer when COR is received. 
....................   // Any COR value refreshes the link TOT timer. 
....................   if ( Link_TOT != 0 && (cor_in)!=0 ) { 
17C1:  MOVLB  00
17C2:  MOVF   6D,F
17C3:  BTFSC  03.2
17C4:  GOTO   7CE
17C5:  MOVLB  01
17C6:  MOVF   6A,F
17C7:  BTFSS  03.2
17C8:  GOTO   7CB
17C9:  MOVLB  00
17CA:  GOTO   7CE
....................     LinkDurationTimer = Link_TOT; 
17CB:  MOVLB  00
17CC:  MOVF   6D,W
17CD:  MOVWF  6E
....................   } 
.................... } // }}} 
17CE:  MOVLP  20
17CF:  GOTO   15D (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
17D0:  MOVLB  01
17D1:  CLRF   68
17D2:  MOVF   68,W
17D3:  SUBLW  09
17D4:  BTFSS  03.0
17D5:  GOTO   7E0
....................     DTMF_ARRAY[x]=(sDTMF)0; 
17D6:  MOVLW  66
17D7:  ADDWF  68,W
17D8:  MOVWF  04
17D9:  MOVLW  20
17DA:  MOVWF  05
17DB:  BTFSC  03.0
17DC:  INCF   05,F
17DD:  CLRF   00
....................   } 
17DE:  INCF   68,F
17DF:  GOTO   7D2
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
17E0:  MOVLW  20
17E1:  MOVWF  41
17E2:  MOVLW  66
17E3:  MOVWF  40
.................... } // }}} 
17E4:  MOVLP  20
17E5:  MOVLB  00
17E6:  GOTO   189 (RETURN)
....................  
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   dtmf_in=dtmf_read(CONTROL_REG); 
*
13AE:  MOVLW  01
13AF:  MOVLB  02
13B0:  MOVWF  3C
13B1:  MOVLP  00
13B2:  MOVLB  00
13B3:  CALL   634
13B4:  MOVLP  10
13B5:  MOVF   78,W
13B6:  MOVLB  02
13B7:  MOVWF  34
....................   aux_in = 0; 
13B8:  CLRF   35
....................   for(x=0;x<RegMapNum;x++) { 
13B9:  CLRF   2E
13BA:  CLRF   2D
13BB:  MOVF   2E,F
13BC:  BTFSS  03.2
13BD:  GOTO   4B9
13BE:  MOVF   2D,W
13BF:  SUBLW  38
13C0:  BTFSS  03.0
13C1:  GOTO   4B9
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
13C2:  MOVLW  01
13C3:  MOVWF  7A
13C4:  MOVLW  9B
13C5:  MOVWF  3C
13C6:  MOVF   7A,W
13C7:  MOVWF  3D
13C8:  MOVF   2E,W
13C9:  MOVWF  3F
13CA:  MOVF   2D,W
13CB:  MOVWF  3E
13CC:  CLRF   41
13CD:  MOVLW  06
13CE:  MOVWF  40
13CF:  MOVLB  00
13D0:  CALL   028
13D1:  MOVF   78,W
13D2:  MOVLB  02
13D3:  ADDWF  3C,W
13D4:  MOVWF  30
13D5:  MOVF   79,W
13D6:  ADDWFC 3D,W
13D7:  MOVWF  31
....................     romstrcpy(rname,cPtr); 
13D8:  MOVLW  20
13D9:  MOVWF  3D
13DA:  MOVLW  B6
13DB:  MOVWF  3C
13DC:  MOVF   31,W
13DD:  MOVWF  3F
13DE:  MOVF   30,W
13DF:  MOVWF  3E
13E0:  MOVLB  00
13E1:  CALL   03F
....................   regPtr=RegMap[x].reg_ptr; 
13E2:  MOVLB  02
13E3:  RLF    2D,W
13E4:  MOVWF  3C
13E5:  RLF    2E,W
13E6:  MOVWF  3D
13E7:  RLF    3C,F
13E8:  RLF    3D,F
13E9:  MOVLW  FC
13EA:  ANDWF  3C,F
13EB:  MOVF   3D,W
13EC:  MOVWF  7A
13ED:  MOVF   3C,W
13EE:  MOVWF  3E
13EF:  INCF   3C,W
13F0:  MOVLP  00
13F1:  MOVLB  00
13F2:  CALL   043
13F3:  MOVLP  10
13F4:  MOVWF  7A
13F5:  MOVLB  02
13F6:  MOVF   3E,W
13F7:  MOVLP  00
13F8:  MOVLB  00
13F9:  CALL   043
13FA:  MOVLP  10
13FB:  MOVLB  02
13FC:  MOVWF  32
13FD:  MOVF   7A,W
13FE:  MOVWF  33
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
13FF:  MOVF   33,W
1400:  MOVWF  7A
1401:  MOVF   32,W
1402:  MOVWF  04
1403:  MOVF   7A,W
1404:  MOVWF  05
1405:  MOVF   00,W
1406:  MOVWF  3C
1407:  MOVLW  5B
1408:  CLRWDT
1409:  MOVLB  00
140A:  BTFSC  11.4
140B:  GOTO   40E
140C:  MOVLB  02
140D:  GOTO   408
140E:  MOVLB  03
140F:  MOVWF  1A
1410:  MOVLW  0B
1411:  MOVWF  04
1412:  MOVLB  02
1413:  MOVF   2E,W
1414:  MOVWF  3E
1415:  MOVF   2D,W
1416:  MOVWF  3D
*
1474:  MOVLW  5D
1475:  CLRWDT
1476:  MOVLB  00
1477:  BTFSC  11.4
1478:  GOTO   47B
1479:  MOVLB  02
147A:  GOTO   475
147B:  MOVLB  03
147C:  MOVWF  1A
147D:  MOVLW  20
147E:  CLRWDT
147F:  MOVLB  00
1480:  BTFSC  11.4
1481:  GOTO   484
1482:  MOVLB  03
1483:  GOTO   47E
1484:  MOVLB  03
1485:  MOVWF  1A
1486:  MOVLW  20
1487:  MOVWF  05
1488:  MOVLW  B6
1489:  MOVWF  04
148A:  MOVLP  08
148B:  MOVLB  00
148C:  CALL   266
148D:  MOVLP  10
148E:  MOVLW  20
148F:  CLRWDT
1490:  BTFSS  11.4
1491:  GOTO   48F
1492:  MOVLB  03
1493:  MOVWF  1A
1494:  MOVLB  02
1495:  MOVF   3C,W
1496:  MOVWF  50
1497:  MOVLW  1B
1498:  MOVWF  51
1499:  MOVLP  00
149A:  MOVLB  00
149B:  CALL   6D6
149C:  MOVLP  10
149D:  MOVLW  09
149E:  CLRWDT
149F:  BTFSS  11.4
14A0:  GOTO   49E
14A1:  MOVLB  03
14A2:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
14A3:  MOVLB  02
14A4:  MOVF   2D,W
14A5:  ANDLW  03
14A6:  MOVWF  3C
14A7:  CLRF   3D
14A8:  MOVF   3C,W
14A9:  SUBLW  03
14AA:  BTFSS  03.2
14AB:  GOTO   4B4
14AC:  MOVF   3D,F
14AD:  BTFSS  03.2
14AE:  GOTO   4B4
....................       crlf(); 
14AF:  MOVLP  00
14B0:  MOVLB  00
14B1:  CALL   45E
14B2:  MOVLP  10
14B3:  MOVLB  02
....................     } 
....................     restart_wdt(); 
14B4:  CLRWDT
....................   } 
14B5:  INCF   2D,F
14B6:  BTFSC  03.2
14B7:  INCF   2E,F
14B8:  GOTO   3BB
....................   for(y=0;y<3;y++) { 
14B9:  CLRF   2F
14BA:  MOVF   2F,W
14BB:  SUBLW  02
14BC:  BTFSS  03.0
14BD:  GOTO   4D4
....................     if(AuxInSW[y]==1) { 
14BE:  MOVLW  1F
14BF:  ADDWF  2F,W
14C0:  MOVWF  04
14C1:  MOVLW  20
14C2:  MOVWF  05
14C3:  BTFSC  03.0
14C4:  INCF   05,F
14C5:  DECFSZ 00,W
14C6:  GOTO   4D2
....................       aux_in += (1<<y); 
14C7:  MOVLW  01
14C8:  MOVWF  77
14C9:  MOVF   2F,W
14CA:  MOVWF  78
14CB:  BTFSC  03.2
14CC:  GOTO   4D0
14CD:  LSLF   77,F
14CE:  DECFSZ 78,F
14CF:  GOTO   4CD
14D0:  MOVF   77,W
14D1:  ADDWF  35,F
....................     } 
....................   } 
14D2:  INCF   2F,F
14D3:  GOTO   4BA
....................   putc('\n'); 
14D4:  MOVLW  0A
14D5:  MOVLP  00
14D6:  MOVLB  00
14D7:  CALL   2F0
14D8:  MOVLP  10
....................   crlf(); 
14D9:  MOVLP  00
14DA:  CALL   45E
14DB:  MOVLP  10
....................   printf("COR:%u AuxIn:%u",COR_IN_EFFECTIVE,aux_in); 
14DC:  MOVLW  D8
14DD:  MOVLB  03
14DE:  MOVWF  11
14DF:  MOVLW  03
14E0:  MOVWF  12
14E1:  BCF    03.0
14E2:  MOVLW  04
14E3:  MOVLB  02
14E4:  MOVWF  50
14E5:  MOVLP  00
14E6:  MOVLB  00
14E7:  CALL   662
14E8:  MOVLP  10
14E9:  MOVF   61,W
14EA:  MOVLB  02
14EB:  MOVWF  50
14EC:  MOVLW  1B
14ED:  MOVWF  51
14EE:  MOVLP  00
14EF:  MOVLB  00
14F0:  CALL   6D6
14F1:  MOVLP  10
14F2:  MOVLW  DB
14F3:  MOVLB  03
14F4:  MOVWF  11
14F5:  MOVLW  03
14F6:  MOVWF  12
14F7:  BCF    03.0
14F8:  MOVLW  07
14F9:  MOVLB  02
14FA:  MOVWF  50
14FB:  MOVLP  00
14FC:  MOVLB  00
14FD:  CALL   662
14FE:  MOVLP  10
14FF:  MOVLB  02
1500:  MOVF   35,W
1501:  MOVWF  50
1502:  MOVLW  1B
1503:  MOVWF  51
1504:  MOVLP  00
1505:  MOVLB  00
1506:  CALL   6D6
1507:  MOVLP  10
....................   crlf(); 
1508:  MOVLP  00
1509:  CALL   45E
150A:  MOVLP  10
....................   printf("DTMF:%u",dtmf_in); 
150B:  MOVLW  E0
150C:  MOVLB  03
150D:  MOVWF  11
150E:  MOVLW  03
150F:  MOVWF  12
1510:  BCF    03.0
1511:  MOVLW  05
1512:  MOVLB  02
1513:  MOVWF  50
1514:  MOVLP  00
1515:  MOVLB  00
1516:  CALL   662
1517:  MOVLP  10
1518:  MOVLB  02
1519:  MOVF   34,W
151A:  MOVWF  50
151B:  MOVLW  1B
151C:  MOVWF  51
151D:  MOVLP  00
151E:  MOVLB  00
151F:  CALL   6D6
1520:  MOVLP  10
....................   pot_values_to_lcd(); 
1521:  MOVLP  08
1522:  CALL   280
1523:  MOVLP  10
....................   PROMPT_FLAG=1; 
1524:  MOVLB  01
1525:  BSF    65.0
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0A80:  MOVLW  20
0A81:  MOVLB  02
0A82:  MOVWF  43
0A83:  MOVWF  44
0A84:  MOVWF  45
0A85:  MOVWF  46
....................   unsigned pval[4]={0,0,0,0}; 
0A86:  CLRF   47
0A87:  CLRF   48
0A88:  CLRF   49
0A89:  CLRF   4A
....................   delay_ms(40); 
0A8A:  MOVLW  28
0A8B:  MOVWF  4B
0A8C:  MOVLP  00
0A8D:  MOVLB  00
0A8E:  CALL   785
0A8F:  MOVLP  08
....................   i2c_start(); 
0A90:  MOVLB  04
0A91:  BSF    16.0
0A92:  BTFSC  16.0
0A93:  GOTO   292
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0A94:  MOVLW  51
0A95:  MOVLB  02
0A96:  MOVWF  56
0A97:  MOVLP  00
0A98:  MOVLB  00
0A99:  CALL   64D
0A9A:  MOVLP  08
0A9B:  MOVF   78,W
0A9C:  MOVLB  02
0A9D:  BCF    42.1
0A9E:  BTFSC  78.0
0A9F:  BSF    42.1
....................   for(x=0;x<4;x++) { 
0AA0:  CLRF   40
0AA1:  MOVF   40,W
0AA2:  SUBLW  03
0AA3:  BTFSS  03.0
0AA4:  GOTO   2E0
....................     if(x==3) { 
0AA5:  MOVF   40,W
0AA6:  SUBLW  03
0AA7:  BTFSS  03.2
0AA8:  GOTO   2AB
....................       ack=0; 
0AA9:  BCF    42.0
....................     } else { 
0AAA:  GOTO   2AC
....................       ack=1; 
0AAB:  BSF    42.0
....................     } 
....................     pot_val=i2c_read(ack); 
0AAC:  MOVLW  00
0AAD:  BTFSC  42.0
0AAE:  MOVLW  01
0AAF:  MOVWF  4B
0AB0:  MOVF   4B,W
0AB1:  MOVWF  77
*
0AC0:  MOVF   78,W
0AC1:  MOVLB  02
0AC2:  MOVWF  41
....................     pot_val=pot_val&0x3F; 
0AC3:  MOVLW  3F
0AC4:  ANDWF  41,F
....................     pval[x]=pot_val; 
0AC5:  MOVLW  C7
0AC6:  ADDWF  40,W
0AC7:  MOVWF  04
0AC8:  MOVLW  20
0AC9:  MOVWF  05
0ACA:  BTFSC  03.0
0ACB:  INCF   05,F
0ACC:  MOVF   41,W
0ACD:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0ACE:  MOVLB  01
0ACF:  MOVF   30,W
0AD0:  ANDLW  03
0AD1:  MOVLB  02
0AD2:  SUBWF  40,W
0AD3:  BTFSS  03.2
0AD4:  GOTO   2DE
....................       c[x] = '*'; 
0AD5:  MOVLW  C3
0AD6:  ADDWF  40,W
0AD7:  MOVWF  04
0AD8:  MOVLW  20
0AD9:  MOVWF  05
0ADA:  BTFSC  03.0
0ADB:  INCF   05,F
0ADC:  MOVLW  2A
0ADD:  MOVWF  00
....................     } 
....................   } 
0ADE:  INCF   40,F
0ADF:  GOTO   2A1
....................   i2c_stop(); 
0AE0:  MOVLB  04
0AE1:  BSF    16.2
0AE2:  BTFSC  16.2
0AE3:  GOTO   2E2
....................   delay_ms(50); 
0AE4:  MOVLW  32
0AE5:  MOVLB  02
0AE6:  MOVWF  4B
0AE7:  MOVLP  00
0AE8:  MOVLB  00
0AE9:  CALL   785
0AEA:  MOVLP  08
....................   if ( ack_in!=0 ) { 
0AEB:  MOVLB  02
0AEC:  BTFSS  42.1
0AED:  GOTO   30E
....................     crlf(); 
0AEE:  MOVLP  00
0AEF:  MOVLB  00
0AF0:  CALL   45E
0AF1:  MOVLP  08
....................     printf("I2C Error : No ACK from TRIMPOTS : %u",ack); 
0AF2:  MOVLW  00
0AF3:  MOVLB  02
0AF4:  BTFSC  42.0
0AF5:  MOVLW  01
0AF6:  MOVWF  4B
0AF7:  MOVLW  E4
0AF8:  MOVLB  03
0AF9:  MOVWF  11
0AFA:  MOVLW  03
0AFB:  MOVWF  12
0AFC:  BCF    03.0
0AFD:  MOVLW  23
0AFE:  MOVLB  02
0AFF:  MOVWF  50
0B00:  MOVLP  00
0B01:  MOVLB  00
0B02:  CALL   662
0B03:  MOVLP  08
0B04:  MOVLB  02
0B05:  MOVF   4B,W
0B06:  MOVWF  50
0B07:  MOVLW  1B
0B08:  MOVWF  51
0B09:  MOVLP  00
0B0A:  MOVLB  00
0B0B:  CALL   6D6
0B0C:  MOVLP  08
0B0D:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0B0E:  MOVLW  20
0B0F:  MOVLB  01
0B10:  MOVWF  67
0B11:  MOVLW  7A
0B12:  MOVWF  66
0B13:  MOVLW  F7
0B14:  MOVLB  03
0B15:  MOVWF  11
0B16:  MOVLW  03
0B17:  MOVWF  12
0B18:  BCF    03.0
0B19:  MOVLW  04
0B1A:  MOVLB  02
0B1B:  MOVWF  4B
0B1C:  MOVLB  00
0B1D:  CALL   0B7
0B1E:  MOVLB  02
0B1F:  MOVF   43,W
0B20:  MOVWF  51
0B21:  MOVLP  00
0B22:  MOVLB  00
0B23:  CALL   7DF
0B24:  MOVLP  08
0B25:  MOVLB  02
0B26:  MOVF   47,W
0B27:  MOVWF  4B
0B28:  MOVLW  18
0B29:  MOVWF  4C
0B2A:  MOVLB  00
0B2B:  CALL   1F7
0B2C:  MOVLW  20
0B2D:  MOVLB  02
0B2E:  MOVWF  51
0B2F:  MOVLP  00
0B30:  MOVLB  00
0B31:  CALL   7DF
0B32:  MOVLP  08
0B33:  MOVLB  02
0B34:  MOVF   44,W
0B35:  MOVWF  51
0B36:  MOVLP  00
0B37:  MOVLB  00
0B38:  CALL   7DF
0B39:  MOVLP  08
0B3A:  MOVLB  02
0B3B:  MOVF   48,W
0B3C:  MOVWF  4B
0B3D:  MOVLW  18
0B3E:  MOVWF  4C
0B3F:  MOVLB  00
0B40:  CALL   1F7
0B41:  MOVLW  20
0B42:  MOVLB  02
0B43:  MOVWF  51
0B44:  MOVLP  00
0B45:  MOVLB  00
0B46:  CALL   7DF
0B47:  MOVLP  08
0B48:  MOVLB  02
0B49:  MOVF   45,W
0B4A:  MOVWF  51
0B4B:  MOVLP  00
0B4C:  MOVLB  00
0B4D:  CALL   7DF
0B4E:  MOVLP  08
0B4F:  MOVLB  02
0B50:  MOVF   49,W
0B51:  MOVWF  4B
0B52:  MOVLW  18
0B53:  MOVWF  4C
0B54:  MOVLB  00
0B55:  CALL   1F7
0B56:  MOVLW  20
0B57:  MOVLB  02
0B58:  MOVWF  51
0B59:  MOVLP  00
0B5A:  MOVLB  00
0B5B:  CALL   7DF
0B5C:  MOVLP  08
0B5D:  MOVLB  02
0B5E:  MOVF   46,W
0B5F:  MOVWF  51
0B60:  MOVLP  00
0B61:  MOVLB  00
0B62:  CALL   7DF
0B63:  MOVLP  08
0B64:  MOVLB  02
0B65:  MOVF   4A,W
0B66:  MOVWF  4B
0B67:  MOVLW  18
0B68:  MOVWF  4C
0B69:  MOVLB  00
0B6A:  CALL   1F7
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0B6B:  MOVLB  02
0B6C:  CLRF   4B
0B6D:  MOVLW  20
0B6E:  MOVWF  4D
0B6F:  MOVLW  7A
0B70:  MOVWF  4C
0B71:  MOVLB  00
0B72:  CALL   154
....................   crlf(); 
0B73:  MOVLP  00
0B74:  CALL   45E
0B75:  MOVLP  08
....................   printf("%s",LCD_str); 
0B76:  MOVLW  20
0B77:  MOVWF  05
0B78:  MOVLW  7A
0B79:  MOVWF  04
0B7A:  CALL   266
....................  
.................... } // }}} 
0B7B:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
10F5:  MOVLB  01
10F6:  BTFSS  65.1
10F7:  GOTO   10B
....................     putc('\n'); 
10F8:  MOVLW  0A
10F9:  MOVLP  00
10FA:  MOVLB  00
10FB:  CALL   2F0
10FC:  MOVLP  10
....................     crlf(); 
10FD:  MOVLP  00
10FE:  CALL   45E
10FF:  MOVLP  10
....................     printf("ADMIN> "); 
1100:  MOVLW  03
1101:  MOVLB  03
1102:  MOVWF  11
1103:  MOVLW  04
1104:  MOVWF  12
1105:  MOVLP  00
1106:  MOVLB  00
1107:  CALL   463
1108:  MOVLP  10
....................   } else { 
1109:  GOTO   11C
110A:  MOVLB  01
....................     putc('\n'); 
110B:  MOVLW  0A
110C:  MOVLP  00
110D:  MOVLB  00
110E:  CALL   2F0
110F:  MOVLP  10
....................     crlf(); 
1110:  MOVLP  00
1111:  CALL   45E
1112:  MOVLP  10
....................     printf("COMMAND> "); 
1113:  MOVLW  07
1114:  MOVLB  03
1115:  MOVWF  11
1116:  MOVLW  04
1117:  MOVWF  12
1118:  MOVLP  00
1119:  MOVLB  00
111A:  CALL   463
111B:  MOVLP  10
....................   } 
.................... } // }}} 
111C:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
0444:  MOVLW  10
0445:  MOVLB  01
0446:  MOVWF  69
....................   for (x=0;x<char_num;x++) { 
0447:  CLRF   68
0448:  MOVF   69,W
0449:  SUBWF  68,W
044A:  BTFSC  03.0
044B:  GOTO   456
....................     sBuffer[x]='\0'; 
044C:  MOVLW  50
044D:  ADDWF  68,W
044E:  MOVWF  04
044F:  MOVLW  20
0450:  MOVWF  05
0451:  BTFSC  03.0
0452:  INCF   05,F
0453:  CLRF   00
....................   } 
0454:  INCF   68,F
0455:  GOTO   448
....................   sBufferIndex=0; 
0456:  CLRF   7C
....................   sBufferFlag=0;   
0457:  BCF    7D.0
....................   argument=-1; 
0458:  MOVLW  FF
0459:  MOVWF  42
....................   argument_name[0]='\0'; 
045A:  CLRF   44
....................   command=0; 
045B:  CLRF   70
.................... } // }}} 
045C:  MOVLB  00
045D:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
05F4:  MOVLW  00
05F5:  MOVLB  01
05F6:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
05F7:  MOVLB  02
05F8:  BCF    46.0
05F9:  MOVF   44,W
05FA:  ANDLW  0F
05FB:  ANDLW  01
05FC:  BTFSS  03.2
05FD:  BSF    46.0
....................   output_bit(DTMF_D0,dbit); 
05FE:  BTFSC  46.0
05FF:  GOTO   602
0600:  BCF    0F.0
0601:  GOTO   603
0602:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
0603:  BCF    46.0
0604:  MOVF   44,W
0605:  ANDLW  0F
0606:  ANDLW  02
0607:  BTFSS  03.2
0608:  BSF    46.0
....................   output_bit(DTMF_D1,dbit); 
0609:  BTFSC  46.0
060A:  GOTO   60D
060B:  BCF    0F.1
060C:  GOTO   60E
060D:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
060E:  BCF    46.0
060F:  MOVF   44,W
0610:  ANDLW  0F
0611:  ANDLW  04
0612:  BTFSS  03.2
0613:  BSF    46.0
....................   output_bit(DTMF_D2,dbit); 
0614:  BTFSC  46.0
0615:  GOTO   618
0616:  BCF    0F.2
0617:  GOTO   619
0618:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
0619:  BCF    46.0
061A:  MOVF   44,W
061B:  ANDLW  0F
061C:  ANDLW  08
061D:  BTFSS  03.2
061E:  BSF    46.0
....................   output_bit(DTMF_D3,dbit); 
061F:  BTFSC  46.0
0620:  GOTO   623
0621:  BCF    0F.3
0622:  GOTO   624
0623:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
0624:  MOVF   45,F
0625:  BTFSS  03.2
0626:  GOTO   629
0627:  BCF    0F.6
0628:  GOTO   62A
0629:  BSF    0F.6
....................   delay_cycles(2); 
062A:  GOTO   62B
....................   output_bit(DTMF_WEB,0); 
062B:  BCF    0F.5
....................   delay_cycles(2); 
062C:  GOTO   62D
....................   output_bit(DTMF_WEB,1);   
062D:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
062E:  GOTO   62F
....................   set_tris_d(0x0F); 
062F:  MOVLW  0F
0630:  MOVLB  01
0631:  MOVWF  0F
.................... } // }}} 
0632:  MOVLB  00
0633:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
0634:  MOVLW  0F
0635:  MOVLB  01
0636:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
0637:  MOVLB  02
0638:  MOVF   3C,F
0639:  BTFSS  03.2
063A:  GOTO   63D
063B:  BCF    0F.6
063C:  GOTO   63E
063D:  BSF    0F.6
....................   delay_cycles(1); 
063E:  NOP
....................   output_bit(DTMF_REB,0); 
063F:  BCF    0F.4
....................   delay_cycles(1); 
0640:  NOP
....................   value=input_d(); 
0641:  MOVLB  00
0642:  MOVF   0F,W
0643:  MOVLB  02
0644:  MOVWF  3D
....................   value&=0x0F; 
0645:  MOVLW  0F
0646:  ANDWF  3D,F
....................   output_bit(DTMF_REB,1); 
0647:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
0648:  NOP
....................   return(value); 
0649:  MOVF   3D,W
064A:  MOVWF  78
.................... } // }}} 
064B:  MOVLB  00
064C:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0D4B:  MOVLB  02
0D4C:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0D4D:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0D4E:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0D4F:  CLRF   44
0D50:  MOVLW  01
0D51:  MOVWF  45
0D52:  MOVLP  00
0D53:  MOVLB  00
0D54:  CALL   5F4
0D55:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0D56:  MOVLB  02
0D57:  CLRF   44
0D58:  MOVLW  01
0D59:  MOVWF  45
0D5A:  MOVLP  00
0D5B:  MOVLB  00
0D5C:  CALL   5F4
0D5D:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0D5E:  MOVLW  0C
0D5F:  MOVLB  02
0D60:  MOVWF  44
0D61:  MOVLW  01
0D62:  MOVWF  45
0D63:  MOVLP  00
0D64:  MOVLB  00
0D65:  CALL   5F4
0D66:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0D67:  MOVLW  01
0D68:  MOVLB  02
0D69:  MOVWF  44
0D6A:  MOVWF  45
0D6B:  MOVLP  00
0D6C:  MOVLB  00
0D6D:  CALL   5F4
0D6E:  MOVLP  08
....................     dtmf_read(CONTROL_REG); 
0D6F:  MOVLW  01
0D70:  MOVLB  02
0D71:  MOVWF  3C
0D72:  MOVLP  00
0D73:  MOVLB  00
0D74:  CALL   634
0D75:  MOVLP  08
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
1A49:  MOVF   42,W
1A4A:  MOVWF  44
1A4B:  CLRF   45
1A4C:  MOVLP  00
1A4D:  MOVLB  00
1A4E:  CALL   5F4
1A4F:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
1A50:  MOVLW  0C
1A51:  MOVLB  02
1A52:  MOVWF  44
1A53:  MOVLW  01
1A54:  MOVWF  45
1A55:  MOVLP  00
1A56:  MOVLB  00
1A57:  CALL   5F4
1A58:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
1A59:  MOVLW  01
1A5A:  MOVLB  02
1A5B:  MOVWF  44
1A5C:  MOVWF  45
1A5D:  MOVLP  00
1A5E:  MOVLB  00
1A5F:  CALL   5F4
1A60:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A61:  MOVLW  05
1A62:  MOVLB  02
1A63:  MOVWF  44
1A64:  MOVLW  01
1A65:  MOVWF  45
1A66:  MOVLP  00
1A67:  MOVLB  00
1A68:  CALL   5F4
1A69:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A6A:  MOVLB  01
1A6B:  CLRF   34
1A6C:  MOVLW  10
1A6D:  MOVWF  33
....................   while(aux_timer) { 
1A6E:  MOVF   33,W
1A6F:  IORWF  34,W
1A70:  BTFSC  03.2
1A71:  GOTO   274
....................     delay_cycles(1); 
1A72:  NOP
....................   } 
1A73:  GOTO   26E
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A74:  MOVLW  04
1A75:  MOVLB  02
1A76:  MOVWF  44
1A77:  MOVLW  01
1A78:  MOVWF  45
1A79:  MOVLP  00
1A7A:  MOVLB  00
1A7B:  CALL   5F4
1A7C:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
07B1:  MOVLW  01
07B2:  MOVLB  02
07B3:  MOVWF  44
07B4:  CLRF   45
07B5:  MOVLB  00
07B6:  CALL   5F4
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
07B7:  MOVLW  0C
07B8:  MOVLB  02
07B9:  MOVWF  44
07BA:  MOVLW  01
07BB:  MOVWF  45
07BC:  MOVLB  00
07BD:  CALL   5F4
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
07BE:  MOVLW  05
07BF:  MOVLB  02
07C0:  MOVWF  44
07C1:  MOVLW  01
07C2:  MOVWF  45
07C3:  MOVLB  00
07C4:  CALL   5F4
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
07C5:  MOVLW  05
07C6:  MOVLB  02
07C7:  MOVWF  44
07C8:  MOVLW  01
07C9:  MOVWF  45
07CA:  MOVLB  00
07CB:  CALL   5F4
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
07CC:  MOVLB  01
07CD:  CLRF   34
07CE:  MOVLW  02
07CF:  MOVWF  33
....................   while(aux_timer) { 
07D0:  MOVF   33,W
07D1:  IORWF  34,W
07D2:  BTFSC  03.2
07D3:  GOTO   7D6
....................     delay_cycles(1); 
07D4:  NOP
....................   } 
07D5:  GOTO   7D0
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
07D6:  MOVLW  04
07D7:  MOVLB  02
07D8:  MOVWF  44
07D9:  MOVLW  01
07DA:  MOVWF  45
07DB:  MOVLB  00
07DC:  CALL   5F4
....................   restart_wdt(); 
07DD:  CLRWDT
.................... } // }}} 
07DE:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
0800:  MOVLW  01
0801:  MOVLB  02
0802:  MOVWF  44
0803:  CLRF   45
0804:  MOVLP  00
0805:  MOVLB  00
0806:  CALL   5F4
0807:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0808:  MOVLW  0C
0809:  MOVLB  02
080A:  MOVWF  44
080B:  MOVLW  01
080C:  MOVWF  45
080D:  MOVLP  00
080E:  MOVLB  00
080F:  CALL   5F4
0810:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0811:  MOVLW  05
0812:  MOVLB  02
0813:  MOVWF  44
0814:  MOVLW  01
0815:  MOVWF  45
0816:  MOVLP  00
0817:  MOVLB  00
0818:  CALL   5F4
0819:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
081A:  MOVLW  05
081B:  MOVLB  02
081C:  MOVWF  44
081D:  MOVLW  01
081E:  MOVWF  45
081F:  MOVLP  00
0820:  MOVLB  00
0821:  CALL   5F4
0822:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
0823:  MOVLB  01
0824:  CLRF   34
0825:  MOVLW  06
0826:  MOVWF  33
....................   while(aux_timer) { 
0827:  MOVF   33,W
0828:  IORWF  34,W
0829:  BTFSC  03.2
082A:  GOTO   02D
....................     delay_cycles(1); 
082B:  NOP
....................   } 
082C:  GOTO   027
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
082D:  MOVLW  04
082E:  MOVLB  02
082F:  MOVWF  44
0830:  MOVLW  01
0831:  MOVWF  45
0832:  MOVLP  00
0833:  MOVLB  00
0834:  CALL   5F4
0835:  MOVLP  08
....................   restart_wdt(); 
0836:  CLRWDT
.................... } // }}} 
0837:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
04B8:  MOVLB  02
04B9:  MOVF   39,W
04BA:  MOVWF  04
04BB:  MOVF   3A,W
04BC:  MOVWF  05
04BD:  MOVF   00,W
04BE:  MOVWF  3C
....................   if ( tmp > 127 ) { 
04BF:  MOVF   3C,W
04C0:  SUBLW  7F
04C1:  BTFSS  03.0
....................     tmp++; 
04C2:  INCF   3C,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
04C3:  BCF    03.0
04C4:  RLF    3C,W
04C5:  XORLW  09
04C6:  ADDWF  3B,W
04C7:  MOVWF  3C
....................   *cksum=tmp; 
04C8:  MOVF   39,W
04C9:  MOVWF  04
04CA:  MOVF   3A,W
04CB:  MOVWF  05
04CC:  MOVF   3C,W
04CD:  MOVWF  00
.................... } // }}} 
04CE:  MOVLB  00
04CF:  RETURN
.................... void print_dtmf_info(void) { // {{{ 
....................   unsigned int x; 
....................   char dtmf; 
....................   char tmp[5]; 
....................   strcpy(LCD_str,"DTMF:"); 
*
1F12:  MOVLB  02
1F13:  CLRF   20
1F14:  CLRF   21
1F15:  MOVLW  20
1F16:  MOVWF  05
1F17:  MOVLW  7A
1F18:  MOVWF  04
1F19:  MOVF   20,W
1F1A:  ADDWF  04,F
1F1B:  MOVLW  00
1F1C:  ADDWFC 05,F
1F1D:  MOVF   21,W
1F1E:  MOVLP  00
1F1F:  MOVLB  00
1F20:  CALL   139
1F21:  MOVLP  18
1F22:  MOVWF  00
1F23:  IORLW  00
1F24:  BTFSC  03.2
1F25:  GOTO   72B
1F26:  MOVLB  02
1F27:  INCF   21,F
1F28:  INCF   20,F
1F29:  GOTO   715
1F2A:  MOVLB  00
....................   crlf(); 
1F2B:  MOVLP  00
1F2C:  CALL   45E
1F2D:  MOVLP  18
....................   printf("DTMF="); 
1F2E:  MOVLW  0C
1F2F:  MOVLB  03
1F30:  MOVWF  11
1F31:  MOVLW  04
1F32:  MOVWF  12
1F33:  MOVLP  00
1F34:  MOVLB  00
1F35:  CALL   463
1F36:  MOVLP  18
....................   for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1F37:  MOVLB  01
1F38:  CLRF   68
1F39:  MOVF   68,W
1F3A:  SUBLW  09
1F3B:  BTFSS  03.0
1F3C:  GOTO   776
....................     if(DTMF_ARRAY[x].Strobe) { 
1F3D:  MOVLW  66
1F3E:  ADDWF  68,W
1F3F:  MOVWF  04
1F40:  MOVLW  20
1F41:  MOVWF  05
1F42:  BTFSC  03.0
1F43:  INCF   05,F
1F44:  BTFSS  00.4
1F45:  GOTO   773
....................       dtmf=(int)DTMF_ARRAY[x].Key; 
1F46:  MOVLW  66
1F47:  ADDWF  68,W
1F48:  MOVWF  04
1F49:  MOVLW  20
1F4A:  MOVWF  05
1F4B:  BTFSC  03.0
1F4C:  INCF   05,F
1F4D:  MOVF   00,W
1F4E:  ANDLW  0F
1F4F:  MOVWF  69
....................       sprintf(tmp,"%d",dtmf); 
1F50:  MOVLW  20
1F51:  MOVWF  67
1F52:  MOVLW  9A
1F53:  MOVWF  66
1F54:  MOVF   69,W
1F55:  MOVLB  02
1F56:  MOVWF  4B
1F57:  MOVLW  18
1F58:  MOVWF  4C
1F59:  MOVLP  08
1F5A:  MOVLB  00
1F5B:  CALL   1F7
1F5C:  MOVLP  18
....................       strcat(LCD_str,tmp); 
1F5D:  MOVLW  20
1F5E:  MOVLB  02
1F5F:  MOVWF  2C
1F60:  MOVLW  7A
1F61:  MOVWF  2B
1F62:  MOVLW  20
1F63:  MOVWF  2E
1F64:  MOVLW  9A
1F65:  MOVWF  2D
1F66:  MOVLB  00
1F67:  CALL   506
....................       printf("%u",dtmf); 
1F68:  MOVLB  01
1F69:  MOVF   69,W
1F6A:  MOVLB  02
1F6B:  MOVWF  50
1F6C:  MOVLW  1B
1F6D:  MOVWF  51
1F6E:  MOVLP  00
1F6F:  MOVLB  00
1F70:  CALL   6D6
1F71:  MOVLP  18
1F72:  MOVLB  01
....................     } 
....................   restart_wdt(); 
1F73:  CLRWDT
....................   } 
1F74:  INCF   68,F
1F75:  GOTO   739
....................   crlf(); 
1F76:  MOVLP  00
1F77:  MOVLB  00
1F78:  CALL   45E
1F79:  MOVLP  18
....................   PROMPT_FLAG=1; 
1F7A:  MOVLB  01
1F7B:  BSF    65.0
....................   lcd_send(2,LCD_str); // Send DTMF on line 3 
1F7C:  MOVLW  02
1F7D:  MOVLB  02
1F7E:  MOVWF  4B
1F7F:  MOVLW  20
1F80:  MOVWF  4D
1F81:  MOVLW  7A
1F82:  MOVWF  4C
1F83:  MOVLP  08
1F84:  MOVLB  00
1F85:  CALL   154
1F86:  MOVLP  18
.................... } // }}} 
1F87:  MOVLP  20
1F88:  GOTO   179 (RETURN)
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
*
04D0:  MOVLW  01
04D1:  MOVLB  02
04D2:  MOVWF  33
....................   eeprom_index=0; 
04D3:  CLRF   34
....................   retVal = 1; 
04D4:  MOVWF  36
....................   crlf(); 
04D5:  MOVLB  00
04D6:  CALL   45E
....................   printf("Init RAM <= "); 
04D7:  MOVLW  0F
04D8:  MOVLB  03
04D9:  MOVWF  11
04DA:  MOVLW  04
04DB:  MOVWF  12
04DC:  MOVLB  00
04DD:  CALL   463
....................   if ( source == USE_EEPROM_VARS ) { 
04DE:  MOVLB  02
04DF:  DECFSZ 2F,W
04E0:  GOTO   4EA
....................     printf("EEPROM"); 
04E1:  MOVLW  16
04E2:  MOVLB  03
04E3:  MOVWF  11
04E4:  MOVLW  04
04E5:  MOVWF  12
04E6:  MOVLB  00
04E7:  CALL   463
....................   } else { 
04E8:  GOTO   4F1
04E9:  MOVLB  02
....................     printf("HW Defaults"); 
04EA:  MOVLW  1A
04EB:  MOVLB  03
04EC:  MOVWF  11
04ED:  MOVLW  04
04EE:  MOVWF  12
04EF:  MOVLB  00
04F0:  CALL   463
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
04F1:  MOVLB  02
04F2:  CLRF   30
04F3:  MOVF   30,W
04F4:  SUBLW  38
04F5:  BTFSS  03.0
04F6:  GOTO   550
....................     regPtr=RegMap[x].reg_ptr; 
04F7:  RLF    30,W
04F8:  MOVWF  77
04F9:  RLF    77,F
04FA:  MOVLW  FC
04FB:  ANDWF  77,F
04FC:  MOVF   77,W
04FD:  MOVWF  38
04FE:  INCF   38,W
04FF:  MOVLB  00
0500:  CALL   043
0501:  MOVWF  7A
0502:  MOVLB  02
0503:  MOVF   38,W
0504:  MOVLB  00
0505:  CALL   043
0506:  MOVLB  02
0507:  MOVWF  31
0508:  MOVF   7A,W
0509:  MOVWF  32
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
050A:  DECFSZ 2F,W
050B:  GOTO   53C
050C:  RLF    30,W
050D:  MOVWF  77
050E:  RLF    77,F
050F:  MOVLW  FC
0510:  ANDWF  77,F
0511:  MOVF   77,W
0512:  ADDLW  03
0513:  MOVLB  00
0514:  CALL   043
0515:  MOVWF  78
0516:  BTFSC  78.0
0517:  GOTO   51A
0518:  MOVLB  02
0519:  GOTO   53C
....................       eeprom_val=read_eeprom(eeprom_index); 
051A:  MOVLB  02
051B:  MOVF   34,W
051C:  MOVLB  03
051D:  MOVWF  11
051E:  BCF    15.7
051F:  BSF    15.0
0520:  MOVF   13,W
0521:  MOVLB  02
0522:  MOVWF  37
....................       *regPtr=eeprom_val; 
0523:  MOVF   31,W
0524:  MOVWF  04
0525:  MOVF   32,W
0526:  MOVWF  05
0527:  MOVF   37,W
0528:  MOVWF  00
....................       update_checksum(&cksum,*regPtr);     
0529:  MOVF   32,W
052A:  MOVWF  7A
052B:  MOVF   31,W
052C:  MOVWF  04
052D:  MOVF   32,W
052E:  MOVWF  05
052F:  MOVF   00,W
0530:  MOVWF  38
0531:  MOVLW  20
0532:  MOVWF  3A
0533:  MOVLW  B3
0534:  MOVWF  39
0535:  MOVF   38,W
0536:  MOVWF  3B
0537:  MOVLB  00
0538:  CALL   4B8
....................       eeprom_index++; 
0539:  MOVLB  02
053A:  INCF   34,F
....................     } else { 
053B:  GOTO   54E
....................       default_value=(int8)RegMap[x].default_value; 
053C:  RLF    30,W
053D:  MOVWF  77
053E:  RLF    77,F
053F:  MOVLW  FC
0540:  ANDWF  77,F
0541:  MOVF   77,W
0542:  ADDLW  02
0543:  MOVLB  00
0544:  CALL   043
0545:  MOVWF  78
0546:  MOVLB  02
0547:  MOVWF  35
....................       *regPtr=default_value; 
0548:  MOVF   31,W
0549:  MOVWF  04
054A:  MOVF   32,W
054B:  MOVWF  05
054C:  MOVF   35,W
054D:  MOVWF  00
....................     } 
....................   } 
054E:  INCF   30,F
054F:  GOTO   4F3
....................   if ( source == USE_EEPROM_VARS ) { 
0550:  DECFSZ 2F,W
0551:  GOTO   55C
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
0552:  MOVF   34,W
0553:  MOVLB  03
0554:  MOVWF  11
0555:  BCF    15.7
0556:  BSF    15.0
0557:  MOVF   13,W
0558:  MOVLB  02
0559:  SUBWF  33,W
055A:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
055B:  CLRF   36
....................     } 
....................   } 
....................   return (retVal); 
055C:  MOVF   36,W
055D:  MOVWF  78
.................... } // }}} 
055E:  MOVLB  00
055F:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
0560:  MOVLW  01
0561:  MOVLB  02
0562:  MOVWF  33
....................  
....................   eeprom_index=0; 
0563:  CLRF   30
....................   for(x=0;x<RegMapNum;x++) { 
0564:  CLRF   2F
0565:  MOVF   2F,W
0566:  SUBLW  38
0567:  BTFSS  03.0
0568:  GOTO   5BE
....................     regPtr=RegMap[x].reg_ptr; 
0569:  RLF    2F,W
056A:  MOVWF  77
056B:  RLF    77,F
056C:  MOVLW  FC
056D:  ANDWF  77,F
056E:  MOVF   77,W
056F:  MOVWF  35
0570:  INCF   35,W
0571:  MOVLB  00
0572:  CALL   043
0573:  MOVWF  7A
0574:  MOVLB  02
0575:  MOVF   35,W
0576:  MOVLB  00
0577:  CALL   043
0578:  MOVLB  02
0579:  MOVWF  31
057A:  MOVF   7A,W
057B:  MOVWF  32
....................     if ( RegMap[x].non_volatile ) { 
057C:  RLF    2F,W
057D:  MOVWF  77
057E:  RLF    77,F
057F:  MOVLW  FC
0580:  ANDWF  77,F
0581:  MOVF   77,W
0582:  ADDLW  03
0583:  MOVLB  00
0584:  CALL   043
0585:  MOVWF  78
0586:  BTFSS  78.0
0587:  GOTO   5BB
....................      value=*regPtr; 
0588:  MOVLB  02
0589:  MOVF   31,W
058A:  MOVWF  04
058B:  MOVF   32,W
058C:  MOVWF  05
058D:  MOVF   00,W
058E:  MOVWF  34
....................      if ( read_eeprom(eeprom_index) != value ) { 
058F:  MOVF   30,W
0590:  MOVLB  03
0591:  MOVWF  11
0592:  BCF    15.7
0593:  BSF    15.0
0594:  MOVF   13,W
0595:  MOVLB  02
0596:  SUBWF  34,W
0597:  BTFSC  03.2
0598:  GOTO   5B0
....................        write_eeprom(eeprom_index,value); 
0599:  MOVF   0B,W
059A:  MOVWF  77
059B:  BCF    0B.7
059C:  MOVF   30,W
059D:  MOVLB  03
059E:  MOVWF  11
059F:  MOVLB  02
05A0:  MOVF   34,W
05A1:  MOVLB  03
05A2:  MOVWF  13
05A3:  BCF    15.7
05A4:  BSF    15.2
05A5:  MOVLW  55
05A6:  MOVWF  16
05A7:  MOVLW  AA
05A8:  MOVWF  16
05A9:  BSF    15.1
05AA:  BTFSC  15.1
05AB:  GOTO   5AA
05AC:  BCF    15.2
05AD:  MOVF   77,W
05AE:  IORWF  0B,F
05AF:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
05B0:  MOVLW  20
05B1:  MOVWF  3A
05B2:  MOVLW  B3
05B3:  MOVWF  39
05B4:  MOVF   34,W
05B5:  MOVWF  3B
05B6:  MOVLB  00
05B7:  CALL   4B8
....................      eeprom_index++; 
05B8:  MOVLB  02
05B9:  INCF   30,F
05BA:  MOVLB  00
....................     } 
....................   } 
05BB:  MOVLB  02
05BC:  INCF   2F,F
05BD:  GOTO   565
....................   write_eeprom(eeprom_index,cksum); 
05BE:  MOVF   0B,W
05BF:  MOVWF  77
05C0:  BCF    0B.7
05C1:  MOVF   30,W
05C2:  MOVLB  03
05C3:  MOVWF  11
05C4:  MOVLB  02
05C5:  MOVF   33,W
05C6:  MOVLB  03
05C7:  MOVWF  13
05C8:  BCF    15.7
05C9:  BSF    15.2
05CA:  MOVLW  55
05CB:  MOVWF  16
05CC:  MOVLW  AA
05CD:  MOVWF  16
05CE:  BSF    15.1
05CF:  BTFSC  15.1
05D0:  GOTO   5CF
05D1:  BCF    15.2
05D2:  MOVF   77,W
05D3:  IORWF  0B,F
....................   crlf(); 
05D4:  MOVLB  00
05D5:  CALL   45E
....................   printf("EEPROM<=RAM"); 
05D6:  MOVLW  20
05D7:  MOVLB  03
05D8:  MOVWF  11
05D9:  MOVLW  04
05DA:  MOVWF  12
05DB:  MOVLB  00
05DC:  CALL   463
.................... } // }}} 
05DD:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
05DE:  MOVLB  02
05DF:  MOVF   2E,W
05E0:  MOVWF  2F
05E1:  MOVLB  00
05E2:  CALL   4D0
05E3:  MOVF   78,F
05E4:  BTFSS  03.2
05E5:  GOTO   5F3
....................       crlf(); 
05E6:  CALL   45E
....................       printf(" Bad checksum!"); 
05E7:  MOVLW  26
05E8:  MOVLB  03
05E9:  MOVWF  11
05EA:  MOVLW  04
05EB:  MOVWF  12
05EC:  MOVLB  00
05ED:  CALL   463
....................         _init_variables(USE_DEFAULT_VARS); 
05EE:  MOVLB  02
05EF:  CLRF   2F
05F0:  MOVLB  00
05F1:  CALL   4D0
....................     store_variables(); 
05F2:  CALL   560
....................     } 
.................... } // }}} 
05F3:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0D86:  MOVLB  02
0D87:  CLRF   40
0D88:  CLRF   41
0D89:  MOVLP  00
0D8A:  MOVLB  00
0D8B:  CALL   725
0D8C:  MOVLP  08
....................   set_trimpot(1,0); 
0D8D:  MOVLW  01
0D8E:  MOVLB  02
0D8F:  MOVWF  40
0D90:  CLRF   41
0D91:  MOVLP  00
0D92:  MOVLB  00
0D93:  CALL   725
0D94:  MOVLP  08
....................   set_trimpot(2,0); 
0D95:  MOVLW  02
0D96:  MOVLB  02
0D97:  MOVWF  40
0D98:  CLRF   41
0D99:  MOVLP  00
0D9A:  MOVLB  00
0D9B:  CALL   725
0D9C:  MOVLP  08
....................   set_trimpot(3,0); 
0D9D:  MOVLW  03
0D9E:  MOVLB  02
0D9F:  MOVWF  40
0DA0:  CLRF   41
0DA1:  MOVLP  00
0DA2:  MOVLB  00
0DA3:  CALL   725
0DA4:  MOVLP  08
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0D10:  MOVLP  00
0D11:  CALL   444
0D12:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0D13:  MOVLB  02
0D14:  CLRF   12
0D15:  CLRF   11
0D16:  CLRF   14
0D17:  CLRF   13
....................   setup_wdt(WDT_2S); 
0D18:  MOVLW  17
0D19:  MOVLB  01
0D1A:  MOVWF  17
....................   PROCESS_COR_FLAG=0; 
0D1B:  BCF    7D.1
....................   COR_IN_FLAG=0; 
0D1C:  BCF    7D.2
....................   COR_IN=0; 
0D1D:  MOVLB  00
0D1E:  CLRF   60
....................   COR_EMUL=0; 
0D1F:  CLRF   6F
....................   COR_AUX=0; 
0D20:  CLRF   71
....................   COR_DROP_FLAG=0; 
0D21:  MOVLB  01
0D22:  BCF    62.0
....................   DTMF_IN_FLAG=0; 
0D23:  BCF    62.5
....................   DTMF_INTERRUPT_FLAG=0; 
0D24:  BCF    62.6
....................   TOT_FLAG_Mask=0; 
0D25:  MOVLB  00
0D26:  CLRF   6A
....................   AuxOutDelayCnt=0; 
0D27:  MOVLB  01
0D28:  CLRF   35
....................   CurrentCorMask=0; 
0D29:  CLRF   74
....................   CurrentCorPriority=0; 
0D2A:  CLRF   76
....................   CurrentCorIndex=0; 
0D2B:  CLRF   75
....................   CurrentTrimPot=0; 
0D2C:  CLRF   30
....................   set_tris_b(0xFF); 
0D2D:  MOVLW  FF
0D2E:  TRIS   6
....................   set_tris_d(0x00); 
0D2F:  MOVLW  00
0D30:  MOVWF  0F
....................   set_tris_e(0xF8); 
0D31:  BCF    10.0
0D32:  BCF    10.1
0D33:  BCF    10.2
0D34:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0D35:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0D36:  BSF    0B.3
0D37:  MOVLW  CF
0D38:  MOVLB  07
0D39:  IORWF  14,F
0D3A:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0D3B:  BSF    0B.3
0D3C:  BSF    15.4
0D3D:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0D3E:  MOVLW  C0
0D3F:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0D40:  MOVLB  02
0D41:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0D42:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0D43:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0D44:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0D45:  MOVLW  01
0D46:  MOVWF  2E
0D47:  MOVLP  00
0D48:  MOVLB  00
0D49:  CALL   5DE
0D4A:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D76:  MOVLB  01
0D77:  BSF    62.7
....................   Enable_Mask = 0x0F; 
0D78:  MOVLW  0F
0D79:  MOVLB  00
0D7A:  MOVWF  63
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D7B:  MOVF   64,W
0D7C:  ANDLW  0F
0D7D:  IORLW  C0
0D7E:  MOVLB  04
0D7F:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D80:  MOVLB  01
0D81:  BCF    15.7
....................   // }}} 
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D82:  MOVLW  9D
0D83:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0D84:  MOVLW  80
0D85:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0DA5:  MOVLB  01
0DA6:  CLRF   32
0DA7:  MOVLW  1E
0DA8:  MOVWF  31
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0DA9:  MOVF   15,W
0DAA:  ANDLW  C0
0DAB:  IORLW  07
0DAC:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0DAD:  BSF    0B.5
....................   update_ptt(0); 
0DAE:  MOVLB  02
0DAF:  CLRF   2F
0DB0:  MOVLB  00
0DB1:  CALL   37C
....................   MinuteCounter=MIN_COUNTER; 
0DB2:  MOVLW  1D
0DB3:  MOVLB  01
0DB4:  MOVWF  64
....................   SecondCounter=SEC_COUNTER; 
0DB5:  MOVLW  3B
0DB6:  MOVWF  63
....................   THIRTY_MIN_FLAG=0; 
0DB7:  BCF    7D.7
....................   MINUTE_FLAG=0; 
0DB8:  BCF    7D.6
....................   PROMPT_FLAG=1; 
0DB9:  BSF    65.0
....................   TailChar=Tail; 
0DBA:  MOVLB  00
0DBB:  MOVF   67,W
0DBC:  MOVWF  72
....................   ConfirmChar=0; 
0DBD:  CLRF   73
....................   //AuxOut[0] = PO_AUX_OUT0; 
....................   //AuxOut[1] = PO_AUX_OUT1; 
....................   //AuxOut[2] = PO_AUX_OUT2; 
....................   AuxInSW[0] = 0; 
0DBE:  CLRF   3F
....................   AuxInSW[1] = 0; 
0DBF:  CLRF   40
....................   AuxInSW[2] = 0; 
0DC0:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0DC1:  MOVLB  01
0DC2:  BCF    62.1
....................   COR_IN_EFFECTIVE=0; 
0DC3:  MOVLB  00
0DC4:  CLRF   61
....................   set_admin_mode(0); 
0DC5:  MOVLB  02
0DC6:  CLRF   42
0DC7:  MOVLB  00
0DC8:  CALL   4BE
....................   rs232_mode=0; 
0DC9:  MOVLB  01
0DCA:  BCF    65.2
....................   button_state=0; 
0DCB:  CLRF   61
.................... #ifdef LCD_TYPE_PI 
....................   init_lcd(); 
0DCC:  MOVLB  00
0DCD:  CALL   4D3
.................... #endif 
....................   setup_adc(ADC_CLOCK_INTERNAL); 
0DCE:  MOVLB  01
0DCF:  BSF    1E.4
0DD0:  BSF    1E.5
0DD1:  BCF    1E.6
0DD2:  BCF    1E.7
0DD3:  BSF    1D.0
....................   setup_adc_ports(ADJ_POT|VSS_VDD); 
0DD4:  BCF    1E.0
0DD5:  BCF    1E.1
0DD6:  BCF    1E.2
0DD7:  MOVLW  00
0DD8:  MOVLB  03
0DD9:  MOVWF  0C
0DDA:  MOVWF  10
0DDB:  MOVLW  20
0DDC:  MOVWF  0D
0DDD:  MOVLW  00
0DDE:  MOVWF  0F
....................   set_adc_channel(13); 
0DDF:  MOVLW  34
0DE0:  MOVWF  78
0DE1:  MOVLB  01
0DE2:  MOVF   1D,W
0DE3:  ANDLW  83
0DE4:  IORWF  78,W
0DE5:  MOVWF  1D
....................  
.................... //  setup_adc_ports(ADJ_POT); 
.................... //  set_adc_channel(13); 
.................... //  printf("\n\rInitialization complete"); 
.................... } // }}} 
0DE6:  MOVLP  20
0DE7:  MOVLB  00
0DE8:  GOTO   132 (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180E:  MOVLB  02
180F:  BCF    2A.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
1810:  CLRF   41
1811:  CLRF   42
1812:  MOVLW  20
1813:  MOVWF  05
1814:  MOVLW  AD
1815:  MOVWF  04
1816:  MOVF   41,W
1817:  ADDWF  04,F
1818:  MOVLW  00
1819:  ADDWFC 05,F
181A:  MOVF   42,W
181B:  MOVLP  00
181C:  MOVLB  00
181D:  CALL   140
181E:  MOVLP  18
181F:  MOVWF  00
1820:  IORLW  00
1821:  BTFSC  03.2
1822:  GOTO   028
1823:  MOVLB  02
1824:  INCF   42,F
1825:  INCF   41,F
1826:  GOTO   012
1827:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1828:  MOVLW  20
1829:  MOVLB  02
182A:  MOVWF  42
182B:  MOVLW  50
182C:  MOVWF  41
182D:  MOVLW  20
182E:  MOVWF  44
182F:  MOVLW  AD
1830:  MOVWF  43
1831:  MOVLP  08
1832:  MOVLB  00
1833:  CALL   6B1
1834:  MOVLP  18
1835:  MOVF   79,W
1836:  MOVLB  02
1837:  MOVWF  2C
1838:  MOVF   78,W
1839:  MOVWF  2B
....................   if (sptr!=0) {; 
183A:  MOVF   2B,F
183B:  BTFSS  03.2
183C:  GOTO   040
183D:  MOVF   2C,F
183E:  BTFSC  03.2
183F:  GOTO   05A
....................     strcpy(verb,sptr); 
1840:  MOVF   2C,W
1841:  MOVWF  44
1842:  MOVF   2B,W
1843:  MOVWF  43
1844:  MOVLW  20
1845:  MOVWF  42
1846:  MOVLW  A2
1847:  MOVWF  41
1848:  MOVF   44,W
1849:  MOVWF  05
184A:  MOVF   43,W
184B:  MOVWF  04
184C:  MOVF   00,W
184D:  MOVWF  45
184E:  MOVF   42,W
184F:  MOVWF  05
1850:  MOVF   41,W
1851:  MOVWF  04
1852:  MOVF   45,W
1853:  MOVWF  00
1854:  MOVF   00,F
1855:  BTFSC  03.2
1856:  GOTO   05A
1857:  INCF   41,F
1858:  INCF   43,F
1859:  GOTO   048
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
185A:  CLRF   42
185B:  CLRF   41
185C:  MOVLW  20
185D:  MOVWF  44
185E:  MOVLW  AD
185F:  MOVWF  43
1860:  MOVLP  08
1861:  MOVLB  00
1862:  CALL   6B1
1863:  MOVLP  18
1864:  MOVF   79,W
1865:  MOVLB  02
1866:  MOVWF  2C
1867:  MOVF   78,W
1868:  MOVWF  2B
....................   if (sptr!=0) {; 
1869:  MOVF   2B,F
186A:  BTFSS  03.2
186B:  GOTO   06F
186C:  MOVF   2C,F
186D:  BTFSC  03.2
186E:  GOTO   089
....................     strcpy(argument_name,sptr); 
186F:  MOVF   2C,W
1870:  MOVWF  44
1871:  MOVF   2B,W
1872:  MOVWF  43
1873:  MOVLW  20
1874:  MOVWF  42
1875:  MOVLW  74
1876:  MOVWF  41
1877:  MOVF   44,W
1878:  MOVWF  05
1879:  MOVF   43,W
187A:  MOVWF  04
187B:  MOVF   00,W
187C:  MOVWF  45
187D:  MOVF   42,W
187E:  MOVWF  05
187F:  MOVF   41,W
1880:  MOVWF  04
1881:  MOVF   45,W
1882:  MOVWF  00
1883:  MOVF   00,F
1884:  BTFSC  03.2
1885:  GOTO   089
1886:  INCF   41,F
1887:  INCF   43,F
1888:  GOTO   077
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1889:  CLRF   42
188A:  CLRF   41
188B:  MOVLW  20
188C:  MOVWF  44
188D:  MOVLW  AD
188E:  MOVWF  43
188F:  MOVLP  08
1890:  MOVLB  00
1891:  CALL   6B1
1892:  MOVLP  18
1893:  MOVF   79,W
1894:  MOVLB  02
1895:  MOVWF  2C
1896:  MOVF   78,W
1897:  MOVWF  2B
....................   if (sptr!=0) {; 
1898:  MOVF   2B,F
1899:  BTFSS  03.2
189A:  GOTO   09E
189B:  MOVF   2C,F
189C:  BTFSC  03.2
189D:  GOTO   0C5
....................     strcpy(match_val,sptr); 
189E:  MOVF   2C,W
189F:  MOVWF  44
18A0:  MOVF   2B,W
18A1:  MOVWF  43
18A2:  MOVLW  20
18A3:  MOVWF  42
18A4:  MOVLW  B5
18A5:  MOVWF  41
18A6:  MOVF   44,W
18A7:  MOVWF  05
18A8:  MOVF   43,W
18A9:  MOVWF  04
18AA:  MOVF   00,W
18AB:  MOVWF  45
18AC:  MOVF   42,W
18AD:  MOVWF  05
18AE:  MOVF   41,W
18AF:  MOVWF  04
18B0:  MOVF   45,W
18B1:  MOVWF  00
18B2:  MOVF   00,F
18B3:  BTFSC  03.2
18B4:  GOTO   0B8
18B5:  INCF   41,F
18B6:  INCF   43,F
18B7:  GOTO   0A6
....................     value = str_to_decimal(match_val); 
18B8:  MOVLW  20
18B9:  MOVWF  42
18BA:  MOVLW  B5
18BB:  MOVWF  41
18BC:  MOVLP  08
18BD:  MOVLB  00
18BE:  CALL   7B7
18BF:  MOVLP  18
18C0:  MOVF   78,W
18C1:  MOVLB  01
18C2:  MOVWF  43
....................   } else { 
18C3:  GOTO   0CA
18C4:  MOVLB  02
....................     value = 0; 
18C5:  MOVLB  01
18C6:  CLRF   43
....................     do_get_var = 1; 
18C7:  MOVLB  02
18C8:  BSF    2A.0
18C9:  MOVLB  01
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18CA:  MOVLB  02
18CB:  CLRF   41
18CC:  CLRF   42
18CD:  MOVLW  20
18CE:  MOVWF  05
18CF:  MOVLW  B9
18D0:  MOVWF  04
18D1:  MOVF   41,W
18D2:  ADDWF  04,F
18D3:  MOVLW  00
18D4:  ADDWFC 05,F
18D5:  MOVF   42,W
18D6:  MOVLP  00
18D7:  MOVLB  00
18D8:  CALL   146
18D9:  MOVLP  18
18DA:  MOVWF  00
18DB:  IORLW  00
18DC:  BTFSC  03.2
18DD:  GOTO   0E3
18DE:  MOVLB  02
18DF:  INCF   42,F
18E0:  INCF   41,F
18E1:  GOTO   0CD
18E2:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
18E3:  MOVLW  20
18E4:  MOVLB  02
18E5:  MOVWF  42
18E6:  MOVLW  B9
18E7:  MOVWF  41
18E8:  MOVLW  20
18E9:  MOVWF  44
18EA:  MOVLW  A2
18EB:  MOVWF  43
18EC:  MOVLP  10
18ED:  MOVLB  00
18EE:  CALL   000
18EF:  MOVLP  18
18F0:  MOVF   78,F
18F1:  BTFSS  03.2
18F2:  GOTO   0FC
....................     if ( do_get_var ) { 
18F3:  MOVLB  02
18F4:  BTFSS  2A.0
18F5:  GOTO   0F9
....................       command=GET_REG; 
18F6:  MOVLW  03
18F7:  MOVWF  70
....................     } else { 
18F8:  GOTO   0FB
....................       command=SET_REG; 
18F9:  MOVLW  02
18FA:  MOVWF  70
18FB:  MOVLB  00
....................     } 
....................   } // }}} 
.................... #if __DEVICE__  == 1939 
....................   // Check for "setb" command {{{ 
....................   strcpy(smatch_reg,"setb");   
18FC:  MOVLB  02
18FD:  CLRF   41
18FE:  CLRF   42
18FF:  MOVLW  20
1900:  MOVWF  05
1901:  MOVLW  B9
1902:  MOVWF  04
1903:  MOVF   41,W
1904:  ADDWF  04,F
1905:  MOVLW  00
1906:  ADDWFC 05,F
1907:  MOVF   42,W
1908:  MOVLP  00
1909:  MOVLB  00
190A:  CALL   14B
190B:  MOVLP  18
190C:  MOVWF  00
190D:  IORLW  00
190E:  BTFSC  03.2
190F:  GOTO   115
1910:  MOVLB  02
1911:  INCF   42,F
1912:  INCF   41,F
1913:  GOTO   0FF
1914:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1915:  MOVLW  20
1916:  MOVLB  02
1917:  MOVWF  42
1918:  MOVLW  B9
1919:  MOVWF  41
191A:  MOVLW  20
191B:  MOVWF  44
191C:  MOVLW  A2
191D:  MOVWF  43
191E:  MOVLP  10
191F:  MOVLB  00
1920:  CALL   000
1921:  MOVLP  18
1922:  MOVF   78,F
1923:  BTFSS  03.2
1924:  GOTO   127
....................       command=SET_BIT; 
1925:  MOVLW  0E
1926:  MOVWF  70
....................   } // }}} 
....................   // Check for "setb" command {{{ 
....................   strcpy(smatch_reg,"clrb");   
1927:  MOVLB  02
1928:  CLRF   41
1929:  CLRF   42
192A:  MOVLW  20
192B:  MOVWF  05
192C:  MOVLW  B9
192D:  MOVWF  04
192E:  MOVF   41,W
192F:  ADDWF  04,F
1930:  MOVLW  00
1931:  ADDWFC 05,F
1932:  MOVF   42,W
1933:  MOVLP  00
1934:  MOVLB  00
1935:  CALL   151
1936:  MOVLP  18
1937:  MOVWF  00
1938:  IORLW  00
1939:  BTFSC  03.2
193A:  GOTO   140
193B:  MOVLB  02
193C:  INCF   42,F
193D:  INCF   41,F
193E:  GOTO   12A
193F:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1940:  MOVLW  20
1941:  MOVLB  02
1942:  MOVWF  42
1943:  MOVLW  B9
1944:  MOVWF  41
1945:  MOVLW  20
1946:  MOVWF  44
1947:  MOVLW  A2
1948:  MOVWF  43
1949:  MOVLP  10
194A:  MOVLB  00
194B:  CALL   000
194C:  MOVLP  18
194D:  MOVF   78,F
194E:  BTFSS  03.2
194F:  GOTO   152
....................       command=CLEAR_BIT; 
1950:  MOVLW  0F
1951:  MOVWF  70
....................   } // }}} 
.................... #endif 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
1952:  MOVLB  02
1953:  CLRF   41
1954:  CLRF   42
1955:  MOVLW  20
1956:  MOVWF  05
1957:  MOVLW  B9
1958:  MOVWF  04
1959:  MOVF   41,W
195A:  ADDWF  04,F
195B:  MOVLW  00
195C:  ADDWFC 05,F
195D:  MOVF   42,W
195E:  MOVLP  00
195F:  MOVLB  00
1960:  CALL   157
1961:  MOVLP  18
1962:  MOVWF  00
1963:  IORLW  00
1964:  BTFSC  03.2
1965:  GOTO   16B
1966:  MOVLB  02
1967:  INCF   42,F
1968:  INCF   41,F
1969:  GOTO   155
196A:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
196B:  MOVLW  20
196C:  MOVLB  02
196D:  MOVWF  42
196E:  MOVLW  B9
196F:  MOVWF  41
1970:  MOVLW  20
1971:  MOVWF  44
1972:  MOVLW  A2
1973:  MOVWF  43
1974:  MOVLP  10
1975:  MOVLB  00
1976:  CALL   000
1977:  MOVLP  18
1978:  MOVF   78,F
1979:  BTFSS  03.2
197A:  GOTO   17D
....................       command=SAVE_SETTINGS; 
197B:  MOVLW  04
197C:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
197D:  MOVLB  02
197E:  CLRF   41
197F:  CLRF   42
1980:  MOVLW  20
1981:  MOVWF  05
1982:  MOVLW  B9
1983:  MOVWF  04
1984:  MOVF   41,W
1985:  ADDWF  04,F
1986:  MOVLW  00
1987:  ADDWFC 05,F
1988:  MOVF   42,W
1989:  MOVLP  00
198A:  MOVLB  00
198B:  CALL   15D
198C:  MOVLP  18
198D:  MOVWF  00
198E:  IORLW  00
198F:  BTFSC  03.2
1990:  GOTO   196
1991:  MOVLB  02
1992:  INCF   42,F
1993:  INCF   41,F
1994:  GOTO   180
1995:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1996:  MOVLW  20
1997:  MOVLB  02
1998:  MOVWF  42
1999:  MOVLW  B9
199A:  MOVWF  41
199B:  MOVLW  20
199C:  MOVWF  44
199D:  MOVLW  A2
199E:  MOVWF  43
199F:  MOVLP  10
19A0:  MOVLB  00
19A1:  CALL   000
19A2:  MOVLP  18
19A3:  MOVF   78,F
19A4:  BTFSS  03.2
19A5:  GOTO   1A8
....................       command=RESTORE_SETTINGS; 
19A6:  MOVLW  05
19A7:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
19A8:  MOVLB  02
19A9:  CLRF   41
19AA:  CLRF   42
19AB:  MOVLW  20
19AC:  MOVWF  05
19AD:  MOVLW  B9
19AE:  MOVWF  04
19AF:  MOVF   41,W
19B0:  ADDWF  04,F
19B1:  MOVLW  00
19B2:  ADDWFC 05,F
19B3:  MOVF   42,W
19B4:  MOVLP  00
19B5:  MOVLB  00
19B6:  CALL   166
19B7:  MOVLP  18
19B8:  MOVWF  00
19B9:  IORLW  00
19BA:  BTFSC  03.2
19BB:  GOTO   1C1
19BC:  MOVLB  02
19BD:  INCF   42,F
19BE:  INCF   41,F
19BF:  GOTO   1AB
19C0:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19C1:  MOVLW  20
19C2:  MOVLB  02
19C3:  MOVWF  42
19C4:  MOVLW  B9
19C5:  MOVWF  41
19C6:  MOVLW  20
19C7:  MOVWF  44
19C8:  MOVLW  A2
19C9:  MOVWF  43
19CA:  MOVLP  10
19CB:  MOVLB  00
19CC:  CALL   000
19CD:  MOVLP  18
19CE:  MOVF   78,F
19CF:  BTFSS  03.2
19D0:  GOTO   1D3
....................     command=STATUS; 
19D1:  MOVLW  08
19D2:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
19D3:  MOVLB  02
19D4:  CLRF   41
19D5:  CLRF   42
19D6:  MOVLW  20
19D7:  MOVWF  05
19D8:  MOVLW  B9
19D9:  MOVWF  04
19DA:  MOVF   41,W
19DB:  ADDWF  04,F
19DC:  MOVLW  00
19DD:  ADDWFC 05,F
19DE:  MOVF   42,W
19DF:  MOVLP  00
19E0:  MOVLB  00
19E1:  CALL   16E
19E2:  MOVLP  18
19E3:  MOVWF  00
19E4:  IORLW  00
19E5:  BTFSC  03.2
19E6:  GOTO   1EC
19E7:  MOVLB  02
19E8:  INCF   42,F
19E9:  INCF   41,F
19EA:  GOTO   1D6
19EB:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19EC:  MOVLW  20
19ED:  MOVLB  02
19EE:  MOVWF  42
19EF:  MOVLW  B9
19F0:  MOVWF  41
19F1:  MOVLW  20
19F2:  MOVWF  44
19F3:  MOVLW  A2
19F4:  MOVWF  43
19F5:  MOVLP  10
19F6:  MOVLB  00
19F7:  CALL   000
19F8:  MOVLP  18
19F9:  MOVF   78,F
19FA:  BTFSS  03.2
19FB:  GOTO   202
....................     command=ADMIN; 
19FC:  MOVLW  09
19FD:  MOVWF  70
....................     argument=REBOOT; 
19FE:  MOVLW  02
19FF:  MOVLB  01
1A00:  MOVWF  42
1A01:  MOVLB  00
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
1A02:  MOVLB  02
1A03:  CLRF   41
1A04:  CLRF   42
1A05:  MOVLW  20
1A06:  MOVWF  05
1A07:  MOVLW  B9
1A08:  MOVWF  04
1A09:  MOVF   41,W
1A0A:  ADDWF  04,F
1A0B:  MOVLW  00
1A0C:  ADDWFC 05,F
1A0D:  MOVF   42,W
1A0E:  MOVLP  00
1A0F:  MOVLB  00
1A10:  CALL   176
1A11:  MOVLP  18
1A12:  MOVWF  00
1A13:  IORLW  00
1A14:  BTFSC  03.2
1A15:  GOTO   21B
1A16:  MOVLB  02
1A17:  INCF   42,F
1A18:  INCF   41,F
1A19:  GOTO   205
1A1A:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A1B:  MOVLW  20
1A1C:  MOVLB  02
1A1D:  MOVWF  42
1A1E:  MOVLW  B9
1A1F:  MOVWF  41
1A20:  MOVLW  20
1A21:  MOVWF  44
1A22:  MOVLW  A2
1A23:  MOVWF  43
1A24:  MOVLP  10
1A25:  MOVLB  00
1A26:  CALL   000
1A27:  MOVLP  18
1A28:  MOVF   78,F
1A29:  BTFSS  03.2
1A2A:  GOTO   27D
....................     //command=DTMF_SEND; 
....................     command=0; 
1A2B:  CLRF   70
....................     value = str_to_decimal(argument_name); 
1A2C:  MOVLW  20
1A2D:  MOVLB  02
1A2E:  MOVWF  42
1A2F:  MOVLW  74
1A30:  MOVWF  41
1A31:  MOVLP  08
1A32:  MOVLB  00
1A33:  CALL   7B7
1A34:  MOVLP  18
1A35:  MOVF   78,W
1A36:  MOVLB  01
1A37:  MOVWF  43
....................     if ( value == d0 ) { 
1A38:  MOVF   43,W
1A39:  SUBLW  0A
1A3A:  BTFSS  03.2
1A3B:  GOTO   23E
....................       value = dd; 
1A3C:  CLRF   43
....................     } else if (value == dd) { 
1A3D:  GOTO   243
1A3E:  MOVF   43,F
1A3F:  BTFSS  03.2
1A40:  GOTO   243
....................       value = d0; 
1A41:  MOVLW  0A
1A42:  MOVWF  43
....................     } 
....................     dtmf_send_digit(value&0x0F); 
1A43:  MOVF   43,W
1A44:  ANDLW  0F
1A45:  MOVLB  02
1A46:  MOVWF  41
1A47:  MOVF   41,W
1A48:  MOVWF  42
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A7D:  MOVLB  02
1A7E:  CLRF   41
1A7F:  CLRF   42
1A80:  MOVLW  20
1A81:  MOVWF  05
1A82:  MOVLW  B9
1A83:  MOVWF  04
1A84:  MOVF   41,W
1A85:  ADDWF  04,F
1A86:  MOVLW  00
1A87:  ADDWFC 05,F
1A88:  MOVF   42,W
1A89:  MOVLP  00
1A8A:  MOVLB  00
1A8B:  CALL   179
1A8C:  MOVLP  18
1A8D:  MOVWF  00
1A8E:  IORLW  00
1A8F:  BTFSC  03.2
1A90:  GOTO   296
1A91:  MOVLB  02
1A92:  INCF   42,F
1A93:  INCF   41,F
1A94:  GOTO   280
1A95:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A96:  MOVLW  20
1A97:  MOVLB  02
1A98:  MOVWF  42
1A99:  MOVLW  B9
1A9A:  MOVWF  41
1A9B:  MOVLW  20
1A9C:  MOVWF  44
1A9D:  MOVLW  A2
1A9E:  MOVWF  43
1A9F:  MOVLP  10
1AA0:  MOVLB  00
1AA1:  CALL   000
1AA2:  MOVLP  18
1AA3:  MOVF   78,F
1AA4:  BTFSS  03.2
1AA5:  GOTO   2A8
....................     command=I2C_SEND; 
1AA6:  MOVLW  0C
1AA7:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1AA8:  MOVLB  02
1AA9:  CLRF   41
1AAA:  CLRF   42
1AAB:  MOVLW  20
1AAC:  MOVWF  05
1AAD:  MOVLW  B9
1AAE:  MOVWF  04
1AAF:  MOVF   41,W
1AB0:  ADDWF  04,F
1AB1:  MOVLW  00
1AB2:  ADDWFC 05,F
1AB3:  MOVF   42,W
1AB4:  MOVLP  00
1AB5:  MOVLB  00
1AB6:  CALL   17E
1AB7:  MOVLP  18
1AB8:  MOVWF  00
1AB9:  IORLW  00
1ABA:  BTFSC  03.2
1ABB:  GOTO   2C1
1ABC:  MOVLB  02
1ABD:  INCF   42,F
1ABE:  INCF   41,F
1ABF:  GOTO   2AB
1AC0:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AC1:  MOVLW  20
1AC2:  MOVLB  02
1AC3:  MOVWF  42
1AC4:  MOVLW  B9
1AC5:  MOVWF  41
1AC6:  MOVLW  20
1AC7:  MOVWF  44
1AC8:  MOVLW  A2
1AC9:  MOVWF  43
1ACA:  MOVLP  10
1ACB:  MOVLB  00
1ACC:  CALL   000
1ACD:  MOVLP  18
1ACE:  MOVF   78,F
1ACF:  BTFSS  03.2
1AD0:  GOTO   2EA
....................     value = str_to_decimal(argument_name); 
1AD1:  MOVLW  20
1AD2:  MOVLB  02
1AD3:  MOVWF  42
1AD4:  MOVLW  74
1AD5:  MOVWF  41
1AD6:  MOVLP  08
1AD7:  MOVLB  00
1AD8:  CALL   7B7
1AD9:  MOVLP  18
1ADA:  MOVF   78,W
1ADB:  MOVLB  01
1ADC:  MOVWF  43
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1ADD:  MOVF   43,W
1ADE:  SUBLW  24
1ADF:  BTFSS  03.0
1AE0:  GOTO   2E5
....................       argument = 0; 
1AE1:  CLRF   42
....................       command  = MORSE_SEND; 
1AE2:  MOVLW  0B
1AE3:  MOVWF  70
....................     } else { 
1AE4:  GOTO   2E9
....................       command  = ADMIN; 
1AE5:  MOVLW  09
1AE6:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1AE7:  MOVLW  03
1AE8:  MOVWF  42
1AE9:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1AEA:  MOVLB  02
1AEB:  CLRF   41
1AEC:  CLRF   42
1AED:  MOVLW  20
1AEE:  MOVWF  05
1AEF:  MOVLW  B9
1AF0:  MOVWF  04
1AF1:  MOVF   41,W
1AF2:  ADDWF  04,F
1AF3:  MOVLW  00
1AF4:  ADDWFC 05,F
1AF5:  MOVF   42,W
1AF6:  MOVLP  00
1AF7:  MOVLB  00
1AF8:  CALL   185
1AF9:  MOVLP  18
1AFA:  MOVWF  00
1AFB:  IORLW  00
1AFC:  BTFSC  03.2
1AFD:  GOTO   303
1AFE:  MOVLB  02
1AFF:  INCF   42,F
1B00:  INCF   41,F
1B01:  GOTO   2ED
1B02:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B03:  MOVLW  20
1B04:  MOVLB  02
1B05:  MOVWF  42
1B06:  MOVLW  B9
1B07:  MOVWF  41
1B08:  MOVLW  20
1B09:  MOVWF  44
1B0A:  MOVLW  A2
1B0B:  MOVWF  43
1B0C:  MOVLP  10
1B0D:  MOVLB  00
1B0E:  CALL   000
1B0F:  MOVLP  18
1B10:  MOVF   78,F
1B11:  BTFSS  03.2
1B12:  GOTO   315
....................     command=INCREMENT_REG; 
1B13:  MOVLW  06
1B14:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1B15:  MOVLB  02
1B16:  CLRF   41
1B17:  CLRF   42
1B18:  MOVLW  20
1B19:  MOVWF  05
1B1A:  MOVLW  B9
1B1B:  MOVWF  04
1B1C:  MOVF   41,W
1B1D:  ADDWF  04,F
1B1E:  MOVLW  00
1B1F:  ADDWFC 05,F
1B20:  MOVF   42,W
1B21:  MOVLP  00
1B22:  MOVLB  00
1B23:  CALL   188
1B24:  MOVLP  18
1B25:  MOVWF  00
1B26:  IORLW  00
1B27:  BTFSC  03.2
1B28:  GOTO   32E
1B29:  MOVLB  02
1B2A:  INCF   42,F
1B2B:  INCF   41,F
1B2C:  GOTO   318
1B2D:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B2E:  MOVLW  20
1B2F:  MOVLB  02
1B30:  MOVWF  42
1B31:  MOVLW  B9
1B32:  MOVWF  41
1B33:  MOVLW  20
1B34:  MOVWF  44
1B35:  MOVLW  A2
1B36:  MOVWF  43
1B37:  MOVLP  10
1B38:  MOVLB  00
1B39:  CALL   000
1B3A:  MOVLP  18
1B3B:  MOVF   78,F
1B3C:  BTFSS  03.2
1B3D:  GOTO   340
....................     command=DECREMENT_REG; 
1B3E:  MOVLW  07
1B3F:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1B40:  MOVLB  02
1B41:  CLRF   41
1B42:  CLRF   42
1B43:  MOVLW  20
1B44:  MOVWF  05
1B45:  MOVLW  B9
1B46:  MOVWF  04
1B47:  MOVF   41,W
1B48:  ADDWF  04,F
1B49:  MOVLW  00
1B4A:  ADDWFC 05,F
1B4B:  MOVF   42,W
1B4C:  MOVLP  00
1B4D:  MOVLB  00
1B4E:  CALL   18B
1B4F:  MOVLP  18
1B50:  MOVWF  00
1B51:  IORLW  00
1B52:  BTFSC  03.2
1B53:  GOTO   359
1B54:  MOVLB  02
1B55:  INCF   42,F
1B56:  INCF   41,F
1B57:  GOTO   343
1B58:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B59:  MOVLW  20
1B5A:  MOVLB  02
1B5B:  MOVWF  42
1B5C:  MOVLW  B9
1B5D:  MOVWF  41
1B5E:  MOVLW  20
1B5F:  MOVWF  44
1B60:  MOVLW  A2
1B61:  MOVWF  43
1B62:  MOVLP  10
1B63:  MOVLB  00
1B64:  CALL   000
1B65:  MOVLP  18
1B66:  MOVF   78,F
1B67:  BTFSS  03.2
1B68:  GOTO   389
....................     command=SET_REG; 
1B69:  MOVLW  02
1B6A:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B6B:  MOVLW  01
1B6C:  MOVLB  01
1B6D:  ADDWF  30,W
1B6E:  ANDLW  03
1B6F:  MOVWF  43
....................     strcpy(argument_name,"CPOT"); 
1B70:  MOVLB  02
1B71:  CLRF   41
1B72:  CLRF   42
1B73:  MOVLW  20
1B74:  MOVWF  05
1B75:  MOVLW  74
1B76:  MOVWF  04
1B77:  MOVF   41,W
1B78:  ADDWF  04,F
1B79:  MOVLW  00
1B7A:  ADDWFC 05,F
1B7B:  MOVF   42,W
1B7C:  MOVLP  00
1B7D:  MOVLB  00
1B7E:  CALL   18E
1B7F:  MOVLP  18
1B80:  MOVWF  00
1B81:  IORLW  00
1B82:  BTFSC  03.2
1B83:  GOTO   389
1B84:  MOVLB  02
1B85:  INCF   42,F
1B86:  INCF   41,F
1B87:  GOTO   373
1B88:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B89:  MOVLB  02
1B8A:  CLRF   41
1B8B:  CLRF   42
1B8C:  MOVLW  20
1B8D:  MOVWF  05
1B8E:  MOVLW  B9
1B8F:  MOVWF  04
1B90:  MOVF   41,W
1B91:  ADDWF  04,F
1B92:  MOVLW  00
1B93:  ADDWFC 05,F
1B94:  MOVF   42,W
1B95:  MOVLP  00
1B96:  MOVLB  00
1B97:  CALL   194
1B98:  MOVLP  18
1B99:  MOVWF  00
1B9A:  IORLW  00
1B9B:  BTFSC  03.2
1B9C:  GOTO   3A2
1B9D:  MOVLB  02
1B9E:  INCF   42,F
1B9F:  INCF   41,F
1BA0:  GOTO   38C
1BA1:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1BA2:  MOVLW  20
1BA3:  MOVLB  02
1BA4:  MOVWF  42
1BA5:  MOVLW  B9
1BA6:  MOVWF  41
1BA7:  MOVLW  20
1BA8:  MOVWF  44
1BA9:  MOVLW  A2
1BAA:  MOVWF  43
1BAB:  MOVLP  10
1BAC:  MOVLB  00
1BAD:  CALL   000
1BAE:  MOVLP  18
1BAF:  MOVF   78,F
1BB0:  BTFSS  03.2
1BB1:  GOTO   3C2
....................     AdminMode = ~AdminMode; 
1BB2:  MOVLW  02
1BB3:  MOVLB  01
1BB4:  XORWF  65,F
....................     set_admin_mode(AdminMode); 
1BB5:  MOVLW  00
1BB6:  BTFSC  65.1
1BB7:  MOVLW  01
1BB8:  MOVLB  02
1BB9:  MOVWF  41
1BBA:  MOVWF  42
1BBB:  MOVLP  08
1BBC:  MOVLB  00
1BBD:  CALL   4BE
1BBE:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1BBF:  MOVLB  01
1BC0:  BSF    65.0
1BC1:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... #if __DEVICE__  == 1939 
.................... void set_bit (void) { // {{{ 
....................   int *pObj; 
....................     pObj=RegMap[argument].reg_ptr; 
*
1564:  MOVLB  01
1565:  RLF    42,W
1566:  MOVWF  77
1567:  RLF    77,F
1568:  MOVLW  FC
1569:  ANDWF  77,F
156A:  MOVF   77,W
156B:  MOVLB  02
156C:  MOVWF  2F
156D:  INCF   2F,W
156E:  MOVLP  00
156F:  MOVLB  00
1570:  CALL   043
1571:  MOVLP  10
1572:  MOVWF  7A
1573:  MOVLB  02
1574:  MOVF   2F,W
1575:  MOVLP  00
1576:  MOVLB  00
1577:  CALL   043
1578:  MOVLP  10
1579:  MOVLB  02
157A:  MOVWF  2D
157B:  MOVF   7A,W
157C:  MOVWF  2E
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
157D:  MOVLP  00
157E:  MOVLB  00
157F:  CALL   7EE
1580:  MOVLP  10
1581:  MOVF   78,F
1582:  BTFSS  03.2
1583:  GOTO   593
1584:  MOVLB  01
1585:  RLF    42,W
1586:  MOVWF  77
1587:  RLF    77,F
1588:  MOVLW  FC
1589:  ANDWF  77,F
158A:  MOVF   77,W
158B:  ADDLW  03
158C:  MOVLP  00
158D:  MOVLB  00
158E:  CALL   043
158F:  MOVLP  10
1590:  MOVWF  78
1591:  BTFSC  78.1
1592:  GOTO   5B6
....................       *pObj=bit_set(*pObj,(value&0x1F)); 
1593:  MOVLB  02
1594:  MOVF   2D,W
1595:  MOVWF  2F
1596:  MOVF   2E,W
1597:  MOVWF  30
1598:  MOVF   2E,W
1599:  MOVWF  7A
159A:  MOVF   2D,W
159B:  MOVWF  04
159C:  MOVF   2E,W
159D:  MOVWF  05
159E:  MOVLB  01
159F:  MOVF   43,W
15A0:  ANDLW  1F
15A1:  MOVLB  02
15A2:  MOVWF  31
15A3:  MOVLW  01
15A4:  MOVWF  77
15A5:  MOVF   31,W
15A6:  MOVWF  78
15A7:  BTFSC  03.2
15A8:  GOTO   5AC
15A9:  LSLF   77,F
15AA:  DECFSZ 78,F
15AB:  GOTO   5A9
15AC:  MOVF   77,W
15AD:  IORWF  00,F
15AE:  MOVWF  31
15AF:  MOVF   30,W
15B0:  MOVWF  05
15B1:  MOVF   2F,W
15B2:  MOVWF  04
15B3:  MOVF   31,W
15B4:  MOVWF  00
15B5:  MOVLB  00
....................     } 
.................... } // }}} 
.................... void clear_bit (void) { // {{{ 
....................   int *pObj; 
....................     pObj=RegMap[argument].reg_ptr; 
*
15B7:  MOVLB  01
15B8:  RLF    42,W
15B9:  MOVWF  77
15BA:  RLF    77,F
15BB:  MOVLW  FC
15BC:  ANDWF  77,F
15BD:  MOVF   77,W
15BE:  MOVLB  02
15BF:  MOVWF  2F
15C0:  INCF   2F,W
15C1:  MOVLP  00
15C2:  MOVLB  00
15C3:  CALL   043
15C4:  MOVLP  10
15C5:  MOVWF  7A
15C6:  MOVLB  02
15C7:  MOVF   2F,W
15C8:  MOVLP  00
15C9:  MOVLB  00
15CA:  CALL   043
15CB:  MOVLP  10
15CC:  MOVLB  02
15CD:  MOVWF  2D
15CE:  MOVF   7A,W
15CF:  MOVWF  2E
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
15D0:  MOVLP  00
15D1:  MOVLB  00
15D2:  CALL   7EE
15D3:  MOVLP  10
15D4:  MOVF   78,F
15D5:  BTFSS  03.2
15D6:  GOTO   5E6
15D7:  MOVLB  01
15D8:  RLF    42,W
15D9:  MOVWF  77
15DA:  RLF    77,F
15DB:  MOVLW  FC
15DC:  ANDWF  77,F
15DD:  MOVF   77,W
15DE:  ADDLW  03
15DF:  MOVLP  00
15E0:  MOVLB  00
15E1:  CALL   043
15E2:  MOVLP  10
15E3:  MOVWF  78
15E4:  BTFSC  78.1
15E5:  GOTO   60A
....................       *pObj=bit_clear(*pObj,(value&0x1F)); 
15E6:  MOVLB  02
15E7:  MOVF   2D,W
15E8:  MOVWF  2F
15E9:  MOVF   2E,W
15EA:  MOVWF  30
15EB:  MOVF   2E,W
15EC:  MOVWF  7A
15ED:  MOVF   2D,W
15EE:  MOVWF  04
15EF:  MOVF   2E,W
15F0:  MOVWF  05
15F1:  MOVLB  01
15F2:  MOVF   43,W
15F3:  ANDLW  1F
15F4:  MOVLB  02
15F5:  MOVWF  31
15F6:  MOVLW  01
15F7:  MOVWF  77
15F8:  MOVF   31,W
15F9:  MOVWF  78
15FA:  BTFSC  03.2
15FB:  GOTO   5FF
15FC:  LSLF   77,F
15FD:  DECFSZ 78,F
15FE:  GOTO   5FC
15FF:  MOVF   77,W
1600:  XORLW  FF
1601:  ANDWF  00,F
1602:  MOVWF  31
1603:  MOVF   30,W
1604:  MOVWF  05
1605:  MOVF   2F,W
1606:  MOVWF  04
1607:  MOVF   31,W
1608:  MOVWF  00
1609:  MOVLB  00
....................     } 
....................     PROMPT_FLAG=1; 
160A:  MOVLB  01
160B:  BSF    65.0
.................... } // }}} 
.................... #endif 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
11DE:  MOVLB  01
11DF:  MOVF   43,W
11E0:  SUBLW  FF
11E1:  BTFSS  03.2
11E2:  GOTO   201
....................     crlf(); 
11E3:  MOVLP  00
11E4:  MOVLB  00
11E5:  CALL   45E
11E6:  MOVLP  10
....................     printf ("%s %u",argument,value); 
11E7:  CLRF   05
11E8:  MOVLB  01
11E9:  MOVF   42,W
11EA:  MOVWF  04
11EB:  MOVLP  08
11EC:  MOVLB  00
11ED:  CALL   266
11EE:  MOVLP  10
11EF:  MOVLW  20
11F0:  CLRWDT
11F1:  BTFSS  11.4
11F2:  GOTO   1F0
11F3:  MOVLB  03
11F4:  MOVWF  1A
11F5:  MOVLB  01
11F6:  MOVF   43,W
11F7:  MOVLB  02
11F8:  MOVWF  50
11F9:  MOVLW  1B
11FA:  MOVWF  51
11FB:  MOVLP  00
11FC:  MOVLB  00
11FD:  CALL   6D6
11FE:  MOVLP  10
....................   } else { 
11FF:  GOTO   295
1200:  MOVLB  01
....................     pObj=RegMap[argument].reg_ptr; 
1201:  RLF    42,W
1202:  MOVWF  77
1203:  RLF    77,F
1204:  MOVLW  FC
1205:  ANDWF  77,F
1206:  MOVF   77,W
1207:  MOVLB  02
1208:  MOVWF  30
1209:  INCF   30,W
120A:  MOVLP  00
120B:  MOVLB  00
120C:  CALL   043
120D:  MOVLP  10
120E:  MOVWF  7A
120F:  MOVLB  02
1210:  MOVF   30,W
1211:  MOVLP  00
1212:  MOVLB  00
1213:  CALL   043
1214:  MOVLP  10
1215:  MOVLB  02
1216:  MOVWF  2D
1217:  MOVF   7A,W
1218:  MOVWF  2E
....................     // Consider allowing some registers to be updated outside AdminMode. 
....................     // Example : AuxOut registers, Enable 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
1219:  MOVLP  00
121A:  MOVLB  00
121B:  CALL   7EE
121C:  MOVLP  10
121D:  MOVF   78,F
121E:  BTFSS  03.2
121F:  GOTO   22F
1220:  MOVLB  01
1221:  RLF    42,W
1222:  MOVWF  77
1223:  RLF    77,F
1224:  MOVLW  FC
1225:  ANDWF  77,F
1226:  MOVF   77,W
1227:  ADDLW  03
1228:  MOVLP  00
1229:  MOVLB  00
122A:  CALL   043
122B:  MOVLP  10
122C:  MOVWF  78
122D:  BTFSC  78.1
122E:  GOTO   238
....................       *pObj=value; 
122F:  MOVLB  02
1230:  MOVF   2D,W
1231:  MOVWF  04
1232:  MOVF   2E,W
1233:  MOVWF  05
1234:  MOVLB  01
1235:  MOVF   43,W
1236:  MOVWF  00
1237:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
1238:  MOVLB  02
1239:  MOVF   2D,W
123A:  MOVWF  04
123B:  MOVF   2E,W
123C:  MOVWF  05
123D:  MOVF   00,W
123E:  MOVWF  2F
....................     crlf(); 
123F:  MOVLP  00
1240:  MOVLB  00
1241:  CALL   45E
1242:  MOVLP  10
....................     printf ("%s(%u) <= %u",argument_name,argument,lVar); 
1243:  MOVLW  20
1244:  MOVWF  05
1245:  MOVLW  74
1246:  MOVWF  04
1247:  MOVLP  08
1248:  CALL   266
1249:  MOVLP  10
124A:  MOVLW  28
124B:  CLRWDT
124C:  BTFSS  11.4
124D:  GOTO   24B
124E:  MOVLB  03
124F:  MOVWF  1A
1250:  MOVLB  01
1251:  MOVF   42,W
1252:  MOVLB  02
1253:  MOVWF  50
1254:  MOVLW  1B
1255:  MOVWF  51
1256:  MOVLP  00
1257:  MOVLB  00
1258:  CALL   6D6
1259:  MOVLP  10
125A:  MOVLW  30
125B:  MOVLB  03
125C:  MOVWF  11
125D:  MOVLW  04
125E:  MOVWF  12
125F:  BSF    03.0
1260:  MOVLW  05
1261:  MOVLB  02
1262:  MOVWF  50
1263:  MOVLP  00
1264:  MOVLB  00
1265:  CALL   662
1266:  MOVLP  10
1267:  MOVLB  02
1268:  MOVF   2F,W
1269:  MOVWF  50
126A:  MOVLW  1B
126B:  MOVWF  51
126C:  MOVLP  00
126D:  MOVLB  00
126E:  CALL   6D6
126F:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
1270:  MOVLB  02
1271:  MOVF   2E,W
1272:  SUBLW  1F
1273:  BTFSC  03.0
1274:  GOTO   286
1275:  XORLW  FF
1276:  BTFSS  03.2
1277:  GOTO   27C
1278:  MOVF   2D,W
1279:  SUBLW  0B
127A:  BTFSC  03.0
127B:  GOTO   286
127C:  MOVF   2E,W
127D:  SUBLW  20
127E:  BTFSS  03.0
127F:  GOTO   286
1280:  BTFSS  03.2
1281:  GOTO   28E
1282:  MOVF   2D,W
1283:  SUBLW  1B
1284:  BTFSC  03.0
1285:  GOTO   28E
1286:  MOVF   2D,W
1287:  SUBLW  60
1288:  BTFSS  03.2
1289:  GOTO   292
128A:  MOVF   2E,W
128B:  SUBLW  20
128C:  BTFSS  03.2
128D:  GOTO   292
....................       increment(0); // Increment is done in this function. Only update trim pot. 
128E:  CLRF   30
128F:  MOVLB  00
1290:  CALL   06A
1291:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
1292:  MOVLB  01
1293:  BSF    65.0
1294:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
106A:  MOVLB  01
106B:  MOVF   30,W
106C:  ANDLW  03
106D:  MOVLB  02
106E:  MOVWF  34
....................   if ( CurrentCorIndex ) { 
106F:  MOVF   75,F
1070:  BTFSC  03.2
1071:  GOTO   0A7
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
1072:  MOVLW  01
1073:  SUBWF  75,W
1074:  MOVWF  77
1075:  RLF    77,F
1076:  RLF    77,F
1077:  MOVLW  FC
1078:  ANDWF  77,F
1079:  MOVF   77,W
107A:  ADDWF  34,W
107B:  ADDLW  0C
107C:  MOVWF  31
107D:  MOVLW  20
107E:  MOVWF  32
107F:  BTFSC  03.0
1080:  INCF   32,F
....................     value = *pot_ptr; 
1081:  MOVF   31,W
1082:  MOVWF  04
1083:  MOVF   32,W
1084:  MOVWF  05
1085:  MOVF   00,W
1086:  MOVWF  33
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
1087:  MOVF   31,W
1088:  MOVWF  04
1089:  MOVF   32,W
108A:  MOVWF  05
108B:  MOVF   30,W
108C:  ADDWF  33,W
108D:  MOVWF  00
....................     if ( in_admin_mode() ) { 
108E:  MOVLP  00
108F:  MOVLB  00
1090:  CALL   7EE
1091:  MOVLP  10
1092:  MOVF   78,F
1093:  BTFSC  03.2
1094:  GOTO   0A6
....................       set_trimpot(CPotPtr,*pot_ptr); 
1095:  MOVLB  02
1096:  MOVF   32,W
1097:  MOVWF  7A
1098:  MOVF   31,W
1099:  MOVWF  04
109A:  MOVF   32,W
109B:  MOVWF  05
109C:  MOVF   00,W
109D:  MOVWF  35
109E:  MOVF   34,W
109F:  MOVWF  40
10A0:  MOVF   35,W
10A1:  MOVWF  41
10A2:  MOVLP  00
10A3:  MOVLB  00
10A4:  CALL   725
10A5:  MOVLP  10
10A6:  MOVLB  02
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
10A7:  MOVLP  08
10A8:  MOVLB  00
10A9:  CALL   280
10AA:  MOVLP  10
.................... } // }}} 
10AB:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
103F:  MOVLB  02
1040:  CLRF   40
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
1041:  MOVF   40,W
1042:  SUBLW  05
1043:  BTFSS  03.0
1044:  GOTO   068
....................     dest[c]=src[c]; 
1045:  MOVF   40,W
1046:  ADDWF  3C,W
1047:  MOVWF  78
1048:  MOVLW  00
1049:  ADDWFC 3D,W
104A:  MOVWF  7A
104B:  MOVF   78,W
104C:  MOVWF  41
104D:  MOVF   7A,W
104E:  MOVWF  42
104F:  MOVF   40,W
1050:  ADDWF  3E,W
1051:  MOVWF  78
1052:  MOVLW  00
1053:  ADDWFC 3F,W
1054:  MOVWF  7A
1055:  MOVF   78,W
1056:  MOVLB  03
1057:  MOVWF  11
1058:  MOVF   7A,W
1059:  MOVWF  12
105A:  MOVLB  02
105B:  MOVF   42,W
105C:  MOVWF  05
105D:  MOVF   41,W
105E:  MOVWF  04
105F:  MOVLW  01
1060:  MOVWF  46
1061:  MOVLP  00
1062:  MOVLB  00
1063:  CALL   79E
1064:  MOVLP  10
....................   c++; 
1065:  MOVLB  02
1066:  INCF   40,F
....................   } 
1067:  GOTO   041
.................... } // }}} 
1068:  MOVLB  00
1069:  RETURN
.................... void ExecAuxOutOp(char op,char arg,char ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
1D7A:  MOVF   2C,W
1D7B:  ANDLW  0F
1D7C:  MOVWF  2E
....................   uarg = (arg & 0xF0) >> 4; 
1D7D:  MOVF   2C,W
1D7E:  ANDLW  F0
1D7F:  MOVWF  77
1D80:  SWAPF  77,W
1D81:  MOVWF  2F
1D82:  MOVLW  0F
1D83:  ANDWF  2F,F
....................   switch(op) { 
1D84:  MOVF   2B,W
1D85:  XORLW  02
1D86:  MOVLB  00
1D87:  BTFSC  03.2
1D88:  GOTO   58D
1D89:  XORLW  03
1D8A:  BTFSC  03.2
1D8B:  GOTO   5A7
1D8C:  GOTO   5FB
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
1D8D:  MOVLW  22
1D8E:  MOVLB  02
1D8F:  ADDWF  2D,W
1D90:  MOVWF  04
1D91:  MOVLW  20
1D92:  MOVWF  05
1D93:  BTFSC  03.0
1D94:  INCF   05,F
1D95:  MOVF   2E,W
1D96:  ANDLW  1F
1D97:  MOVWF  33
1D98:  MOVF   7A,W
1D99:  MOVWF  34
1D9A:  MOVF   2F,W
1D9B:  XORWF  33,F
1D9C:  BTFSS  03.2
1D9D:  GOTO   5A3
1D9E:  MOVF   34,F
1D9F:  BTFSS  03.2
1DA0:  GOTO   5A3
1DA1:  MOVLW  00
1DA2:  GOTO   5A4
1DA3:  MOVLW  01
1DA4:  MOVWF  00
....................     break; 
1DA5:  MOVLB  00
1DA6:  GOTO   5FB
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       // Only COR_IN_HW is used which corresponds to the COR inputs on the controller. 
....................       // Emulated COR_IN are ignored. 
....................       int1 invert_output = ((arg & AUX_OUT_FOLLOW_COR_INVERT_OUTPUT)!=0); 
....................       int1 cor_active = ((COR_IN_HW & ~TOT_FLAG_Mask & larg) != 0); 
....................       int1 disable_delay_en = ((arg & AUX_OUT_FOLLOW_COR_OFF_DELAY) !=0); 
....................       int1 enable_delay = ((arg & AUX_OUT_FOLLOW_COR_ON_DELAY) !=0); 
....................       int1 disable_delay = (disable_delay_en && (AuxOutDelayCnt != 0)); 
....................       int1 pin_value; 
1DA7:  MOVLB  02
1DA8:  BCF    30.0
1DA9:  MOVF   2C,W
1DAA:  ANDLW  10
1DAB:  BTFSS  03.2
1DAC:  BSF    30.0
1DAD:  BCF    30.1
1DAE:  MOVLB  00
1DAF:  MOVF   6A,W
1DB0:  XORLW  FF
1DB1:  ANDWF  5F,W
1DB2:  MOVLB  02
1DB3:  ANDWF  2E,W
1DB4:  BTFSS  03.2
1DB5:  BSF    30.1
1DB6:  BCF    30.2
1DB7:  MOVF   2C,W
1DB8:  ANDLW  20
1DB9:  BTFSS  03.2
1DBA:  BSF    30.2
1DBB:  BCF    30.3
1DBC:  MOVF   2C,W
1DBD:  ANDLW  40
1DBE:  BTFSS  03.2
1DBF:  BSF    30.3
1DC0:  BCF    30.4
1DC1:  BTFSS  30.2
1DC2:  GOTO   5CB
1DC3:  MOVLB  01
1DC4:  MOVF   35,F
1DC5:  BTFSS  03.2
1DC6:  GOTO   5C9
1DC7:  MOVLB  02
1DC8:  GOTO   5CB
1DC9:  MOVLB  02
1DCA:  BSF    30.4
....................       if ( cor_active ) { 
1DCB:  BTFSS  30.1
1DCC:  GOTO   5E7
....................         // Activate output after several seconds of active QSO 
....................         // or keep the pin active if servicing a disable delay. 
....................         if (enable_delay) { 
1DCD:  BTFSS  30.3
1DCE:  GOTO   5E5
....................           pin_value = (QSO_Duration > QSO_DURATION_DELAY) || disable_delay; 
1DCF:  BCF    30.5
1DD0:  MOVLB  00
1DD1:  MOVF   6C,F
1DD2:  BTFSS  03.2
1DD3:  GOTO   5DC
1DD4:  MOVF   6B,W
1DD5:  SUBLW  05
1DD6:  BTFSS  03.0
1DD7:  GOTO   5DC
1DD8:  MOVLB  02
1DD9:  BTFSS  30.4
1DDA:  GOTO   5DE
1DDB:  MOVLB  00
1DDC:  MOVLB  02
1DDD:  BSF    30.5
....................           if ( pin_value ) { 
1DDE:  BTFSS  30.5
1DDF:  GOTO   5E4
....................             AuxOutDelayCnt = 60; 
1DE0:  MOVLW  3C
1DE1:  MOVLB  01
1DE2:  MOVWF  35
1DE3:  MOVLB  02
....................           } 
....................         } else { 
1DE4:  GOTO   5E6
....................           pin_value = 1; 
1DE5:  BSF    30.5
....................         } 
....................       } else { 
1DE6:  GOTO   5EA
....................         pin_value = disable_delay; 
1DE7:  BCF    30.5
1DE8:  BTFSC  30.4
1DE9:  BSF    30.5
....................       } 
....................       AuxOut[ID] = pin_value ^ invert_output; 
1DEA:  MOVLW  22
1DEB:  ADDWF  2D,W
1DEC:  MOVWF  04
1DED:  MOVLW  20
1DEE:  MOVWF  05
1DEF:  BTFSC  03.0
1DF0:  INCF   05,F
1DF1:  MOVLW  00
1DF2:  BTFSC  30.5
1DF3:  MOVLW  01
1DF4:  MOVWF  34
1DF5:  MOVLW  00
1DF6:  BTFSC  30.0
1DF7:  MOVLW  01
1DF8:  XORWF  34,W
1DF9:  MOVWF  00
....................     break; 
1DFA:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0FB7:  MOVLB  02
0FB8:  CLRF   43
0FB9:  CLRF   44
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0FBA:  MOVF   43,W
0FBB:  ADDWF  41,W
0FBC:  MOVWF  04
0FBD:  MOVLW  00
0FBE:  ADDWFC 42,W
0FBF:  MOVWF  05
0FC0:  MOVF   00,F
0FC1:  BTFSC  03.2
0FC2:  GOTO   7EC
0FC3:  MOVF   43,W
0FC4:  ADDWF  41,W
0FC5:  MOVWF  04
0FC6:  MOVLW  00
0FC7:  ADDWFC 42,W
0FC8:  MOVWF  05
0FC9:  MOVF   00,W
0FCA:  SUBLW  2F
0FCB:  BTFSC  03.0
0FCC:  GOTO   7EC
0FCD:  MOVF   43,W
0FCE:  ADDWF  41,W
0FCF:  MOVWF  04
0FD0:  MOVLW  00
0FD1:  ADDWFC 42,W
0FD2:  MOVWF  05
0FD3:  MOVF   00,W
0FD4:  SUBLW  39
0FD5:  BTFSS  03.0
0FD6:  GOTO   7EC
....................     value = (value * 10) + (str[x]-'0'); 
0FD7:  MOVF   44,W
0FD8:  MOVWF  45
0FD9:  MOVLW  0A
0FDA:  MOVWF  46
0FDB:  MOVLB  00
0FDC:  CALL   790
0FDD:  MOVF   78,W
0FDE:  MOVLB  02
0FDF:  MOVWF  45
0FE0:  MOVF   43,W
0FE1:  ADDWF  41,W
0FE2:  MOVWF  04
0FE3:  MOVLW  00
0FE4:  ADDWFC 42,W
0FE5:  MOVWF  05
0FE6:  MOVLW  30
0FE7:  SUBWF  00,W
0FE8:  ADDWF  45,W
0FE9:  MOVWF  44
....................     x++; 
0FEA:  INCF   43,F
....................   } 
0FEB:  GOTO   7BA
....................   return(value); 
0FEC:  MOVF   44,W
0FED:  MOVWF  78
.................... } // }}} 
0FEE:  MOVLB  00
0FEF:  RETURN
.................... void ExecAuxInOp(char op,char arg,char ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
1C98:  MOVLB  02
1C99:  BCF    2E.0
1C9A:  MOVLW  1F
1C9B:  ADDWF  2D,W
1C9C:  MOVWF  04
1C9D:  MOVLW  20
1C9E:  MOVWF  05
1C9F:  BTFSC  03.0
1CA0:  INCF   05,F
1CA1:  MOVF   00,F
1CA2:  BTFSS  03.2
1CA3:  BSF    2E.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   // Include arg[4] for COR4 emulation 
....................   larg = arg & 0x1F; 
1CA4:  MOVF   2C,W
1CA5:  ANDLW  1F
1CA6:  MOVWF  2F
....................   uarg = (arg & 0xF0) >> 4; 
1CA7:  MOVF   2C,W
1CA8:  ANDLW  F0
1CA9:  MOVWF  77
1CAA:  SWAPF  77,W
1CAB:  MOVWF  30
1CAC:  MOVLW  0F
1CAD:  ANDWF  30,F
....................   switch(op) { 
1CAE:  MOVLW  01
1CAF:  SUBWF  2B,W
1CB0:  ADDLW  FC
1CB1:  BTFSC  03.0
1CB2:  GOTO   4F7
1CB3:  ADDLW  04
1CB4:  MOVLB  00
1CB5:  GOTO   4FA
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
1CB6:  MOVLB  02
1CB7:  BTFSS  2E.0
1CB8:  GOTO   4BE
....................         Enable_Mask &= arg; 
1CB9:  MOVF   2C,W
1CBA:  MOVLB  00
1CBB:  ANDWF  63,F
....................       } else { // AuxIn is not enabled 
1CBC:  GOTO   4C3
1CBD:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
1CBE:  MOVF   2C,W
1CBF:  XORLW  FF
1CC0:  ANDLW  0F
1CC1:  MOVLB  00
1CC2:  IORWF  63,F
....................       } 
....................       break; 
1CC3:  MOVLB  02
1CC4:  GOTO   4F7
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
1CC5:  MOVLB  02
1CC6:  BTFSS  2E.0
1CC7:  GOTO   4CE
....................         COR_DROP_FLAG=1; 
1CC8:  MOVLB  01
1CC9:  BSF    62.0
....................         TailChar=arg; 
1CCA:  MOVLB  02
1CCB:  MOVF   2C,W
1CCC:  MOVWF  72
....................       } else { 
1CCD:  GOTO   4CF
....................         TailChar=0; 
1CCE:  CLRF   72
....................       } 
....................     break; 
1CCF:  GOTO   4F7
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
1CD0:  MOVLB  02
1CD1:  BTFSC  2E.0
1CD2:  GOTO   4D9
....................         COR_DROP_FLAG=1; 
1CD3:  MOVLB  01
1CD4:  BSF    62.0
....................         TailChar=arg; 
1CD5:  MOVLB  02
1CD6:  MOVF   2C,W
1CD7:  MOVWF  72
....................       } else { 
1CD8:  GOTO   4DA
....................         TailChar=0; 
1CD9:  CLRF   72
....................       } 
....................     break; 
1CDA:  GOTO   4F7
....................     case AUXI_EMULATE_COR: 
....................       int1 active_low = (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0; 
1CDB:  MOVLB  02
1CDC:  BCF    2E.2
1CDD:  MOVF   2C,W
1CDE:  ANDLW  20
1CDF:  BTFSS  03.2
1CE0:  BSF    2E.2
....................       tmp_bit = (active_low ^ in_bit); 
1CE1:  MOVLW  00
1CE2:  BTFSC  2E.2
1CE3:  MOVLW  01
1CE4:  MOVWF  32
1CE5:  MOVLW  00
1CE6:  BTFSC  2E.0
1CE7:  MOVLW  01
1CE8:  XORWF  32,W
1CE9:  MOVWF  78
1CEA:  BCF    2E.1
1CEB:  BTFSC  78.0
1CEC:  BSF    2E.1
....................       if ( tmp_bit ) { 
1CED:  BTFSS  2E.1
1CEE:  GOTO   4F2
....................         COR_AUX |= larg; 
1CEF:  MOVF   2F,W
1CF0:  IORWF  71,F
....................       } else { 
1CF1:  GOTO   4F5
....................         COR_AUX &= ~larg; 
1CF2:  MOVF   2F,W
1CF3:  XORLW  FF
1CF4:  ANDWF  71,F
....................       } 
....................     break; 
1CF5:  GOTO   4F7
1CF6:  MOVLB  02
....................   } 
.................... } // }}} 
1CF7:  MOVLP  18
1CF8:  MOVLB  00
1CF9:  GOTO   66C (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
1643:  MOVLB  01
1644:  CLRF   68
1645:  MOVF   68,W
1646:  SUBLW  02
1647:  BTFSS  03.0
1648:  GOTO   68A
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = ((input(AUX_IN_PIN[x])!=0 )|| (AuxIn[x]!=0)); 
1649:  MOVLW  1F
164A:  ADDWF  68,W
164B:  MOVWF  78
164C:  MOVLW  20
164D:  MOVWF  7A
164E:  BTFSC  03.0
164F:  INCF   7A,F
1650:  MOVF   78,W
1651:  MOVWF  69
1652:  MOVF   7A,W
1653:  MOVWF  6A
1654:  MOVF   68,W
1655:  MOVLP  00
1656:  MOVLB  00
1657:  CALL   03F
1658:  MOVLP  10
1659:  MOVLB  01
165A:  MOVWF  6B
165B:  MOVLB  02
165C:  MOVWF  41
165D:  MOVLW  01
165E:  MOVWF  42
165F:  CLRF   44
1660:  MOVLW  80
1661:  MOVWF  43
1662:  MOVLP  08
1663:  MOVLB  00
1664:  CALL   095
1665:  MOVLP  10
1666:  MOVLB  01
1667:  MOVF   6B,W
1668:  MOVWF  6C
1669:  CLRF   6E
166A:  CLRF   6D
166B:  MOVLB  00
166C:  GOTO   629
166D:  BTFSC  78.0
166E:  GOTO   67F
166F:  MOVLW  1C
1670:  MOVLB  01
1671:  ADDWF  68,W
1672:  MOVWF  04
1673:  MOVLW  20
1674:  MOVWF  05
1675:  BTFSC  03.0
1676:  INCF   05,F
1677:  MOVF   00,F
1678:  BTFSC  03.2
1679:  GOTO   67C
167A:  MOVLB  00
167B:  GOTO   67F
167C:  MOVLW  00
167D:  GOTO   681
167E:  MOVLB  00
167F:  MOVLW  01
1680:  MOVLB  01
1681:  MOVWF  6C
1682:  MOVF   6A,W
1683:  MOVWF  05
1684:  MOVF   69,W
1685:  MOVWF  04
1686:  MOVF   6C,W
1687:  MOVWF  00
....................   } 
1688:  INCF   68,F
1689:  GOTO   645
.................... } // }}} 
168A:  MOVLP  20
168B:  MOVLB  00
168C:  GOTO   147 (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
1D3F:  MOVLW  30
1D40:  MOVLB  01
1D41:  MOVWF  6B
1D42:  MOVWF  6C
1D43:  MOVWF  6D
1D44:  CLRF   6E
....................   char AuxOut_s[4]={'0','0','0',0}; 
1D45:  MOVWF  6F
1D46:  MOVLB  02
1D47:  MOVWF  20
1D48:  MOVWF  21
1D49:  CLRF   22
....................   char ADM[]=" ADMIN"; 
1D4A:  MOVLW  20
1D4B:  MOVWF  23
1D4C:  MOVLW  41
1D4D:  MOVWF  24
1D4E:  MOVLW  44
1D4F:  MOVWF  25
1D50:  MOVLW  4D
1D51:  MOVWF  26
1D52:  MOVLW  49
1D53:  MOVWF  27
1D54:  MOVLW  4E
1D55:  MOVWF  28
1D56:  CLRF   29
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
1D57:  MOVLB  01
1D58:  CLRF   68
1D59:  MOVF   68,W
1D5A:  SUBLW  02
1D5B:  BTFSS  03.0
1D5C:  GOTO   66F
....................     AuxOp = AuxOutOp[x]; 
1D5D:  MOVLW  33
1D5E:  ADDWF  68,W
1D5F:  MOVWF  04
1D60:  MOVLW  20
1D61:  MOVWF  05
1D62:  BTFSC  03.0
1D63:  INCF   05,F
1D64:  MOVF   00,W
1D65:  MOVWF  69
....................     AuxArg = AuxOutArg[x]; 
1D66:  MOVLW  36
1D67:  ADDWF  68,W
1D68:  MOVWF  04
1D69:  MOVLW  20
1D6A:  MOVWF  05
1D6B:  BTFSC  03.0
1D6C:  INCF   05,F
1D6D:  MOVF   00,W
1D6E:  MOVWF  6A
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
1D6F:  MOVF   69,W
1D70:  MOVLB  02
1D71:  MOVWF  2B
1D72:  MOVLB  01
1D73:  MOVF   6A,W
1D74:  MOVLB  02
1D75:  MOVWF  2C
1D76:  MOVLB  01
1D77:  MOVF   68,W
1D78:  MOVLB  02
1D79:  MOVWF  2D
....................     out_bit = (AuxOut[x])==0; 
*
1DFB:  MOVLB  02
1DFC:  BCF    2A.0
1DFD:  MOVLW  22
1DFE:  MOVLB  01
1DFF:  ADDWF  68,W
1E00:  MOVWF  04
1E01:  MOVLW  20
1E02:  MOVWF  05
1E03:  BTFSC  03.0
1E04:  INCF   05,F
1E05:  MOVF   00,F
1E06:  BTFSS  03.2
1E07:  GOTO   60B
1E08:  MOVLB  02
1E09:  BSF    2A.0
1E0A:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
1E0B:  MOVF   68,W
1E0C:  MOVLP  00
1E0D:  MOVLB  00
1E0E:  CALL   03B
1E0F:  MOVLP  18
1E10:  MOVLB  02
1E11:  MOVWF  2B
1E12:  MOVLW  00
1E13:  BTFSC  2A.0
1E14:  MOVLW  01
1E15:  MOVWF  77
1E16:  MOVF   2B,W
1E17:  MOVWF  41
1E18:  MOVF   77,W
1E19:  MOVWF  42
1E1A:  MOVLW  01
1E1B:  MOVWF  44
1E1C:  CLRF   43
1E1D:  MOVLP  08
1E1E:  MOVLB  00
1E1F:  CALL   095
1E20:  MOVLP  18
1E21:  MOVLB  02
1E22:  MOVF   2B,W
1E23:  MOVWF  41
1E24:  CLRF   42
1E25:  CLRF   44
1E26:  MOVLW  80
1E27:  MOVWF  43
1E28:  MOVLP  08
1E29:  MOVLB  00
1E2A:  CALL   095
1E2B:  MOVLP  18
....................     if(out_bit==0) { 
1E2C:  MOVLB  02
1E2D:  BTFSC  2A.0
1E2E:  GOTO   63A
....................       AuxOut_s[x]='1'; 
1E2F:  MOVLW  9F
1E30:  MOVLB  01
1E31:  ADDWF  68,W
1E32:  MOVWF  04
1E33:  MOVLW  20
1E34:  MOVWF  05
1E35:  BTFSC  03.0
1E36:  INCF   05,F
1E37:  MOVLW  31
1E38:  MOVWF  00
1E39:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
1E3A:  MOVLW  39
1E3B:  MOVLB  01
1E3C:  ADDWF  68,W
1E3D:  MOVWF  04
1E3E:  MOVLW  20
1E3F:  MOVWF  05
1E40:  BTFSC  03.0
1E41:  INCF   05,F
1E42:  MOVF   00,W
1E43:  MOVWF  69
....................     AuxArg = AuxInArg[x]; 
1E44:  MOVLW  3C
1E45:  ADDWF  68,W
1E46:  MOVWF  04
1E47:  MOVLW  20
1E48:  MOVWF  05
1E49:  BTFSC  03.0
1E4A:  INCF   05,F
1E4B:  MOVF   00,W
1E4C:  MOVWF  6A
....................     if(AuxInSW[x]==1) { 
1E4D:  MOVLW  1F
1E4E:  ADDWF  68,W
1E4F:  MOVWF  04
1E50:  MOVLW  20
1E51:  MOVWF  05
1E52:  BTFSC  03.0
1E53:  INCF   05,F
1E54:  DECFSZ 00,W
1E55:  GOTO   65F
....................       AuxIn_s[x]='1'; 
1E56:  MOVLW  9B
1E57:  ADDWF  68,W
1E58:  MOVWF  04
1E59:  MOVLW  20
1E5A:  MOVWF  05
1E5B:  BTFSC  03.0
1E5C:  INCF   05,F
1E5D:  MOVLW  31
1E5E:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
1E5F:  MOVF   69,W
1E60:  MOVLB  02
1E61:  MOVWF  2B
1E62:  MOVLB  01
1E63:  MOVF   6A,W
1E64:  MOVLB  02
1E65:  MOVWF  2C
1E66:  MOVLB  01
1E67:  MOVF   68,W
1E68:  MOVLB  02
1E69:  MOVWF  2D
1E6A:  MOVLB  00
1E6B:  GOTO   498
....................     // }}} 
....................   } 
1E6C:  MOVLB  01
1E6D:  INCF   68,F
1E6E:  GOTO   559
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
1E6F:  MOVLW  20
1E70:  MOVWF  67
1E71:  MOVLW  7A
1E72:  MOVWF  66
1E73:  MOVLW  49
1E74:  MOVLB  02
1E75:  MOVWF  51
1E76:  MOVLP  00
1E77:  MOVLB  00
1E78:  CALL   7DF
1E79:  MOVLP  18
1E7A:  MOVLW  3A
1E7B:  MOVLB  02
1E7C:  MOVWF  51
1E7D:  MOVLP  00
1E7E:  MOVLB  00
1E7F:  CALL   7DF
1E80:  MOVLP  18
1E81:  MOVLW  20
1E82:  MOVWF  05
1E83:  MOVLW  9B
1E84:  MOVWF  04
1E85:  MOVLP  08
1E86:  CALL   10E
1E87:  MOVLP  18
1E88:  MOVLW  20
1E89:  MOVLB  02
1E8A:  MOVWF  51
1E8B:  MOVLP  00
1E8C:  MOVLB  00
1E8D:  CALL   7DF
1E8E:  MOVLP  18
1E8F:  MOVLW  4F
1E90:  MOVLB  02
1E91:  MOVWF  51
1E92:  MOVLP  00
1E93:  MOVLB  00
1E94:  CALL   7DF
1E95:  MOVLP  18
1E96:  MOVLW  3A
1E97:  MOVLB  02
1E98:  MOVWF  51
1E99:  MOVLP  00
1E9A:  MOVLB  00
1E9B:  CALL   7DF
1E9C:  MOVLP  18
1E9D:  MOVLW  20
1E9E:  MOVWF  05
1E9F:  MOVLW  9F
1EA0:  MOVWF  04
1EA1:  MOVLP  08
1EA2:  CALL   10E
1EA3:  MOVLP  18
....................   if ( AdminMode ) { 
1EA4:  MOVLB  01
1EA5:  BTFSS  65.1
1EA6:  GOTO   6B3
....................     strcat(LCD_str,ADM); 
1EA7:  MOVLW  20
1EA8:  MOVLB  02
1EA9:  MOVWF  2C
1EAA:  MOVLW  7A
1EAB:  MOVWF  2B
1EAC:  MOVLW  20
1EAD:  MOVWF  2E
1EAE:  MOVLW  A3
1EAF:  MOVWF  2D
1EB0:  MOVLB  00
1EB1:  CALL   506
1EB2:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
1EB3:  MOVLW  03
1EB4:  MOVLB  02
1EB5:  MOVWF  4B
1EB6:  MOVLW  20
1EB7:  MOVWF  4D
1EB8:  MOVLW  7A
1EB9:  MOVWF  4C
1EBA:  MOVLP  08
1EBB:  MOVLB  00
1EBC:  CALL   154
1EBD:  MOVLP  18
.................... } // }}} 
1EBE:  MOVLP  20
1EBF:  GOTO   169 (RETURN)
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
111D:  MOVLW  01
111E:  MOVLB  02
111F:  MOVWF  2F
1120:  MOVLP  08
1121:  MOVLB  00
1122:  CALL   37C
1123:  MOVLP  10
....................   delay_ms(1000); 
1124:  MOVLW  04
1125:  MOVLB  02
1126:  MOVWF  2F
1127:  MOVLW  FA
1128:  MOVWF  4B
1129:  MOVLP  00
112A:  MOVLB  00
112B:  CALL   785
112C:  MOVLP  10
112D:  MOVLB  02
112E:  DECFSZ 2F,F
112F:  GOTO   127
....................   for(x=0;x<6;x++) { 
1130:  CLRF   2D
1131:  MOVF   2D,W
1132:  SUBLW  05
1133:  BTFSS  03.0
1134:  GOTO   151
....................     mchar=Morse[x]; 
1135:  MOVLW  2D
1136:  ADDWF  2D,W
1137:  MOVWF  04
1138:  MOVLW  20
1139:  MOVWF  05
113A:  BTFSC  03.0
113B:  INCF   05,F
113C:  MOVF   00,W
113D:  MOVWF  2E
....................     morse(mchar); 
113E:  MOVF   2E,W
113F:  MOVWF  40
1140:  MOVLP  08
1141:  MOVLB  00
1142:  CALL   038
1143:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
1144:  MOVLB  01
1145:  CLRF   34
1146:  MOVLW  06
1147:  MOVWF  33
....................     while(aux_timer) { 
1148:  MOVF   33,W
1149:  IORWF  34,W
114A:  BTFSC  03.2
114B:  GOTO   14E
....................       delay_cycles(1); 
114C:  NOP
....................     } 
114D:  GOTO   148
....................   } 
114E:  MOVLB  02
114F:  INCF   2D,F
1150:  GOTO   131
....................   delay_ms(1000); 
1151:  MOVLW  04
1152:  MOVWF  2F
1153:  MOVLW  FA
1154:  MOVWF  4B
1155:  MOVLP  00
1156:  MOVLB  00
1157:  CALL   785
1158:  MOVLP  10
1159:  MOVLB  02
115A:  DECFSZ 2F,F
115B:  GOTO   153
....................   PROCESS_COR_FLAG=1; 
115C:  BSF    7D.1
.................... } // }}} 
115D:  MOVLB  00
115E:  RETURN
.................... void main (void) { // {{{ 
*
20FF:  CLRF   05
2100:  CLRF   04
2101:  MOVLW  1F
2102:  ANDWF  03,F
2103:  MOVLW  72
2104:  MOVLB  01
2105:  MOVWF  19
2106:  BSF    0E.3
2107:  BSF    0E.4
2108:  MOVLB  04
2109:  BCF    17.0
210A:  BCF    17.1
210B:  BCF    17.3
210C:  MOVLW  13
210D:  MOVWF  12
210E:  MOVLW  28
210F:  MOVWF  15
2110:  BSF    14.7
2111:  BCF    14.6
2112:  MOVLW  0C
2113:  MOVLB  03
2114:  MOVWF  1B
2115:  MOVLW  A2
2116:  MOVWF  1E
2117:  MOVLW  90
2118:  MOVWF  1D
2119:  MOVLB  01
211A:  BSF    65.3
211B:  CLRF   67
211C:  CLRF   66
211D:  MOVLB  0F
211E:  CLRF   11
211F:  CLRF   12
2120:  CLRF   18
2121:  CLRF   19
2122:  CLRF   1A
2123:  MOVLB  03
2124:  CLRF   0C
2125:  CLRF   0D
2126:  CLRF   0F
2127:  CLRF   10
2128:  MOVLB  02
2129:  CLRF   12
212A:  CLRF   11
212B:  CLRF   14
212C:  CLRF   13
....................   initialize(); 
*
2130:  MOVLP  08
2131:  GOTO   510
2132:  MOVLP  20
.................... #ignore_warnings 203 
....................   while(1) { // {{{ 
.................... #ignore_warnings none 
....................     restart_wdt(); 
2133:  CLRWDT
....................   process_buttons(); 
2134:  MOVLP  08
2135:  GOTO   5E9
2136:  MOVLP  20
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "\r" or "+" or "-" is received. 
....................     if ( sBufferFlag ) { 
2137:  BTFSS  7D.0
2138:  GOTO   140
....................       process_sBuffer(); 
2139:  MOVLP  18
213A:  GOTO   000
213B:  MOVLP  20
....................       clear_sBuffer(); 
213C:  MOVLP  00
213D:  CALL   444
213E:  MOVLP  20
....................       sBufferFlag=0; 
213F:  BCF    7D.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
2140:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
2141:  MOVLB  01
2142:  BTFSS  62.1
2143:  GOTO   14B
....................       update_aux_in(); 
2144:  MOVLP  10
2145:  MOVLB  00
2146:  GOTO   643
2147:  MOVLP  20
....................       AUX_IN_FLAG=0; 
2148:  MOVLB  01
2149:  BCF    62.1
....................       AUX_OUT_FLAG=1; 
214A:  BSF    62.2
....................     } 
....................     do_delay_counters(); 
214B:  MOVLP  10
214C:  MOVLB  00
214D:  GOTO   68D
214E:  MOVLP  20
....................     restart_wdt(); 
214F:  CLRWDT
....................     if ( COR_IN_FLAG ) { 
2150:  BTFSS  7D.2
2151:  GOTO   159
....................       PROCESS_COR_FLAG = read_cor_in_ports(); 
2152:  MOVLP  10
2153:  GOTO   72D
2154:  MOVLP  20
2155:  BCF    7D.1
2156:  BTFSC  78.0
2157:  BSF    7D.1
....................       COR_IN_FLAG = 0; 
2158:  BCF    7D.2
....................     } 
....................     if ( PROCESS_COR_FLAG ) { 
2159:  BTFSS  7D.1
215A:  GOTO   163
....................       process_cor(); 
215B:  MOVLP  10
215C:  GOTO   74D
215D:  MOVLP  20
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       AUX_OUT_FLAG=1; 
215E:  MOVLB  01
215F:  BSF    62.2
....................       PROCESS_COR_FLAG=0; 
2160:  BCF    7D.1
....................       restart_wdt(); 
2161:  CLRWDT
2162:  MOVLB  00
....................     } 
....................     if ( AUX_OUT_FLAG ) { 
2163:  MOVLB  01
2164:  BTFSS  62.2
2165:  GOTO   16C
....................       update_aux_out();  
2166:  MOVLP  18
2167:  MOVLB  00
2168:  GOTO   53F
2169:  MOVLP  20
....................       AUX_OUT_FLAG=0; 
216A:  MOVLB  01
216B:  BCF    62.2
....................     } 
....................     if ( DTMF_INTERRUPT_FLAG ) { 
216C:  BTFSS  62.6
216D:  GOTO   174
....................       // Extract data from DTMF device 
....................       process_dtmf_interrupt(); 
216E:  MOVLP  18
216F:  MOVLB  00
2170:  GOTO   6C0
2171:  MOVLP  20
....................       DTMF_INTERRUPT_FLAG=0; 
2172:  MOVLB  01
2173:  BCF    62.6
....................     } 
....................     if ( DTMF_IN_FLAG ) { 
2174:  BTFSS  62.5
2175:  GOTO   17D
....................       print_dtmf_info(); 
2176:  MOVLP  18
2177:  MOVLB  00
2178:  GOTO   712
2179:  MOVLP  20
....................       DTMF_IN_FLAG=0; 
217A:  MOVLB  01
217B:  BCF    62.5
....................       restart_wdt(); 
217C:  CLRWDT
....................     } 
....................     if ( DTMF_FLAG ) { 
217D:  BTFSS  62.4
217E:  GOTO   184
....................       process_dtmf(); 
217F:  MOVLB  00
2180:  GOTO   000
....................       DTMF_FLAG=0; 
2181:  MOVLB  01
2182:  BCF    62.4
....................     restart_wdt(); 
2183:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
2184:  BTFSS  62.7
2185:  GOTO   18C
....................       clear_dtmf_array(); 
2186:  MOVLP  10
2187:  MOVLB  00
2188:  GOTO   7D0
2189:  MOVLP  20
....................       CLEAR_DTMF_FLAG=0; 
218A:  MOVLB  01
218B:  BCF    62.7
....................     } 
....................     if ( PROMPT_FLAG ) { 
218C:  BTFSS  65.0
218D:  GOTO   195
....................       prompt(); 
218E:  MOVLP  10
218F:  MOVLB  00
2190:  CALL   0F5
2191:  MOVLP  20
....................       PROMPT_FLAG=0; 
2192:  MOVLB  01
2193:  BCF    65.0
....................     restart_wdt(); 
2194:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
2195:  MOVLB  00
2196:  GOTO   133
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0BA9:  CLRWDT
*
2197:  SLEEP
....................   delay_ms(1000); 
*
0BAA:  MOVLW  04
0BAB:  MOVLB  02
0BAC:  MOVWF  40
0BAD:  MOVLW  FA
0BAE:  MOVWF  4B
0BAF:  MOVLP  00
0BB0:  MOVLB  00
0BB1:  CALL   785
0BB2:  MOVLP  08
0BB3:  MOVLB  02
0BB4:  DECFSZ 40,F
0BB5:  GOTO   3AD
....................   if ( ConfirmChar!=0 ) { 
0BB6:  MOVF   73,F
0BB7:  BTFSC  03.2
0BB8:  GOTO   3CB
....................     morse(ConfirmChar); 
0BB9:  MOVF   73,W
0BBA:  MOVWF  40
0BBB:  MOVLB  00
0BBC:  CALL   038
....................     ConfirmChar=0; 
0BBD:  CLRF   73
....................     restart_wdt(); 
0BBE:  CLRWDT
....................     delay_ms(500); 
0BBF:  MOVLW  02
0BC0:  MOVLB  02
0BC1:  MOVWF  40
0BC2:  MOVLW  FA
0BC3:  MOVWF  4B
0BC4:  MOVLP  00
0BC5:  MOVLB  00
0BC6:  CALL   785
0BC7:  MOVLP  08
0BC8:  MOVLB  02
0BC9:  DECFSZ 40,F
0BCA:  GOTO   3C2
....................   } 
....................   if (TailChar != 0) { 
0BCB:  MOVF   72,F
0BCC:  BTFSC  03.2
0BCD:  GOTO   3E0
....................     morse(TailChar); 
0BCE:  MOVF   72,W
0BCF:  MOVWF  40
0BD0:  MOVLB  00
0BD1:  CALL   038
....................     TailChar=0; 
0BD2:  CLRF   72
....................     restart_wdt(); 
0BD3:  CLRWDT
....................     delay_ms(500); 
0BD4:  MOVLW  02
0BD5:  MOVLB  02
0BD6:  MOVWF  40
0BD7:  MOVLW  FA
0BD8:  MOVWF  4B
0BD9:  MOVLP  00
0BDA:  MOVLB  00
0BDB:  CALL   785
0BDC:  MOVLP  08
0BDD:  MOVLB  02
0BDE:  DECFSZ 40,F
0BDF:  GOTO   3D7
....................   } 
....................   restart_wdt(); 
0BE0:  CLRWDT
0BE1:  MOVLB  01
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
07EE:  MOVLB  01
07EF:  BTFSS  65.1
07F0:  GOTO   7F3
....................     admin_timer = ADMIN_TIMEOUT; 
07F1:  MOVLW  FF
07F2:  MOVWF  7E
....................   } 
....................   return(AdminMode||rs232_mode); 
07F3:  BTFSC  65.1
07F4:  GOTO   7F9
07F5:  BTFSC  65.2
07F6:  GOTO   7F9
07F7:  MOVLW  00
07F8:  GOTO   7FA
07F9:  MOVLW  01
07FA:  MOVWF  78
.................... } // }}} 
07FB:  MOVLB  00
07FC:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0CBE:  MOVLB  01
0CBF:  BCF    65.1
0CC0:  MOVLB  02
0CC1:  MOVF   42,F
0CC2:  BTFSC  03.2
0CC3:  GOTO   4C7
0CC4:  MOVLB  01
0CC5:  BSF    65.1
0CC6:  MOVLB  02
....................   if (AdminMode) { 
0CC7:  MOVLB  01
0CC8:  BTFSS  65.1
0CC9:  GOTO   4CF
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0CCA:  MOVLW  0A
0CCB:  MOVWF  73
....................     admin_timer = ADMIN_TIMEOUT; 
0CCC:  MOVLW  FF
0CCD:  MOVWF  7E
....................   } else { 
0CCE:  GOTO   4D1
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0CCF:  MOVLW  18
0CD0:  MOVWF  73
....................   }  
.................... } // }}} 
0CD1:  MOVLB  00
0CD2:  RETURN
.................... // string matchnig function with case insensitive match. 
.................... int1 my_stricmp(char *s1,char *s2) { // {{{ 
*
1000:  MOVLB  02
1001:  CLRF   45
....................   unsigned int x=0; 
....................   const char AMASK=0xDF; 
....................   while((AMASK&s1[x])==(AMASK&s2[x])) { 
1002:  MOVF   45,W
1003:  ADDWF  41,W
1004:  MOVWF  04
1005:  MOVLW  00
1006:  ADDWFC 42,W
1007:  MOVWF  05
1008:  MOVF   00,W
1009:  ANDLW  DF
100A:  MOVWF  46
100B:  MOVF   45,W
100C:  ADDWF  43,W
100D:  MOVWF  04
100E:  MOVLW  00
100F:  ADDWFC 44,W
1010:  MOVWF  05
1011:  MOVF   00,W
1012:  ANDLW  DF
1013:  SUBWF  46,W
1014:  BTFSS  03.2
1015:  GOTO   024
....................     if(s1[x]==0) { 
1016:  MOVF   45,W
1017:  ADDWF  41,W
1018:  MOVWF  04
1019:  MOVLW  00
101A:  ADDWFC 42,W
101B:  MOVWF  05
101C:  MOVF   00,F
101D:  BTFSS  03.2
101E:  GOTO   022
....................       return 0; 
101F:  MOVLW  00
1020:  MOVWF  78
1021:  GOTO   026
....................     } 
....................     x++; 
1022:  INCF   45,F
....................   } 
1023:  GOTO   002
....................   // Strings don't match. Return 1. 
....................   return 1; 
1024:  MOVLW  01
1025:  MOVWF  78
.................... } // }}} 
1026:  MOVLB  00
1027:  RETURN
.................... // Fetches data from MC8888 device upon interrupt 
.................... void process_dtmf_interrupt(void) { // {{{ 
....................   int value,dtmf_status; 
....................   dtmf_status = dtmf_read(CONTROL_REG); 
*
1EC0:  MOVLW  01
1EC1:  MOVLB  02
1EC2:  MOVWF  3C
1EC3:  MOVLP  00
1EC4:  MOVLB  00
1EC5:  CALL   634
1EC6:  MOVLP  18
1EC7:  MOVF   78,W
1EC8:  MOVLB  01
1EC9:  MOVWF  69
....................   if ( dtmf_status & DTMF_BUFFER_FULL) { 
1ECA:  BTFSS  69.2
1ECB:  GOTO   70F
....................     value=dtmf_read(DATA_REG); 
1ECC:  MOVLB  02
1ECD:  CLRF   3C
1ECE:  MOVLP  00
1ECF:  MOVLB  00
1ED0:  CALL   634
1ED1:  MOVLP  18
1ED2:  MOVF   78,W
1ED3:  MOVLB  01
1ED4:  MOVWF  68
....................     DTMF_IN_FLAG=1; 
1ED5:  BSF    62.5
....................     if ( value == dd ) { 
1ED6:  MOVF   68,F
1ED7:  BTFSS  03.2
1ED8:  GOTO   6DC
....................       value=d0; 
1ED9:  MOVLW  0A
1EDA:  MOVWF  68
....................     } else if ( value == d0 ) { 
1EDB:  GOTO   6E0
1EDC:  MOVF   68,W
1EDD:  SUBLW  0A
1EDE:  BTFSC  03.2
....................       value=dd; 
1EDF:  CLRF   68
....................     } 
....................     if ( value == ds ) { 
1EE0:  MOVF   68,W
1EE1:  SUBLW  0B
1EE2:  BTFSC  03.2
....................       CLEAR_DTMF_FLAG=1; 
1EE3:  BSF    62.7
....................     } 
....................     // Check for '#' 
....................     if ( value == dp ) { 
1EE4:  MOVF   68,W
1EE5:  SUBLW  0C
1EE6:  BTFSS  03.2
1EE7:  GOTO   6F0
....................       DTMF_FLAG = 1; 
1EE8:  BSF    62.4
....................       DTMF_ptr->Last=1; 
1EE9:  MOVF   40,W
1EEA:  MOVWF  04
1EEB:  MOVF   41,W
1EEC:  MOVWF  05
1EED:  ADDFSR 00,FSR0
1EEE:  BSF    00.5
....................     } else { 
1EEF:  GOTO   70F
....................       if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
1EF0:  MOVF   41,W
1EF1:  SUBLW  20
1EF2:  BTFSS  03.0
1EF3:  GOTO   70F
1EF4:  BTFSS  03.2
1EF5:  GOTO   6FA
1EF6:  MOVF   40,W
1EF7:  SUBLW  6F
1EF8:  BTFSS  03.0
1EF9:  GOTO   70F
....................         DTMF_ptr->Key=value; 
1EFA:  MOVF   40,W
1EFB:  MOVWF  04
1EFC:  MOVF   41,W
1EFD:  MOVWF  05
1EFE:  ADDFSR 00,FSR0
1EFF:  MOVF   68,W
1F00:  ANDLW  0F
1F01:  MOVWF  77
1F02:  MOVLW  F0
1F03:  ANDWF  00,W
1F04:  IORWF  77,W
1F05:  MOVWF  00
....................         DTMF_ptr->Strobe=1; 
1F06:  MOVF   40,W
1F07:  MOVWF  04
1F08:  MOVF   41,W
1F09:  MOVWF  05
1F0A:  ADDFSR 00,FSR0
1F0B:  BSF    00.4
....................         DTMF_ptr++; 
1F0C:  INCF   40,F
1F0D:  BTFSC  03.2
1F0E:  INCF   41,F
....................       } 
....................     } 
....................   } 
.................... } // }}} 
1F0F:  MOVLP  20
1F10:  MOVLB  00
1F11:  GOTO   171 (RETURN)
.................... void init_lcd(void) { // {{{ 
.................... #define INIT 0x18 
.................... #define MODE_SET 0x1C 
.................... #define ENABLE 0x04 
....................   i2c_start(); 
*
0CD3:  MOVLB  04
0CD4:  BSF    16.0
0CD5:  BTFSC  16.0
0CD6:  GOTO   4D5
....................   i2c_write(LCD_I2C_ADD<<1); 
0CD7:  MOVLW  4E
0CD8:  MOVLB  02
0CD9:  MOVWF  56
0CDA:  MOVLP  00
0CDB:  MOVLB  00
0CDC:  CALL   64D
0CDD:  MOVLP  08
....................   // Function set 
....................   // Initialize in 8-bit mode first for 3 clock cycles 
....................   lcd_strobe(0x30);lcd_strobe(0x30);lcd_strobe(0x30); 
0CDE:  MOVLW  30
0CDF:  MOVLB  02
0CE0:  MOVWF  54
0CE1:  MOVLB  00
0CE2:  CALL   125
0CE3:  MOVLW  30
0CE4:  MOVLB  02
0CE5:  MOVWF  54
0CE6:  MOVLB  00
0CE7:  CALL   125
0CE8:  MOVLW  30
0CE9:  MOVLB  02
0CEA:  MOVWF  54
0CEB:  MOVLB  00
0CEC:  CALL   125
....................   // Init 4-bit interface mode 
....................   lcd_strobe(0x20); 
0CED:  MOVLW  20
0CEE:  MOVLB  02
0CEF:  MOVWF  54
0CF0:  MOVLB  00
0CF1:  CALL   125
....................   lcd_write(0,0x2C); 
0CF2:  MOVLB  02
0CF3:  CLRF   50
0CF4:  MOVLW  2C
0CF5:  MOVWF  51
0CF6:  MOVLB  00
0CF7:  CALL   138
....................   // Display On/Off, Cursor off 
....................   lcd_write(0,0x0C); 
0CF8:  MOVLB  02
0CF9:  CLRF   50
0CFA:  MOVLW  0C
0CFB:  MOVWF  51
0CFC:  MOVLB  00
0CFD:  CALL   138
....................   // Display clear 
....................   lcd_write(0,0x01); 
0CFE:  MOVLB  02
0CFF:  CLRF   50
0D00:  MOVLW  01
0D01:  MOVWF  51
0D02:  MOVLB  00
0D03:  CALL   138
....................   // Entry mode set 
....................   lcd_write(0,0x04); 
0D04:  MOVLB  02
0D05:  CLRF   50
0D06:  MOVLW  04
0D07:  MOVWF  51
0D08:  MOVLB  00
0D09:  CALL   138
....................   i2c_stop(); 
0D0A:  MOVLB  04
0D0B:  BSF    16.2
0D0C:  BTFSC  16.2
0D0D:  GOTO   50C
.................... } // }}} 
0D0E:  MOVLB  00
0D0F:  RETURN
.................... void do_delay_counters(void) { 
....................   // Second Flag {{{ 
....................   if ( SECOND_FLAG ) { 
*
168D:  BTFSS  7D.5
168E:  GOTO   6F1
....................     if ((COR_IN_EFFECTIVE != 0x00) && (QSO_Duration != 0xFFFF )) { 
168F:  MOVF   61,F
1690:  BTFSC  03.2
1691:  GOTO   69A
1692:  INCFSZ 6B,W
1693:  GOTO   697
1694:  INCFSZ 6C,W
1695:  GOTO   697
1696:  GOTO   69A
....................       QSO_Duration++;  
1697:  INCF   6B,F
1698:  BTFSC  03.2
1699:  INCF   6C,F
....................     } 
....................     AUX_OUT_FLAG=1; 
169A:  MOVLB  01
169B:  BSF    62.2
....................     // Time Out PTT {{{ 
....................     if ( (TOT_Min > 0) && (QSO_Duration >= (TOT_Min*60))) { 
169C:  MOVLB  00
169D:  MOVF   68,F
169E:  BTFSS  03.2
169F:  GOTO   6A3
16A0:  MOVF   69,F
16A1:  BTFSC  03.2
16A2:  GOTO   6D4
16A3:  MOVF   69,W
16A4:  MOVLB  02
16A5:  MOVWF  3F
16A6:  MOVLB  00
16A7:  MOVF   68,W
16A8:  MOVLB  02
16A9:  MOVWF  3E
16AA:  CLRF   41
16AB:  MOVLW  3C
16AC:  MOVWF  40
16AD:  MOVLB  00
16AE:  CALL   028
16AF:  MOVF   79,W
16B0:  MOVWF  7A
16B1:  MOVF   7A,W
16B2:  SUBWF  6C,W
16B3:  BTFSS  03.0
16B4:  GOTO   6D4
16B5:  BTFSS  03.2
16B6:  GOTO   6BB
16B7:  MOVF   78,W
16B8:  SUBWF  6B,W
16B9:  BTFSS  03.0
16BA:  GOTO   6D4
....................       if ( TOT_FLAG_Mask == 0 ) { 
16BB:  MOVF   6A,F
16BC:  BTFSS  03.2
16BD:  GOTO   6D2
....................         crlf(); 
16BE:  MOVLP  00
16BF:  CALL   45E
16C0:  MOVLP  10
....................         printf("# PTT Timeout!\n"); 
16C1:  MOVLW  35
16C2:  MOVLB  03
16C3:  MOVWF  11
16C4:  MOVLW  04
16C5:  MOVWF  12
16C6:  MOVLP  00
16C7:  MOVLB  00
16C8:  CALL   463
16C9:  MOVLP  10
....................         PROMPT_FLAG=1; 
16CA:  MOVLB  01
16CB:  BSF    65.0
....................         update_ptt(0); 
16CC:  MOVLB  02
16CD:  CLRF   2F
16CE:  MOVLP  08
16CF:  MOVLB  00
16D0:  CALL   37C
16D1:  MOVLP  10
....................       } 
....................       TOT_FLAG_Mask=COR_IN_EFFECTIVE; 
16D2:  MOVF   61,W
16D3:  MOVWF  6A
....................     } 
....................     // }}} 
....................     // AuxOutDelayCnt {{{ 
....................     if ( AuxOutDelayCnt ) { 
16D4:  MOVLB  01
16D5:  MOVF   35,F
16D6:  BTFSS  03.2
....................       AuxOutDelayCnt--; 
16D7:  DECF   35,F
....................     } 
....................     // }}} 
....................     // Admin mode timeout {{{ 
....................     if ( admin_timer ) { 
16D8:  MOVF   7E,F
16D9:  BTFSC  03.2
16DA:  GOTO   6DD
....................       admin_timer--; 
16DB:  DECF   7E,F
....................     } else { 
16DC:  GOTO   6E6
....................       // Exit admin mode. 
....................       if ( AdminMode ) { 
16DD:  BTFSS  65.1
16DE:  GOTO   6E6
....................         set_admin_mode(0); 
16DF:  MOVLB  02
16E0:  CLRF   42
16E1:  MOVLP  08
16E2:  MOVLB  00
16E3:  CALL   4BE
16E4:  MOVLP  10
16E5:  MOVLB  01
....................       } 
....................     } 
....................     // }}} 
....................     restart_wdt(); 
16E6:  CLRWDT
....................     if ( SecondCounter ) { 
16E7:  MOVF   63,F
16E8:  BTFSC  03.2
16E9:  GOTO   6EC
....................       SecondCounter--; 
16EA:  DECF   63,F
....................     } else { 
16EB:  GOTO   6EF
....................       SecondCounter=SEC_COUNTER; 
16EC:  MOVLW  3B
16ED:  MOVWF  63
....................       MINUTE_FLAG = 1; 
16EE:  BSF    7D.6
....................     } 
....................     SECOND_FLAG=0; 
16EF:  BCF    7D.5
16F0:  MOVLB  00
....................   } 
....................   // Second Flag }}} 
....................   // Minute flag {{{ 
....................   if ( MINUTE_FLAG ) { 
16F1:  BTFSS  7D.6
16F2:  GOTO   713
....................     if ( MinuteCounter ) { 
16F3:  MOVLB  01
16F4:  MOVF   64,F
16F5:  BTFSC  03.2
16F6:  GOTO   6F9
....................       MinuteCounter--; 
16F7:  DECF   64,F
....................     } else { 
16F8:  GOTO   6FC
....................       THIRTY_MIN_FLAG=1; 
16F9:  BSF    7D.7
....................       MinuteCounter = MIN_COUNTER; 
16FA:  MOVLW  1D
16FB:  MOVWF  64
....................     } 
....................     MINUTE_FLAG = 0; 
16FC:  BCF    7D.6
....................     // Link timeout timer {{{ 
....................     if ( Link_TOT != 0 ) { 
16FD:  MOVLB  00
16FE:  MOVF   6D,F
16FF:  BTFSC  03.2
1700:  GOTO   713
....................       if ( LinkDurationTimer ) { 
1701:  MOVF   6E,F
1702:  BTFSC  03.2
1703:  GOTO   706
....................         LinkDurationTimer--; 
1704:  DECF   6E,F
....................       } else { 
1705:  GOTO   713
....................         // Disable Link 
....................         crlf(); 
1706:  MOVLP  00
1707:  CALL   45E
1708:  MOVLP  10
....................         printf("# Link TOT!\n"); 
1709:  MOVLW  3D
170A:  MOVLB  03
170B:  MOVWF  11
170C:  MOVLW  04
170D:  MOVWF  12
170E:  MOVLP  00
170F:  MOVLB  00
1710:  CALL   463
1711:  MOVLP  10
....................         Enable&=0xFE; 
1712:  BCF    62.0
....................       } 
....................     } 
....................     // Link timeout timer }}} 
....................   } 
....................   // Minute flag }}} 
....................   if ( THIRTY_MIN_FLAG ) { // {{{ 
1713:  BTFSS  7D.7
1714:  GOTO   72B
....................     if ( (TXSiteID&0x03) !=0 ) { 
1715:  MOVF   66,W
1716:  ANDLW  03
1717:  BTFSC  03.2
1718:  GOTO   72A
....................       // Transmit Site ID every 30 mins when: 
....................       // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................       // E = Transmit every 30 mins 
....................       // M = Transmit only if EnableMask is off 
....................       if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
1719:  MOVF   66,W
171A:  ANDLW  01
171B:  BTFSS  03.2
171C:  GOTO   729
171D:  MOVF   66,W
171E:  ANDLW  02
171F:  BTFSC  03.2
1720:  GOTO   72A
1721:  SWAPF  66,W
1722:  MOVWF  77
1723:  MOVLW  0F
1724:  ANDWF  77,F
1725:  MOVF   77,W
1726:  ANDLW  0F
1727:  ANDWF  62,W
1728:  BTFSC  03.2
....................         send_morse_id(); 
1729:  CALL   11D
....................       } 
....................     } 
....................     THIRTY_MIN_FLAG=0; 
172A:  BCF    7D.7
....................   } // }}} 
.................... } 
172B:  MOVLP  20
172C:  GOTO   14E (RETURN)
....................  
.................... void crlf(void) { // {{{ 
....................   putc('\n'); 
*
045E:  MOVLW  0A
045F:  CALL   2F0
....................   putc('\r'); 
0460:  MOVLW  0D
0461:  CALL   2F0
.................... } // }}} 
0462:  RETURN
....................  
.................... void process_buttons(void) { // {{{ 
.................... #ifdef BUTTON_STATES 
....................   char enter_b,select_b; 
....................   unsigned _cor_in; 
....................   unsigned int pot_value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
0DE9:  MOVLB  01
0DEA:  MOVF   30,W
0DEB:  ANDLW  03
0DEC:  MOVWF  6C
....................   // Process Enter / select buttons {{{ 
....................   _cor_in = (COR_IN | COR_EMUL ) & 0x0F; 
0DED:  MOVLB  00
0DEE:  MOVF   60,W
0DEF:  IORWF  6F,W
0DF0:  ANDLW  0F
0DF1:  MOVLB  01
0DF2:  MOVWF  6A
....................   if ( input(ENTER_BUTTON)==0 ) { 
0DF3:  BSF    0C.7
0DF4:  MOVLB  00
0DF5:  BTFSC  0C.7
0DF6:  GOTO   603
....................     ENTER_PRESSED = (enter_b == DEBOUNCE_COUNT); 
0DF7:  BCF    7D.3
0DF8:  MOVLB  01
0DF9:  MOVF   68,W
0DFA:  SUBLW  08
0DFB:  BTFSC  03.2
0DFC:  BSF    7D.3
....................     if ( enter_b < DEBOUNCE_COUNT+ 1 ) { 
0DFD:  MOVF   68,W
0DFE:  SUBLW  08
0DFF:  BTFSC  03.0
....................       enter_b++;  
0E00:  INCF   68,F
....................     } 
....................   } else { 
0E01:  GOTO   606
0E02:  MOVLB  00
....................     enter_b = 0; 
0E03:  MOVLB  01
0E04:  CLRF   68
....................     ENTER_PRESSED = 0; 
0E05:  BCF    7D.3
....................   } 
....................   if ( input(SELECT_BUTTON)==0 ) { 
0E06:  MOVLB  00
0E07:  BTFSC  10.3
0E08:  GOTO   615
....................     SELECT_PRESSED = (select_b == DEBOUNCE_COUNT); 
0E09:  BCF    7D.4
0E0A:  MOVLB  01
0E0B:  MOVF   69,W
0E0C:  SUBLW  08
0E0D:  BTFSC  03.2
0E0E:  BSF    7D.4
....................     if ( select_b < DEBOUNCE_COUNT + 1 ) { 
0E0F:  MOVF   69,W
0E10:  SUBLW  08
0E11:  BTFSC  03.0
....................       select_b++; 
0E12:  INCF   69,F
....................     } 
....................   } else { 
0E13:  GOTO   618
0E14:  MOVLB  00
....................     select_b = 0; 
0E15:  MOVLB  01
0E16:  CLRF   69
....................     SELECT_PRESSED = 0; 
0E17:  BCF    7D.4
....................   } 
....................   // Define Button States 
....................   // IDLE + ENTER --> TRIM 
....................   // TRIM + ENTER --> Exit 
....................   // TRIM + SELECT --> NextPot 
....................   switch (button_state) { 
0E18:  MOVF   61,W
0E19:  XORLW  00
0E1A:  MOVLB  00
0E1B:  BTFSC  03.2
0E1C:  GOTO   624
0E1D:  XORLW  10
0E1E:  BTFSC  03.2
0E1F:  GOTO   62B
0E20:  XORLW  1F
0E21:  BTFSC  03.2
0E22:  GOTO   63B
0E23:  GOTO   6AB
....................     case BUTTON_IDLE:   
....................       if ( ENTER_PRESSED == 1 ) { 
0E24:  BTFSS  7D.3
0E25:  GOTO   62A
....................         button_state=CALIB; 
0E26:  MOVLW  10
0E27:  MOVLB  01
0E28:  MOVWF  61
0E29:  MOVLB  00
....................       } 
....................     break; 
0E2A:  GOTO   6AE
....................     case CALIB: 
....................       adj_value_a = read_adc() >> 2; 
0E2B:  MOVLB  01
0E2C:  BSF    1D.1
0E2D:  BTFSC  1D.1
0E2E:  GOTO   62D
0E2F:  RRF    1C,W
0E30:  MOVWF  5F
0E31:  RRF    5F,F
0E32:  MOVLW  3F
0E33:  ANDWF  5F,F
....................       adj_value_b = adj_value_a; 
0E34:  MOVF   5F,W
0E35:  MOVWF  60
....................       button_state=TRIM; 
0E36:  MOVLW  0F
0E37:  MOVWF  61
....................       pot_values_to_lcd(); 
0E38:  MOVLB  00
0E39:  CALL   280
....................       break; 
0E3A:  GOTO   6AE
....................     case TRIM: 
....................        if ( _cor_in != 0 ) { 
0E3B:  MOVLB  01
0E3C:  MOVF   6A,F
0E3D:  BTFSC  03.2
0E3E:  GOTO   670
....................          adj_value_a = read_adc() >> 2; 
0E3F:  BSF    1D.1
0E40:  BTFSC  1D.1
0E41:  GOTO   640
0E42:  RRF    1C,W
0E43:  MOVWF  5F
0E44:  RRF    5F,F
0E45:  MOVLW  3F
0E46:  ANDWF  5F,F
....................          pot_value = 63-adj_value_a; 
0E47:  MOVF   5F,W
0E48:  SUBLW  3F
0E49:  MOVWF  6B
....................          if ( adj_value_a != adj_value_b ) { 
0E4A:  MOVF   60,W
0E4B:  SUBWF  5F,W
0E4C:  BTFSC  03.2
0E4D:  GOTO   66E
....................            rs232_mode = 1; 
0E4E:  BSF    65.2
....................            set_trimpot(CurrentTrimPot, pot_value); 
0E4F:  MOVF   30,W
0E50:  MOVLB  02
0E51:  MOVWF  40
0E52:  MOVLB  01
0E53:  MOVF   6B,W
0E54:  MOVLB  02
0E55:  MOVWF  41
0E56:  MOVLP  00
0E57:  MOVLB  00
0E58:  CALL   725
0E59:  MOVLP  08
....................            pot_values_to_lcd(); 
0E5A:  CALL   280
.................... 	   RX_GAIN[CurrentCorIndex-1][CPotPtr]=pot_value; 
0E5B:  MOVLW  01
0E5C:  SUBWF  75,W
0E5D:  MOVWF  77
0E5E:  RLF    77,F
0E5F:  RLF    77,F
0E60:  MOVLW  FC
0E61:  ANDWF  77,F
0E62:  MOVF   77,W
0E63:  MOVLB  01
0E64:  ADDWF  6C,W
0E65:  ADDLW  0C
0E66:  MOVWF  04
0E67:  MOVLW  20
0E68:  MOVWF  05
0E69:  BTFSC  03.0
0E6A:  INCF   05,F
0E6B:  MOVF   6B,W
0E6C:  MOVWF  00
....................            rs232_mode = 0; 
0E6D:  BCF    65.2
....................          } 
....................          adj_value_b = adj_value_a; 
0E6E:  MOVF   5F,W
0E6F:  MOVWF  60
.................... 	     } 
....................        if ( SELECT_PRESSED == 1 ) { 
0E70:  BTFSS  7D.4
0E71:  GOTO   679
....................          CurrentTrimPot = (CurrentTrimPot + 1 ) & 0x03; 
0E72:  MOVLW  01
0E73:  ADDWF  30,W
0E74:  ANDLW  03
0E75:  MOVWF  30
....................          pot_values_to_lcd(); 
0E76:  MOVLB  00
0E77:  CALL   280
0E78:  MOVLB  01
....................        } 
....................        if ( ENTER_PRESSED == 1 ) { 
0E79:  BTFSS  7D.3
0E7A:  GOTO   683
....................          // Hold SELECT and press ENTER to store settings in EEPROM 
....................          if ( input(SELECT_BUTTON)==0 ) { 
0E7B:  MOVLB  00
0E7C:  BTFSC  10.3
0E7D:  GOTO   681
....................            store_variables(); 
0E7E:  MOVLP  00
0E7F:  CALL   560
0E80:  MOVLP  08
....................          } 
....................          button_state = BUTTON_IDLE; 
0E81:  MOVLB  01
0E82:  CLRF   61
.................... 	     }  
....................        status_led(); 
....................     break; 
*
0EA9:  MOVLB  00
0EAA:  GOTO   6AE
....................     default: 
....................   		button_state = BUTTON_IDLE; 
0EAB:  MOVLB  01
0EAC:  CLRF   61
....................     break; 
0EAD:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0EAE:  CLRWDT
....................   // }}} 
.................... #endif 
.................... } // }}} 
0EAF:  MOVLP  20
0EB0:  GOTO   136 (RETURN)

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
003FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
003FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
003FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
003FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
003FFB: 3468 3496 349A 34A5 3400 
