CCS PCM C Compiler, Version 4.140, 64991               10-Jan-21 15:42

               Filename:   C:\Users\Luc\Projects\RC2G Branches\RC2G_a\54_Nicolas\Firmware.lst

               ROM used:   8062 words (98%)
                           Largest free fragment is 62
               RAM used:   172 (34%) at main() level
                           243 (47%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   591
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   357
002D:  MOVLP  00
002E:  GOTO   3D1
002F:  MOVLP  00
0030:  GOTO   2E1
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #device ADC=8; 
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
15FF:  MOVLB  02
1600:  MOVF   30,W
1601:  MOVWF  34
1602:  MOVF   2F,W
1603:  MOVWF  33
1604:  MOVF   34,W
1605:  MOVWF  7A
1606:  MOVF   33,W
1607:  MOVWF  04
1608:  MOVF   7A,W
1609:  MOVWF  05
160A:  MOVF   00,F
160B:  BTFSC  03.2
160C:  GOTO   611
160D:  INCF   33,F
160E:  BTFSC  03.2
160F:  INCF   34,F
1610:  GOTO   604
....................    while(*s2 != '\0') 
....................    { 
1611:  MOVF   32,W
1612:  MOVWF  7A
1613:  MOVF   31,W
1614:  MOVWF  04
1615:  MOVF   7A,W
1616:  MOVWF  05
1617:  MOVF   00,F
1618:  BTFSC  03.2
1619:  GOTO   62D
....................       *s = *s2; 
161A:  MOVF   31,W
161B:  MOVWF  04
161C:  MOVF   32,W
161D:  MOVWF  05
161E:  MOVF   00,W
161F:  MOVWF  37
1620:  MOVF   34,W
1621:  MOVWF  05
1622:  MOVF   33,W
1623:  MOVWF  04
1624:  MOVF   37,W
1625:  MOVWF  00
....................       ++s; 
1626:  INCF   33,F
1627:  BTFSC  03.2
1628:  INCF   34,F
....................       ++s2; 
1629:  INCF   31,F
162A:  BTFSC  03.2
162B:  INCF   32,F
....................    } 
162C:  GOTO   611
....................  
....................    *s = '\0'; 
162D:  MOVF   33,W
162E:  MOVWF  04
162F:  MOVF   34,W
1630:  MOVWF  05
1631:  CLRF   00
....................    return(s1); 
1632:  MOVF   2F,W
1633:  MOVWF  78
1634:  MOVF   30,W
1635:  MOVWF  79
.................... } 
1636:  MOVLB  00
1637:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E84:  MOVF   4E,W
0E85:  MOVWF  52
0E86:  MOVF   4D,W
0E87:  MOVWF  51
0E88:  MOVF   52,W
0E89:  MOVWF  7A
0E8A:  MOVF   51,W
0E8B:  MOVWF  04
0E8C:  MOVF   7A,W
0E8D:  MOVWF  05
0E8E:  MOVF   00,F
0E8F:  BTFSC  03.2
0E90:  GOTO   6BD
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0E91:  MOVF   50,W
0E92:  MOVWF  54
0E93:  MOVF   4F,W
0E94:  MOVWF  53
0E95:  MOVF   54,W
0E96:  MOVWF  7A
0E97:  MOVF   53,W
0E98:  MOVWF  04
0E99:  MOVF   7A,W
0E9A:  MOVWF  05
0E9B:  MOVF   00,F
0E9C:  BTFSC  03.2
0E9D:  GOTO   6B9
....................          if (*sc1 == *sc2) 
0E9E:  MOVF   52,W
0E9F:  MOVWF  7A
0EA0:  MOVF   51,W
0EA1:  MOVWF  04
0EA2:  MOVF   7A,W
0EA3:  MOVWF  05
0EA4:  MOVF   00,W
0EA5:  MOVWF  55
0EA6:  MOVF   54,W
0EA7:  MOVWF  7A
0EA8:  MOVF   53,W
0EA9:  MOVWF  04
0EAA:  MOVF   7A,W
0EAB:  MOVWF  05
0EAC:  MOVF   00,W
0EAD:  SUBWF  55,W
0EAE:  BTFSS  03.2
0EAF:  GOTO   6B5
....................             return(sc1); 
0EB0:  MOVF   51,W
0EB1:  MOVWF  78
0EB2:  MOVF   52,W
0EB3:  MOVWF  79
0EB4:  GOTO   6C0
0EB5:  INCF   53,F
0EB6:  BTFSC  03.2
0EB7:  INCF   54,F
0EB8:  GOTO   695
0EB9:  INCF   51,F
0EBA:  BTFSC  03.2
0EBB:  INCF   52,F
0EBC:  GOTO   688
....................    return(0); 
0EBD:  MOVLW  00
0EBE:  MOVWF  78
0EBF:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E1D:  MOVF   4E,W
0E1E:  MOVWF  52
0E1F:  MOVF   4D,W
0E20:  MOVWF  51
0E21:  MOVF   52,W
0E22:  MOVWF  7A
0E23:  MOVF   51,W
0E24:  MOVWF  04
0E25:  MOVF   7A,W
0E26:  MOVWF  05
0E27:  MOVF   00,F
0E28:  BTFSC  03.2
0E29:  GOTO   65B
....................       for (sc2 = s2; ; sc2++) 
0E2A:  MOVF   50,W
0E2B:  MOVWF  54
0E2C:  MOVF   4F,W
0E2D:  MOVWF  53
....................     if (*sc2 == '\0') 
0E2E:  MOVF   54,W
0E2F:  MOVWF  7A
0E30:  MOVF   53,W
0E31:  MOVWF  04
0E32:  MOVF   7A,W
0E33:  MOVWF  05
0E34:  MOVF   00,F
0E35:  BTFSS  03.2
0E36:  GOTO   641
....................        return(sc1 - s1); 
0E37:  MOVF   4D,W
0E38:  SUBWF  51,W
0E39:  MOVWF  77
0E3A:  MOVF   4E,W
0E3B:  SUBWFC 52,W
0E3C:  MOVWF  7A
0E3D:  MOVF   77,W
0E3E:  MOVWF  78
0E3F:  GOTO   663
....................          else if (*sc1 == *sc2) 
0E40:  GOTO   653
0E41:  MOVF   52,W
0E42:  MOVWF  7A
0E43:  MOVF   51,W
0E44:  MOVWF  04
0E45:  MOVF   7A,W
0E46:  MOVWF  05
0E47:  MOVF   00,W
0E48:  MOVWF  55
0E49:  MOVF   54,W
0E4A:  MOVWF  7A
0E4B:  MOVF   53,W
0E4C:  MOVWF  04
0E4D:  MOVF   7A,W
0E4E:  MOVWF  05
0E4F:  MOVF   00,W
0E50:  SUBWF  55,W
0E51:  BTFSC  03.2
....................             break; 
0E52:  GOTO   657
0E53:  INCF   53,F
0E54:  BTFSC  03.2
0E55:  INCF   54,F
0E56:  GOTO   62E
0E57:  INCF   51,F
0E58:  BTFSC  03.2
0E59:  INCF   52,F
0E5A:  GOTO   621
....................    return(sc1 - s1); 
0E5B:  MOVF   4D,W
0E5C:  SUBWF  51,W
0E5D:  MOVWF  77
0E5E:  MOVF   4E,W
0E5F:  SUBWFC 52,W
0E60:  MOVWF  7A
0E61:  MOVF   77,W
0E62:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1DBF:  MOVLB  00
1DC0:  CLRF   26
1DC1:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0E04:  MOVLB  02
0E05:  MOVF   45,W
0E06:  IORWF  46,W
0E07:  BTFSC  03.2
0E08:  GOTO   60D
0E09:  MOVF   46,W
0E0A:  MOVWF  7A
0E0B:  MOVF   45,W
0E0C:  GOTO   612
0E0D:  MOVLB  00
0E0E:  MOVF   27,W
0E0F:  MOVWF  7A
0E10:  MOVF   26,W
0E11:  MOVLB  02
0E12:  MOVWF  49
0E13:  MOVF   7A,W
0E14:  MOVWF  4A
....................    beg += strspn(beg, s2); 
0E15:  MOVF   4A,W
0E16:  MOVWF  4E
0E17:  MOVF   49,W
0E18:  MOVWF  4D
0E19:  MOVF   48,W
0E1A:  MOVWF  50
0E1B:  MOVF   47,W
0E1C:  MOVWF  4F
*
0E63:  MOVF   78,W
0E64:  ADDWF  49,F
0E65:  MOVLW  00
0E66:  ADDWFC 4A,F
....................    if (*beg == '\0') 
0E67:  MOVF   4A,W
0E68:  MOVWF  7A
0E69:  MOVF   49,W
0E6A:  MOVWF  04
0E6B:  MOVF   7A,W
0E6C:  MOVWF  05
0E6D:  MOVF   00,F
0E6E:  BTFSS  03.2
0E6F:  GOTO   67C
....................    { 
....................       *save = ' '; 
0E70:  MOVLB  00
0E71:  MOVF   26,W
0E72:  MOVWF  04
0E73:  MOVF   27,W
0E74:  MOVWF  05
0E75:  MOVLW  20
0E76:  MOVWF  00
....................       return(0); 
0E77:  MOVLW  00
0E78:  MOVWF  78
0E79:  MOVWF  79
0E7A:  GOTO   6E1
0E7B:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0E7C:  MOVF   4A,W
0E7D:  MOVWF  4E
0E7E:  MOVF   49,W
0E7F:  MOVWF  4D
0E80:  MOVF   48,W
0E81:  MOVWF  50
0E82:  MOVF   47,W
0E83:  MOVWF  4F
*
0EC0:  MOVF   79,W
0EC1:  MOVWF  4C
0EC2:  MOVF   78,W
0EC3:  MOVWF  4B
....................    if (*end != '\0') 
0EC4:  MOVF   4C,W
0EC5:  MOVWF  7A
0EC6:  MOVF   4B,W
0EC7:  MOVWF  04
0EC8:  MOVF   7A,W
0EC9:  MOVWF  05
0ECA:  MOVF   00,F
0ECB:  BTFSC  03.2
0ECC:  GOTO   6D5
....................    { 
....................       *end = '\0'; 
0ECD:  MOVF   4B,W
0ECE:  MOVWF  04
0ECF:  MOVF   4C,W
0ED0:  MOVWF  05
0ED1:  CLRF   00
....................       end++; 
0ED2:  INCF   4B,F
0ED3:  BTFSC  03.2
0ED4:  INCF   4C,F
....................    } 
....................    save = end; 
0ED5:  MOVF   4C,W
0ED6:  MOVLB  00
0ED7:  MOVWF  27
0ED8:  MOVLB  02
0ED9:  MOVF   4B,W
0EDA:  MOVLB  00
0EDB:  MOVWF  26
....................    return(beg); 
0EDC:  MOVLB  02
0EDD:  MOVF   49,W
0EDE:  MOVWF  78
0EDF:  MOVF   4A,W
0EE0:  MOVWF  79
0EE1:  MOVLB  00
.................... } 
0EE2:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
.................... #define BUTTON_STATES 
.................... #define POT_MAX 63 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
07CB:  MOVLW  20
07CC:  MOVWF  05
07CD:  MOVLW  D0
07CE:  MOVWF  04
07CF:  MOVF   00,W
07D0:  BTFSC  03.2
07D1:  GOTO   7E3
07D2:  MOVLW  02
07D3:  MOVWF  78
07D4:  MOVLW  BF
07D5:  MOVWF  77
07D6:  CLRWDT
07D7:  DECFSZ 77,F
07D8:  GOTO   7D6
07D9:  DECFSZ 78,F
07DA:  GOTO   7D4
07DB:  MOVLW  96
07DC:  MOVWF  77
07DD:  DECFSZ 77,F
07DE:  GOTO   7DD
07DF:  GOTO   7E0
07E0:  CLRWDT
07E1:  DECFSZ 00,F
07E2:  GOTO   7D2
07E3:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
06F3:  MOVLB  04
06F4:  BCF    15.7
06F5:  MOVLB  00
06F6:  BCF    11.3
06F7:  MOVLB  02
06F8:  MOVF   56,W
06F9:  MOVLB  04
06FA:  MOVWF  11
06FB:  MOVLW  02
06FC:  BTFSC  15.7
06FD:  GOTO   705
06FE:  MOVLB  00
06FF:  BTFSS  11.3
0700:  GOTO   6FF
0701:  MOVLW  00
0702:  MOVLB  04
0703:  BTFSC  16.6
0704:  MOVLW  01
0705:  MOVWF  78
0706:  MOVLB  00
0707:  RETURN
*
0AF2:  MOVLB  04
0AF3:  BCF    15.6
0AF4:  BSF    16.3
0AF5:  BTFSC  16.3
0AF6:  GOTO   2F5
0AF7:  BTFSC  77.0
0AF8:  BCF    16.5
0AF9:  BTFSS  77.0
0AFA:  BSF    16.5
0AFB:  BSF    16.4
0AFC:  BTFSC  16.4
0AFD:  GOTO   2FC
0AFE:  MOVF   11,W
0AFF:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02DA:  CLRWDT
02DB:  BTFSS  11.4
02DC:  GOTO   2DA
02DD:  MOVLB  03
02DE:  MOVWF  1A
02DF:  MOVLB  00
02E0:  RETURN
.................... //#use fast_io (a) 
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void send_tail(void); 
.................... void status_led(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
.................... int1 my_stricmp(char *, char *); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN; 
.................... unsigned int Enable,Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned int TOT_Min; 
.................... unsigned int COR_EMUL; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... char COR_IN_EFFECTIVE; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define DEBOUNCE_COUNT 8 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... //#define DTMF_SEND_OLD 10 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x10 
.................... #define AUXI_EMULATE_COR0 0x01 
.................... #define AUXI_EMULATE_COR1 0x02 
.................... #define AUXI_EMULATE_COR2 0x04 
.................... #define AUXI_EMULATE_COR3 0x08 
....................  
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... #define LCD_I2C_ADD 0x60 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... char command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... unsigned int  LastRegisterIndex; 
.................... unsigned int  LastRegisterIndexValid; 
....................  
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... //	int      reg_name_index; 
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1 ENTER_PRESSED; 
.................... int1 SELECT_PRESSED; 
.................... int  adj_value_a,adj_value_b; 
.................... char button_state; 
.................... int1       COR_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... int1       STATUS_LED; 
.................... unsigned long TOT_SecondCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... #define PTT_TIMEOUT_SECS 60 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... #ifndef GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 
.................... 	{"XI2"},	  // 19 
.................... 	{"XI3"},	  // 20 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"COR"},  // 54 
....................     {"CPOT"}  // 55 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
....................  
.................... #define SITE_ID_VAL  	54 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... // All radios ON except Radio3 (147.105) 
.................... #define ENABLE_DEFAULT 0x0B 
.................... #define TOT_MIN 5 
.................... #define DEFAULT_GAIN 20 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('e') 
.................... #define MORSEID5	MCHAR('h') 
....................  
.................... #define AUXOUTOP0 AUX_OUT_FOLLOW_COR 
.................... #define AUXOUTARG0 AUX_OUT_FOLLOW_COR2|AUX_OUT_FOLLOW_COR_INVERT2 
.................... #define AUXOUTOP1 0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2 0 
.................... #define AUXOUTARG2 0 
....................  
.................... //#define AUXINOP0 AUXI_ENABLE 
.................... //#define AUXINARG0 AUXI_ENABLE2|AUXI_ENABLE3|AUXI_ENABLE4 
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  0 
.................... #define AUXINARG0 0 
.................... #define AUXINOP1  AUXI_TAIL_WHEN_LO 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
....................  
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  ,EEPROM}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL,EEPROM}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&AuxIn[0]      ,0           , EEPROM}, 
.................... 	{&AuxIn[1]      ,0           , EEPROM}, 
.................... 	{&AuxIn[2]      ,0           , EEPROM}, 
.................... 	{&AuxOut[0]     ,0           , EEPROM}, 
.................... 	{&AuxOut[1]     ,0           , EEPROM}, 
.................... 	{&AuxOut[2]     ,0           , EEPROM}, 
.................... 	{&RXPriority[0] ,4           , EEPROM}, 
.................... 	{&RXPriority[1] ,6           , EEPROM}, 
.................... 	{&RXPriority[2] ,6           , EEPROM}, 
.................... 	{&RXPriority[3] ,2           , EEPROM}, 
.................... 	{&RX_PTT[0]     ,0x0E        , EEPROM}, 
.................... 	{&RX_PTT[1]     ,0x0D        , EEPROM}, 
.................... 	{&RX_PTT[2]     ,0x0B        , EEPROM}, 
.................... 	{&RX_PTT[3]     ,0x07        , EEPROM}, 
.................... 	{&SiteID        ,SITE_ID_VAL , EEPROM}, 
.................... 	{&TXSiteID      ,0x12        , EEPROM}, 
....................     {&Morse[0]      ,MORSEID0    , EEPROM}, 
....................     {&Morse[1]      ,MORSEID1    , EEPROM}, 
....................     {&Morse[2]      ,MORSEID2    , EEPROM}, 
....................     {&Morse[3]      ,MORSEID3    , EEPROM}, 
....................     {&Morse[4]      ,MORSEID4    , EEPROM}, 
....................     {&Morse[5]      ,MORSEID5    , EEPROM}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0   , EEPROM}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1   , EEPROM}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2   , EEPROM}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0  , EEPROM}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1  , EEPROM}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2  , EEPROM}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0    , EEPROM}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1    , EEPROM}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2    , EEPROM}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0   , EEPROM}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1   , EEPROM}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2   , EEPROM}, 
....................   {&Tail          ,TAIL_CHAR   , EEPROM}, 
....................   {&TOT_Min       ,TOT_MIN     , EEPROM}, 
.................... 	{&COR_EMUL      ,0x00        , RAM}, 
.................... 	{&CurrentTrimPot,0x00        , RAM}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02E1:  BTFSS  11.5
02E2:  GOTO   338
....................     c = getc(); 
02E3:  CLRWDT
02E4:  BTFSS  11.5
02E5:  GOTO   2E3
02E6:  MOVLB  03
02E7:  MOVF   19,W
02E8:  MOVLB  02
02E9:  MOVWF  5E
....................     if ( c == '\b' ) { 
02EA:  MOVF   5E,W
02EB:  SUBLW  08
02EC:  BTFSS  03.2
02ED:  GOTO   316
....................       if ( sBufferIndex > 0 ) { 
02EE:  MOVF   71,F
02EF:  BTFSC  03.2
02F0:  GOTO   310
....................         sBufferIndex--; 
02F1:  DECF   71,F
....................         sBuffer[sBufferIndex]='\0'; 
02F2:  MOVLW  4E
02F3:  ADDWF  71,W
02F4:  MOVWF  04
02F5:  MOVLW  20
02F6:  MOVWF  05
02F7:  BTFSC  03.0
02F8:  INCF   05,F
02F9:  CLRF   00
....................         putc('\b'); 
02FA:  MOVLW  08
02FB:  MOVLB  00
02FC:  CALL   2DA
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
02FD:  MOVLW  1B
02FE:  CALL   2DA
....................   printf("[K"); 
02FF:  MOVLW  5B
0300:  CLRWDT
0301:  BTFSS  11.4
0302:  GOTO   300
0303:  MOVLB  03
0304:  MOVWF  1A
0305:  MOVLW  4B
0306:  CLRWDT
0307:  MOVLB  00
0308:  BTFSC  11.4
0309:  GOTO   30C
030A:  MOVLB  03
030B:  GOTO   306
030C:  MOVLB  03
030D:  MOVWF  1A
....................       } else { 
030E:  GOTO   314
030F:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
0310:  MOVLW  07
0311:  MOVLB  00
0312:  CALL   2DA
0313:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
0314:  GOTO   33A
0315:  MOVLB  02
0316:  MOVF   71,W
0317:  SUBLW  0F
0318:  BTFSS  03.0
0319:  GOTO   335
....................       putc(c); // echo the character 
031A:  MOVF   5E,W
031B:  MOVLB  00
031C:  CALL   2DA
....................       sBuffer[sBufferIndex++] = c; 
031D:  MOVF   71,W
031E:  INCF   71,F
031F:  ADDLW  4E
0320:  MOVWF  04
0321:  MOVLW  20
0322:  MOVWF  05
0323:  BTFSC  03.0
0324:  INCF   05,F
0325:  MOVLB  02
0326:  MOVF   5E,W
0327:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0328:  MOVF   5E,W
0329:  SUBLW  0D
032A:  BTFSC  03.2
032B:  GOTO   333
032C:  MOVF   5E,W
032D:  SUBLW  2B
032E:  BTFSC  03.2
032F:  GOTO   333
0330:  MOVF   5E,W
0331:  SUBLW  2D
0332:  BTFSC  03.2
....................         sBufferFlag=1; 
0333:  BSF    72.0
....................       } 
....................     } else { 
0334:  GOTO   339
....................       putc('\a'); // Send alert. Avoid buffer overflow 
0335:  MOVLW  07
0336:  MOVLB  00
0337:  CALL   2DA
0338:  MOVLB  02
0339:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
033A:  MOVLB  00
033B:  BCF    11.5
033C:  MOVLP  00
033D:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   int value,dtmf_status; 
....................   int LAST_COR_IN; 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if(IOCBF&0x0F) { // Check for interrupts on RB[3:0] only 
*
0357:  MOVLB  07
0358:  MOVF   16,W
0359:  ANDLW  0F
035A:  BTFSC  03.2
035B:  GOTO   36D
....................     LAST_COR_IN=COR_IN; 
035C:  MOVLB  00
035D:  MOVF   5F,W
035E:  MOVLB  02
035F:  MOVWF  60
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
0360:  MOVLB  00
0361:  MOVF   0D,W
0362:  XORWF  62,W
0363:  ANDLW  0F
0364:  MOVWF  5F
....................     if ( LAST_COR_IN != COR_IN ) { 
0365:  MOVF   5F,W
0366:  MOVLB  02
0367:  SUBWF  60,W
0368:  BTFSS  03.2
....................       COR_FLAG = 1; 
0369:  BSF    72.3
....................     } 
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
036A:  MOVLW  F0
036B:  MOVLB  07
036C:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
036D:  BTFSS  0B.0
036E:  GOTO   3C6
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     dtmf_status = dtmf_read(CONTROL_REG); 
036F:  MOVLW  01
0370:  MOVLB  02
0371:  MOVWF  61
0372:  MOVLB  00
0373:  CALL   33E
0374:  MOVF   78,W
0375:  MOVLB  02
0376:  MOVWF  5F
....................     if ( dtmf_status & DTMF_BUFFER_FULL) { 
0377:  BTFSS  5F.2
0378:  GOTO   3C4
....................       value=dtmf_read(DATA_REG); 
0379:  CLRF   61
037A:  MOVLB  00
037B:  CALL   33E
037C:  MOVF   78,W
037D:  MOVLB  02
037E:  MOVWF  5E
....................       DTMF_IN_FLAG=1; 
037F:  MOVLB  01
0380:  BSF    5B.3
....................       if ( value == dd ) { 
0381:  MOVLB  02
0382:  MOVF   5E,F
0383:  BTFSS  03.2
0384:  GOTO   388
....................         value=d0; 
0385:  MOVLW  0A
0386:  MOVWF  5E
....................       } else if ( value == d0 ) { 
0387:  GOTO   38C
0388:  MOVF   5E,W
0389:  SUBLW  0A
038A:  BTFSC  03.2
....................         value=dd; 
038B:  CLRF   5E
....................       } 
....................       if ( value == ds ) { 
038C:  MOVF   5E,W
038D:  SUBLW  0B
038E:  BTFSS  03.2
038F:  GOTO   393
....................         CLEAR_DTMF_FLAG=1; 
0390:  MOVLB  01
0391:  BSF    5B.4
0392:  MOVLB  02
....................       } 
....................       // Check for '#' 
....................       if ( value == dp ) { 
0393:  MOVF   5E,W
0394:  SUBLW  0C
0395:  BTFSS  03.2
0396:  GOTO   3A1
....................         DTMF_FLAG = 1; 
0397:  MOVLB  01
0398:  BSF    5B.2
....................         DTMF_ptr->Last=1; 
0399:  MOVF   3C,W
039A:  MOVWF  04
039B:  MOVF   3D,W
039C:  MOVWF  05
039D:  ADDFSR 00,FSR0
039E:  BSF    00.5
....................       } else { 
039F:  GOTO   3C3
03A0:  MOVLB  02
....................         if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
03A1:  MOVLB  01
03A2:  MOVF   3D,W
03A3:  SUBLW  20
03A4:  BTFSS  03.0
03A5:  GOTO   3C3
03A6:  BTFSS  03.2
03A7:  GOTO   3AC
03A8:  MOVF   3C,W
03A9:  SUBLW  6B
03AA:  BTFSS  03.0
03AB:  GOTO   3C3
....................           DTMF_ptr->Key=value; 
03AC:  MOVF   3C,W
03AD:  MOVWF  04
03AE:  MOVF   3D,W
03AF:  MOVWF  05
03B0:  ADDFSR 00,FSR0
03B1:  MOVLB  02
03B2:  MOVF   5E,W
03B3:  ANDLW  0F
03B4:  MOVWF  77
03B5:  MOVLW  F0
03B6:  ANDWF  00,W
03B7:  IORWF  77,W
03B8:  MOVWF  00
....................           DTMF_ptr->Strobe=1; 
03B9:  MOVLB  01
03BA:  MOVF   3C,W
03BB:  MOVWF  04
03BC:  MOVF   3D,W
03BD:  MOVWF  05
03BE:  ADDFSR 00,FSR0
03BF:  BSF    00.4
....................           DTMF_ptr++; 
03C0:  INCF   3C,F
03C1:  BTFSC  03.2
03C2:  INCF   3D,F
03C3:  MOVLB  02
....................         } 
....................       } 
....................     } 
....................   clear_interrupt(INT_RB4_H2L); 
03C4:  MOVLB  07
03C5:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
03C6:  BTFSS  0B.0
03C7:  GOTO   3CD
....................     AUX_IN_FLAG=1; 
03C8:  MOVLB  01
03C9:  BSF    5B.0
....................     clear_interrupt(INT_RB6|INT_RB7); 
03CA:  MOVLW  3F
03CB:  MOVLB  07
03CC:  ANDWF  16,F
....................   } 
.................... } // }}} 
03CD:  BCF    0B.0
03CE:  MOVLP  00
03CF:  MOVLB  00
03D0:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
03D1:  MOVLB  01
03D2:  MOVF   2E,W
03D3:  IORWF  2F,W
03D4:  BTFSC  03.2
03D5:  GOTO   3DB
....................     rtcc_cnt--; 
03D6:  MOVF   2E,W
03D7:  BTFSC  03.2
03D8:  DECF   2F,F
03D9:  DECF   2E,F
....................   } else { 
03DA:  GOTO   3E7
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
03DB:  MOVLB  00
03DC:  MOVF   0D,W
03DD:  XORWF  62,W
03DE:  ANDLW  0F
03DF:  MOVWF  5F
....................     COR_FLAG=1; 
03E0:  BSF    72.3
....................     SECOND_FLAG=1; 
03E1:  BSF    72.4
....................     AUX_IN_FLAG=1; 
03E2:  MOVLB  01
03E3:  BSF    5B.0
....................     rtcc_cnt=30; 
03E4:  CLRF   2F
03E5:  MOVLW  1E
03E6:  MOVWF  2E
....................   } 
....................   if (aux_timer ) { 
03E7:  MOVF   30,W
03E8:  IORWF  31,W
03E9:  BTFSC  03.2
03EA:  GOTO   3EF
....................     aux_timer--; 
03EB:  MOVF   30,W
03EC:  BTFSC  03.2
03ED:  DECF   31,F
03EE:  DECF   30,F
....................   } 
.................... } // }}} 
03EF:  BCF    0B.2
03F0:  MOVLP  00
03F1:  MOVLB  00
03F2:  GOTO   020
.................... int1 warn_no_lcd = 1; 
.................... void lcd_send(int line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
*
09DB:  BCF    03.0
09DC:  MOVLB  02
09DD:  RLF    50,W
09DE:  ANDLW  0E
09DF:  IORLW  60
09E0:  MOVWF  53
....................   i2c_start(); 
09E1:  MOVLB  04
09E2:  BSF    16.0
09E3:  BTFSC  16.0
09E4:  GOTO   1E3
....................   ack=i2c_write(lcd_cmd); 
09E5:  MOVLB  02
09E6:  MOVF   53,W
09E7:  MOVWF  56
09E8:  MOVLP  00
09E9:  MOVLB  00
09EA:  CALL   6F3
09EB:  MOVLP  08
09EC:  MOVF   78,W
09ED:  MOVLB  02
09EE:  BCF    54.0
09EF:  BTFSC  78.0
09F0:  BSF    54.0
....................   if ( ack!=0 ) { 
09F1:  BTFSS  54.0
09F2:  GOTO   215
....................     if ( warn_no_lcd ) { 
09F3:  MOVLB  01
09F4:  BTFSS  60.0
09F5:  GOTO   213
....................       printf("\n\rI2C ERROR : No ACK from LCD : %u",ack); 
09F6:  MOVLW  00
09F7:  MOVLB  02
09F8:  BTFSC  54.0
09F9:  MOVLW  01
09FA:  MOVWF  55
09FB:  MOVLW  F3
09FC:  MOVLB  03
09FD:  MOVWF  11
09FE:  MOVLW  03
09FF:  MOVWF  12
0A00:  BCF    03.0
0A01:  MOVLW  20
0A02:  MOVLB  02
0A03:  MOVWF  56
0A04:  MOVLP  00
0A05:  MOVLB  00
0A06:  CALL   708
0A07:  MOVLP  08
0A08:  MOVLB  02
0A09:  MOVF   55,W
0A0A:  MOVWF  56
0A0B:  MOVLW  1B
0A0C:  MOVWF  57
0A0D:  MOVLP  00
0A0E:  MOVLB  00
0A0F:  CALL   77C
0A10:  MOVLP  08
....................       warn_no_lcd = 0; 
0A11:  MOVLB  01
0A12:  BCF    60.0
....................     } 
....................   } else { 
0A13:  GOTO   217
0A14:  MOVLB  02
....................     warn_no_lcd = 1; 
0A15:  MOVLB  01
0A16:  BSF    60.0
....................   } 
....................   while(*s) { 
0A17:  MOVLB  02
0A18:  MOVF   52,W
0A19:  MOVWF  7A
0A1A:  MOVF   51,W
0A1B:  MOVWF  04
0A1C:  MOVF   7A,W
0A1D:  MOVWF  05
0A1E:  MOVF   00,F
0A1F:  BTFSC  03.2
0A20:  GOTO   234
....................     i2c_write(*s++); 
0A21:  MOVF   52,W
0A22:  MOVWF  7A
0A23:  MOVF   51,W
0A24:  INCF   51,F
0A25:  BTFSC  03.2
0A26:  INCF   52,F
0A27:  MOVWF  04
0A28:  MOVF   7A,W
0A29:  MOVWF  05
0A2A:  MOVF   00,W
0A2B:  MOVWF  55
0A2C:  MOVWF  56
0A2D:  MOVLP  00
0A2E:  MOVLB  00
0A2F:  CALL   6F3
0A30:  MOVLP  08
....................   } 
0A31:  MOVLB  01
0A32:  GOTO   217
0A33:  MOVLB  02
....................   i2c_write(0); // EOL 
0A34:  CLRF   56
0A35:  MOVLP  00
0A36:  MOVLB  00
0A37:  CALL   6F3
0A38:  MOVLP  08
....................   i2c_stop(); 
0A39:  MOVLB  04
0A3A:  BSF    16.2
0A3B:  BTFSC  16.2
0A3C:  GOTO   23B
.................... #endif 
.................... } // }}} 
0A3D:  MOVLB  00
0A3E:  RETURN
.................... #ifdef BUTTON_STATES 
.................... void status_led(void) { // {{{ 
....................   char cnt_val; 
....................   STATUS_LED=0; 
*
0DDA:  MOVLB  01
0DDB:  BCF    5B.1
....................   cnt_val = rtcc_cnt>>3; 
0DDC:  RRF    2F,W
0DDD:  MOVWF  7A
0DDE:  RRF    2E,W
0DDF:  MOVWF  79
0DE0:  RRF    7A,F
0DE1:  RRF    79,F
0DE2:  RRF    7A,F
0DE3:  RRF    79,F
0DE4:  MOVF   79,W
0DE5:  MOVWF  6C
....................   if ( button_state!=0 ) { 
0DE6:  MOVF   5A,F
0DE7:  BTFSC  03.2
0DE8:  GOTO   5F7
....................     if ( (rtcc_cnt & 0x04) ) { 
0DE9:  MOVF   2E,W
0DEA:  ANDLW  04
0DEB:  MOVWF  77
0DEC:  CLRF   7A
0DED:  MOVF   77,W
0DEE:  IORWF  7A,W
0DEF:  BTFSC  03.2
0DF0:  GOTO   5F7
....................       STATUS_LED = (cnt_val < (CurrentTrimPot+1));  
0DF1:  BCF    5B.1
0DF2:  MOVLW  01
0DF3:  ADDWF  74,W
0DF4:  SUBWF  6C,W
0DF5:  BTFSS  03.0
0DF6:  BSF    5B.1
....................     } 
....................   }  
....................   output_bit(STATUS_LED_PIN,STATUS_LED); 
0DF7:  BTFSC  5B.1
0DF8:  GOTO   5FD
0DF9:  MOVLB  02
0DFA:  BCF    0C.6
0DFB:  GOTO   5FF
0DFC:  MOVLB  01
0DFD:  MOVLB  02
0DFE:  BSF    0C.6
0DFF:  MOVLB  01
0E00:  BCF    0C.6
.................... } // }}} 
0E01:  MOVLP  18
0E02:  MOVLB  00
0E03:  GOTO   66B (RETURN)
.................... #endif 
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
10A3:  MOVF   70,F
10A4:  BTFSC  03.2
10A5:  GOTO   107
....................     printf("\n\rProcessing Command:"); 
10A6:  MOVLW  05
10A7:  MOVLB  03
10A8:  MOVWF  11
10A9:  MOVLW  04
10AA:  MOVWF  12
10AB:  MOVLP  00
10AC:  MOVLB  00
10AD:  CALL   530
10AE:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
10AF:  MOVLW  10
10B0:  MOVLB  03
10B1:  MOVWF  11
10B2:  MOVLW  04
10B3:  MOVWF  12
10B4:  BCF    03.0
10B5:  MOVLW  0E
10B6:  MOVLB  02
10B7:  MOVWF  56
10B8:  MOVLP  00
10B9:  MOVLB  00
10BA:  CALL   708
10BB:  MOVLP  10
10BC:  MOVF   63,W
10BD:  MOVLB  02
10BE:  MOVWF  56
10BF:  MOVLW  1B
10C0:  MOVWF  57
10C1:  MOVLP  00
10C2:  MOVLB  00
10C3:  CALL   77C
10C4:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
10C5:  MOVLW  19
10C6:  MOVLB  03
10C7:  MOVWF  11
10C8:  MOVLW  04
10C9:  MOVWF  12
10CA:  BCF    03.0
10CB:  MOVLW  0E
10CC:  MOVLB  02
10CD:  MOVWF  56
10CE:  MOVLP  00
10CF:  MOVLB  00
10D0:  CALL   708
10D1:  MOVLP  10
10D2:  MOVF   70,W
10D3:  MOVLB  02
10D4:  MOVWF  56
10D5:  MOVLW  1B
10D6:  MOVWF  57
10D7:  MOVLP  00
10D8:  MOVLB  00
10D9:  CALL   77C
10DA:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
10DB:  MOVLW  22
10DC:  MOVLB  03
10DD:  MOVWF  11
10DE:  MOVLW  04
10DF:  MOVWF  12
10E0:  BCF    03.0
10E1:  MOVLW  0E
10E2:  MOVLB  02
10E3:  MOVWF  56
10E4:  MOVLP  00
10E5:  MOVLB  00
10E6:  CALL   708
10E7:  MOVLP  10
10E8:  MOVF   75,W
10E9:  MOVLB  02
10EA:  MOVWF  56
10EB:  MOVLW  1B
10EC:  MOVWF  57
10ED:  MOVLP  00
10EE:  MOVLB  00
10EF:  CALL   77C
10F0:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
10F1:  MOVLW  2B
10F2:  MOVLB  03
10F3:  MOVWF  11
10F4:  MOVLW  04
10F5:  MOVWF  12
10F6:  BCF    03.0
10F7:  MOVLW  0E
10F8:  MOVLB  02
10F9:  MOVWF  56
10FA:  MOVLP  00
10FB:  MOVLB  00
10FC:  CALL   708
10FD:  MOVLP  10
10FE:  MOVF   76,W
10FF:  MOVLB  02
1100:  MOVWF  56
1101:  MOVLW  1B
1102:  MOVWF  57
1103:  MOVLP  00
1104:  MOVLB  00
1105:  CALL   77C
1106:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
1107:  MOVLW  02
1108:  SUBWF  70,W
1109:  ADDLW  F5
110A:  BTFSC  03.0
110B:  GOTO   51C
110C:  ADDLW  0B
110D:  GOTO   51D
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
11C9:  GOTO   51C
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
11CA:  RLF    75,W
11CB:  MOVWF  77
11CC:  RLF    77,F
11CD:  MOVLW  FC
11CE:  ANDWF  77,F
11CF:  MOVF   77,W
11D0:  MOVLB  02
11D1:  MOVWF  32
11D2:  INCF   32,W
11D3:  MOVLP  00
11D4:  MOVLB  00
11D5:  CALL   043
11D6:  MOVLP  10
11D7:  MOVWF  7A
11D8:  MOVLB  02
11D9:  MOVF   32,W
11DA:  MOVLP  00
11DB:  MOVLB  00
11DC:  CALL   043
11DD:  MOVLP  10
11DE:  MOVLB  02
11DF:  MOVWF  26
11E0:  MOVF   7A,W
11E1:  MOVWF  27
....................       LastRegisterIndex = argument; 
11E2:  MOVF   75,W
11E3:  MOVWF  7C
....................       LastRegisterIndexValid=1; 
11E4:  MOVLW  01
11E5:  MOVWF  7D
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
11E6:  MOVLW  01
11E7:  MOVWF  7A
11E8:  MOVLW  8B
11E9:  MOVWF  32
11EA:  MOVF   7A,W
11EB:  MOVWF  33
11EC:  CLRF   35
11ED:  MOVF   75,W
11EE:  MOVWF  34
11EF:  MOVF   35,W
11F0:  MOVWF  44
11F1:  MOVF   34,W
11F2:  MOVWF  43
11F3:  CLRF   46
11F4:  MOVLW  06
11F5:  MOVWF  45
11F6:  MOVLP  08
11F7:  MOVLB  00
11F8:  CALL   76C
11F9:  MOVLP  10
11FA:  MOVF   78,W
11FB:  MOVLB  02
11FC:  ADDWF  32,W
11FD:  MOVWF  2A
11FE:  MOVF   79,W
11FF:  ADDWFC 33,W
1200:  MOVWF  2B
....................       romstrcpy(rname,cPtr); 
1201:  MOVLW  20
1202:  MOVWF  42
1203:  MOVLW  AC
1204:  MOVWF  41
1205:  MOVF   2B,W
1206:  MOVWF  44
1207:  MOVF   2A,W
1208:  MOVWF  43
1209:  MOVLP  08
120A:  MOVLB  00
120B:  CALL   783
120C:  MOVLP  10
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
120D:  MOVLB  02
120E:  MOVF   27,W
120F:  MOVWF  7A
1210:  MOVF   26,W
1211:  MOVWF  04
1212:  MOVF   27,W
1213:  MOVWF  05
1214:  MOVF   00,W
1215:  MOVWF  32
1216:  MOVLW  20
1217:  MOVLB  01
1218:  MOVWF  62
1219:  MOVLW  74
121A:  MOVWF  61
121B:  MOVLW  5B
121C:  MOVLB  02
121D:  MOVWF  56
121E:  MOVLP  08
121F:  MOVLB  00
1220:  CALL   164
1221:  MOVLP  10
1222:  MOVF   75,W
1223:  MOVLB  02
1224:  MOVWF  33
1225:  MOVLW  01
1226:  MOVWF  34
1227:  MOVLB  00
1228:  CALL   000
1229:  MOVLW  5D
122A:  MOVLB  02
122B:  MOVWF  56
122C:  MOVLP  08
122D:  MOVLB  00
122E:  CALL   164
122F:  MOVLP  10
1230:  MOVLW  20
1231:  MOVLB  02
1232:  MOVWF  56
1233:  MOVLP  08
1234:  MOVLB  00
1235:  CALL   164
1236:  MOVLP  10
1237:  MOVLW  20
1238:  MOVWF  05
1239:  MOVLW  AC
123A:  MOVWF  04
123B:  MOVLP  08
123C:  CALL   1C6
123D:  MOVLP  10
123E:  MOVLW  20
123F:  MOVLB  02
1240:  MOVWF  56
1241:  MOVLP  08
1242:  MOVLB  00
1243:  CALL   164
1244:  MOVLP  10
1245:  MOVLB  02
1246:  MOVF   32,W
1247:  MOVWF  33
1248:  MOVLW  1B
1249:  MOVWF  34
124A:  MOVLB  00
124B:  CALL   000
124C:  MOVLW  0A
124D:  MOVLB  02
124E:  MOVWF  56
124F:  MOVLP  08
1250:  MOVLB  00
1251:  CALL   164
1252:  MOVLP  10
1253:  MOVLW  0D
1254:  MOVLB  02
1255:  MOVWF  56
1256:  MOVLP  08
1257:  MOVLB  00
1258:  CALL   164
1259:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
125A:  MOVLW  0A
125B:  CLRWDT
125C:  BTFSS  11.4
125D:  GOTO   25B
125E:  MOVLB  03
125F:  MOVWF  1A
1260:  MOVLW  0D
1261:  CLRWDT
1262:  MOVLB  00
1263:  BTFSC  11.4
1264:  GOTO   267
1265:  MOVLB  03
1266:  GOTO   261
1267:  MOVLB  03
1268:  MOVWF  1A
1269:  MOVLW  20
126A:  MOVWF  05
126B:  MOVLW  74
126C:  MOVWF  04
126D:  MOVLP  08
126E:  MOVLB  00
126F:  CALL   2A6
1270:  MOVLP  10
....................       lcd_send(2,LCD_str); 
1271:  MOVLW  02
1272:  MOVLB  02
1273:  MOVWF  50
1274:  MOVLW  20
1275:  MOVWF  52
1276:  MOVLW  74
1277:  MOVWF  51
1278:  MOVLP  08
1279:  MOVLB  00
127A:  CALL   1DB
127B:  MOVLP  10
....................       prompt(); 
127C:  CALL   049
....................       break; 
127D:  GOTO   51C
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
127E:  MOVLP  08
127F:  CALL   7AE
1280:  MOVLP  10
1281:  MOVF   78,F
1282:  BTFSC  03.2
1283:  GOTO   287
....................         store_variables(); 
1284:  MOVLP  00
1285:  CALL   623
1286:  MOVLP  10
....................       } 
....................       break; 
1287:  GOTO   51C
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
1288:  DECFSZ 76,W
1289:  GOTO   28E
....................         init_src=USE_EEPROM_VARS; 
128A:  MOVLB  02
128B:  BSF    28.0
....................       } else { 
128C:  GOTO   290
128D:  MOVLB  00
....................         init_src=USE_DEFAULT_VARS; 
128E:  MOVLB  02
128F:  BCF    28.0
....................       } 
....................       if ( in_admin_mode() ) { 
1290:  MOVLP  08
1291:  MOVLB  00
1292:  CALL   7AE
1293:  MOVLP  10
1294:  MOVF   78,F
1295:  BTFSC  03.2
1296:  GOTO   2A1
....................         init_variables(init_src); 
1297:  MOVLW  00
1298:  MOVLB  02
1299:  BTFSC  28.0
129A:  MOVLW  01
129B:  MOVWF  32
129C:  MOVWF  33
129D:  MOVLP  00
129E:  MOVLB  00
129F:  CALL   69E
12A0:  MOVLP  10
....................       } 
....................       break; 
12A1:  GOTO   51C
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
12A2:  MOVF   75,W
12A3:  ANDLW  03
12A4:  MOVWF  74
....................       increment(value); 
12A5:  MOVF   76,W
12A6:  MOVLB  02
12A7:  MOVWF  35
12A8:  MOVLP  08
12A9:  MOVLB  00
12AA:  CALL   7BD
12AB:  MOVLP  10
....................       PROMPT_FLAG=1; 
12AC:  MOVLB  01
12AD:  BSF    5B.5
....................       break; 
12AE:  MOVLB  00
12AF:  GOTO   51C
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
12B0:  MOVF   75,W
12B1:  ANDLW  03
12B2:  MOVWF  74
....................       increment(-1*value); 
12B3:  MOVLW  FF
12B4:  MOVLB  02
12B5:  MOVWF  49
12B6:  MOVF   76,W
12B7:  MOVWF  4A
12B8:  MOVLP  08
12B9:  MOVLB  00
12BA:  CALL   6E3
12BB:  MOVLP  10
12BC:  MOVF   78,W
12BD:  MOVLB  02
12BE:  MOVWF  32
12BF:  MOVWF  35
12C0:  MOVLP  08
12C1:  MOVLB  00
12C2:  CALL   7BD
12C3:  MOVLP  10
....................       PROMPT_FLAG=1; 
12C4:  MOVLB  01
12C5:  BSF    5B.5
....................       break; 
12C6:  MOVLB  00
12C7:  GOTO   51C
....................     case STATUS: 
....................       status(); 
....................       break; 
*
1497:  MOVLB  00
1498:  GOTO   51C
....................     case ADMIN: 
....................       switch(argument) { 
1499:  MOVF   75,W
149A:  XORLW  02
149B:  BTFSC  03.2
149C:  GOTO   4A4
149D:  XORLW  03
149E:  BTFSC  03.2
149F:  GOTO   4AB
14A0:  XORLW  02
14A1:  BTFSC  03.2
14A2:  GOTO   4B3
14A3:  GOTO   4B5
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
14A4:  MOVLP  08
14A5:  CALL   7AE
14A6:  MOVLP  10
14A7:  MOVF   78,F
14A8:  BTFSS  03.2
....................             reset_cpu(); 
14A9:  RESET
....................           } 
....................           break; 
14AA:  GOTO   4BB
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
14AB:  MOVLW  01
14AC:  MOVLB  02
14AD:  MOVWF  46
14AE:  MOVLP  08
14AF:  MOVLB  00
14B0:  CALL   506
14B1:  MOVLP  10
....................           break; 
14B2:  GOTO   4BB
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
14B3:  CALL   061
....................         break; 
14B4:  GOTO   4BB
....................         default: 
....................           set_admin_mode(0); 
14B5:  MOVLB  02
14B6:  CLRF   46
14B7:  MOVLP  08
14B8:  MOVLB  00
14B9:  CALL   506
14BA:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
14BB:  GOTO   51C
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
....................       lcd_cmd=4+(value&0x03); 
14BC:  MOVF   76,W
14BD:  ANDLW  03
14BE:  ADDLW  04
14BF:  MOVLB  02
14C0:  MOVWF  29
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
14C1:  MOVLW  20
14C2:  MOVLB  01
14C3:  MOVWF  62
14C4:  MOVLW  74
14C5:  MOVWF  61
14C6:  MOVLW  34
14C7:  MOVLB  03
14C8:  MOVWF  11
14C9:  MOVLW  04
14CA:  MOVWF  12
14CB:  BCF    03.0
14CC:  MOVLW  04
14CD:  MOVLB  02
14CE:  MOVWF  50
14CF:  MOVLP  08
14D0:  MOVLB  00
14D1:  CALL   173
14D2:  MOVLP  10
14D3:  MOVLW  60
14D4:  MOVLB  02
14D5:  MOVWF  50
14D6:  MOVLW  18
14D7:  MOVWF  51
14D8:  MOVLP  08
14D9:  MOVLB  00
14DA:  CALL   23F
14DB:  MOVLP  10
14DC:  MOVLW  37
14DD:  MOVLB  03
14DE:  MOVWF  11
14DF:  MOVLW  04
14E0:  MOVWF  12
14E1:  BCF    03.0
14E2:  MOVLW  08
14E3:  MOVLB  02
14E4:  MOVWF  50
14E5:  MOVLP  08
14E6:  MOVLB  00
14E7:  CALL   173
14E8:  MOVLP  10
14E9:  MOVLB  02
14EA:  MOVF   29,W
14EB:  MOVWF  50
14EC:  MOVLW  18
14ED:  MOVWF  51
14EE:  MOVLP  08
14EF:  MOVLB  00
14F0:  CALL   23F
14F1:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
14F2:  MOVLW  0A
14F3:  CLRWDT
14F4:  BTFSS  11.4
14F5:  GOTO   4F3
14F6:  MOVLB  03
14F7:  MOVWF  1A
14F8:  MOVLW  0D
14F9:  CLRWDT
14FA:  MOVLB  00
14FB:  BTFSC  11.4
14FC:  GOTO   4FF
14FD:  MOVLB  03
14FE:  GOTO   4F9
14FF:  MOVLB  03
1500:  MOVWF  1A
1501:  MOVLW  20
1502:  MOVWF  05
1503:  MOVLW  74
1504:  MOVWF  04
1505:  MOVLP  08
1506:  MOVLB  00
1507:  CALL   2A6
1508:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
1509:  MOVLB  02
150A:  MOVF   29,W
150B:  MOVWF  50
150C:  MOVLW  20
150D:  MOVWF  52
150E:  MOVLW  74
150F:  MOVWF  51
1510:  MOVLP  08
1511:  MOVLB  00
1512:  CALL   1DB
1513:  MOVLP  10
....................       break; 
1514:  GOTO   51C
....................     case MORSE_SEND: 
....................       morse(value); 
1515:  MOVF   76,W
1516:  MOVLB  02
1517:  MOVWF  45
1518:  MOVLP  08
1519:  MOVLB  00
151A:  CALL   0E9
151B:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
151C:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  50
1803:  MOVLW  20
1804:  MOVWF  52
1805:  MOVLW  4E
1806:  MOVWF  51
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   1DB
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVWF  75
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B62:  MOVLB  01
1B63:  CLRF   6D
1B64:  CLRF   6C
1B65:  MOVF   6D,F
1B66:  BTFSS  03.2
1B67:  GOTO   3B6
1B68:  MOVF   6C,W
1B69:  SUBLW  37
1B6A:  BTFSS  03.0
1B6B:  GOTO   3B6
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B6C:  MOVLW  01
1B6D:  MOVWF  7A
1B6E:  MOVLW  8B
1B6F:  MOVLB  02
1B70:  MOVWF  26
1B71:  MOVF   7A,W
1B72:  MOVWF  27
1B73:  MOVLB  01
1B74:  MOVF   6D,W
1B75:  MOVLB  02
1B76:  MOVWF  44
1B77:  MOVLB  01
1B78:  MOVF   6C,W
1B79:  MOVLB  02
1B7A:  MOVWF  43
1B7B:  CLRF   46
1B7C:  MOVLW  06
1B7D:  MOVWF  45
1B7E:  MOVLP  08
1B7F:  MOVLB  00
1B80:  CALL   76C
1B81:  MOVLP  18
1B82:  MOVF   78,W
1B83:  MOVLB  02
1B84:  ADDWF  26,W
1B85:  MOVLB  01
1B86:  MOVWF  6E
1B87:  MOVF   79,W
1B88:  MOVLB  02
1B89:  ADDWFC 27,W
1B8A:  MOVLB  01
1B8B:  MOVWF  6F
....................     romstrcpy(rname,cPtr); 
1B8C:  MOVLW  20
1B8D:  MOVLB  02
1B8E:  MOVWF  42
1B8F:  MOVLW  A0
1B90:  MOVWF  41
1B91:  MOVLB  01
1B92:  MOVF   6F,W
1B93:  MOVLB  02
1B94:  MOVWF  44
1B95:  MOVLB  01
1B96:  MOVF   6E,W
1B97:  MOVLB  02
1B98:  MOVWF  43
1B99:  MOVLP  08
1B9A:  MOVLB  00
1B9B:  CALL   783
1B9C:  MOVLP  18
....................     if(my_stricmp(argument_name,rname)==0) { 
1B9D:  MOVLW  20
1B9E:  MOVLB  02
1B9F:  MOVWF  46
1BA0:  MOVLW  6E
1BA1:  MOVWF  45
1BA2:  MOVLW  20
1BA3:  MOVWF  48
1BA4:  MOVLW  A0
1BA5:  MOVWF  47
1BA6:  MOVLP  08
1BA7:  MOVLB  00
1BA8:  CALL   743
1BA9:  MOVLP  18
1BAA:  MOVF   78,F
1BAB:  BTFSS  03.2
1BAC:  GOTO   3B1
....................       argument=x; 
1BAD:  MOVLB  01
1BAE:  MOVF   6C,W
1BAF:  MOVWF  75
1BB0:  MOVLB  00
....................     } 
....................   } 
1BB1:  MOVLB  01
1BB2:  INCF   6C,F
1BB3:  BTFSC  03.2
1BB4:  INCF   6D,F
1BB5:  GOTO   365
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BB6:  MOVF   75,W
1BB7:  SUBLW  FF
1BB8:  BTFSS  03.2
1BB9:  GOTO   41A
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BBA:  MOVLW  20
1BBB:  MOVLB  02
1BBC:  MOVWF  46
1BBD:  MOVLW  6E
1BBE:  MOVWF  45
1BBF:  MOVLP  08
1BC0:  MOVLB  00
1BC1:  CALL   70A
1BC2:  MOVLP  18
1BC3:  MOVF   78,W
1BC4:  MOVWF  76
....................     strcpy(rname,"eeprom"); 
1BC5:  MOVLB  02
1BC6:  CLRF   26
1BC7:  CLRF   27
1BC8:  MOVLW  20
1BC9:  MOVWF  05
1BCA:  MOVLW  A0
1BCB:  MOVWF  04
1BCC:  MOVF   26,W
1BCD:  ADDWF  04,F
1BCE:  MOVLW  00
1BCF:  ADDWFC 05,F
1BD0:  MOVF   27,W
1BD1:  MOVLP  00
1BD2:  MOVLB  00
1BD3:  CALL   124
1BD4:  MOVLP  18
1BD5:  MOVWF  00
1BD6:  IORLW  00
1BD7:  BTFSC  03.2
1BD8:  GOTO   3DE
1BD9:  MOVLB  02
1BDA:  INCF   27,F
1BDB:  INCF   26,F
1BDC:  GOTO   3C8
1BDD:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1BDE:  MOVLW  20
1BDF:  MOVLB  02
1BE0:  MOVWF  46
1BE1:  MOVLW  6E
1BE2:  MOVWF  45
1BE3:  MOVLW  20
1BE4:  MOVWF  48
1BE5:  MOVLW  A0
1BE6:  MOVWF  47
1BE7:  MOVLP  08
1BE8:  MOVLB  00
1BE9:  CALL   743
1BEA:  MOVLP  18
1BEB:  MOVF   78,F
1BEC:  BTFSS  03.2
1BED:  GOTO   3F0
....................       value=USE_EEPROM_VARS; 
1BEE:  MOVLW  01
1BEF:  MOVWF  76
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BF0:  MOVLB  02
1BF1:  CLRF   26
1BF2:  CLRF   27
1BF3:  MOVLW  20
1BF4:  MOVWF  05
1BF5:  MOVLW  A0
1BF6:  MOVWF  04
1BF7:  MOVF   26,W
1BF8:  ADDWF  04,F
1BF9:  MOVLW  00
1BFA:  ADDWFC 05,F
1BFB:  MOVF   27,W
1BFC:  MOVLP  00
1BFD:  MOVLB  00
1BFE:  CALL   12C
1BFF:  MOVLP  18
1C00:  MOVWF  00
1C01:  IORLW  00
1C02:  BTFSC  03.2
1C03:  GOTO   409
1C04:  MOVLB  02
1C05:  INCF   27,F
1C06:  INCF   26,F
1C07:  GOTO   3F3
1C08:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C09:  MOVLW  20
1C0A:  MOVLB  02
1C0B:  MOVWF  46
1C0C:  MOVLW  6E
1C0D:  MOVWF  45
1C0E:  MOVLW  20
1C0F:  MOVWF  48
1C10:  MOVLW  A0
1C11:  MOVWF  47
1C12:  MOVLP  08
1C13:  MOVLB  00
1C14:  CALL   743
1C15:  MOVLP  18
1C16:  MOVF   78,F
1C17:  BTFSC  03.2
....................       value=USE_DEFAULT_VARS; 
1C18:  CLRF   76
1C19:  MOVLB  01
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C1A:  MOVF   70,W
1C1B:  SUBLW  06
1C1C:  BTFSC  03.2
1C1D:  GOTO   422
1C1E:  MOVF   70,W
1C1F:  SUBLW  07
1C20:  BTFSS  03.2
1C21:  GOTO   426
....................     value = 1; 
1C22:  MOVLW  01
1C23:  MOVWF  76
....................     argument = CurrentTrimPot; 
1C24:  MOVF   74,W
1C25:  MOVWF  75
....................   } 
....................   rs232_mode = 1; 
1C26:  BSF    5B.7
....................   execute_command(); 
1C27:  MOVLP  10
1C28:  MOVLB  00
1C29:  CALL   0A3
1C2A:  MOVLP  18
....................   rs232_mode = 0; 
1C2B:  MOVLB  01
1C2C:  BCF    5B.7
.................... } // }}} 
1C2D:  MOVLP  18
1C2E:  MOVLB  00
1C2F:  GOTO   66F (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
12C8:  MOVLW  1B
12C9:  MOVLP  00
12CA:  CALL   2DA
12CB:  MOVLP  10
....................   printf("[2J"); 
12CC:  MOVLW  5B
12CD:  CLRWDT
12CE:  BTFSS  11.4
12CF:  GOTO   2CD
12D0:  MOVLB  03
12D1:  MOVWF  1A
12D2:  MOVLW  32
12D3:  CLRWDT
12D4:  MOVLB  00
12D5:  BTFSC  11.4
12D6:  GOTO   2D9
12D7:  MOVLB  03
12D8:  GOTO   2D3
12D9:  MOVLB  03
12DA:  MOVWF  1A
12DB:  MOVLW  4A
12DC:  CLRWDT
12DD:  MOVLB  00
12DE:  BTFSC  11.4
12DF:  GOTO   2E2
12E0:  MOVLB  03
12E1:  GOTO   2DC
12E2:  MOVLB  03
12E3:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
12E4:  MOVLW  1B
12E5:  MOVLP  00
12E6:  MOVLB  00
12E7:  CALL   2DA
12E8:  MOVLP  10
....................   printf("[0;0H"); 
12E9:  MOVLW  3D
12EA:  MOVLB  03
12EB:  MOVWF  11
12EC:  MOVLW  04
12ED:  MOVWF  12
12EE:  MOVLP  00
12EF:  MOVLB  00
12F0:  CALL   530
12F1:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
0800:  MOVLB  02
0801:  SWAPF  45,W
0802:  MOVWF  47
0803:  RLF    47,F
0804:  RLF    47,F
0805:  MOVLW  C0
0806:  ANDWF  47,F
....................   tx_value=tx_value + (value & 0x3F); 
0807:  MOVF   46,W
0808:  ANDLW  3F
0809:  ADDWF  47,F
....................   i2c_start(); 
080A:  MOVLB  04
080B:  BSF    16.0
080C:  BTFSC  16.0
080D:  GOTO   00C
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
080E:  MOVLW  50
080F:  MOVLB  02
0810:  MOVWF  56
0811:  MOVLP  00
0812:  MOVLB  00
0813:  CALL   6F3
0814:  MOVLP  08
0815:  MOVF   78,W
0816:  MOVLB  02
0817:  BCF    48.0
0818:  BTFSC  78.0
0819:  BSF    48.0
....................   if ( ack != 0) { 
081A:  BTFSS  48.0
081B:  GOTO   037
....................     printf("\n\rI2C : No ACK : %u",ack); 
081C:  MOVLW  00
081D:  BTFSC  48.0
081E:  MOVLW  01
081F:  MOVWF  49
0820:  MOVLW  40
0821:  MOVLB  03
0822:  MOVWF  11
0823:  MOVLW  04
0824:  MOVWF  12
0825:  BCF    03.0
0826:  MOVLW  11
0827:  MOVLB  02
0828:  MOVWF  56
0829:  MOVLP  00
082A:  MOVLB  00
082B:  CALL   708
082C:  MOVLP  08
082D:  MOVLB  02
082E:  MOVF   49,W
082F:  MOVWF  56
0830:  MOVLW  1B
0831:  MOVWF  57
0832:  MOVLP  00
0833:  MOVLB  00
0834:  CALL   77C
0835:  MOVLP  08
0836:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
0837:  MOVF   47,W
0838:  MOVWF  56
0839:  MOVLP  00
083A:  MOVLB  00
083B:  CALL   6F3
083C:  MOVLP  08
....................   i2c_stop();   
083D:  MOVLB  04
083E:  BSF    16.2
083F:  BTFSC  16.2
0840:  GOTO   03F
....................   printf("\n\rPot(%u)<=%u",pot,value); 
0841:  MOVLW  4A
0842:  MOVLB  03
0843:  MOVWF  11
0844:  MOVLW  04
0845:  MOVWF  12
0846:  BCF    03.0
0847:  MOVLW  06
0848:  MOVLB  02
0849:  MOVWF  56
084A:  MOVLP  00
084B:  MOVLB  00
084C:  CALL   708
084D:  MOVLP  08
084E:  MOVLB  02
084F:  MOVF   45,W
0850:  MOVWF  56
0851:  MOVLW  1B
0852:  MOVWF  57
0853:  MOVLP  00
0854:  MOVLB  00
0855:  CALL   77C
0856:  MOVLP  08
0857:  MOVLW  29
0858:  CLRWDT
0859:  BTFSS  11.4
085A:  GOTO   058
085B:  MOVLB  03
085C:  MOVWF  1A
085D:  MOVLW  3C
085E:  CLRWDT
085F:  MOVLB  00
0860:  BTFSC  11.4
0861:  GOTO   064
0862:  MOVLB  03
0863:  GOTO   05E
0864:  MOVLB  03
0865:  MOVWF  1A
0866:  MOVLW  3D
0867:  CLRWDT
0868:  MOVLB  00
0869:  BTFSC  11.4
086A:  GOTO   06D
086B:  MOVLB  03
086C:  GOTO   067
086D:  MOVLB  03
086E:  MOVWF  1A
086F:  MOVLB  02
0870:  MOVF   46,W
0871:  MOVWF  56
0872:  MOVLW  1B
0873:  MOVWF  57
0874:  MOVLP  00
0875:  MOVLB  00
0876:  CALL   77C
0877:  MOVLP  08
....................  
.................... } // }}} 
0878:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
08E9:  MOVLW  DB
08EA:  MOVLB  02
08EB:  ADDWF  45,W
08EC:  MOVWF  49
08ED:  MOVLW  1F
08EE:  MOVWF  4A
08EF:  BTFSC  03.0
08F0:  INCF   4A,F
08F1:  MOVF   4A,W
08F2:  MOVLB  03
08F3:  MOVWF  12
08F4:  MOVLB  02
08F5:  MOVF   49,W
08F6:  MOVLB  03
08F7:  MOVWF  11
08F8:  MOVLW  20
08F9:  MOVWF  05
08FA:  MOVLW  C6
08FB:  MOVWF  04
08FC:  MOVLW  01
08FD:  MOVLB  02
08FE:  MOVWF  4B
08FF:  MOVLP  00
0900:  MOVLB  00
0901:  CALL   7E4
0902:  MOVLP  08
....................    
....................   PROMPT_FLAG=1; 
0903:  MOVLB  01
0904:  BSF    5B.5
....................   for(x=0;x<4;x++) { 
0905:  MOVLB  02
0906:  CLRF   47
0907:  MOVF   47,W
0908:  SUBLW  03
0909:  BTFSS  03.0
090A:  GOTO   131
....................     do_delay=1; 
090B:  BSF    48.0
....................     switch(mc & 0xc0) { // Check two MSB's 
090C:  MOVF   46,W
090D:  ANDLW  C0
090E:  XORLW  40
090F:  MOVLB  00
0910:  BTFSC  03.2
0911:  GOTO   116
0912:  XORLW  C0
0913:  BTFSC  03.2
0914:  GOTO   118
0915:  GOTO   11A
....................       case(0x40): 
....................         dit(); 
0916:  CALL   079
....................         break; 
0917:  GOTO   11D
....................       case(0x80): 
....................         dah(); 
0918:  CALL   0B1
....................         break; 
0919:  GOTO   11D
....................       default: 
....................         do_delay=0; 
091A:  MOVLB  02
091B:  BCF    48.0
....................         break; 
091C:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
091D:  MOVLB  02
091E:  RLF    46,F
091F:  RLF    46,F
0920:  MOVLW  FC
0921:  ANDWF  46,F
....................     if ( do_delay ) { 
0922:  BTFSS  48.0
0923:  GOTO   12F
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
0924:  MOVLB  01
0925:  CLRF   31
0926:  MOVLW  02
0927:  MOVWF  30
....................       while(aux_timer) { 
0928:  MOVF   30,W
0929:  IORWF  31,W
092A:  BTFSC  03.2
092B:  GOTO   12E
....................         delay_cycles(1); 
092C:  NOP
....................       } 
092D:  GOTO   128
092E:  MOVLB  02
....................     } 
....................   } 
092F:  INCF   47,F
0930:  GOTO   107
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
0931:  MOVF   45,W
0932:  SUBLW  09
0933:  BTFSS  03.0
0934:  GOTO   140
....................     if ( c < 5 ) { 
0935:  MOVF   45,W
0936:  SUBLW  04
0937:  BTFSS  03.0
0938:  GOTO   13D
....................       dah(); 
0939:  MOVLB  00
093A:  CALL   0B1
....................     } 
....................     else { 
093B:  GOTO   13F
093C:  MOVLB  02
....................       dit(); 
093D:  MOVLB  00
093E:  CALL   079
093F:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
0940:  MOVLB  00
0941:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0BB4:  MOVLW  30
0BB5:  MOVLB  02
0BB6:  MOVWF  3A
0BB7:  MOVWF  3B
0BB8:  MOVWF  3C
0BB9:  MOVWF  3D
0BBA:  CLRF   3E
....................   char PTT_s[5]={'0','0','0','0',0}; 
0BBB:  MOVWF  3F
0BBC:  MOVWF  40
0BBD:  MOVWF  41
0BBE:  MOVWF  42
0BBF:  CLRF   43
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0BC0:  MOVF   34,W
0BC1:  MOVLB  00
0BC2:  MOVWF  6B
....................  
....................   if ( cor ) { 
0BC3:  MOVLB  02
0BC4:  MOVF   34,F
0BC5:  BTFSC  03.2
0BC6:  GOTO   3D8
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0BC7:  MOVLW  01
0BC8:  SUBWF  34,W
0BC9:  ADDLW  29
0BCA:  MOVWF  04
0BCB:  MOVLW  20
0BCC:  MOVWF  05
0BCD:  BTFSC  03.0
0BCE:  INCF   05,F
0BCF:  MOVF   00,W
0BD0:  MOVWF  45
0BD1:  MOVLB  00
0BD2:  MOVF   60,W
0BD3:  ANDWF  61,W
0BD4:  MOVLB  02
0BD5:  ANDWF  45,W
0BD6:  MOVWF  39
....................   } else { 
0BD7:  GOTO   421
....................     ptt=0; 
0BD8:  CLRF   39
....................     if ( COR_DROP_FLAG ) { 
0BD9:  BTFSS  72.7
0BDA:  GOTO   421
....................       COR_DROP_FLAG=0; 
0BDB:  BCF    72.7
....................       if ( ConfirmChar || TailChar ) { 
0BDC:  MOVLB  00
0BDD:  MOVF   69,F
0BDE:  BTFSS  03.2
0BDF:  GOTO   3E3
0BE0:  MOVF   68,F
0BE1:  BTFSC  03.2
0BE2:  GOTO   420
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0C21:  MOVLW  01
0C22:  MOVWF  38
....................   for(x=0;x<4;x++) { 
0C23:  CLRF   35
0C24:  MOVF   35,W
0C25:  SUBLW  03
0C26:  BTFSS  03.0
0C27:  GOTO   48C
....................     if ( !cor ) { 
0C28:  MOVF   34,F
0C29:  BTFSS  03.2
0C2A:  GOTO   42E
....................       rx_bit=0; 
0C2B:  BCF    44.0
....................       ptt_bit=0; 
0C2C:  BCF    44.1
....................     } else { 
0C2D:  GOTO   441
....................       if ( cor == (x+1) ) { 
0C2E:  MOVLW  01
0C2F:  ADDWF  35,W
0C30:  SUBWF  34,W
0C31:  BTFSS  03.2
0C32:  GOTO   439
....................         rx_bit=1; 
0C33:  BSF    44.0
....................         CurrentCorMask=mask; 
0C34:  MOVF   38,W
0C35:  MOVLB  00
0C36:  MOVWF  6A
....................       } else { 
0C37:  GOTO   43B
0C38:  MOVLB  02
....................         rx_bit=0; 
0C39:  BCF    44.0
0C3A:  MOVLB  00
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0C3B:  MOVLB  02
0C3C:  BCF    44.1
0C3D:  MOVF   39,W
0C3E:  ANDWF  38,W
0C3F:  BTFSS  03.2
0C40:  BSF    44.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0C41:  MOVF   35,W
0C42:  MOVLP  00
0C43:  MOVLB  00
0C44:  CALL   031
0C45:  MOVLP  08
0C46:  MOVLB  02
0C47:  MOVWF  45
0C48:  MOVLW  00
0C49:  BTFSC  44.0
0C4A:  MOVLW  01
0C4B:  MOVWF  77
0C4C:  MOVF   45,W
0C4D:  MOVWF  46
0C4E:  MOVF   77,W
0C4F:  MOVWF  47
0C50:  MOVLW  01
0C51:  MOVWF  49
0C52:  CLRF   48
0C53:  MOVLB  00
0C54:  CALL   142
0C55:  MOVLB  02
0C56:  MOVF   45,W
0C57:  MOVWF  46
0C58:  CLRF   47
0C59:  CLRF   49
0C5A:  MOVLW  80
0C5B:  MOVWF  48
0C5C:  MOVLB  00
0C5D:  CALL   142
....................     output_bit(PTT_PIN[x],ptt_bit); 
0C5E:  MOVLB  02
0C5F:  MOVF   35,W
0C60:  MOVLP  00
0C61:  MOVLB  00
0C62:  CALL   036
0C63:  MOVLP  08
0C64:  MOVLB  02
0C65:  MOVWF  45
0C66:  MOVLW  00
0C67:  BTFSC  44.1
0C68:  MOVLW  01
0C69:  MOVWF  77
0C6A:  MOVF   45,W
0C6B:  MOVWF  46
0C6C:  MOVF   77,W
0C6D:  MOVWF  47
0C6E:  MOVLW  01
0C6F:  MOVWF  49
0C70:  CLRF   48
0C71:  MOVLB  00
0C72:  CALL   142
0C73:  MOVLB  02
0C74:  MOVF   45,W
0C75:  MOVWF  46
0C76:  CLRF   47
0C77:  CLRF   49
0C78:  MOVLW  80
0C79:  MOVWF  48
0C7A:  MOVLB  00
0C7B:  CALL   142
....................     if(ptt_bit) { 
0C7C:  MOVLB  02
0C7D:  BTFSS  44.1
0C7E:  GOTO   488
....................       PTT_s[x]='1'; 
0C7F:  MOVLW  BF
0C80:  ADDWF  35,W
0C81:  MOVWF  04
0C82:  MOVLW  20
0C83:  MOVWF  05
0C84:  BTFSC  03.0
0C85:  INCF   05,F
0C86:  MOVLW  31
0C87:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C88:  BCF    03.0
0C89:  RLF    38,F
....................   }  
0C8A:  INCF   35,F
0C8B:  GOTO   424
....................   if(!cor) { 
0C8C:  MOVF   34,F
0C8D:  BTFSS  03.2
0C8E:  GOTO   493
....................     CurrentCorPriority=0; 
0C8F:  MOVLB  00
0C90:  CLRF   6C
....................   } else { 
0C91:  GOTO   4C1
0C92:  MOVLB  02
....................     CurrentCorPriority=RXPriority[cor-1]; 
0C93:  MOVLW  01
0C94:  SUBWF  34,W
0C95:  ADDLW  25
0C96:  MOVWF  04
0C97:  MOVLW  20
0C98:  MOVWF  05
0C99:  BTFSC  03.0
0C9A:  INCF   05,F
0C9B:  MOVF   00,W
0C9C:  MOVLB  00
0C9D:  MOVWF  6C
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0C9E:  MOVLB  02
0C9F:  CLRF   36
0CA0:  MOVF   36,W
0CA1:  SUBLW  03
0CA2:  BTFSS  03.0
0CA3:  GOTO   4BE
....................       pot_val=RX_GAIN[cor-1][pot]; 
0CA4:  MOVLW  01
0CA5:  SUBWF  34,W
0CA6:  MOVWF  77
0CA7:  RLF    77,F
0CA8:  RLF    77,F
0CA9:  MOVLW  FC
0CAA:  ANDWF  77,F
0CAB:  MOVF   77,W
0CAC:  ADDWF  36,W
0CAD:  ADDLW  0C
0CAE:  MOVWF  04
0CAF:  MOVLW  20
0CB0:  MOVWF  05
0CB1:  BTFSC  03.0
0CB2:  INCF   05,F
0CB3:  MOVF   00,W
0CB4:  MOVWF  37
....................       set_trimpot(pot,pot_val); 
0CB5:  MOVF   36,W
0CB6:  MOVWF  45
0CB7:  MOVF   37,W
0CB8:  MOVWF  46
0CB9:  MOVLB  00
0CBA:  CALL   000
....................     } 
0CBB:  MOVLB  02
0CBC:  INCF   36,F
0CBD:  GOTO   4A0
....................     PROMPT_FLAG=1; 
0CBE:  MOVLB  01
0CBF:  BSF    5B.5
0CC0:  MOVLB  00
....................   } 
....................   if(cor>0) { 
0CC1:  MOVLB  02
0CC2:  MOVF   34,F
0CC3:  BTFSC  03.2
0CC4:  GOTO   4CF
....................     COR_s[cor-1]='1'; 
0CC5:  MOVLW  01
0CC6:  SUBWF  34,W
0CC7:  ADDLW  BA
0CC8:  MOVWF  04
0CC9:  MOVLW  20
0CCA:  MOVWF  05
0CCB:  BTFSC  03.0
0CCC:  INCF   05,F
0CCD:  MOVLW  31
0CCE:  MOVWF  00
....................   } 
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0CCF:  MOVLW  20
0CD0:  MOVLB  01
0CD1:  MOVWF  62
0CD2:  MOVLW  74
0CD3:  MOVWF  61
0CD4:  MOVLW  51
0CD5:  MOVLB  03
0CD6:  MOVWF  11
0CD7:  MOVLW  04
0CD8:  MOVWF  12
0CD9:  BCF    03.0
0CDA:  MOVLW  04
0CDB:  MOVLB  02
0CDC:  MOVWF  50
0CDD:  MOVLB  00
0CDE:  CALL   173
0CDF:  MOVLW  20
0CE0:  MOVWF  05
0CE1:  MOVLW  BA
0CE2:  MOVWF  04
0CE3:  CALL   1C6
0CE4:  MOVLW  54
0CE5:  MOVLB  03
0CE6:  MOVWF  11
0CE7:  MOVLW  04
0CE8:  MOVWF  12
0CE9:  BCF    03.0
0CEA:  MOVLW  05
0CEB:  MOVLB  02
0CEC:  MOVWF  50
0CED:  MOVLB  00
0CEE:  CALL   173
0CEF:  MOVLW  20
0CF0:  MOVWF  05
0CF1:  MOVLW  BF
0CF2:  MOVWF  04
0CF3:  CALL   1C6
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0CF4:  MOVLW  01
0CF5:  MOVLB  02
0CF6:  MOVWF  50
0CF7:  MOVLW  20
0CF8:  MOVWF  52
0CF9:  MOVLW  74
0CFA:  MOVWF  51
0CFB:  MOVLB  00
0CFC:  CALL   1DB
....................   delay_ms(50); 
0CFD:  MOVLW  32
0CFE:  MOVLB  02
0CFF:  MOVWF  50
0D00:  MOVLP  00
0D01:  MOVLB  00
0D02:  CALL   7CB
0D03:  MOVLP  08
....................   pot_values_to_lcd(); 
0D04:  CALL   2C0
.................... }// }}} 
0D05:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1D05:  MOVF   6E,W
1D06:  SUBLW  0A
1D07:  BTFSS  03.0
1D08:  GOTO   523
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1D09:  MOVLW  62
1D0A:  ADDWF  6E,W
1D0B:  MOVWF  04
1D0C:  MOVLW  20
1D0D:  MOVWF  05
1D0E:  BTFSC  03.0
1D0F:  INCF   05,F
1D10:  BTFSS  00.4
1D11:  GOTO   521
1D12:  MOVLW  62
1D13:  ADDWF  6E,W
1D14:  MOVWF  04
1D15:  MOVLW  20
1D16:  MOVWF  05
1D17:  BTFSC  03.0
1D18:  INCF   05,F
1D19:  MOVF   00,W
1D1A:  ANDLW  0F
1D1B:  SUBLW  0C
1D1C:  BTFSC  03.2
1D1D:  GOTO   521
....................       strobe=1; 
1D1E:  MOVLW  01
1D1F:  MOVWF  6F
....................      } else { 
1D20:  GOTO   522
....................       strobe = 0; 
1D21:  CLRF   6F
....................     }  
....................   } else { 
1D22:  GOTO   524
....................     strobe=0; 
1D23:  CLRF   6F
....................   } 
....................   return(strobe); 
1D24:  MOVF   6F,W
1D25:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
1778:  MOVLB  01
1779:  MOVF   6E,W
177A:  SUBWF  6F,W
177B:  BTFSS  03.0
177C:  GOTO   7A8
177D:  MOVF   6E,W
177E:  SUBLW  09
177F:  BTFSS  03.0
1780:  GOTO   7A8
....................     valid=1; 
1781:  MOVLB  02
1782:  BSF    22.0
....................     for(x=a;x<=b;x++) { 
1783:  MOVLB  01
1784:  MOVF   6E,W
1785:  MOVLB  02
1786:  MOVWF  21
1787:  MOVF   21,W
1788:  MOVLB  01
1789:  SUBWF  6F,W
178A:  BTFSS  03.0
178B:  GOTO   7A7
....................       key=(int)DTMF_ARRAY[x].Key; 
178C:  MOVLW  62
178D:  MOVLB  02
178E:  ADDWF  21,W
178F:  MOVWF  04
1790:  MOVLW  20
1791:  MOVWF  05
1792:  BTFSC  03.0
1793:  INCF   05,F
1794:  MOVF   00,W
1795:  ANDLW  0F
1796:  MOVWF  20
....................       if(! DTMF_ARRAY[x].Strobe ) { 
1797:  MOVLW  62
1798:  ADDWF  21,W
1799:  MOVWF  04
179A:  MOVLW  20
179B:  MOVWF  05
179C:  BTFSC  03.0
179D:  INCF   05,F
179E:  BTFSS  00.4
....................         valid=0; 
179F:  BCF    22.0
....................       } 
....................      if(key==dp) { 
17A0:  MOVF   20,W
17A1:  SUBLW  0C
17A2:  BTFSC  03.2
....................         valid=0; 
17A3:  BCF    22.0
....................       } 
....................     } 
17A4:  INCF   21,F
17A5:  GOTO   787
17A6:  MOVLB  01
....................   } else { 
17A7:  GOTO   7AB
....................     valid=0; 
17A8:  MOVLB  02
17A9:  BCF    22.0
17AA:  MOVLB  01
....................   } 
....................   return(valid); 
17AB:  MOVLW  00
17AC:  MOVLB  02
17AD:  BTFSC  22.0
17AE:  MOVLW  01
17AF:  MOVWF  78
.................... } // }}} 
17B0:  MOVLB  00
17B1:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   unsigned int site_id; 
....................   unsigned digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : DTMF send 
....................   // 11 : Morse send 
....................   // 12 : Send to I2C 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   value = 0; 
*
1CBD:  CLRF   76
....................   command=0; 
1CBE:  CLRF   70
....................   if ( ValidKeyRange(0,5)) { 
1CBF:  MOVLB  01
1CC0:  CLRF   6E
1CC1:  MOVLW  05
1CC2:  MOVWF  6F
1CC3:  MOVLP  10
1CC4:  MOVLB  00
1CC5:  CALL   778
1CC6:  MOVLP  18
1CC7:  MOVF   78,F
1CC8:  BTFSC  03.2
1CC9:  GOTO   555
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1CCA:  MOVLB  01
1CCB:  MOVF   32,W
1CCC:  ANDLW  0F
1CCD:  MOVWF  6F
1CCE:  MOVLB  02
1CCF:  MOVWF  49
1CD0:  MOVLW  0A
1CD1:  MOVWF  4A
1CD2:  MOVLP  08
1CD3:  MOVLB  00
1CD4:  CALL   6E3
1CD5:  MOVLP  18
1CD6:  MOVF   78,W
1CD7:  MOVLB  01
1CD8:  MOVWF  6E
1CD9:  MOVF   33,W
1CDA:  ANDLW  0F
1CDB:  ADDWF  6E,W
1CDC:  MOVWF  6C
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1CDD:  MOVF   34,W
1CDE:  ANDLW  0F
1CDF:  MOVWF  6F
1CE0:  MOVLB  02
1CE1:  MOVWF  49
1CE2:  MOVLW  0A
1CE3:  MOVWF  4A
1CE4:  MOVLP  08
1CE5:  MOVLB  00
1CE6:  CALL   6E3
1CE7:  MOVLP  18
1CE8:  MOVF   78,W
1CE9:  MOVLB  01
1CEA:  MOVWF  6E
1CEB:  MOVF   35,W
1CEC:  ANDLW  0F
1CED:  ADDWF  6E,W
1CEE:  MOVWF  70
....................     argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1CEF:  MOVF   36,W
1CF0:  ANDLW  0F
1CF1:  MOVWF  6F
1CF2:  MOVLB  02
1CF3:  MOVWF  49
1CF4:  MOVLW  0A
1CF5:  MOVWF  4A
1CF6:  MOVLP  08
1CF7:  MOVLB  00
1CF8:  CALL   6E3
1CF9:  MOVLP  18
1CFA:  MOVF   78,W
1CFB:  MOVLB  01
1CFC:  MOVWF  6E
1CFD:  MOVF   37,W
1CFE:  ANDLW  0F
1CFF:  ADDWF  6E,W
1D00:  MOVWF  75
....................     digit=6; 
1D01:  MOVLW  06
1D02:  MOVWF  6D
....................     while(ValidKey(digit)) { 
1D03:  MOVF   6D,W
1D04:  MOVWF  6E
*
1D26:  MOVF   78,F
1D27:  BTFSC  03.2
1D28:  GOTO   542
....................      value = value * 10 + DTMF_ARRAY[digit].Key; 
1D29:  MOVF   76,W
1D2A:  MOVLB  02
1D2B:  MOVWF  49
1D2C:  MOVLW  0A
1D2D:  MOVWF  4A
1D2E:  MOVLP  08
1D2F:  MOVLB  00
1D30:  CALL   6E3
1D31:  MOVLP  18
1D32:  MOVF   78,W
1D33:  MOVLB  01
1D34:  MOVWF  6E
1D35:  MOVLW  62
1D36:  ADDWF  6D,W
1D37:  MOVWF  04
1D38:  MOVLW  20
1D39:  MOVWF  05
1D3A:  BTFSC  03.0
1D3B:  INCF   05,F
1D3C:  MOVF   00,W
1D3D:  ANDLW  0F
1D3E:  ADDWF  6E,W
1D3F:  MOVWF  76
....................      digit++; 
1D40:  INCF   6D,F
....................     } 
1D41:  GOTO   503
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1D42:  MOVF   70,W
1D43:  XORLW  04
1D44:  MOVLB  00
1D45:  BTFSC  03.2
1D46:  GOTO   54A
1D47:  XORLW  01
1D48:  BTFSS  03.2
1D49:  GOTO   54C
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1D4A:  MOVF   75,W
1D4B:  MOVWF  76
....................         break; 
....................     } 
....................     if ( site_id == SiteID ) { 
1D4C:  MOVF   63,W
1D4D:  MOVLB  01
1D4E:  SUBWF  6C,W
1D4F:  BTFSS  03.2
1D50:  GOTO   556
....................       execute_command(); 
1D51:  MOVLP  10
1D52:  MOVLB  00
1D53:  CALL   0A3
1D54:  MOVLP  18
1D55:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1D56:  MOVF   32,W
1D57:  ANDLW  0F
1D58:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1D59:  BTFSS  5B.6
1D5A:  GOTO   58D
1D5B:  CLRF   6E
1D5C:  CLRF   6F
1D5D:  MOVLP  10
1D5E:  MOVLB  00
1D5F:  CALL   778
1D60:  MOVLP  18
1D61:  MOVF   78,F
1D62:  BTFSS  03.2
1D63:  GOTO   566
1D64:  MOVLB  01
1D65:  GOTO   58D
....................     restart_wdt(); 
1D66:  CLRWDT
....................     switch(command) { 
1D67:  MOVF   70,W
1D68:  XORLW  0E
1D69:  BTFSC  03.2
1D6A:  GOTO   572
1D6B:  XORLW  01
1D6C:  BTFSC  03.2
1D6D:  GOTO   57A
1D6E:  XORLW  05
1D6F:  BTFSC  03.2
1D70:  GOTO   582
1D71:  GOTO   589
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1D72:  MOVLW  01
1D73:  ADDWF  74,W
1D74:  ANDLW  03
1D75:  MOVWF  74
....................         pot_values_to_lcd(); 
1D76:  MOVLP  08
1D77:  CALL   2C0
1D78:  MOVLP  18
....................         break; 
1D79:  GOTO   589
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1D7A:  MOVLW  FF
1D7B:  MOVLB  02
1D7C:  MOVWF  35
1D7D:  MOVLP  08
1D7E:  MOVLB  00
1D7F:  CALL   7BD
1D80:  MOVLP  18
....................         break; 
1D81:  GOTO   589
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1D82:  MOVLW  01
1D83:  MOVLB  02
1D84:  MOVWF  35
1D85:  MOVLP  08
1D86:  MOVLB  00
1D87:  CALL   7BD
1D88:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1D89:  MOVLP  08
1D8A:  CALL   7AE
1D8B:  MOVLP  18
1D8C:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1D8D:  BSF    5B.4
.................... } // }}} 
1D8E:  MOVLP  18
1D8F:  MOVLB  00
1D90:  GOTO   787 (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask,cor_index; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
1C30:  MOVLW  01
1C31:  MOVLB  01
1C32:  MOVWF  6C
....................   do_update_ptt=0; 
1C33:  MOVLB  02
1C34:  CLRF   20
....................   cor_in = COR_IN | (COR_EMUL&0x0F); 
1C35:  MOVLB  00
1C36:  MOVF   67,W
1C37:  ANDLW  0F
1C38:  IORWF  5F,W
1C39:  MOVLB  01
1C3A:  MOVWF  6F
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in&CurrentCorMask) ) { 
1C3B:  MOVLB  00
1C3C:  MOVF   6C,F
1C3D:  BTFSC  03.2
1C3E:  GOTO   457
1C3F:  MOVLB  01
1C40:  MOVF   6F,W
1C41:  MOVLB  00
1C42:  ANDWF  6A,W
1C43:  BTFSS  03.2
1C44:  GOTO   457
....................     CurrentCorPriority=0; 
1C45:  CLRF   6C
....................     CurrentCorMask=0; 
1C46:  CLRF   6A
....................     do_update_ptt=1; 
1C47:  MOVLW  01
1C48:  MOVLB  02
1C49:  MOVWF  20
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
1C4A:  MOVLB  01
1C4B:  MOVF   6F,W
1C4C:  MOVLB  00
1C4D:  ANDWF  60,W
1C4E:  ANDWF  61,W
1C4F:  BTFSS  03.2
1C50:  GOTO   457
....................       COR_DROP_FLAG=1; 
1C51:  BSF    72.7
....................       if ( Tail ) { 
1C52:  MOVF   65,F
1C53:  BTFSC  03.2
1C54:  GOTO   457
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
1C55:  MOVF   65,W
1C56:  MOVWF  68
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
1C57:  MOVLB  01
1C58:  CLRF   6D
....................   for(x=0;x<4;x++) { 
1C59:  MOVLB  02
1C5A:  CLRF   21
1C5B:  MOVF   21,W
1C5C:  SUBLW  03
1C5D:  BTFSS  03.0
1C5E:  GOTO   4A4
....................     if ( cor_in & cor_mask ) { 
1C5F:  MOVLB  01
1C60:  MOVF   6F,W
1C61:  ANDWF  6C,W
1C62:  BTFSC  03.2
1C63:  GOTO   49F
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
1C64:  MOVLB  00
1C65:  MOVF   60,W
1C66:  ANDWF  61,W
1C67:  MOVLB  01
1C68:  ANDWF  6C,W
1C69:  BTFSC  03.2
1C6A:  GOTO   477
....................         rx_priority=RXPriority[x]; 
1C6B:  MOVLW  25
1C6C:  MOVLB  02
1C6D:  ADDWF  21,W
1C6E:  MOVWF  04
1C6F:  MOVLW  20
1C70:  MOVWF  05
1C71:  BTFSC  03.0
1C72:  INCF   05,F
1C73:  MOVF   00,W
1C74:  MOVLB  01
1C75:  MOVWF  6E
....................       } else { 
1C76:  GOTO   479
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
1C77:  MOVLW  01
1C78:  MOVWF  6E
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1C79:  MOVF   6E,W
1C7A:  MOVLB  00
1C7B:  SUBWF  6C,W
1C7C:  BTFSC  03.0
1C7D:  GOTO   49E
....................         if ( ! CurrentCorPriority ) { 
1C7E:  MOVF   6C,F
1C7F:  BTFSS  03.2
1C80:  GOTO   485
....................           CurrentCorPriority = rx_priority; 
1C81:  MOVLB  01
1C82:  MOVF   6E,W
1C83:  MOVLB  00
1C84:  MOVWF  6C
....................         } 
....................         cor_index=x+1; 
1C85:  MOVLW  01
1C86:  MOVLB  02
1C87:  ADDWF  21,W
1C88:  MOVLB  01
1C89:  MOVWF  6D
....................         do_update_ptt=1; 
1C8A:  MOVLW  01
1C8B:  MOVLB  02
1C8C:  MOVWF  20
....................         TOT_SecondCounter= 60 * TOT_Min; 
1C8D:  MOVLW  3C
1C8E:  MOVWF  49
1C8F:  MOVLB  00
1C90:  MOVF   66,W
1C91:  MOVLB  02
1C92:  MOVWF  4A
1C93:  MOVLP  08
1C94:  MOVLB  00
1C95:  CALL   6E3
1C96:  MOVLP  18
1C97:  MOVLB  01
1C98:  CLRF   5F
1C99:  MOVF   78,W
1C9A:  MOVWF  5E
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
1C9B:  MOVF   6C,W
1C9C:  MOVLB  00
1C9D:  MOVWF  6D
1C9E:  MOVLB  01
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
1C9F:  BCF    03.0
1CA0:  RLF    6C,F
....................   } 
1CA1:  MOVLB  02
1CA2:  INCF   21,F
1CA3:  GOTO   45B
....................   if ( do_update_ptt ) { 
1CA4:  MOVF   20,F
1CA5:  BTFSC  03.2
1CA6:  GOTO   4B2
....................     update_ptt(cor_index); 
1CA7:  MOVLB  01
1CA8:  MOVF   6D,W
1CA9:  MOVLB  02
1CAA:  MOVWF  34
1CAB:  MOVLP  08
1CAC:  MOVLB  00
1CAD:  CALL   3B4
1CAE:  MOVLP  18
....................     PROMPT_FLAG=1; 
1CAF:  MOVLB  01
1CB0:  BSF    5B.5
1CB1:  MOVLB  02
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
1CB2:  MOVLB  01
1CB3:  MOVF   6F,F
1CB4:  BTFSS  03.2
1CB5:  GOTO   4BA
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
1CB6:  BSF    5B.4
....................     COR_IN_EFFECTIVE=0; 
1CB7:  MOVLB  00
1CB8:  CLRF   6D
1CB9:  MOVLB  01
....................   } 
.................... } // }}} 
1CBA:  MOVLP  18
1CBB:  MOVLB  00
1CBC:  GOTO   6EA (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
17B2:  MOVLB  01
17B3:  CLRF   6C
17B4:  MOVF   6C,W
17B5:  SUBLW  09
17B6:  BTFSS  03.0
17B7:  GOTO   7C2
....................     DTMF_ARRAY[x]=(sDTMF)0; 
17B8:  MOVLW  62
17B9:  ADDWF  6C,W
17BA:  MOVWF  04
17BB:  MOVLW  20
17BC:  MOVWF  05
17BD:  BTFSC  03.0
17BE:  INCF   05,F
17BF:  CLRF   00
....................   } 
17C0:  INCF   6C,F
17C1:  GOTO   7B4
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
17C2:  MOVLW  20
17C3:  MOVWF  3D
17C4:  MOVLW  62
17C5:  MOVWF  3C
.................... } // }}} 
17C6:  MOVLP  18
17C7:  MOVLB  00
17C8:  GOTO   78F (RETURN)
.................... void header (void) { // {{{ 
.................... //  putc(ESC); 
.................... //  printf("[47;34m\n\rRadio Repeater Controller - "); 
.................... //  putc(ESC); 
.................... //  printf("[47;31mVE2LRS"); 
.................... //  putc(ESC); 
.................... //  printf("[47;34m (C) 2013\n\n\r"); 
.................... //  putc(ESC); 
.................... //  printf("[40;37m"); 
.................... } // }}} 
*
0003:  RETURN
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   header(); 
*
12F2:  MOVLP  00
12F3:  CALL   003
12F4:  MOVLP  10
12F5:  CLRF   25
12F6:  BTFSC  0B.7
12F7:  BSF    25.7
12F8:  BCF    0B.7
....................   dtmf_in=dtmf_read(CONTROL_REG); 
12F9:  MOVLW  01
12FA:  MOVLB  02
12FB:  MOVWF  61
12FC:  MOVLP  00
12FD:  MOVLB  00
12FE:  CALL   33E
12FF:  MOVLP  10
1300:  BTFSC  25.7
1301:  BSF    0B.7
1302:  MOVF   78,W
1303:  MOVLB  02
1304:  MOVWF  39
....................   aux_in = 0; 
1305:  CLRF   3A
....................   for(x=0;x<RegMapNum;x++) { 
1306:  CLRF   33
1307:  CLRF   32
1308:  MOVF   33,F
1309:  BTFSS  03.2
130A:  GOTO   40F
130B:  MOVF   32,W
130C:  SUBLW  37
130D:  BTFSS  03.0
130E:  GOTO   40F
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
130F:  MOVLW  01
1310:  MOVWF  7A
1311:  MOVLW  8B
1312:  MOVWF  41
1313:  MOVF   7A,W
1314:  MOVWF  42
1315:  MOVF   33,W
1316:  MOVWF  44
1317:  MOVF   32,W
1318:  MOVWF  43
1319:  CLRF   46
131A:  MOVLW  06
131B:  MOVWF  45
131C:  MOVLP  08
131D:  MOVLB  00
131E:  CALL   76C
131F:  MOVLP  10
1320:  MOVF   78,W
1321:  MOVLB  02
1322:  ADDWF  41,W
1323:  MOVWF  35
1324:  MOVF   79,W
1325:  ADDWFC 42,W
1326:  MOVWF  36
....................     romstrcpy(rname,cPtr); 
1327:  MOVLW  20
1328:  MOVWF  42
1329:  MOVLW  BB
132A:  MOVWF  41
132B:  MOVF   36,W
132C:  MOVWF  44
132D:  MOVF   35,W
132E:  MOVWF  43
132F:  MOVLP  08
1330:  MOVLB  00
1331:  CALL   783
1332:  MOVLP  10
....................   regPtr=RegMap[x].reg_ptr; 
1333:  MOVLB  02
1334:  RLF    32,W
1335:  MOVWF  41
1336:  RLF    33,W
1337:  MOVWF  42
1338:  RLF    41,F
1339:  RLF    42,F
133A:  MOVLW  FC
133B:  ANDWF  41,F
133C:  MOVF   42,W
133D:  MOVWF  7A
133E:  MOVF   41,W
133F:  MOVWF  43
1340:  INCF   41,W
1341:  MOVLP  00
1342:  MOVLB  00
1343:  CALL   043
1344:  MOVLP  10
1345:  MOVWF  7A
1346:  MOVLB  02
1347:  MOVF   43,W
1348:  MOVLP  00
1349:  MOVLB  00
134A:  CALL   043
134B:  MOVLP  10
134C:  MOVLB  02
134D:  MOVWF  37
134E:  MOVF   7A,W
134F:  MOVWF  38
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
1350:  MOVF   38,W
1351:  MOVWF  7A
1352:  MOVF   37,W
1353:  MOVWF  04
1354:  MOVF   7A,W
1355:  MOVWF  05
1356:  MOVF   00,W
1357:  MOVWF  41
1358:  MOVLW  5B
1359:  CLRWDT
135A:  MOVLB  00
135B:  BTFSC  11.4
135C:  GOTO   35F
135D:  MOVLB  02
135E:  GOTO   359
135F:  MOVLB  03
1360:  MOVWF  1A
1361:  MOVLW  0B
1362:  MOVWF  04
1363:  MOVLB  02
1364:  MOVF   33,W
1365:  MOVWF  43
1366:  MOVF   32,W
1367:  MOVWF  42
*
13C5:  MOVLW  5D
13C6:  CLRWDT
13C7:  MOVLB  00
13C8:  BTFSC  11.4
13C9:  GOTO   3CC
13CA:  MOVLB  02
13CB:  GOTO   3C6
13CC:  MOVLB  03
13CD:  MOVWF  1A
13CE:  MOVLW  20
13CF:  CLRWDT
13D0:  MOVLB  00
13D1:  BTFSC  11.4
13D2:  GOTO   3D5
13D3:  MOVLB  03
13D4:  GOTO   3CF
13D5:  MOVLB  03
13D6:  MOVWF  1A
13D7:  MOVLW  20
13D8:  MOVWF  05
13D9:  MOVLW  BB
13DA:  MOVWF  04
13DB:  MOVLP  08
13DC:  MOVLB  00
13DD:  CALL   2A6
13DE:  MOVLP  10
13DF:  MOVLW  20
13E0:  CLRWDT
13E1:  BTFSS  11.4
13E2:  GOTO   3E0
13E3:  MOVLB  03
13E4:  MOVWF  1A
13E5:  MOVLB  02
13E6:  MOVF   41,W
13E7:  MOVWF  56
13E8:  MOVLW  1B
13E9:  MOVWF  57
13EA:  MOVLP  00
13EB:  MOVLB  00
13EC:  CALL   77C
13ED:  MOVLP  10
13EE:  MOVLW  09
13EF:  CLRWDT
13F0:  BTFSS  11.4
13F1:  GOTO   3EF
13F2:  MOVLB  03
13F3:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
13F4:  MOVLB  02
13F5:  MOVF   32,W
13F6:  ANDLW  03
13F7:  MOVWF  41
13F8:  CLRF   42
13F9:  MOVF   41,W
13FA:  SUBLW  03
13FB:  BTFSS  03.2
13FC:  GOTO   40A
13FD:  MOVF   42,F
13FE:  BTFSS  03.2
13FF:  GOTO   40A
....................       putc('\n'); 
1400:  MOVLW  0A
1401:  MOVLP  00
1402:  MOVLB  00
1403:  CALL   2DA
1404:  MOVLP  10
....................       putc('\r'); 
1405:  MOVLW  0D
1406:  MOVLP  00
1407:  CALL   2DA
1408:  MOVLP  10
1409:  MOVLB  02
....................     } 
....................     restart_wdt(); 
140A:  CLRWDT
....................   } 
140B:  INCF   32,F
140C:  BTFSC  03.2
140D:  INCF   33,F
140E:  GOTO   308
....................   for(y=0;y<3;y++) { 
140F:  CLRF   34
1410:  MOVF   34,W
1411:  SUBLW  02
1412:  BTFSS  03.0
1413:  GOTO   42A
....................     if(AuxInSW[y]==1) { 
1414:  MOVLW  1F
1415:  ADDWF  34,W
1416:  MOVWF  04
1417:  MOVLW  20
1418:  MOVWF  05
1419:  BTFSC  03.0
141A:  INCF   05,F
141B:  DECFSZ 00,W
141C:  GOTO   428
....................       aux_in += 2<<y; 
141D:  MOVLW  02
141E:  MOVWF  77
141F:  MOVF   34,W
1420:  MOVWF  78
1421:  BTFSC  03.2
1422:  GOTO   426
1423:  LSLF   77,F
1424:  DECFSZ 78,F
1425:  GOTO   423
1426:  MOVF   77,W
1427:  ADDWF  3A,F
....................     } 
....................   } 
1428:  INCF   34,F
1429:  GOTO   410
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u",COR_IN,COR_EMUL,aux_in); 
142A:  MOVLW  58
142B:  MOVLB  03
142C:  MOVWF  11
142D:  MOVLW  04
142E:  MOVWF  12
142F:  BCF    03.0
1430:  MOVLW  07
1431:  MOVLB  02
1432:  MOVWF  56
1433:  MOVLP  00
1434:  MOVLB  00
1435:  CALL   708
1436:  MOVLP  10
1437:  MOVF   5F,W
1438:  MOVLB  02
1439:  MOVWF  56
143A:  MOVLW  1B
143B:  MOVWF  57
143C:  MOVLP  00
143D:  MOVLB  00
143E:  CALL   77C
143F:  MOVLP  10
1440:  MOVLW  5C
1441:  MOVLB  03
1442:  MOVWF  11
1443:  MOVLW  04
1444:  MOVWF  12
1445:  BSF    03.0
1446:  MOVLW  07
1447:  MOVLB  02
1448:  MOVWF  56
1449:  MOVLP  00
144A:  MOVLB  00
144B:  CALL   708
144C:  MOVLP  10
144D:  MOVF   67,W
144E:  MOVLB  02
144F:  MOVWF  56
1450:  MOVLW  1B
1451:  MOVWF  57
1452:  MOVLP  00
1453:  MOVLB  00
1454:  CALL   77C
1455:  MOVLP  10
1456:  MOVLW  61
1457:  MOVLB  03
1458:  MOVWF  11
1459:  MOVLW  04
145A:  MOVWF  12
145B:  BCF    03.0
145C:  MOVLW  09
145D:  MOVLB  02
145E:  MOVWF  56
145F:  MOVLP  00
1460:  MOVLB  00
1461:  CALL   708
1462:  MOVLP  10
1463:  MOVLB  02
1464:  MOVF   3A,W
1465:  MOVWF  56
1466:  MOVLW  1B
1467:  MOVWF  57
1468:  MOVLP  00
1469:  MOVLB  00
146A:  CALL   77C
146B:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
146C:  MOVLW  67
146D:  MOVLB  03
146E:  MOVWF  11
146F:  MOVLW  04
1470:  MOVWF  12
1471:  BCF    03.0
1472:  MOVLW  10
1473:  MOVLB  02
1474:  MOVWF  56
1475:  MOVLP  00
1476:  MOVLB  00
1477:  CALL   708
1478:  MOVLP  10
1479:  MOVLB  02
147A:  MOVF   39,W
147B:  MOVWF  56
147C:  MOVLW  1B
147D:  MOVWF  57
147E:  MOVLP  00
147F:  MOVLB  00
1480:  CALL   77C
1481:  MOVLP  10
1482:  MOVLW  0A
1483:  CLRWDT
1484:  BTFSS  11.4
1485:  GOTO   483
1486:  MOVLB  03
1487:  MOVWF  1A
1488:  MOVLW  0D
1489:  CLRWDT
148A:  MOVLB  00
148B:  BTFSC  11.4
148C:  GOTO   48F
148D:  MOVLB  03
148E:  GOTO   489
148F:  MOVLB  03
1490:  MOVWF  1A
....................   pot_values_to_lcd(); 
1491:  MOVLP  08
1492:  MOVLB  00
1493:  CALL   2C0
1494:  MOVLP  10
....................   PROMPT_FLAG=1; 
1495:  MOVLB  01
1496:  BSF    5B.5
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0AC0:  MOVLW  20
0AC1:  MOVLB  02
0AC2:  MOVWF  48
0AC3:  MOVWF  49
0AC4:  MOVWF  4A
0AC5:  MOVWF  4B
....................   unsigned pval[4]={0,0,0,0}; 
0AC6:  CLRF   4C
0AC7:  CLRF   4D
0AC8:  CLRF   4E
0AC9:  CLRF   4F
....................   delay_ms(40); 
0ACA:  MOVLW  28
0ACB:  MOVWF  50
0ACC:  MOVLP  00
0ACD:  MOVLB  00
0ACE:  CALL   7CB
0ACF:  MOVLP  08
....................   i2c_start(); 
0AD0:  MOVLB  04
0AD1:  BSF    16.0
0AD2:  BTFSC  16.0
0AD3:  GOTO   2D2
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0AD4:  MOVLW  51
0AD5:  MOVLB  02
0AD6:  MOVWF  56
0AD7:  MOVLP  00
0AD8:  MOVLB  00
0AD9:  CALL   6F3
0ADA:  MOVLP  08
0ADB:  MOVF   78,W
0ADC:  MOVLB  02
0ADD:  BCF    47.1
0ADE:  BTFSC  78.0
0ADF:  BSF    47.1
....................   for(x=0;x<4;x++) { 
0AE0:  CLRF   45
0AE1:  MOVF   45,W
0AE2:  SUBLW  03
0AE3:  BTFSS  03.0
0AE4:  GOTO   31E
....................     if(x==3) { 
0AE5:  MOVF   45,W
0AE6:  SUBLW  03
0AE7:  BTFSS  03.2
0AE8:  GOTO   2EB
....................       ack=0; 
0AE9:  BCF    47.0
....................     } else { 
0AEA:  GOTO   2EC
....................       ack=1; 
0AEB:  BSF    47.0
....................     } 
....................     pot_val=i2c_read(ack); 
0AEC:  MOVLW  00
0AED:  BTFSC  47.0
0AEE:  MOVLW  01
0AEF:  MOVWF  50
0AF0:  MOVF   50,W
0AF1:  MOVWF  77
*
0B00:  MOVF   78,W
0B01:  MOVLB  02
0B02:  MOVWF  46
....................     pot_val=pot_val&0x3F; 
0B03:  MOVLW  3F
0B04:  ANDWF  46,F
....................     pval[x]=pot_val; 
0B05:  MOVLW  CC
0B06:  ADDWF  45,W
0B07:  MOVWF  04
0B08:  MOVLW  20
0B09:  MOVWF  05
0B0A:  BTFSC  03.0
0B0B:  INCF   05,F
0B0C:  MOVF   46,W
0B0D:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0B0E:  MOVF   74,W
0B0F:  ANDLW  03
0B10:  SUBWF  45,W
0B11:  BTFSS  03.2
0B12:  GOTO   31C
....................       c[x] = '*'; 
0B13:  MOVLW  C8
0B14:  ADDWF  45,W
0B15:  MOVWF  04
0B16:  MOVLW  20
0B17:  MOVWF  05
0B18:  BTFSC  03.0
0B19:  INCF   05,F
0B1A:  MOVLW  2A
0B1B:  MOVWF  00
....................     } 
....................   } 
0B1C:  INCF   45,F
0B1D:  GOTO   2E1
....................   i2c_stop(); 
0B1E:  MOVLB  04
0B1F:  BSF    16.2
0B20:  BTFSC  16.2
0B21:  GOTO   320
....................   delay_ms(50); 
0B22:  MOVLW  32
0B23:  MOVLB  02
0B24:  MOVWF  50
0B25:  MOVLP  00
0B26:  MOVLB  00
0B27:  CALL   7CB
0B28:  MOVLP  08
....................   if ( ack_in!=0 ) { 
0B29:  MOVLB  02
0B2A:  BTFSS  47.1
0B2B:  GOTO   347
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0B2C:  MOVLW  00
0B2D:  BTFSC  47.0
0B2E:  MOVLW  01
0B2F:  MOVWF  50
0B30:  MOVLW  72
0B31:  MOVLB  03
0B32:  MOVWF  11
0B33:  MOVLW  04
0B34:  MOVWF  12
0B35:  BCF    03.0
0B36:  MOVLW  25
0B37:  MOVLB  02
0B38:  MOVWF  56
0B39:  MOVLP  00
0B3A:  MOVLB  00
0B3B:  CALL   708
0B3C:  MOVLP  08
0B3D:  MOVLB  02
0B3E:  MOVF   50,W
0B3F:  MOVWF  56
0B40:  MOVLW  1B
0B41:  MOVWF  57
0B42:  MOVLP  00
0B43:  MOVLB  00
0B44:  CALL   77C
0B45:  MOVLP  08
0B46:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0B47:  MOVLW  20
0B48:  MOVLB  01
0B49:  MOVWF  62
0B4A:  MOVLW  74
0B4B:  MOVWF  61
0B4C:  MOVLW  86
0B4D:  MOVLB  03
0B4E:  MOVWF  11
0B4F:  MOVLW  04
0B50:  MOVWF  12
0B51:  BCF    03.0
0B52:  MOVLW  04
0B53:  MOVLB  02
0B54:  MOVWF  50
0B55:  MOVLB  00
0B56:  CALL   173
0B57:  MOVLB  02
0B58:  MOVF   48,W
0B59:  MOVWF  56
0B5A:  MOVLB  00
0B5B:  CALL   164
0B5C:  MOVLB  02
0B5D:  MOVF   4C,W
0B5E:  MOVWF  50
0B5F:  MOVLW  18
0B60:  MOVWF  51
0B61:  MOVLB  00
0B62:  CALL   23F
0B63:  MOVLW  20
0B64:  MOVLB  02
0B65:  MOVWF  56
0B66:  MOVLB  00
0B67:  CALL   164
0B68:  MOVLB  02
0B69:  MOVF   49,W
0B6A:  MOVWF  56
0B6B:  MOVLB  00
0B6C:  CALL   164
0B6D:  MOVLB  02
0B6E:  MOVF   4D,W
0B6F:  MOVWF  50
0B70:  MOVLW  18
0B71:  MOVWF  51
0B72:  MOVLB  00
0B73:  CALL   23F
0B74:  MOVLW  20
0B75:  MOVLB  02
0B76:  MOVWF  56
0B77:  MOVLB  00
0B78:  CALL   164
0B79:  MOVLB  02
0B7A:  MOVF   4A,W
0B7B:  MOVWF  56
0B7C:  MOVLB  00
0B7D:  CALL   164
0B7E:  MOVLB  02
0B7F:  MOVF   4E,W
0B80:  MOVWF  50
0B81:  MOVLW  18
0B82:  MOVWF  51
0B83:  MOVLB  00
0B84:  CALL   23F
0B85:  MOVLW  20
0B86:  MOVLB  02
0B87:  MOVWF  56
0B88:  MOVLB  00
0B89:  CALL   164
0B8A:  MOVLB  02
0B8B:  MOVF   4B,W
0B8C:  MOVWF  56
0B8D:  MOVLB  00
0B8E:  CALL   164
0B8F:  MOVLB  02
0B90:  MOVF   4F,W
0B91:  MOVWF  50
0B92:  MOVLW  18
0B93:  MOVWF  51
0B94:  MOVLB  00
0B95:  CALL   23F
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0B96:  MOVLB  02
0B97:  CLRF   50
0B98:  MOVLW  20
0B99:  MOVWF  52
0B9A:  MOVLW  74
0B9B:  MOVWF  51
0B9C:  MOVLB  00
0B9D:  CALL   1DB
....................   printf("\n\r%s",LCD_str); 
0B9E:  MOVLW  0A
0B9F:  CLRWDT
0BA0:  BTFSS  11.4
0BA1:  GOTO   39F
0BA2:  MOVLB  03
0BA3:  MOVWF  1A
0BA4:  MOVLW  0D
0BA5:  CLRWDT
0BA6:  MOVLB  00
0BA7:  BTFSC  11.4
0BA8:  GOTO   3AB
0BA9:  MOVLB  03
0BAA:  GOTO   3A5
0BAB:  MOVLB  03
0BAC:  MOVWF  1A
0BAD:  MOVLW  20
0BAE:  MOVWF  05
0BAF:  MOVLW  74
0BB0:  MOVWF  04
0BB1:  MOVLB  00
0BB2:  CALL   2A6
....................  
.................... } // }}} 
0BB3:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
1049:  MOVLB  01
104A:  BTFSS  5B.6
104B:  GOTO   057
....................     printf("\n\n\rADMIN> "); 
104C:  MOVLW  92
104D:  MOVLB  03
104E:  MOVWF  11
104F:  MOVLW  04
1050:  MOVWF  12
1051:  MOVLP  00
1052:  MOVLB  00
1053:  CALL   530
1054:  MOVLP  10
....................   } else { 
1055:  GOTO   060
1056:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
1057:  MOVLW  98
1058:  MOVLB  03
1059:  MOVWF  11
105A:  MOVLW  04
105B:  MOVWF  12
105C:  MOVLP  00
105D:  MOVLB  00
105E:  CALL   530
105F:  MOVLP  10
....................   } 
.................... } // }}} 
1060:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
0516:  MOVLW  10
0517:  MOVLB  01
0518:  MOVWF  6D
....................   for (x=0;x<char_num;x++) { 
0519:  CLRF   6C
051A:  MOVF   6D,W
051B:  SUBWF  6C,W
051C:  BTFSC  03.0
051D:  GOTO   528
....................     sBuffer[x]='\0'; 
051E:  MOVLW  4E
051F:  ADDWF  6C,W
0520:  MOVWF  04
0521:  MOVLW  20
0522:  MOVWF  05
0523:  BTFSC  03.0
0524:  INCF   05,F
0525:  CLRF   00
....................   } 
0526:  INCF   6C,F
0527:  GOTO   51A
....................   sBufferIndex=0; 
0528:  CLRF   71
....................   sBufferFlag=0;   
0529:  BCF    72.0
....................   argument=-1; 
052A:  MOVLW  FF
052B:  MOVWF  75
....................   argument_name[0]='\0'; 
052C:  CLRF   3E
....................   command=0; 
052D:  CLRF   70
.................... } // }}} 
052E:  MOVLB  00
052F:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
06B3:  MOVLW  00
06B4:  MOVLB  01
06B5:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
06B6:  MOVLB  02
06B7:  BCF    4B.0
06B8:  MOVF   49,W
06B9:  ANDLW  0F
06BA:  ANDLW  01
06BB:  BTFSS  03.2
06BC:  BSF    4B.0
....................   output_bit(DTMF_D0,dbit); 
06BD:  BTFSC  4B.0
06BE:  GOTO   6C1
06BF:  BCF    0F.0
06C0:  GOTO   6C2
06C1:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
06C2:  BCF    4B.0
06C3:  MOVF   49,W
06C4:  ANDLW  0F
06C5:  ANDLW  02
06C6:  BTFSS  03.2
06C7:  BSF    4B.0
....................   output_bit(DTMF_D1,dbit); 
06C8:  BTFSC  4B.0
06C9:  GOTO   6CC
06CA:  BCF    0F.1
06CB:  GOTO   6CD
06CC:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
06CD:  BCF    4B.0
06CE:  MOVF   49,W
06CF:  ANDLW  0F
06D0:  ANDLW  04
06D1:  BTFSS  03.2
06D2:  BSF    4B.0
....................   output_bit(DTMF_D2,dbit); 
06D3:  BTFSC  4B.0
06D4:  GOTO   6D7
06D5:  BCF    0F.2
06D6:  GOTO   6D8
06D7:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
06D8:  BCF    4B.0
06D9:  MOVF   49,W
06DA:  ANDLW  0F
06DB:  ANDLW  08
06DC:  BTFSS  03.2
06DD:  BSF    4B.0
....................   output_bit(DTMF_D3,dbit); 
06DE:  BTFSC  4B.0
06DF:  GOTO   6E2
06E0:  BCF    0F.3
06E1:  GOTO   6E3
06E2:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
06E3:  MOVF   4A,F
06E4:  BTFSS  03.2
06E5:  GOTO   6E8
06E6:  BCF    0F.6
06E7:  GOTO   6E9
06E8:  BSF    0F.6
....................   delay_cycles(2); 
06E9:  GOTO   6EA
....................   output_bit(DTMF_WEB,0); 
06EA:  BCF    0F.5
....................   delay_cycles(2); 
06EB:  GOTO   6EC
....................   output_bit(DTMF_WEB,1);   
06EC:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
06ED:  GOTO   6EE
....................   set_tris_d(0x0F); 
06EE:  MOVLW  0F
06EF:  MOVLB  01
06F0:  MOVWF  0F
.................... } // }}} 
06F1:  MOVLB  00
06F2:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
*
033E:  MOVLW  0F
033F:  MOVLB  01
0340:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
0341:  MOVLB  02
0342:  MOVF   61,F
0343:  BTFSS  03.2
0344:  GOTO   347
0345:  BCF    0F.6
0346:  GOTO   348
0347:  BSF    0F.6
....................   delay_cycles(1); 
0348:  NOP
....................   output_bit(DTMF_REB,0); 
0349:  BCF    0F.4
....................   delay_cycles(1); 
034A:  NOP
....................   value=input_d(); 
034B:  MOVLB  00
034C:  MOVF   0F,W
034D:  MOVLB  02
034E:  MOVWF  62
....................   value&=0x0F; 
034F:  MOVLW  0F
0350:  ANDWF  62,F
....................   output_bit(DTMF_REB,1); 
0351:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
0352:  NOP
....................   return(value); 
0353:  MOVF   62,W
0354:  MOVWF  78
.................... } // }}} 
0355:  MOVLB  00
0356:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0D50:  MOVLB  02
0D51:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0D52:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0D53:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0D54:  CLRF   49
0D55:  MOVLW  01
0D56:  MOVWF  4A
0D57:  MOVLP  00
0D58:  MOVLB  00
0D59:  CALL   6B3
0D5A:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0D5B:  MOVLB  02
0D5C:  CLRF   49
0D5D:  MOVLW  01
0D5E:  MOVWF  4A
0D5F:  MOVLP  00
0D60:  MOVLB  00
0D61:  CALL   6B3
0D62:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0D63:  MOVLW  0C
0D64:  MOVLB  02
0D65:  MOVWF  49
0D66:  MOVLW  01
0D67:  MOVWF  4A
0D68:  MOVLP  00
0D69:  MOVLB  00
0D6A:  CALL   6B3
0D6B:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0D6C:  MOVLW  01
0D6D:  MOVLB  02
0D6E:  MOVWF  49
0D6F:  MOVWF  4A
0D70:  MOVLP  00
0D71:  MOVLB  00
0D72:  CALL   6B3
0D73:  MOVLP  08
0D74:  CLRF   25
0D75:  BTFSC  0B.7
0D76:  BSF    25.7
0D77:  BCF    0B.7
....................     dtmf_read(CONTROL_REG); 
0D78:  MOVLW  01
0D79:  MOVLB  02
0D7A:  MOVWF  61
0D7B:  MOVLP  00
0D7C:  MOVLB  00
0D7D:  CALL   33E
0D7E:  MOVLP  08
0D7F:  BTFSC  25.7
0D80:  BSF    0B.7
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19EC:  MOVF   46,W
19ED:  MOVWF  49
19EE:  CLRF   4A
19EF:  MOVLP  00
19F0:  MOVLB  00
19F1:  CALL   6B3
19F2:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19F3:  MOVLW  0C
19F4:  MOVLB  02
19F5:  MOVWF  49
19F6:  MOVLW  01
19F7:  MOVWF  4A
19F8:  MOVLP  00
19F9:  MOVLB  00
19FA:  CALL   6B3
19FB:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
19FC:  MOVLW  01
19FD:  MOVLB  02
19FE:  MOVWF  49
19FF:  MOVWF  4A
1A00:  MOVLP  00
1A01:  MOVLB  00
1A02:  CALL   6B3
1A03:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A04:  MOVLW  05
1A05:  MOVLB  02
1A06:  MOVWF  49
1A07:  MOVLW  01
1A08:  MOVWF  4A
1A09:  MOVLP  00
1A0A:  MOVLB  00
1A0B:  CALL   6B3
1A0C:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A0D:  MOVLB  01
1A0E:  CLRF   31
1A0F:  MOVLW  10
1A10:  MOVWF  30
....................   while(aux_timer) { 
1A11:  MOVF   30,W
1A12:  IORWF  31,W
1A13:  BTFSC  03.2
1A14:  GOTO   217
....................     delay_cycles(1); 
1A15:  NOP
....................   } 
1A16:  GOTO   211
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A17:  MOVLW  04
1A18:  MOVLB  02
1A19:  MOVWF  49
1A1A:  MOVLW  01
1A1B:  MOVWF  4A
1A1C:  MOVLP  00
1A1D:  MOVLB  00
1A1E:  CALL   6B3
1A1F:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
0879:  MOVLW  01
087A:  MOVLB  02
087B:  MOVWF  49
087C:  CLRF   4A
087D:  MOVLP  00
087E:  MOVLB  00
087F:  CALL   6B3
0880:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0881:  MOVLW  0C
0882:  MOVLB  02
0883:  MOVWF  49
0884:  MOVLW  01
0885:  MOVWF  4A
0886:  MOVLP  00
0887:  MOVLB  00
0888:  CALL   6B3
0889:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
088A:  MOVLW  05
088B:  MOVLB  02
088C:  MOVWF  49
088D:  MOVLW  01
088E:  MOVWF  4A
088F:  MOVLP  00
0890:  MOVLB  00
0891:  CALL   6B3
0892:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0893:  MOVLW  05
0894:  MOVLB  02
0895:  MOVWF  49
0896:  MOVLW  01
0897:  MOVWF  4A
0898:  MOVLP  00
0899:  MOVLB  00
089A:  CALL   6B3
089B:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
089C:  MOVLB  01
089D:  CLRF   31
089E:  MOVLW  02
089F:  MOVWF  30
....................   while(aux_timer) { 
08A0:  MOVF   30,W
08A1:  IORWF  31,W
08A2:  BTFSC  03.2
08A3:  GOTO   0A6
....................     delay_cycles(1); 
08A4:  NOP
....................   } 
08A5:  GOTO   0A0
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
08A6:  MOVLW  04
08A7:  MOVLB  02
08A8:  MOVWF  49
08A9:  MOVLW  01
08AA:  MOVWF  4A
08AB:  MOVLP  00
08AC:  MOVLB  00
08AD:  CALL   6B3
08AE:  MOVLP  08
....................   restart_wdt(); 
08AF:  CLRWDT
.................... } // }}} 
08B0:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
08B1:  MOVLW  01
08B2:  MOVLB  02
08B3:  MOVWF  49
08B4:  CLRF   4A
08B5:  MOVLP  00
08B6:  MOVLB  00
08B7:  CALL   6B3
08B8:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
08B9:  MOVLW  0C
08BA:  MOVLB  02
08BB:  MOVWF  49
08BC:  MOVLW  01
08BD:  MOVWF  4A
08BE:  MOVLP  00
08BF:  MOVLB  00
08C0:  CALL   6B3
08C1:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
08C2:  MOVLW  05
08C3:  MOVLB  02
08C4:  MOVWF  49
08C5:  MOVLW  01
08C6:  MOVWF  4A
08C7:  MOVLP  00
08C8:  MOVLB  00
08C9:  CALL   6B3
08CA:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
08CB:  MOVLW  05
08CC:  MOVLB  02
08CD:  MOVWF  49
08CE:  MOVLW  01
08CF:  MOVWF  4A
08D0:  MOVLP  00
08D1:  MOVLB  00
08D2:  CALL   6B3
08D3:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
08D4:  MOVLB  01
08D5:  CLRF   31
08D6:  MOVLW  06
08D7:  MOVWF  30
....................   while(aux_timer) { 
08D8:  MOVF   30,W
08D9:  IORWF  31,W
08DA:  BTFSC  03.2
08DB:  GOTO   0DE
....................     delay_cycles(1); 
08DC:  NOP
....................   } 
08DD:  GOTO   0D8
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
08DE:  MOVLW  04
08DF:  MOVLB  02
08E0:  MOVWF  49
08E1:  MOVLW  01
08E2:  MOVWF  4A
08E3:  MOVLP  00
08E4:  MOVLB  00
08E5:  CALL   6B3
08E6:  MOVLP  08
....................   restart_wdt(); 
08E7:  CLRWDT
.................... } // }}} 
08E8:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
0585:  MOVLB  02
0586:  MOVF   3E,W
0587:  MOVWF  04
0588:  MOVF   3F,W
0589:  MOVWF  05
058A:  MOVF   00,W
058B:  MOVWF  41
....................   if ( tmp > 127 ) { 
058C:  MOVF   41,W
058D:  SUBLW  7F
058E:  BTFSS  03.0
....................     tmp++; 
058F:  INCF   41,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
0590:  BCF    03.0
0591:  RLF    41,W
0592:  XORLW  09
0593:  ADDWF  40,W
0594:  MOVWF  41
....................   *cksum=tmp; 
0595:  MOVF   3E,W
0596:  MOVWF  04
0597:  MOVF   3F,W
0598:  MOVWF  05
0599:  MOVF   41,W
059A:  MOVWF  00
.................... } // }}} 
059B:  MOVLB  00
059C:  RETURN
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
059D:  MOVLW  01
059E:  MOVLB  02
059F:  MOVWF  38
....................   eeprom_index=0; 
05A0:  CLRF   39
....................   retVal = 1; 
05A1:  MOVWF  3B
....................   if ( source == USE_EEPROM_VARS ) { 
05A2:  DECFSZ 34,W
05A3:  GOTO   5AD
....................     printf("\n\rInitializing RAM variables from EEPROM"); 
05A4:  MOVLW  9F
05A5:  MOVLB  03
05A6:  MOVWF  11
05A7:  MOVLW  04
05A8:  MOVWF  12
05A9:  MOVLB  00
05AA:  CALL   530
....................   } else { 
05AB:  GOTO   5B4
05AC:  MOVLB  02
....................     printf("\n\rInitializing RAM variables with firmware default values"); 
05AD:  MOVLW  B4
05AE:  MOVLB  03
05AF:  MOVWF  11
05B0:  MOVLW  04
05B1:  MOVWF  12
05B2:  MOVLB  00
05B3:  CALL   530
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
05B4:  MOVLB  02
05B5:  CLRF   35
05B6:  MOVF   35,W
05B7:  SUBLW  37
05B8:  BTFSS  03.0
05B9:  GOTO   613
....................     regPtr=RegMap[x].reg_ptr; 
05BA:  RLF    35,W
05BB:  MOVWF  77
05BC:  RLF    77,F
05BD:  MOVLW  FC
05BE:  ANDWF  77,F
05BF:  MOVF   77,W
05C0:  MOVWF  3D
05C1:  INCF   3D,W
05C2:  MOVLB  00
05C3:  CALL   043
05C4:  MOVWF  7A
05C5:  MOVLB  02
05C6:  MOVF   3D,W
05C7:  MOVLB  00
05C8:  CALL   043
05C9:  MOVLB  02
05CA:  MOVWF  36
05CB:  MOVF   7A,W
05CC:  MOVWF  37
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
05CD:  DECFSZ 34,W
05CE:  GOTO   5FF
05CF:  RLF    35,W
05D0:  MOVWF  77
05D1:  RLF    77,F
05D2:  MOVLW  FC
05D3:  ANDWF  77,F
05D4:  MOVF   77,W
05D5:  ADDLW  03
05D6:  MOVLB  00
05D7:  CALL   043
05D8:  MOVWF  78
05D9:  BTFSC  78.0
05DA:  GOTO   5DD
05DB:  MOVLB  02
05DC:  GOTO   5FF
....................     eeprom_val=read_eeprom(eeprom_index); 
05DD:  MOVLB  02
05DE:  MOVF   39,W
05DF:  MOVLB  03
05E0:  MOVWF  11
05E1:  BCF    15.7
05E2:  BSF    15.0
05E3:  MOVF   13,W
05E4:  MOVLB  02
05E5:  MOVWF  3C
....................     *regPtr=eeprom_val; 
05E6:  MOVF   36,W
05E7:  MOVWF  04
05E8:  MOVF   37,W
05E9:  MOVWF  05
05EA:  MOVF   3C,W
05EB:  MOVWF  00
....................     update_checksum(&cksum,*regPtr);     
05EC:  MOVF   37,W
05ED:  MOVWF  7A
05EE:  MOVF   36,W
05EF:  MOVWF  04
05F0:  MOVF   37,W
05F1:  MOVWF  05
05F2:  MOVF   00,W
05F3:  MOVWF  3D
05F4:  MOVLW  20
05F5:  MOVWF  3F
05F6:  MOVLW  B8
05F7:  MOVWF  3E
05F8:  MOVF   3D,W
05F9:  MOVWF  40
05FA:  MOVLB  00
05FB:  CALL   585
....................       eeprom_index++; 
05FC:  MOVLB  02
05FD:  INCF   39,F
....................     } else { 
05FE:  GOTO   611
....................       default_value=(int8)RegMap[x].default_value; 
05FF:  RLF    35,W
0600:  MOVWF  77
0601:  RLF    77,F
0602:  MOVLW  FC
0603:  ANDWF  77,F
0604:  MOVF   77,W
0605:  ADDLW  02
0606:  MOVLB  00
0607:  CALL   043
0608:  MOVWF  78
0609:  MOVLB  02
060A:  MOVWF  3A
....................       *regPtr=default_value; 
060B:  MOVF   36,W
060C:  MOVWF  04
060D:  MOVF   37,W
060E:  MOVWF  05
060F:  MOVF   3A,W
0610:  MOVWF  00
....................     } 
....................   } 
0611:  INCF   35,F
0612:  GOTO   5B6
....................   if ( source == USE_EEPROM_VARS ) { 
0613:  DECFSZ 34,W
0614:  GOTO   61F
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
0615:  MOVF   39,W
0616:  MOVLB  03
0617:  MOVWF  11
0618:  BCF    15.7
0619:  BSF    15.0
061A:  MOVF   13,W
061B:  MOVLB  02
061C:  SUBWF  38,W
061D:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
061E:  CLRF   3B
....................     } 
....................   } 
....................   return (retVal); 
061F:  MOVF   3B,W
0620:  MOVWF  78
.................... } // }}} 
0621:  MOVLB  00
0622:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
0623:  MOVLW  01
0624:  MOVLB  02
0625:  MOVWF  38
....................  
....................   eeprom_index=0; 
0626:  CLRF   35
....................   for(x=0;x<RegMapNum;x++) { 
0627:  CLRF   34
0628:  MOVF   34,W
0629:  SUBLW  37
062A:  BTFSS  03.0
062B:  GOTO   681
....................     regPtr=RegMap[x].reg_ptr; 
062C:  RLF    34,W
062D:  MOVWF  77
062E:  RLF    77,F
062F:  MOVLW  FC
0630:  ANDWF  77,F
0631:  MOVF   77,W
0632:  MOVWF  3A
0633:  INCF   3A,W
0634:  MOVLB  00
0635:  CALL   043
0636:  MOVWF  7A
0637:  MOVLB  02
0638:  MOVF   3A,W
0639:  MOVLB  00
063A:  CALL   043
063B:  MOVLB  02
063C:  MOVWF  36
063D:  MOVF   7A,W
063E:  MOVWF  37
....................     if ( RegMap[x].non_volatile ) { 
063F:  RLF    34,W
0640:  MOVWF  77
0641:  RLF    77,F
0642:  MOVLW  FC
0643:  ANDWF  77,F
0644:  MOVF   77,W
0645:  ADDLW  03
0646:  MOVLB  00
0647:  CALL   043
0648:  MOVWF  78
0649:  BTFSS  78.0
064A:  GOTO   67E
....................      value=*regPtr; 
064B:  MOVLB  02
064C:  MOVF   36,W
064D:  MOVWF  04
064E:  MOVF   37,W
064F:  MOVWF  05
0650:  MOVF   00,W
0651:  MOVWF  39
....................      if ( read_eeprom(eeprom_index) != value ) { 
0652:  MOVF   35,W
0653:  MOVLB  03
0654:  MOVWF  11
0655:  BCF    15.7
0656:  BSF    15.0
0657:  MOVF   13,W
0658:  MOVLB  02
0659:  SUBWF  39,W
065A:  BTFSC  03.2
065B:  GOTO   673
....................        write_eeprom(eeprom_index,value); 
065C:  MOVF   0B,W
065D:  MOVWF  77
065E:  BCF    0B.7
065F:  MOVF   35,W
0660:  MOVLB  03
0661:  MOVWF  11
0662:  MOVLB  02
0663:  MOVF   39,W
0664:  MOVLB  03
0665:  MOVWF  13
0666:  BCF    15.7
0667:  BSF    15.2
0668:  MOVLW  55
0669:  MOVWF  16
066A:  MOVLW  AA
066B:  MOVWF  16
066C:  BSF    15.1
066D:  BTFSC  15.1
066E:  GOTO   66D
066F:  BCF    15.2
0670:  MOVF   77,W
0671:  IORWF  0B,F
0672:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
0673:  MOVLW  20
0674:  MOVWF  3F
0675:  MOVLW  B8
0676:  MOVWF  3E
0677:  MOVF   39,W
0678:  MOVWF  40
0679:  MOVLB  00
067A:  CALL   585
....................      eeprom_index++; 
067B:  MOVLB  02
067C:  INCF   35,F
067D:  MOVLB  00
....................     } 
....................   } 
067E:  MOVLB  02
067F:  INCF   34,F
0680:  GOTO   628
....................   write_eeprom(eeprom_index,cksum); 
0681:  MOVF   0B,W
0682:  MOVWF  77
0683:  BCF    0B.7
0684:  MOVF   35,W
0685:  MOVLB  03
0686:  MOVWF  11
0687:  MOVLB  02
0688:  MOVF   38,W
0689:  MOVLB  03
068A:  MOVWF  13
068B:  BCF    15.7
068C:  BSF    15.2
068D:  MOVLW  55
068E:  MOVWF  16
068F:  MOVLW  AA
0690:  MOVWF  16
0691:  BSF    15.1
0692:  BTFSC  15.1
0693:  GOTO   692
0694:  BCF    15.2
0695:  MOVF   77,W
0696:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
0697:  MOVLW  D1
0698:  MOVWF  11
0699:  MOVLW  04
069A:  MOVWF  12
069B:  MOVLB  00
069C:  CALL   530
.................... } // }}} 
069D:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
069E:  MOVLB  02
069F:  MOVF   33,W
06A0:  MOVWF  34
06A1:  MOVLB  00
06A2:  CALL   59D
06A3:  MOVF   78,F
06A4:  BTFSS  03.2
06A5:  GOTO   6B2
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
06A6:  MOVLW  E4
06A7:  MOVLB  03
06A8:  MOVWF  11
06A9:  MOVLW  04
06AA:  MOVWF  12
06AB:  MOVLB  00
06AC:  CALL   530
....................         _init_variables(USE_DEFAULT_VARS); 
06AD:  MOVLB  02
06AE:  CLRF   34
06AF:  MOVLB  00
06B0:  CALL   59D
....................     store_variables(); 
06B1:  CALL   623
....................     } 
.................... } // }}} 
06B2:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0D95:  MOVLB  02
0D96:  CLRF   45
0D97:  CLRF   46
0D98:  MOVLB  00
0D99:  CALL   000
....................   set_trimpot(1,0); 
0D9A:  MOVLW  01
0D9B:  MOVLB  02
0D9C:  MOVWF  45
0D9D:  CLRF   46
0D9E:  MOVLB  00
0D9F:  CALL   000
....................   set_trimpot(2,0); 
0DA0:  MOVLW  02
0DA1:  MOVLB  02
0DA2:  MOVWF  45
0DA3:  CLRF   46
0DA4:  MOVLB  00
0DA5:  CALL   000
....................   set_trimpot(3,0); 
0DA6:  MOVLW  03
0DA7:  MOVLB  02
0DA8:  MOVWF  45
0DA9:  CLRF   46
0DAA:  MOVLB  00
0DAB:  CALL   000
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0D1D:  MOVLP  00
0D1E:  CALL   516
0D1F:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0D20:  MOVLB  02
0D21:  CLRF   12
0D22:  CLRF   11
0D23:  CLRF   14
0D24:  CLRF   13
....................   setup_wdt(WDT_2S); 
0D25:  MOVLW  17
0D26:  MOVLB  01
0D27:  MOVWF  17
....................   COR_IN=0; 
0D28:  MOVLB  00
0D29:  CLRF   5F
....................   COR_DROP_FLAG=0; 
0D2A:  BCF    72.7
....................   LastRegisterIndexValid=0; 
0D2B:  CLRF   7D
....................   LastRegisterIndex=0; 
0D2C:  CLRF   7C
....................   CurrentCorMask=0; 
0D2D:  CLRF   6A
....................   CurrentCorPriority=0; 
0D2E:  CLRF   6C
....................   CurrentCorIndex=0; 
0D2F:  CLRF   6B
....................   CurrentTrimPot=0; 
0D30:  CLRF   74
....................   set_tris_b(0xFF); 
0D31:  MOVLW  FF
0D32:  TRIS   6
....................   set_tris_d(0x00); 
0D33:  MOVLW  00
0D34:  MOVLB  01
0D35:  MOVWF  0F
....................   // 0b11111000 
....................   set_tris_e(0xF8); 
0D36:  BCF    10.0
0D37:  BCF    10.1
0D38:  BCF    10.2
0D39:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0D3A:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0D3B:  BSF    0B.3
0D3C:  MOVLW  CF
0D3D:  MOVLB  07
0D3E:  IORWF  14,F
0D3F:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0D40:  BSF    0B.3
0D41:  BSF    15.4
0D42:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0D43:  MOVLW  C0
0D44:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0D45:  MOVLB  02
0D46:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0D47:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0D48:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0D49:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0D4A:  MOVLW  01
0D4B:  MOVWF  33
0D4C:  MOVLP  00
0D4D:  MOVLB  00
0D4E:  CALL   69E
0D4F:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D81:  MOVLB  01
0D82:  BSF    5B.4
....................   Enable_Mask = 0x0F; 
0D83:  MOVLW  0F
0D84:  MOVLB  00
0D85:  MOVWF  61
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D86:  MOVF   62,W
0D87:  ANDLW  0F
0D88:  IORLW  C0
0D89:  MOVLB  04
0D8A:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D8B:  MOVLB  01
0D8C:  BCF    15.7
....................   // }}} 
....................   header(); 
0D8D:  MOVLP  00
0D8E:  MOVLB  00
0D8F:  CALL   003
0D90:  MOVLP  08
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D91:  MOVLW  9D
0D92:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0D93:  MOVLW  80
0D94:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0DAC:  MOVLB  01
0DAD:  CLRF   2F
0DAE:  MOVLW  1E
0DAF:  MOVWF  2E
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0DB0:  MOVF   15,W
0DB1:  ANDLW  C0
0DB2:  IORLW  07
0DB3:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0DB4:  BSF    0B.5
....................   update_ptt(0); 
0DB5:  MOVLB  02
0DB6:  CLRF   34
0DB7:  MOVLB  00
0DB8:  CALL   3B4
....................   MinuteCounter=MIN_COUNTER; 
0DB9:  MOVLW  1D
0DBA:  MOVLB  01
0DBB:  MOVWF  5D
....................   SecondCounter=SEC_COUNTER; 
0DBC:  MOVLW  3B
0DBD:  MOVWF  5C
....................   THIRTY_MIN_FLAG=0; 
0DBE:  BCF    72.6
....................   MINUTE_FLAG=0; 
0DBF:  BCF    72.5
....................   PROMPT_FLAG=1; 
0DC0:  BSF    5B.5
....................   TailChar=Tail; 
0DC1:  MOVLB  00
0DC2:  MOVF   65,W
0DC3:  MOVWF  68
....................   ConfirmChar=0; 
0DC4:  CLRF   69
....................   AuxOut[0] = PO_AUX_OUT0; 
0DC5:  MOVLW  01
0DC6:  MOVWF  42
....................   AuxOut[1] = PO_AUX_OUT1; 
0DC7:  MOVWF  43
....................   AuxOut[2] = PO_AUX_OUT2; 
0DC8:  MOVWF  44
....................   AuxInSW[0] = 0; 
0DC9:  CLRF   3F
....................   AuxInSW[1] = 0; 
0DCA:  CLRF   40
....................   AuxInSW[2] = 0; 
0DCB:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0DCC:  MOVLB  01
0DCD:  BCF    5B.0
....................   COR_IN_EFFECTIVE=0; 
0DCE:  MOVLB  00
0DCF:  CLRF   6D
....................   set_admin_mode(0); 
0DD0:  MOVLB  02
0DD1:  CLRF   46
0DD2:  MOVLB  00
0DD3:  CALL   506
....................   rs232_mode=0; 
0DD4:  MOVLB  01
0DD5:  BCF    5B.7
....................   button_state=0; 
0DD6:  CLRF   5A
.................... //  setup_adc_ports(ADJ_POT); 
.................... //  set_adc_channel(13); 
.................... //  printf("\n\rInitialization complete"); 
.................... } // }}} 
0DD7:  MOVLP  18
0DD8:  MOVLB  00
0DD9:  GOTO   5C4 (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180D:  MOVLB  02
180E:  BCF    2E.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
180F:  CLRF   45
1810:  CLRF   46
1811:  MOVLW  20
1812:  MOVWF  05
1813:  MOVLW  B1
1814:  MOVWF  04
1815:  MOVF   45,W
1816:  ADDWF  04,F
1817:  MOVLW  00
1818:  ADDWFC 05,F
1819:  MOVF   46,W
181A:  MOVLP  00
181B:  MOVLB  00
181C:  CALL   135
181D:  MOVLP  18
181E:  MOVWF  00
181F:  IORLW  00
1820:  BTFSC  03.2
1821:  GOTO   027
1822:  MOVLB  02
1823:  INCF   46,F
1824:  INCF   45,F
1825:  GOTO   011
1826:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1827:  MOVLW  20
1828:  MOVLB  02
1829:  MOVWF  46
182A:  MOVLW  4E
182B:  MOVWF  45
182C:  MOVLW  20
182D:  MOVWF  48
182E:  MOVLW  B1
182F:  MOVWF  47
1830:  MOVLP  08
1831:  MOVLB  00
1832:  CALL   604
1833:  MOVLP  18
1834:  MOVF   79,W
1835:  MOVLB  02
1836:  MOVWF  30
1837:  MOVF   78,W
1838:  MOVWF  2F
....................   if (sptr!=0) {; 
1839:  MOVF   2F,F
183A:  BTFSS  03.2
183B:  GOTO   03F
183C:  MOVF   30,F
183D:  BTFSC  03.2
183E:  GOTO   059
....................     strcpy(verb,sptr); 
183F:  MOVF   30,W
1840:  MOVWF  48
1841:  MOVF   2F,W
1842:  MOVWF  47
1843:  MOVLW  20
1844:  MOVWF  46
1845:  MOVLW  A6
1846:  MOVWF  45
1847:  MOVF   48,W
1848:  MOVWF  05
1849:  MOVF   47,W
184A:  MOVWF  04
184B:  MOVF   00,W
184C:  MOVWF  49
184D:  MOVF   46,W
184E:  MOVWF  05
184F:  MOVF   45,W
1850:  MOVWF  04
1851:  MOVF   49,W
1852:  MOVWF  00
1853:  MOVF   00,F
1854:  BTFSC  03.2
1855:  GOTO   059
1856:  INCF   45,F
1857:  INCF   47,F
1858:  GOTO   047
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
1859:  CLRF   46
185A:  CLRF   45
185B:  MOVLW  20
185C:  MOVWF  48
185D:  MOVLW  B1
185E:  MOVWF  47
185F:  MOVLP  08
1860:  MOVLB  00
1861:  CALL   604
1862:  MOVLP  18
1863:  MOVF   79,W
1864:  MOVLB  02
1865:  MOVWF  30
1866:  MOVF   78,W
1867:  MOVWF  2F
....................   if (sptr!=0) {; 
1868:  MOVF   2F,F
1869:  BTFSS  03.2
186A:  GOTO   06E
186B:  MOVF   30,F
186C:  BTFSC  03.2
186D:  GOTO   088
....................     strcpy(argument_name,sptr); 
186E:  MOVF   30,W
186F:  MOVWF  48
1870:  MOVF   2F,W
1871:  MOVWF  47
1872:  MOVLW  20
1873:  MOVWF  46
1874:  MOVLW  6E
1875:  MOVWF  45
1876:  MOVF   48,W
1877:  MOVWF  05
1878:  MOVF   47,W
1879:  MOVWF  04
187A:  MOVF   00,W
187B:  MOVWF  49
187C:  MOVF   46,W
187D:  MOVWF  05
187E:  MOVF   45,W
187F:  MOVWF  04
1880:  MOVF   49,W
1881:  MOVWF  00
1882:  MOVF   00,F
1883:  BTFSC  03.2
1884:  GOTO   088
1885:  INCF   45,F
1886:  INCF   47,F
1887:  GOTO   076
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1888:  CLRF   46
1889:  CLRF   45
188A:  MOVLW  20
188B:  MOVWF  48
188C:  MOVLW  B1
188D:  MOVWF  47
188E:  MOVLP  08
188F:  MOVLB  00
1890:  CALL   604
1891:  MOVLP  18
1892:  MOVF   79,W
1893:  MOVLB  02
1894:  MOVWF  30
1895:  MOVF   78,W
1896:  MOVWF  2F
....................   if (sptr!=0) {; 
1897:  MOVF   2F,F
1898:  BTFSS  03.2
1899:  GOTO   09D
189A:  MOVF   30,F
189B:  BTFSC  03.2
189C:  GOTO   0C3
....................     strcpy(match_val,sptr); 
189D:  MOVF   30,W
189E:  MOVWF  48
189F:  MOVF   2F,W
18A0:  MOVWF  47
18A1:  MOVLW  20
18A2:  MOVWF  46
18A3:  MOVLW  B9
18A4:  MOVWF  45
18A5:  MOVF   48,W
18A6:  MOVWF  05
18A7:  MOVF   47,W
18A8:  MOVWF  04
18A9:  MOVF   00,W
18AA:  MOVWF  49
18AB:  MOVF   46,W
18AC:  MOVWF  05
18AD:  MOVF   45,W
18AE:  MOVWF  04
18AF:  MOVF   49,W
18B0:  MOVWF  00
18B1:  MOVF   00,F
18B2:  BTFSC  03.2
18B3:  GOTO   0B7
18B4:  INCF   45,F
18B5:  INCF   47,F
18B6:  GOTO   0A5
....................     value = str_to_decimal(match_val); 
18B7:  MOVLW  20
18B8:  MOVWF  46
18B9:  MOVLW  B9
18BA:  MOVWF  45
18BB:  MOVLP  08
18BC:  MOVLB  00
18BD:  CALL   70A
18BE:  MOVLP  18
18BF:  MOVF   78,W
18C0:  MOVWF  76
....................   } else { 
18C1:  GOTO   0C6
18C2:  MOVLB  02
....................     value = 0; 
18C3:  CLRF   76
....................     do_get_var = 1; 
18C4:  BSF    2E.0
18C5:  MOVLB  00
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18C6:  MOVLB  02
18C7:  CLRF   45
18C8:  CLRF   46
18C9:  MOVLW  20
18CA:  MOVWF  05
18CB:  MOVLW  BD
18CC:  MOVWF  04
18CD:  MOVF   45,W
18CE:  ADDWF  04,F
18CF:  MOVLW  00
18D0:  ADDWFC 05,F
18D1:  MOVF   46,W
18D2:  MOVLP  00
18D3:  MOVLB  00
18D4:  CALL   13B
18D5:  MOVLP  18
18D6:  MOVWF  00
18D7:  IORLW  00
18D8:  BTFSC  03.2
18D9:  GOTO   0DF
18DA:  MOVLB  02
18DB:  INCF   46,F
18DC:  INCF   45,F
18DD:  GOTO   0C9
18DE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
18DF:  MOVLW  20
18E0:  MOVLB  02
18E1:  MOVWF  46
18E2:  MOVLW  BD
18E3:  MOVWF  45
18E4:  MOVLW  20
18E5:  MOVWF  48
18E6:  MOVLW  A6
18E7:  MOVWF  47
18E8:  MOVLP  08
18E9:  MOVLB  00
18EA:  CALL   743
18EB:  MOVLP  18
18EC:  MOVF   78,F
18ED:  BTFSS  03.2
18EE:  GOTO   0F8
....................     if ( do_get_var ) { 
18EF:  MOVLB  02
18F0:  BTFSS  2E.0
18F1:  GOTO   0F5
....................       command=GET_REG; 
18F2:  MOVLW  03
18F3:  MOVWF  70
....................     } else { 
18F4:  GOTO   0F7
....................       command=SET_REG; 
18F5:  MOVLW  02
18F6:  MOVWF  70
18F7:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18F8:  MOVLB  02
18F9:  CLRF   45
18FA:  CLRF   46
18FB:  MOVLW  20
18FC:  MOVWF  05
18FD:  MOVLW  BD
18FE:  MOVWF  04
18FF:  MOVF   45,W
1900:  ADDWF  04,F
1901:  MOVLW  00
1902:  ADDWFC 05,F
1903:  MOVF   46,W
1904:  MOVLP  00
1905:  MOVLB  00
1906:  CALL   140
1907:  MOVLP  18
1908:  MOVWF  00
1909:  IORLW  00
190A:  BTFSC  03.2
190B:  GOTO   111
190C:  MOVLB  02
190D:  INCF   46,F
190E:  INCF   45,F
190F:  GOTO   0FB
1910:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1911:  MOVLW  20
1912:  MOVLB  02
1913:  MOVWF  46
1914:  MOVLW  BD
1915:  MOVWF  45
1916:  MOVLW  20
1917:  MOVWF  48
1918:  MOVLW  A6
1919:  MOVWF  47
191A:  MOVLP  08
191B:  MOVLB  00
191C:  CALL   743
191D:  MOVLP  18
191E:  MOVF   78,F
191F:  BTFSS  03.2
1920:  GOTO   123
....................       command=SAVE_SETTINGS; 
1921:  MOVLW  04
1922:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1923:  MOVLB  02
1924:  CLRF   45
1925:  CLRF   46
1926:  MOVLW  20
1927:  MOVWF  05
1928:  MOVLW  BD
1929:  MOVWF  04
192A:  MOVF   45,W
192B:  ADDWF  04,F
192C:  MOVLW  00
192D:  ADDWFC 05,F
192E:  MOVF   46,W
192F:  MOVLP  00
1930:  MOVLB  00
1931:  CALL   146
1932:  MOVLP  18
1933:  MOVWF  00
1934:  IORLW  00
1935:  BTFSC  03.2
1936:  GOTO   13C
1937:  MOVLB  02
1938:  INCF   46,F
1939:  INCF   45,F
193A:  GOTO   126
193B:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
193C:  MOVLW  20
193D:  MOVLB  02
193E:  MOVWF  46
193F:  MOVLW  BD
1940:  MOVWF  45
1941:  MOVLW  20
1942:  MOVWF  48
1943:  MOVLW  A6
1944:  MOVWF  47
1945:  MOVLP  08
1946:  MOVLB  00
1947:  CALL   743
1948:  MOVLP  18
1949:  MOVF   78,F
194A:  BTFSS  03.2
194B:  GOTO   14E
....................       command=RESTORE_SETTINGS; 
194C:  MOVLW  05
194D:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
194E:  MOVLB  02
194F:  CLRF   45
1950:  CLRF   46
1951:  MOVLW  20
1952:  MOVWF  05
1953:  MOVLW  BD
1954:  MOVWF  04
1955:  MOVF   45,W
1956:  ADDWF  04,F
1957:  MOVLW  00
1958:  ADDWFC 05,F
1959:  MOVF   46,W
195A:  MOVLP  00
195B:  MOVLB  00
195C:  CALL   14F
195D:  MOVLP  18
195E:  MOVWF  00
195F:  IORLW  00
1960:  BTFSC  03.2
1961:  GOTO   167
1962:  MOVLB  02
1963:  INCF   46,F
1964:  INCF   45,F
1965:  GOTO   151
1966:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1967:  MOVLW  20
1968:  MOVLB  02
1969:  MOVWF  46
196A:  MOVLW  BD
196B:  MOVWF  45
196C:  MOVLW  20
196D:  MOVWF  48
196E:  MOVLW  A6
196F:  MOVWF  47
1970:  MOVLP  08
1971:  MOVLB  00
1972:  CALL   743
1973:  MOVLP  18
1974:  MOVF   78,F
1975:  BTFSS  03.2
1976:  GOTO   179
....................     command=STATUS; 
1977:  MOVLW  08
1978:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
1979:  MOVLB  02
197A:  CLRF   45
197B:  CLRF   46
197C:  MOVLW  20
197D:  MOVWF  05
197E:  MOVLW  BD
197F:  MOVWF  04
1980:  MOVF   45,W
1981:  ADDWF  04,F
1982:  MOVLW  00
1983:  ADDWFC 05,F
1984:  MOVF   46,W
1985:  MOVLP  00
1986:  MOVLB  00
1987:  CALL   157
1988:  MOVLP  18
1989:  MOVWF  00
198A:  IORLW  00
198B:  BTFSC  03.2
198C:  GOTO   192
198D:  MOVLB  02
198E:  INCF   46,F
198F:  INCF   45,F
1990:  GOTO   17C
1991:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1992:  MOVLW  20
1993:  MOVLB  02
1994:  MOVWF  46
1995:  MOVLW  BD
1996:  MOVWF  45
1997:  MOVLW  20
1998:  MOVWF  48
1999:  MOVLW  A6
199A:  MOVWF  47
199B:  MOVLP  08
199C:  MOVLB  00
199D:  CALL   743
199E:  MOVLP  18
199F:  MOVF   78,F
19A0:  BTFSS  03.2
19A1:  GOTO   1A6
....................     command=ADMIN; 
19A2:  MOVLW  09
19A3:  MOVWF  70
....................     argument=REBOOT; 
19A4:  MOVLW  02
19A5:  MOVWF  75
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19A6:  MOVLB  02
19A7:  CLRF   45
19A8:  CLRF   46
19A9:  MOVLW  20
19AA:  MOVWF  05
19AB:  MOVLW  BD
19AC:  MOVWF  04
19AD:  MOVF   45,W
19AE:  ADDWF  04,F
19AF:  MOVLW  00
19B0:  ADDWFC 05,F
19B1:  MOVF   46,W
19B2:  MOVLP  00
19B3:  MOVLB  00
19B4:  CALL   15F
19B5:  MOVLP  18
19B6:  MOVWF  00
19B7:  IORLW  00
19B8:  BTFSC  03.2
19B9:  GOTO   1BF
19BA:  MOVLB  02
19BB:  INCF   46,F
19BC:  INCF   45,F
19BD:  GOTO   1A9
19BE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19BF:  MOVLW  20
19C0:  MOVLB  02
19C1:  MOVWF  46
19C2:  MOVLW  BD
19C3:  MOVWF  45
19C4:  MOVLW  20
19C5:  MOVWF  48
19C6:  MOVLW  A6
19C7:  MOVWF  47
19C8:  MOVLP  08
19C9:  MOVLB  00
19CA:  CALL   743
19CB:  MOVLP  18
19CC:  MOVF   78,F
19CD:  BTFSS  03.2
19CE:  GOTO   220
....................     //command=DTMF_SEND; 
....................     command=0; 
19CF:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D0:  MOVLW  20
19D1:  MOVLB  02
19D2:  MOVWF  46
19D3:  MOVLW  6E
19D4:  MOVWF  45
19D5:  MOVLP  08
19D6:  MOVLB  00
19D7:  CALL   70A
19D8:  MOVLP  18
19D9:  MOVF   78,W
19DA:  MOVWF  76
....................     if ( value == d0 ) { 
19DB:  MOVF   76,W
19DC:  SUBLW  0A
19DD:  BTFSS  03.2
19DE:  GOTO   1E1
....................       value = dd; 
19DF:  CLRF   76
....................     } else if (value == dd) { 
19E0:  GOTO   1E6
19E1:  MOVF   76,F
19E2:  BTFSS  03.2
19E3:  GOTO   1E6
....................       value = d0; 
19E4:  MOVLW  0A
19E5:  MOVWF  76
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19E6:  MOVF   76,W
19E7:  ANDLW  0F
19E8:  MOVLB  02
19E9:  MOVWF  45
19EA:  MOVF   45,W
19EB:  MOVWF  46
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A20:  MOVLB  02
1A21:  CLRF   45
1A22:  CLRF   46
1A23:  MOVLW  20
1A24:  MOVWF  05
1A25:  MOVLW  BD
1A26:  MOVWF  04
1A27:  MOVF   45,W
1A28:  ADDWF  04,F
1A29:  MOVLW  00
1A2A:  ADDWFC 05,F
1A2B:  MOVF   46,W
1A2C:  MOVLP  00
1A2D:  MOVLB  00
1A2E:  CALL   162
1A2F:  MOVLP  18
1A30:  MOVWF  00
1A31:  IORLW  00
1A32:  BTFSC  03.2
1A33:  GOTO   239
1A34:  MOVLB  02
1A35:  INCF   46,F
1A36:  INCF   45,F
1A37:  GOTO   223
1A38:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A39:  MOVLW  20
1A3A:  MOVLB  02
1A3B:  MOVWF  46
1A3C:  MOVLW  BD
1A3D:  MOVWF  45
1A3E:  MOVLW  20
1A3F:  MOVWF  48
1A40:  MOVLW  A6
1A41:  MOVWF  47
1A42:  MOVLP  08
1A43:  MOVLB  00
1A44:  CALL   743
1A45:  MOVLP  18
1A46:  MOVF   78,F
1A47:  BTFSS  03.2
1A48:  GOTO   24B
....................     command=I2C_SEND; 
1A49:  MOVLW  0C
1A4A:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A4B:  MOVLB  02
1A4C:  CLRF   45
1A4D:  CLRF   46
1A4E:  MOVLW  20
1A4F:  MOVWF  05
1A50:  MOVLW  BD
1A51:  MOVWF  04
1A52:  MOVF   45,W
1A53:  ADDWF  04,F
1A54:  MOVLW  00
1A55:  ADDWFC 05,F
1A56:  MOVF   46,W
1A57:  MOVLP  00
1A58:  MOVLB  00
1A59:  CALL   167
1A5A:  MOVLP  18
1A5B:  MOVWF  00
1A5C:  IORLW  00
1A5D:  BTFSC  03.2
1A5E:  GOTO   264
1A5F:  MOVLB  02
1A60:  INCF   46,F
1A61:  INCF   45,F
1A62:  GOTO   24E
1A63:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A64:  MOVLW  20
1A65:  MOVLB  02
1A66:  MOVWF  46
1A67:  MOVLW  BD
1A68:  MOVWF  45
1A69:  MOVLW  20
1A6A:  MOVWF  48
1A6B:  MOVLW  A6
1A6C:  MOVWF  47
1A6D:  MOVLP  08
1A6E:  MOVLB  00
1A6F:  CALL   743
1A70:  MOVLP  18
1A71:  MOVF   78,F
1A72:  BTFSS  03.2
1A73:  GOTO   28B
....................     value = str_to_decimal(argument_name); 
1A74:  MOVLW  20
1A75:  MOVLB  02
1A76:  MOVWF  46
1A77:  MOVLW  6E
1A78:  MOVWF  45
1A79:  MOVLP  08
1A7A:  MOVLB  00
1A7B:  CALL   70A
1A7C:  MOVLP  18
1A7D:  MOVF   78,W
1A7E:  MOVWF  76
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A7F:  MOVF   76,W
1A80:  SUBLW  24
1A81:  BTFSS  03.0
1A82:  GOTO   287
....................       argument = 0; 
1A83:  CLRF   75
....................       command  = MORSE_SEND; 
1A84:  MOVLW  0B
1A85:  MOVWF  70
....................     } else { 
1A86:  GOTO   28B
....................       command  = ADMIN; 
1A87:  MOVLW  09
1A88:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A89:  MOVLW  03
1A8A:  MOVWF  75
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A8B:  MOVLB  02
1A8C:  CLRF   45
1A8D:  CLRF   46
1A8E:  MOVLW  20
1A8F:  MOVWF  05
1A90:  MOVLW  BD
1A91:  MOVWF  04
1A92:  MOVF   45,W
1A93:  ADDWF  04,F
1A94:  MOVLW  00
1A95:  ADDWFC 05,F
1A96:  MOVF   46,W
1A97:  MOVLP  00
1A98:  MOVLB  00
1A99:  CALL   16E
1A9A:  MOVLP  18
1A9B:  MOVWF  00
1A9C:  IORLW  00
1A9D:  BTFSC  03.2
1A9E:  GOTO   2A4
1A9F:  MOVLB  02
1AA0:  INCF   46,F
1AA1:  INCF   45,F
1AA2:  GOTO   28E
1AA3:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AA4:  MOVLW  20
1AA5:  MOVLB  02
1AA6:  MOVWF  46
1AA7:  MOVLW  BD
1AA8:  MOVWF  45
1AA9:  MOVLW  20
1AAA:  MOVWF  48
1AAB:  MOVLW  A6
1AAC:  MOVWF  47
1AAD:  MOVLP  08
1AAE:  MOVLB  00
1AAF:  CALL   743
1AB0:  MOVLP  18
1AB1:  MOVF   78,F
1AB2:  BTFSS  03.2
1AB3:  GOTO   2B6
....................     command=INCREMENT_REG; 
1AB4:  MOVLW  06
1AB5:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1AB6:  MOVLB  02
1AB7:  CLRF   45
1AB8:  CLRF   46
1AB9:  MOVLW  20
1ABA:  MOVWF  05
1ABB:  MOVLW  BD
1ABC:  MOVWF  04
1ABD:  MOVF   45,W
1ABE:  ADDWF  04,F
1ABF:  MOVLW  00
1AC0:  ADDWFC 05,F
1AC1:  MOVF   46,W
1AC2:  MOVLP  00
1AC3:  MOVLB  00
1AC4:  CALL   171
1AC5:  MOVLP  18
1AC6:  MOVWF  00
1AC7:  IORLW  00
1AC8:  BTFSC  03.2
1AC9:  GOTO   2CF
1ACA:  MOVLB  02
1ACB:  INCF   46,F
1ACC:  INCF   45,F
1ACD:  GOTO   2B9
1ACE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1ACF:  MOVLW  20
1AD0:  MOVLB  02
1AD1:  MOVWF  46
1AD2:  MOVLW  BD
1AD3:  MOVWF  45
1AD4:  MOVLW  20
1AD5:  MOVWF  48
1AD6:  MOVLW  A6
1AD7:  MOVWF  47
1AD8:  MOVLP  08
1AD9:  MOVLB  00
1ADA:  CALL   743
1ADB:  MOVLP  18
1ADC:  MOVF   78,F
1ADD:  BTFSS  03.2
1ADE:  GOTO   2E1
....................     command=DECREMENT_REG; 
1ADF:  MOVLW  07
1AE0:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AE1:  MOVLB  02
1AE2:  CLRF   45
1AE3:  CLRF   46
1AE4:  MOVLW  20
1AE5:  MOVWF  05
1AE6:  MOVLW  BD
1AE7:  MOVWF  04
1AE8:  MOVF   45,W
1AE9:  ADDWF  04,F
1AEA:  MOVLW  00
1AEB:  ADDWFC 05,F
1AEC:  MOVF   46,W
1AED:  MOVLP  00
1AEE:  MOVLB  00
1AEF:  CALL   174
1AF0:  MOVLP  18
1AF1:  MOVWF  00
1AF2:  IORLW  00
1AF3:  BTFSC  03.2
1AF4:  GOTO   2FA
1AF5:  MOVLB  02
1AF6:  INCF   46,F
1AF7:  INCF   45,F
1AF8:  GOTO   2E4
1AF9:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AFA:  MOVLW  20
1AFB:  MOVLB  02
1AFC:  MOVWF  46
1AFD:  MOVLW  BD
1AFE:  MOVWF  45
1AFF:  MOVLW  20
1B00:  MOVWF  48
1B01:  MOVLW  A6
1B02:  MOVWF  47
1B03:  MOVLP  08
1B04:  MOVLB  00
1B05:  CALL   743
1B06:  MOVLP  18
1B07:  MOVF   78,F
1B08:  BTFSS  03.2
1B09:  GOTO   329
....................     command=SET_REG; 
1B0A:  MOVLW  02
1B0B:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B0C:  MOVLW  01
1B0D:  ADDWF  74,W
1B0E:  ANDLW  03
1B0F:  MOVWF  76
....................     strcpy(argument_name,"CPOT"); 
1B10:  MOVLB  02
1B11:  CLRF   45
1B12:  CLRF   46
1B13:  MOVLW  20
1B14:  MOVWF  05
1B15:  MOVLW  6E
1B16:  MOVWF  04
1B17:  MOVF   45,W
1B18:  ADDWF  04,F
1B19:  MOVLW  00
1B1A:  ADDWFC 05,F
1B1B:  MOVF   46,W
1B1C:  MOVLP  00
1B1D:  MOVLB  00
1B1E:  CALL   177
1B1F:  MOVLP  18
1B20:  MOVWF  00
1B21:  IORLW  00
1B22:  BTFSC  03.2
1B23:  GOTO   329
1B24:  MOVLB  02
1B25:  INCF   46,F
1B26:  INCF   45,F
1B27:  GOTO   313
1B28:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B29:  MOVLB  02
1B2A:  CLRF   45
1B2B:  CLRF   46
1B2C:  MOVLW  20
1B2D:  MOVWF  05
1B2E:  MOVLW  BD
1B2F:  MOVWF  04
1B30:  MOVF   45,W
1B31:  ADDWF  04,F
1B32:  MOVLW  00
1B33:  ADDWFC 05,F
1B34:  MOVF   46,W
1B35:  MOVLP  00
1B36:  MOVLB  00
1B37:  CALL   17D
1B38:  MOVLP  18
1B39:  MOVWF  00
1B3A:  IORLW  00
1B3B:  BTFSC  03.2
1B3C:  GOTO   342
1B3D:  MOVLB  02
1B3E:  INCF   46,F
1B3F:  INCF   45,F
1B40:  GOTO   32C
1B41:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B42:  MOVLW  20
1B43:  MOVLB  02
1B44:  MOVWF  46
1B45:  MOVLW  BD
1B46:  MOVWF  45
1B47:  MOVLW  20
1B48:  MOVWF  48
1B49:  MOVLW  A6
1B4A:  MOVWF  47
1B4B:  MOVLP  08
1B4C:  MOVLB  00
1B4D:  CALL   743
1B4E:  MOVLP  18
1B4F:  MOVF   78,F
1B50:  BTFSS  03.2
1B51:  GOTO   362
....................     AdminMode = ~AdminMode; 
1B52:  MOVLW  40
1B53:  MOVLB  01
1B54:  XORWF  5B,F
....................     set_admin_mode(AdminMode); 
1B55:  MOVLW  00
1B56:  BTFSC  5B.6
1B57:  MOVLW  01
1B58:  MOVLB  02
1B59:  MOVWF  45
1B5A:  MOVWF  46
1B5B:  MOVLP  08
1B5C:  MOVLB  00
1B5D:  CALL   506
1B5E:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B5F:  MOVLB  01
1B60:  BSF    5B.5
1B61:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
110E:  MOVF   76,W
110F:  SUBLW  FF
1110:  BTFSS  03.2
1111:  GOTO   138
....................     printf ("\n\r%s %u",argument,value); 
1112:  MOVLW  0A
1113:  CLRWDT
1114:  BTFSS  11.4
1115:  GOTO   113
1116:  MOVLB  03
1117:  MOVWF  1A
1118:  MOVLW  0D
1119:  CLRWDT
111A:  MOVLB  00
111B:  BTFSC  11.4
111C:  GOTO   11F
111D:  MOVLB  03
111E:  GOTO   119
111F:  MOVLB  03
1120:  MOVWF  1A
1121:  CLRF   05
1122:  MOVF   75,W
1123:  MOVWF  04
1124:  MOVLP  08
1125:  MOVLB  00
1126:  CALL   2A6
1127:  MOVLP  10
1128:  MOVLW  20
1129:  CLRWDT
112A:  BTFSS  11.4
112B:  GOTO   129
112C:  MOVLB  03
112D:  MOVWF  1A
112E:  MOVF   76,W
112F:  MOVLB  02
1130:  MOVWF  56
1131:  MOVLW  1B
1132:  MOVWF  57
1133:  MOVLP  00
1134:  MOVLB  00
1135:  CALL   77C
1136:  MOVLP  10
....................   } else { 
1137:  GOTO   1C9
....................     pObj=RegMap[argument].reg_ptr; 
1138:  RLF    75,W
1139:  MOVWF  77
113A:  RLF    77,F
113B:  MOVLW  FC
113C:  ANDWF  77,F
113D:  MOVF   77,W
113E:  MOVLB  02
113F:  MOVWF  35
1140:  INCF   35,W
1141:  MOVLP  00
1142:  MOVLB  00
1143:  CALL   043
1144:  MOVLP  10
1145:  MOVWF  7A
1146:  MOVLB  02
1147:  MOVF   35,W
1148:  MOVLP  00
1149:  MOVLB  00
114A:  CALL   043
114B:  MOVLP  10
114C:  MOVLB  02
114D:  MOVWF  32
114E:  MOVF   7A,W
114F:  MOVWF  33
....................     if ( in_admin_mode() ) { 
1150:  MOVLP  08
1151:  MOVLB  00
1152:  CALL   7AE
1153:  MOVLP  10
1154:  MOVF   78,F
1155:  BTFSC  03.2
1156:  GOTO   15F
....................       *pObj=value; 
1157:  MOVLB  02
1158:  MOVF   32,W
1159:  MOVWF  04
115A:  MOVF   33,W
115B:  MOVWF  05
115C:  MOVF   76,W
115D:  MOVWF  00
115E:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
115F:  MOVLB  02
1160:  MOVF   32,W
1161:  MOVWF  04
1162:  MOVF   33,W
1163:  MOVWF  05
1164:  MOVF   00,W
1165:  MOVWF  34
....................     LastRegisterIndex = argument; 
1166:  MOVF   75,W
1167:  MOVWF  7C
....................     LastRegisterIndexValid=1; 
1168:  MOVLW  01
1169:  MOVWF  7D
....................     printf ("\n\rSetting %s(%u) to %u",argument_name,argument,lVar); 
116A:  MOVLW  FD
116B:  MOVLB  03
116C:  MOVWF  11
116D:  MOVLW  04
116E:  MOVWF  12
116F:  BCF    03.0
1170:  MOVLW  0A
1171:  MOVLB  02
1172:  MOVWF  56
1173:  MOVLP  00
1174:  MOVLB  00
1175:  CALL   708
1176:  MOVLP  10
1177:  MOVLW  20
1178:  MOVWF  05
1179:  MOVLW  6E
117A:  MOVWF  04
117B:  MOVLP  08
117C:  CALL   2A6
117D:  MOVLP  10
117E:  MOVLW  28
117F:  CLRWDT
1180:  BTFSS  11.4
1181:  GOTO   17F
1182:  MOVLB  03
1183:  MOVWF  1A
1184:  MOVF   75,W
1185:  MOVLB  02
1186:  MOVWF  56
1187:  MOVLW  1B
1188:  MOVWF  57
1189:  MOVLP  00
118A:  MOVLB  00
118B:  CALL   77C
118C:  MOVLP  10
118D:  MOVLW  04
118E:  MOVLB  03
118F:  MOVWF  11
1190:  MOVLW  05
1191:  MOVWF  12
1192:  BSF    03.0
1193:  MOVLW  05
1194:  MOVLB  02
1195:  MOVWF  56
1196:  MOVLP  00
1197:  MOVLB  00
1198:  CALL   708
1199:  MOVLP  10
119A:  MOVLB  02
119B:  MOVF   34,W
119C:  MOVWF  56
119D:  MOVLW  1B
119E:  MOVWF  57
119F:  MOVLP  00
11A0:  MOVLB  00
11A1:  CALL   77C
11A2:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
11A3:  MOVLB  02
11A4:  MOVF   33,W
11A5:  SUBLW  1F
11A6:  BTFSC  03.0
11A7:  GOTO   1B9
11A8:  XORLW  FF
11A9:  BTFSS  03.2
11AA:  GOTO   1AF
11AB:  MOVF   32,W
11AC:  SUBLW  0B
11AD:  BTFSC  03.0
11AE:  GOTO   1B9
11AF:  MOVF   33,W
11B0:  SUBLW  20
11B1:  BTFSS  03.0
11B2:  GOTO   1B9
11B3:  BTFSS  03.2
11B4:  GOTO   1C0
11B5:  MOVF   32,W
11B6:  SUBLW  1B
11B7:  BTFSC  03.0
11B8:  GOTO   1C0
11B9:  MOVF   32,W
11BA:  SUBLW  74
11BB:  BTFSS  03.2
11BC:  GOTO   1C6
11BD:  MOVF   33,F
11BE:  BTFSS  03.2
11BF:  GOTO   1C6
....................       increment(0); // Increment is done in this function. Only update trim pot. 
11C0:  CLRF   35
11C1:  MOVLP  08
11C2:  MOVLB  00
11C3:  CALL   7BD
11C4:  MOVLP  10
11C5:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
11C6:  MOVLB  01
11C7:  BSF    5B.5
11C8:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
0FBD:  MOVF   74,W
0FBE:  ANDLW  03
0FBF:  MOVLB  02
0FC0:  MOVWF  39
....................   if ( CurrentCorIndex ) { 
0FC1:  MOVLB  00
0FC2:  MOVF   6B,F
0FC3:  BTFSC  03.2
0FC4:  GOTO   7FA
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
0FC5:  MOVLW  01
0FC6:  SUBWF  6B,W
0FC7:  MOVWF  77
0FC8:  RLF    77,F
0FC9:  RLF    77,F
0FCA:  MOVLW  FC
0FCB:  ANDWF  77,F
0FCC:  MOVF   77,W
0FCD:  MOVLB  02
0FCE:  ADDWF  39,W
0FCF:  ADDLW  0C
0FD0:  MOVWF  78
0FD1:  MOVLW  20
0FD2:  MOVWF  7A
0FD3:  BTFSC  03.0
0FD4:  INCF   7A,F
0FD5:  MOVF   78,W
0FD6:  MOVWF  36
0FD7:  MOVF   7A,W
0FD8:  MOVWF  37
....................     value = *pot_ptr; 
0FD9:  MOVF   36,W
0FDA:  MOVWF  04
0FDB:  MOVF   37,W
0FDC:  MOVWF  05
0FDD:  MOVF   00,W
0FDE:  MOVWF  38
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
0FDF:  MOVF   36,W
0FE0:  MOVWF  04
0FE1:  MOVF   37,W
0FE2:  MOVWF  05
0FE3:  MOVF   35,W
0FE4:  ADDWF  38,W
0FE5:  MOVWF  00
....................     if ( in_admin_mode() ) { 
0FE6:  MOVLB  00
0FE7:  CALL   7AE
0FE8:  MOVF   78,F
0FE9:  BTFSC  03.2
0FEA:  GOTO   7FA
....................       set_trimpot(CPotPtr,*pot_ptr); 
0FEB:  MOVLB  02
0FEC:  MOVF   37,W
0FED:  MOVWF  7A
0FEE:  MOVF   36,W
0FEF:  MOVWF  04
0FF0:  MOVF   37,W
0FF1:  MOVWF  05
0FF2:  MOVF   00,W
0FF3:  MOVWF  3A
0FF4:  MOVF   39,W
0FF5:  MOVWF  45
0FF6:  MOVF   3A,W
0FF7:  MOVWF  46
0FF8:  MOVLB  00
0FF9:  CALL   000
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
0FFA:  CALL   2C0
.................... } // }}} 
0FFB:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
0F83:  MOVLB  02
0F84:  CLRF   45
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
0F85:  MOVF   45,W
0F86:  SUBLW  05
0F87:  BTFSS  03.0
0F88:  GOTO   7AC
....................     dest[c]=src[c]; 
0F89:  MOVF   45,W
0F8A:  ADDWF  41,W
0F8B:  MOVWF  78
0F8C:  MOVLW  00
0F8D:  ADDWFC 42,W
0F8E:  MOVWF  7A
0F8F:  MOVF   78,W
0F90:  MOVWF  46
0F91:  MOVF   7A,W
0F92:  MOVWF  47
0F93:  MOVF   45,W
0F94:  ADDWF  43,W
0F95:  MOVWF  78
0F96:  MOVLW  00
0F97:  ADDWFC 44,W
0F98:  MOVWF  7A
0F99:  MOVF   78,W
0F9A:  MOVLB  03
0F9B:  MOVWF  11
0F9C:  MOVF   7A,W
0F9D:  MOVWF  12
0F9E:  MOVLB  02
0F9F:  MOVF   47,W
0FA0:  MOVWF  05
0FA1:  MOVF   46,W
0FA2:  MOVWF  04
0FA3:  MOVLW  01
0FA4:  MOVWF  4B
0FA5:  MOVLP  00
0FA6:  MOVLB  00
0FA7:  CALL   7E4
0FA8:  MOVLP  08
....................   c++; 
0FA9:  MOVLB  02
0FAA:  INCF   45,F
....................   } 
0FAB:  GOTO   785
.................... } // }}} 
0FAC:  MOVLB  00
0FAD:  RETURN
.................... void ExecAuxOutOp(int op,int arg,int ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
1673:  MOVF   30,W
1674:  ANDLW  0F
1675:  MOVWF  32
....................   uarg = (arg & 0xF0) >> 4; 
1676:  MOVF   30,W
1677:  ANDLW  F0
1678:  MOVWF  77
1679:  SWAPF  77,W
167A:  MOVWF  33
167B:  MOVLW  0F
167C:  ANDWF  33,F
....................   switch(op) { 
167D:  MOVF   2F,W
167E:  XORLW  01
167F:  MOVLB  00
1680:  BTFSC  03.2
1681:  GOTO   686
1682:  XORLW  03
1683:  BTFSC  03.2
1684:  GOTO   69B
1685:  GOTO   6B4
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       AuxOut[ID] = ((COR_IN_EFFECTIVE ^ uarg) & larg) != 0; 
1686:  MOVLW  22
1687:  MOVLB  02
1688:  ADDWF  31,W
1689:  MOVWF  04
168A:  MOVLW  20
168B:  MOVWF  05
168C:  BTFSC  03.0
168D:  INCF   05,F
168E:  MOVLB  00
168F:  MOVF   6D,W
1690:  MOVLB  02
1691:  XORWF  33,W
1692:  ANDWF  32,W
1693:  BTFSS  03.2
1694:  GOTO   697
1695:  MOVLW  00
1696:  GOTO   698
1697:  MOVLW  01
1698:  MOVWF  00
....................     break; 
1699:  MOVLB  00
169A:  GOTO   6B4
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
169B:  MOVLW  22
169C:  MOVLB  02
169D:  ADDWF  31,W
169E:  MOVWF  04
169F:  MOVLW  20
16A0:  MOVWF  05
16A1:  BTFSC  03.0
16A2:  INCF   05,F
16A3:  MOVF   32,W
16A4:  ANDLW  1F
16A5:  MOVWF  36
16A6:  MOVF   7A,W
16A7:  MOVWF  37
16A8:  MOVF   33,W
16A9:  XORWF  36,F
16AA:  BTFSS  03.2
16AB:  GOTO   6B1
16AC:  MOVF   37,F
16AD:  BTFSS  03.2
16AE:  GOTO   6B1
16AF:  MOVLW  00
16B0:  GOTO   6B2
16B1:  MOVLW  01
16B2:  MOVWF  00
....................     break; 
16B3:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0F0A:  MOVLB  02
0F0B:  CLRF   47
0F0C:  CLRF   48
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0F0D:  MOVF   47,W
0F0E:  ADDWF  45,W
0F0F:  MOVWF  04
0F10:  MOVLW  00
0F11:  ADDWFC 46,W
0F12:  MOVWF  05
0F13:  MOVF   00,F
0F14:  BTFSC  03.2
0F15:  GOTO   73F
0F16:  MOVF   47,W
0F17:  ADDWF  45,W
0F18:  MOVWF  04
0F19:  MOVLW  00
0F1A:  ADDWFC 46,W
0F1B:  MOVWF  05
0F1C:  MOVF   00,W
0F1D:  SUBLW  2F
0F1E:  BTFSC  03.0
0F1F:  GOTO   73F
0F20:  MOVF   47,W
0F21:  ADDWF  45,W
0F22:  MOVWF  04
0F23:  MOVLW  00
0F24:  ADDWFC 46,W
0F25:  MOVWF  05
0F26:  MOVF   00,W
0F27:  SUBLW  39
0F28:  BTFSS  03.0
0F29:  GOTO   73F
....................     value = (value * 10) + (str[x]-'0'); 
0F2A:  MOVF   48,W
0F2B:  MOVWF  49
0F2C:  MOVLW  0A
0F2D:  MOVWF  4A
0F2E:  MOVLB  00
0F2F:  CALL   6E3
0F30:  MOVF   78,W
0F31:  MOVLB  02
0F32:  MOVWF  49
0F33:  MOVF   47,W
0F34:  ADDWF  45,W
0F35:  MOVWF  04
0F36:  MOVLW  00
0F37:  ADDWFC 46,W
0F38:  MOVWF  05
0F39:  MOVLW  30
0F3A:  SUBWF  00,W
0F3B:  ADDWF  49,W
0F3C:  MOVWF  48
....................     x++; 
0F3D:  INCF   47,F
....................   } 
0F3E:  GOTO   70D
....................   return(value); 
0F3F:  MOVF   48,W
0F40:  MOVWF  78
.................... } // }}} 
0F41:  MOVLB  00
0F42:  RETURN
.................... void ExecAuxInOp(int op,int arg,int ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
1593:  MOVLB  02
1594:  BCF    32.0
1595:  MOVLW  1F
1596:  ADDWF  31,W
1597:  MOVWF  04
1598:  MOVLW  20
1599:  MOVWF  05
159A:  BTFSC  03.0
159B:  INCF   05,F
159C:  MOVF   00,F
159D:  BTFSS  03.2
159E:  BSF    32.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
159F:  MOVF   30,W
15A0:  ANDLW  0F
15A1:  MOVWF  33
....................   uarg = (arg & 0xF0) >> 4; 
15A2:  MOVF   30,W
15A3:  ANDLW  F0
15A4:  MOVWF  77
15A5:  SWAPF  77,W
15A6:  MOVWF  34
15A7:  MOVLW  0F
15A8:  ANDWF  34,F
....................   switch(op) { 
15A9:  MOVLW  01
15AA:  SUBWF  2F,W
15AB:  ADDLW  FC
15AC:  BTFSC  03.0
15AD:  GOTO   5F4
15AE:  ADDLW  04
15AF:  MOVLB  00
15B0:  GOTO   5F7
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
15B1:  MOVLB  02
15B2:  BTFSS  32.0
15B3:  GOTO   5B9
....................         Enable_Mask &= arg; 
15B4:  MOVF   30,W
15B5:  MOVLB  00
15B6:  ANDWF  61,F
....................       } else { // AuxIn is not enabled 
15B7:  GOTO   5BE
15B8:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
15B9:  MOVF   30,W
15BA:  XORLW  FF
15BB:  ANDLW  0F
15BC:  MOVLB  00
15BD:  IORWF  61,F
....................       } 
....................       break; 
15BE:  MOVLB  02
15BF:  GOTO   5F4
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
15C0:  MOVLB  02
15C1:  BTFSS  32.0
15C2:  GOTO   5C9
....................         COR_DROP_FLAG=1; 
15C3:  BSF    72.7
....................         TailChar=arg; 
15C4:  MOVF   30,W
15C5:  MOVLB  00
15C6:  MOVWF  68
....................       } else { 
15C7:  GOTO   5CB
15C8:  MOVLB  02
....................         TailChar=0; 
15C9:  MOVLB  00
15CA:  CLRF   68
....................       } 
....................     break; 
15CB:  MOVLB  02
15CC:  GOTO   5F4
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
15CD:  MOVLB  02
15CE:  BTFSC  32.0
15CF:  GOTO   5D6
....................         COR_DROP_FLAG=1; 
15D0:  BSF    72.7
....................         TailChar=arg; 
15D1:  MOVF   30,W
15D2:  MOVLB  00
15D3:  MOVWF  68
....................       } else { 
15D4:  GOTO   5D8
15D5:  MOVLB  02
....................         TailChar=0; 
15D6:  MOVLB  00
15D7:  CLRF   68
....................       } 
....................     break; 
15D8:  MOVLB  02
15D9:  GOTO   5F4
....................     case AUXI_EMULATE_COR: 
....................       if ( (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0 ) { 
15DA:  MOVLB  02
15DB:  MOVF   30,W
15DC:  ANDLW  10
15DD:  BTFSC  03.2
15DE:  GOTO   5E3
....................         tmp_bit = ~in_bit; 
15DF:  BCF    32.1
15E0:  BTFSS  32.0
15E1:  BSF    32.1
....................       } else { 
15E2:  GOTO   5E6
....................         tmp_bit = in_bit; 
15E3:  BCF    32.1
15E4:  BTFSC  32.0
15E5:  BSF    32.1
....................       } 
....................       if ( tmp_bit ) { 
15E6:  BTFSS  32.1
15E7:  GOTO   5ED
....................         COR_EMUL |= larg; 
15E8:  MOVF   33,W
15E9:  MOVLB  00
15EA:  IORWF  67,F
....................       } else { 
15EB:  GOTO   5F1
15EC:  MOVLB  02
....................         COR_EMUL &= ~larg; 
15ED:  MOVF   33,W
15EE:  XORLW  FF
15EF:  MOVLB  00
15F0:  ANDWF  67,F
....................       } 
....................     break; 
15F1:  MOVLB  02
15F2:  GOTO   5F4
15F3:  MOVLB  02
....................   } 
.................... } // }}} 
15F4:  MOVLP  10
15F5:  MOVLB  00
15F6:  GOTO   725 (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
1546:  MOVLB  01
1547:  CLRF   6C
1548:  MOVF   6C,W
1549:  SUBLW  02
154A:  BTFSS  03.0
154B:  GOTO   590
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = (input(AUX_IN_PIN[x])!=0) || (AuxIn[x]!=0); 
154C:  MOVLW  1F
154D:  ADDWF  6C,W
154E:  MOVWF  78
154F:  MOVLW  20
1550:  MOVWF  7A
1551:  BTFSC  03.0
1552:  INCF   7A,F
1553:  MOVF   78,W
1554:  MOVLB  02
1555:  MOVWF  20
1556:  MOVF   7A,W
1557:  MOVWF  21
1558:  MOVLB  01
1559:  MOVF   6C,W
155A:  MOVLP  00
155B:  MOVLB  00
155C:  CALL   03F
155D:  MOVLP  10
155E:  MOVLB  02
155F:  MOVWF  22
1560:  MOVWF  46
1561:  MOVLW  01
1562:  MOVWF  47
1563:  CLRF   49
1564:  MOVLW  80
1565:  MOVWF  48
1566:  MOVLP  08
1567:  MOVLB  00
1568:  CALL   142
1569:  MOVLP  10
156A:  MOVLB  02
156B:  MOVF   22,W
156C:  MOVWF  23
156D:  CLRF   25
156E:  CLRF   24
156F:  MOVLB  00
1570:  GOTO   52C
1571:  BTFSC  78.0
1572:  GOTO   583
1573:  MOVLW  1C
1574:  MOVLB  01
1575:  ADDWF  6C,W
1576:  MOVWF  04
1577:  MOVLW  20
1578:  MOVWF  05
1579:  BTFSC  03.0
157A:  INCF   05,F
157B:  MOVF   00,F
157C:  BTFSC  03.2
157D:  GOTO   580
157E:  MOVLB  00
157F:  GOTO   583
1580:  MOVLW  00
1581:  GOTO   585
1582:  MOVLB  00
1583:  MOVLW  01
1584:  MOVLB  01
1585:  MOVLB  02
1586:  MOVWF  23
1587:  MOVF   21,W
1588:  MOVWF  05
1589:  MOVF   20,W
158A:  MOVWF  04
158B:  MOVF   23,W
158C:  MOVWF  00
....................   } 
158D:  MOVLB  01
158E:  INCF   6C,F
158F:  GOTO   548
.................... } // }}} 
1590:  MOVLP  18
1591:  MOVLB  00
1592:  GOTO   67A (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
1638:  MOVLW  30
1639:  MOVLB  01
163A:  MOVWF  6F
163B:  MOVLB  02
163C:  MOVWF  20
163D:  MOVWF  21
163E:  CLRF   22
....................   char AuxOut_s[4]={'0','0','0',0}; 
163F:  MOVWF  23
1640:  MOVWF  24
1641:  MOVWF  25
1642:  CLRF   26
....................   char ADM[]=" ADMIN"; 
1643:  MOVLW  20
1644:  MOVWF  27
1645:  MOVLW  41
1646:  MOVWF  28
1647:  MOVLW  44
1648:  MOVWF  29
1649:  MOVLW  4D
164A:  MOVWF  2A
164B:  MOVLW  49
164C:  MOVWF  2B
164D:  MOVLW  4E
164E:  MOVWF  2C
164F:  CLRF   2D
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
1650:  MOVLB  01
1651:  CLRF   6C
1652:  MOVF   6C,W
1653:  SUBLW  02
1654:  BTFSS  03.0
1655:  GOTO   728
....................     AuxOp = AuxOutOp[x]; 
1656:  MOVLW  33
1657:  ADDWF  6C,W
1658:  MOVWF  04
1659:  MOVLW  20
165A:  MOVWF  05
165B:  BTFSC  03.0
165C:  INCF   05,F
165D:  MOVF   00,W
165E:  MOVWF  6D
....................     AuxArg = AuxOutArg[x]; 
165F:  MOVLW  36
1660:  ADDWF  6C,W
1661:  MOVWF  04
1662:  MOVLW  20
1663:  MOVWF  05
1664:  BTFSC  03.0
1665:  INCF   05,F
1666:  MOVF   00,W
1667:  MOVWF  6E
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
1668:  MOVF   6D,W
1669:  MOVLB  02
166A:  MOVWF  2F
166B:  MOVLB  01
166C:  MOVF   6E,W
166D:  MOVLB  02
166E:  MOVWF  30
166F:  MOVLB  01
1670:  MOVF   6C,W
1671:  MOVLB  02
1672:  MOVWF  31
....................     out_bit = (AuxOut[x])==0; 
*
16B4:  MOVLB  02
16B5:  BCF    2E.0
16B6:  MOVLW  22
16B7:  MOVLB  01
16B8:  ADDWF  6C,W
16B9:  MOVWF  04
16BA:  MOVLW  20
16BB:  MOVWF  05
16BC:  BTFSC  03.0
16BD:  INCF   05,F
16BE:  MOVF   00,F
16BF:  BTFSS  03.2
16C0:  GOTO   6C4
16C1:  MOVLB  02
16C2:  BSF    2E.0
16C3:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
16C4:  MOVF   6C,W
16C5:  MOVLP  00
16C6:  MOVLB  00
16C7:  CALL   03B
16C8:  MOVLP  10
16C9:  MOVLB  02
16CA:  MOVWF  2F
16CB:  MOVLW  00
16CC:  BTFSC  2E.0
16CD:  MOVLW  01
16CE:  MOVWF  77
16CF:  MOVF   2F,W
16D0:  MOVWF  46
16D1:  MOVF   77,W
16D2:  MOVWF  47
16D3:  MOVLW  01
16D4:  MOVWF  49
16D5:  CLRF   48
16D6:  MOVLP  08
16D7:  MOVLB  00
16D8:  CALL   142
16D9:  MOVLP  10
16DA:  MOVLB  02
16DB:  MOVF   2F,W
16DC:  MOVWF  46
16DD:  CLRF   47
16DE:  CLRF   49
16DF:  MOVLW  80
16E0:  MOVWF  48
16E1:  MOVLP  08
16E2:  MOVLB  00
16E3:  CALL   142
16E4:  MOVLP  10
....................     if(out_bit==0) { 
16E5:  MOVLB  02
16E6:  BTFSC  2E.0
16E7:  GOTO   6F3
....................       AuxOut_s[x]='1'; 
16E8:  MOVLW  A3
16E9:  MOVLB  01
16EA:  ADDWF  6C,W
16EB:  MOVWF  04
16EC:  MOVLW  20
16ED:  MOVWF  05
16EE:  BTFSC  03.0
16EF:  INCF   05,F
16F0:  MOVLW  31
16F1:  MOVWF  00
16F2:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
16F3:  MOVLW  39
16F4:  MOVLB  01
16F5:  ADDWF  6C,W
16F6:  MOVWF  04
16F7:  MOVLW  20
16F8:  MOVWF  05
16F9:  BTFSC  03.0
16FA:  INCF   05,F
16FB:  MOVF   00,W
16FC:  MOVWF  6D
....................     AuxArg = AuxInArg[x]; 
16FD:  MOVLW  3C
16FE:  ADDWF  6C,W
16FF:  MOVWF  04
1700:  MOVLW  20
1701:  MOVWF  05
1702:  BTFSC  03.0
1703:  INCF   05,F
1704:  MOVF   00,W
1705:  MOVWF  6E
....................     if(AuxInSW[x]==1) { 
1706:  MOVLW  1F
1707:  ADDWF  6C,W
1708:  MOVWF  04
1709:  MOVLW  20
170A:  MOVWF  05
170B:  BTFSC  03.0
170C:  INCF   05,F
170D:  DECFSZ 00,W
170E:  GOTO   718
....................       AuxIn_s[x]='1'; 
170F:  MOVLW  9F
1710:  ADDWF  6C,W
1711:  MOVWF  04
1712:  MOVLW  20
1713:  MOVWF  05
1714:  BTFSC  03.0
1715:  INCF   05,F
1716:  MOVLW  31
1717:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
1718:  MOVF   6D,W
1719:  MOVLB  02
171A:  MOVWF  2F
171B:  MOVLB  01
171C:  MOVF   6E,W
171D:  MOVLB  02
171E:  MOVWF  30
171F:  MOVLB  01
1720:  MOVF   6C,W
1721:  MOVLB  02
1722:  MOVWF  31
1723:  MOVLB  00
1724:  GOTO   593
....................     // }}} 
....................   } 
1725:  MOVLB  01
1726:  INCF   6C,F
1727:  GOTO   652
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
1728:  MOVLW  20
1729:  MOVWF  62
172A:  MOVLW  74
172B:  MOVWF  61
172C:  MOVLW  49
172D:  MOVLB  02
172E:  MOVWF  56
172F:  MOVLP  08
1730:  MOVLB  00
1731:  CALL   164
1732:  MOVLP  10
1733:  MOVLW  3A
1734:  MOVLB  02
1735:  MOVWF  56
1736:  MOVLP  08
1737:  MOVLB  00
1738:  CALL   164
1739:  MOVLP  10
173A:  MOVLW  20
173B:  MOVWF  05
173C:  MOVLW  9F
173D:  MOVWF  04
173E:  MOVLP  08
173F:  CALL   1C6
1740:  MOVLP  10
1741:  MOVLW  20
1742:  MOVLB  02
1743:  MOVWF  56
1744:  MOVLP  08
1745:  MOVLB  00
1746:  CALL   164
1747:  MOVLP  10
1748:  MOVLW  4F
1749:  MOVLB  02
174A:  MOVWF  56
174B:  MOVLP  08
174C:  MOVLB  00
174D:  CALL   164
174E:  MOVLP  10
174F:  MOVLW  3A
1750:  MOVLB  02
1751:  MOVWF  56
1752:  MOVLP  08
1753:  MOVLB  00
1754:  CALL   164
1755:  MOVLP  10
1756:  MOVLW  20
1757:  MOVWF  05
1758:  MOVLW  A3
1759:  MOVWF  04
175A:  MOVLP  08
175B:  CALL   1C6
175C:  MOVLP  10
....................   if ( AdminMode ) { 
175D:  MOVLB  01
175E:  BTFSS  5B.6
175F:  GOTO   76C
....................     strcat(LCD_str,ADM); 
1760:  MOVLW  20
1761:  MOVLB  02
1762:  MOVWF  30
1763:  MOVLW  74
1764:  MOVWF  2F
1765:  MOVLW  20
1766:  MOVWF  32
1767:  MOVLW  A7
1768:  MOVWF  31
1769:  MOVLB  00
176A:  CALL   5FF
176B:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
176C:  MOVLW  03
176D:  MOVLB  02
176E:  MOVWF  50
176F:  MOVLW  20
1770:  MOVWF  52
1771:  MOVLW  74
1772:  MOVWF  51
1773:  MOVLP  08
1774:  MOVLB  00
1775:  CALL   1DB
1776:  MOVLP  10
.................... } // }}} 
1777:  RETURN
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
1061:  MOVLW  01
1062:  MOVLB  02
1063:  MOVWF  34
1064:  MOVLP  08
1065:  MOVLB  00
1066:  CALL   3B4
1067:  MOVLP  10
....................   delay_ms(1000); 
1068:  MOVLW  04
1069:  MOVLB  02
106A:  MOVWF  34
106B:  MOVLW  FA
106C:  MOVWF  50
106D:  MOVLP  00
106E:  MOVLB  00
106F:  CALL   7CB
1070:  MOVLP  10
1071:  MOVLB  02
1072:  DECFSZ 34,F
1073:  GOTO   06B
....................   for(x=0;x<6;x++) { 
1074:  CLRF   32
1075:  MOVF   32,W
1076:  SUBLW  05
1077:  BTFSS  03.0
1078:  GOTO   095
....................     mchar=Morse[x]; 
1079:  MOVLW  2D
107A:  ADDWF  32,W
107B:  MOVWF  04
107C:  MOVLW  20
107D:  MOVWF  05
107E:  BTFSC  03.0
107F:  INCF   05,F
1080:  MOVF   00,W
1081:  MOVWF  33
....................     morse(mchar); 
1082:  MOVF   33,W
1083:  MOVWF  45
1084:  MOVLP  08
1085:  MOVLB  00
1086:  CALL   0E9
1087:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
1088:  MOVLB  01
1089:  CLRF   31
108A:  MOVLW  06
108B:  MOVWF  30
....................     while(aux_timer) { 
108C:  MOVF   30,W
108D:  IORWF  31,W
108E:  BTFSC  03.2
108F:  GOTO   092
....................       delay_cycles(1); 
1090:  NOP
....................     } 
1091:  GOTO   08C
....................   } 
1092:  MOVLB  02
1093:  INCF   32,F
1094:  GOTO   075
....................   delay_ms(1000); 
1095:  MOVLW  04
1096:  MOVWF  34
1097:  MOVLW  FA
1098:  MOVWF  50
1099:  MOVLP  00
109A:  MOVLB  00
109B:  CALL   7CB
109C:  MOVLP  10
109D:  MOVLB  02
109E:  DECFSZ 34,F
109F:  GOTO   097
....................   COR_FLAG=1; 
10A0:  BSF    72.3
.................... } // }}} 
10A1:  MOVLB  00
10A2:  RETURN
.................... void main (void) { // {{{ 
*
1D91:  CLRF   05
1D92:  CLRF   04
1D93:  MOVLW  1F
1D94:  ANDWF  03,F
1D95:  MOVLW  72
1D96:  MOVLB  01
1D97:  MOVWF  19
1D98:  BSF    0E.3
1D99:  BSF    0E.4
1D9A:  MOVLB  04
1D9B:  BCF    17.0
1D9C:  BCF    17.1
1D9D:  BCF    17.3
1D9E:  MOVLW  13
1D9F:  MOVWF  12
1DA0:  MOVLW  28
1DA1:  MOVWF  15
1DA2:  BSF    14.7
1DA3:  BCF    14.6
1DA4:  MOVLW  0C
1DA5:  MOVLB  03
1DA6:  MOVWF  1B
1DA7:  MOVLW  A2
1DA8:  MOVWF  1E
1DA9:  MOVLW  90
1DAA:  MOVWF  1D
1DAB:  MOVLB  01
1DAC:  BSF    60.0
1DAD:  CLRF   62
1DAE:  CLRF   61
1DAF:  MOVLB  0F
1DB0:  CLRF   11
1DB1:  CLRF   12
1DB2:  CLRF   18
1DB3:  CLRF   19
1DB4:  CLRF   1A
1DB5:  MOVLB  03
1DB6:  CLRF   0C
1DB7:  CLRF   0D
1DB8:  CLRF   0F
1DB9:  CLRF   10
1DBA:  MOVLB  02
1DBB:  CLRF   12
1DBC:  CLRF   11
1DBD:  CLRF   14
1DBE:  CLRF   13
....................   int x,dtmf; 
....................   char tmp[5]; 
....................   initialize(); 
*
1DC2:  MOVLP  08
1DC3:  GOTO   51D
1DC4:  MOVLP  18
....................   char enter_b,select_b; 
....................  
....................   setup_adc(ADC_CLOCK_INTERNAL); 
1DC5:  MOVLB  01
1DC6:  BSF    1E.4
1DC7:  BSF    1E.5
1DC8:  BCF    1E.6
1DC9:  BCF    1E.7
1DCA:  BSF    1D.0
....................   setup_adc_ports(ADJ_POT|VSS_VDD); 
1DCB:  BCF    1E.0
1DCC:  BCF    1E.1
1DCD:  BCF    1E.2
1DCE:  MOVLW  00
1DCF:  MOVLB  03
1DD0:  MOVWF  0C
1DD1:  MOVWF  10
1DD2:  MOVLW  20
1DD3:  MOVWF  0D
1DD4:  MOVLW  00
1DD5:  MOVWF  0F
....................   set_adc_channel(13); 
1DD6:  MOVLW  34
1DD7:  MOVWF  78
1DD8:  MOVLB  01
1DD9:  MOVF   1D,W
1DDA:  ANDLW  83
1DDB:  IORWF  78,W
1DDC:  MOVWF  1D
....................  
....................   while(1) { // {{{ 
....................     restart_wdt(); 
1DDD:  CLRWDT
.................... #ifdef BUTTON_STATES 
....................   // Process Enter / select buttons {{{ 
....................   if ( input(ENTER_BUTTON)==0 ) { 
1DDE:  BSF    0C.7
1DDF:  MOVLB  00
1DE0:  BTFSC  0C.7
1DE1:  GOTO   5EE
....................     ENTER_PRESSED = (enter_b == DEBOUNCE_COUNT); 
1DE2:  BCF    72.1
1DE3:  MOVLB  01
1DE4:  MOVF   6A,W
1DE5:  SUBLW  08
1DE6:  BTFSC  03.2
1DE7:  BSF    72.1
....................     if ( enter_b < DEBOUNCE_COUNT+ 1 ) { 
1DE8:  MOVF   6A,W
1DE9:  SUBLW  08
1DEA:  BTFSC  03.0
....................       enter_b++;  
1DEB:  INCF   6A,F
....................     } 
....................   } else { 
1DEC:  GOTO   5F1
1DED:  MOVLB  00
....................     enter_b = 0; 
1DEE:  MOVLB  01
1DEF:  CLRF   6A
....................     ENTER_PRESSED = 0; 
1DF0:  BCF    72.1
....................   } 
....................   if ( input(SELECT_BUTTON)==0 ) { 
1DF1:  MOVLB  00
1DF2:  BTFSC  10.3
1DF3:  GOTO   600
....................     SELECT_PRESSED = (select_b == DEBOUNCE_COUNT); 
1DF4:  BCF    72.2
1DF5:  MOVLB  01
1DF6:  MOVF   6B,W
1DF7:  SUBLW  08
1DF8:  BTFSC  03.2
1DF9:  BSF    72.2
....................     if ( select_b < DEBOUNCE_COUNT + 1 ) { 
1DFA:  MOVF   6B,W
1DFB:  SUBLW  08
1DFC:  BTFSC  03.0
....................       select_b++; 
1DFD:  INCF   6B,F
....................     } 
....................   } else { 
1DFE:  GOTO   603
1DFF:  MOVLB  00
....................     select_b = 0; 
1E00:  MOVLB  01
1E01:  CLRF   6B
....................     SELECT_PRESSED = 0; 
1E02:  BCF    72.2
....................   } 
....................   // Define Button States 
....................   // IDLE + ENTER --> TRIM 
....................   // TRIM + ENTER --> Exit 
....................   // TRIM + SELECT --> NextPot 
....................   #define IDLE 0 
....................   #define CALIB 16 
....................   #define TRIM 15  
....................   switch (button_state) { 
1E03:  MOVF   5A,W
1E04:  XORLW  00
1E05:  MOVLB  00
1E06:  BTFSC  03.2
1E07:  GOTO   60F
1E08:  XORLW  10
1E09:  BTFSC  03.2
1E0A:  GOTO   616
1E0B:  XORLW  1F
1E0C:  BTFSC  03.2
1E0D:  GOTO   628
1E0E:  GOTO   668
....................     case IDLE:   
....................       if ( ENTER_PRESSED == 1 ) { 
1E0F:  BTFSS  72.1
1E10:  GOTO   615
....................         button_state=CALIB; 
1E11:  MOVLW  10
1E12:  MOVLB  01
1E13:  MOVWF  5A
1E14:  MOVLB  00
....................       } 
....................     break; 
1E15:  GOTO   66B
....................     case CALIB: 
....................       adj_value_a = read_adc() >> 2; 
1E16:  MOVLB  01
1E17:  BSF    1D.1
1E18:  BTFSC  1D.1
1E19:  GOTO   618
1E1A:  RRF    1C,W
1E1B:  MOVWF  7E
1E1C:  RRF    7E,F
1E1D:  MOVLW  3F
1E1E:  ANDWF  7E,F
....................       adj_value_b = adj_value_a; 
1E1F:  MOVF   7E,W
1E20:  MOVWF  59
....................       button_state=TRIM; 
1E21:  MOVLW  0F
1E22:  MOVWF  5A
....................       pot_values_to_lcd(); 
1E23:  MOVLP  08
1E24:  MOVLB  00
1E25:  CALL   2C0
1E26:  MOVLP  18
....................       break; 
1E27:  GOTO   66B
....................     case TRIM: 
....................        if ( ((COR_IN|COR_EMUL)&0x0F) != 0 ) { 
1E28:  MOVF   5F,W
1E29:  IORWF  67,W
1E2A:  ANDLW  0F
1E2B:  BTFSC  03.2
1E2C:  GOTO   651
....................          adj_value_a = read_adc() >> 2; 
1E2D:  MOVLB  01
1E2E:  BSF    1D.1
1E2F:  BTFSC  1D.1
1E30:  GOTO   62F
1E31:  RRF    1C,W
1E32:  MOVWF  7E
1E33:  RRF    7E,F
1E34:  MOVLW  3F
1E35:  ANDWF  7E,F
....................          if ( adj_value_a != adj_value_b ) { 
1E36:  MOVF   59,W
1E37:  SUBWF  7E,W
1E38:  BTFSC  03.2
1E39:  GOTO   64E
....................            rs232_mode = 1; 
1E3A:  BSF    5B.7
....................            set_trimpot(CurrentTrimPot, 63-adj_value_a); 
1E3B:  MOVF   7E,W
1E3C:  SUBLW  3F
1E3D:  MOVWF  6C
1E3E:  MOVF   74,W
1E3F:  MOVLB  02
1E40:  MOVWF  45
1E41:  MOVLB  01
1E42:  MOVF   6C,W
1E43:  MOVLB  02
1E44:  MOVWF  46
1E45:  MOVLP  08
1E46:  MOVLB  00
1E47:  CALL   000
1E48:  MOVLP  18
....................            pot_values_to_lcd(); 
1E49:  MOVLP  08
1E4A:  CALL   2C0
1E4B:  MOVLP  18
....................            rs232_mode = 0; 
1E4C:  MOVLB  01
1E4D:  BCF    5B.7
....................          } 
....................          adj_value_b = adj_value_a; 
1E4E:  MOVF   7E,W
1E4F:  MOVWF  59
1E50:  MOVLB  00
.................... 	     } 
....................        if ( SELECT_PRESSED == 1 ) { 
1E51:  BTFSS  72.2
1E52:  GOTO   65A
....................          CurrentTrimPot = (CurrentTrimPot + 1 ) & 0x03; 
1E53:  MOVLW  01
1E54:  ADDWF  74,W
1E55:  ANDLW  03
1E56:  MOVWF  74
....................          pot_values_to_lcd(); 
1E57:  MOVLP  08
1E58:  CALL   2C0
1E59:  MOVLP  18
....................        } 
....................        if ( ENTER_PRESSED == 1 ) { 
1E5A:  BTFSS  72.1
1E5B:  GOTO   664
....................          // Hold SELECT and press ENTER to store settings in EEPROM 
....................          if ( input(SELECT_BUTTON)==0 ) { 
1E5C:  BTFSC  10.3
1E5D:  GOTO   661
....................            store_variables(); 
1E5E:  MOVLP  00
1E5F:  CALL   623
1E60:  MOVLP  18
....................          } 
....................          button_state = IDLE; 
1E61:  MOVLB  01
1E62:  CLRF   5A
1E63:  MOVLB  00
.................... 	     }  
....................        status_led(); 
1E64:  MOVLP  08
1E65:  GOTO   5DA
1E66:  MOVLP  18
....................     break; 
1E67:  GOTO   66B
....................     default: 
....................   		button_state = IDLE; 
1E68:  MOVLB  01
1E69:  CLRF   5A
....................     break; 
1E6A:  MOVLB  00
....................   } 
....................   restart_wdt(); 
1E6B:  CLRWDT
....................   // }}} 
.................... #endif 
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "#" or a "\r" is received. 
....................     if ( sBufferFlag ) { 
1E6C:  BTFSS  72.0
1E6D:  GOTO   673
....................       process_sBuffer(); 
1E6E:  GOTO   000
....................       clear_sBuffer(); 
1E6F:  MOVLP  00
1E70:  CALL   516
1E71:  MOVLP  18
....................       sBufferFlag=0; 
1E72:  BCF    72.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1E73:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1E74:  MOVLB  01
1E75:  BTFSS  5B.0
1E76:  GOTO   67D
....................       update_aux_in(); 
1E77:  MOVLP  10
1E78:  MOVLB  00
1E79:  GOTO   546
1E7A:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1E7B:  MOVLB  01
1E7C:  BCF    5B.0
....................     } 
....................     if ( SECOND_FLAG ) { 
1E7D:  BTFSS  72.4
1E7E:  GOTO   6C8
....................       update_aux_out(); 
1E7F:  MOVLP  10
1E80:  MOVLB  00
1E81:  CALL   638
1E82:  MOVLP  18
....................       // Time Out PTT {{{ 
....................       if ( TOT_SecondCounter || TOT_Min == 0) { 
1E83:  MOVLB  01
1E84:  MOVF   5E,W
1E85:  IORWF  5F,W
1E86:  BTFSS  03.2
1E87:  GOTO   68D
1E88:  MOVLB  00
1E89:  MOVF   66,F
1E8A:  BTFSS  03.2
1E8B:  GOTO   693
1E8C:  MOVLB  01
....................         TOT_SecondCounter--; 
1E8D:  MOVF   5E,W
1E8E:  BTFSC  03.2
1E8F:  DECF   5F,F
1E90:  DECF   5E,F
....................       } else if ( COR_IN != 0x00 ) { 
1E91:  GOTO   6A7
1E92:  MOVLB  00
1E93:  MOVF   5F,F
1E94:  BTFSC  03.2
1E95:  GOTO   6A8
....................         update_ptt(0); 
1E96:  MOVLB  02
1E97:  CLRF   34
1E98:  MOVLP  08
1E99:  MOVLB  00
1E9A:  CALL   3B4
1E9B:  MOVLP  18
....................         printf("\n\r# PTT Timeout!\n"); 
1E9C:  MOVLW  09
1E9D:  MOVLB  03
1E9E:  MOVWF  11
1E9F:  MOVLW  05
1EA0:  MOVWF  12
1EA1:  MOVLP  00
1EA2:  MOVLB  00
1EA3:  CALL   530
1EA4:  MOVLP  18
....................         PROMPT_FLAG=1; 
1EA5:  MOVLB  01
1EA6:  BSF    5B.5
1EA7:  MOVLB  00
....................       } 
....................       // }}} 
....................       // Admin mode timeout {{{ 
....................       if ( admin_timer ) { 
1EA8:  MOVF   73,F
1EA9:  BTFSC  03.2
1EAA:  GOTO   6AD
....................         admin_timer--; 
1EAB:  DECF   73,F
....................       } else { 
1EAC:  GOTO   6B6
....................         // Exit admin mode. 
....................         if ( AdminMode ) { 
1EAD:  MOVLB  01
1EAE:  BTFSS  5B.6
1EAF:  GOTO   6B7
....................           set_admin_mode(0); 
1EB0:  MOVLB  02
1EB1:  CLRF   46
1EB2:  MOVLP  08
1EB3:  MOVLB  00
1EB4:  CALL   506
1EB5:  MOVLP  18
1EB6:  MOVLB  01
....................         } 
....................       } 
....................       // }}} 
....................       restart_wdt(); 
1EB7:  CLRWDT
....................       if ( SecondCounter ) { 
1EB8:  MOVF   5C,F
1EB9:  BTFSC  03.2
1EBA:  GOTO   6BD
....................         SecondCounter--; 
1EBB:  DECF   5C,F
....................       } else { 
1EBC:  GOTO   6C7
....................         SecondCounter=SEC_COUNTER; 
1EBD:  MOVLW  3B
1EBE:  MOVWF  5C
....................         if ( MinuteCounter ) { 
1EBF:  MOVF   5D,F
1EC0:  BTFSC  03.2
1EC1:  GOTO   6C4
....................           MinuteCounter--; 
1EC2:  DECF   5D,F
....................         } else { 
1EC3:  GOTO   6C7
....................           THIRTY_MIN_FLAG=1; 
1EC4:  BSF    72.6
....................           MinuteCounter = MIN_COUNTER; 
1EC5:  MOVLW  1D
1EC6:  MOVWF  5D
....................         } 
....................       } 
....................       SECOND_FLAG=0; 
1EC7:  BCF    72.4
....................     } 
....................     if ( THIRTY_MIN_FLAG ) { 
1EC8:  BTFSS  72.6
1EC9:  GOTO   6E6
....................       if ( (TXSiteID&0x03) !=0 ) { 
1ECA:  MOVLB  00
1ECB:  MOVF   64,W
1ECC:  ANDLW  03
1ECD:  BTFSC  03.2
1ECE:  GOTO   6E3
....................         // Transmit Site ID every 30 mins when: 
....................         // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................         // E = Transmit every 30 mins 
....................         // M = Transmit only if EnableMask is off 
....................         if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
1ECF:  MOVF   64,W
1ED0:  ANDLW  01
1ED1:  BTFSS  03.2
1ED2:  GOTO   6E0
1ED3:  MOVF   64,W
1ED4:  ANDLW  02
1ED5:  BTFSC  03.2
1ED6:  GOTO   6E3
1ED7:  SWAPF  64,W
1ED8:  MOVWF  77
1ED9:  MOVLW  0F
1EDA:  ANDWF  77,F
1EDB:  MOVF   77,W
1EDC:  ANDLW  0F
1EDD:  ANDWF  60,W
1EDE:  BTFSS  03.2
1EDF:  GOTO   6E3
....................           send_morse_id(); 
1EE0:  MOVLP  10
1EE1:  CALL   061
1EE2:  MOVLP  18
....................         } 
....................       } 
....................       THIRTY_MIN_FLAG=0; 
1EE3:  BCF    72.6
....................       restart_wdt(); 
1EE4:  CLRWDT
1EE5:  MOVLB  01
....................     } 
....................     if ( COR_FLAG ) { 
1EE6:  BTFSS  72.3
1EE7:  GOTO   6F0
....................       process_cor(); 
1EE8:  MOVLB  00
1EE9:  GOTO   430
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       update_aux_out();  
1EEA:  MOVLP  10
1EEB:  CALL   638
1EEC:  MOVLP  18
....................       COR_FLAG=0; 
1EED:  BCF    72.3
....................       restart_wdt(); 
1EEE:  CLRWDT
1EEF:  MOVLB  01
....................      } 
....................     if ( DTMF_IN_FLAG ) { 
1EF0:  BTFSS  5B.3
1EF1:  GOTO   783
....................       strcpy(LCD_str,"DTMF:"); 
1EF2:  CLRF   6C
1EF3:  CLRF   6D
1EF4:  MOVLW  20
1EF5:  MOVWF  05
1EF6:  MOVLW  74
1EF7:  MOVWF  04
1EF8:  MOVF   6C,W
1EF9:  ADDWF  04,F
1EFA:  MOVLW  00
1EFB:  ADDWFC 05,F
1EFC:  MOVF   6D,W
1EFD:  MOVLP  00
1EFE:  MOVLB  00
1EFF:  CALL   184
1F00:  MOVLP  18
1F01:  MOVWF  00
1F02:  IORLW  00
1F03:  BTFSC  03.2
1F04:  GOTO   70A
1F05:  MOVLB  01
1F06:  INCF   6D,F
1F07:  INCF   6C,F
1F08:  GOTO   6F4
1F09:  MOVLB  00
....................       printf("\n\rDTMF="); 
1F0A:  MOVLW  12
1F0B:  MOVLB  03
1F0C:  MOVWF  11
1F0D:  MOVLW  05
1F0E:  MOVWF  12
1F0F:  MOVLP  00
1F10:  MOVLB  00
1F11:  CALL   530
1F12:  MOVLP  18
....................       for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1F13:  MOVLB  01
1F14:  CLRF   63
1F15:  MOVF   63,W
1F16:  SUBLW  09
1F17:  BTFSS  03.0
1F18:  GOTO   761
....................         if(DTMF_ARRAY[x].Strobe) { 
1F19:  MOVLW  62
1F1A:  ADDWF  63,W
1F1B:  MOVWF  04
1F1C:  MOVLW  20
1F1D:  MOVWF  05
1F1E:  BTFSC  03.0
1F1F:  INCF   05,F
1F20:  BTFSS  00.4
1F21:  GOTO   75E
....................           dtmf=(int)DTMF_ARRAY[x].Key; 
1F22:  MOVLW  62
1F23:  ADDWF  63,W
1F24:  MOVWF  04
1F25:  MOVLW  20
1F26:  MOVWF  05
1F27:  BTFSC  03.0
1F28:  INCF   05,F
1F29:  MOVF   00,W
1F2A:  ANDLW  0F
1F2B:  MOVWF  64
....................           sprintf(tmp,"%d ",dtmf); 
1F2C:  MOVLW  20
1F2D:  MOVWF  62
1F2E:  MOVLW  95
1F2F:  MOVWF  61
1F30:  MOVF   64,W
1F31:  MOVLB  02
1F32:  MOVWF  50
1F33:  MOVLW  18
1F34:  MOVWF  51
1F35:  MOVLP  08
1F36:  MOVLB  00
1F37:  CALL   23F
1F38:  MOVLP  18
1F39:  MOVLW  20
1F3A:  MOVLB  02
1F3B:  MOVWF  56
1F3C:  MOVLP  08
1F3D:  MOVLB  00
1F3E:  CALL   164
1F3F:  MOVLP  18
....................           strcat(LCD_str,tmp); 
1F40:  MOVLW  20
1F41:  MOVLB  02
1F42:  MOVWF  30
1F43:  MOVLW  74
1F44:  MOVWF  2F
1F45:  MOVLW  20
1F46:  MOVWF  32
1F47:  MOVLW  95
1F48:  MOVWF  31
1F49:  MOVLP  10
1F4A:  MOVLB  00
1F4B:  CALL   5FF
1F4C:  MOVLP  18
....................           printf(" %u",dtmf); 
1F4D:  MOVLW  20
1F4E:  CLRWDT
1F4F:  BTFSS  11.4
1F50:  GOTO   74E
1F51:  MOVLB  03
1F52:  MOVWF  1A
1F53:  MOVLB  01
1F54:  MOVF   64,W
1F55:  MOVLB  02
1F56:  MOVWF  56
1F57:  MOVLW  1B
1F58:  MOVWF  57
1F59:  MOVLP  00
1F5A:  MOVLB  00
1F5B:  CALL   77C
1F5C:  MOVLP  18
1F5D:  MOVLB  01
....................         } 
....................       restart_wdt(); 
1F5E:  CLRWDT
....................       } 
1F5F:  INCF   63,F
1F60:  GOTO   715
....................       printf("\n\r"); 
1F61:  MOVLW  0A
1F62:  CLRWDT
1F63:  MOVLB  00
1F64:  BTFSC  11.4
1F65:  GOTO   768
1F66:  MOVLB  01
1F67:  GOTO   762
1F68:  MOVLB  03
1F69:  MOVWF  1A
1F6A:  MOVLW  0D
1F6B:  CLRWDT
1F6C:  MOVLB  00
1F6D:  BTFSC  11.4
1F6E:  GOTO   771
1F6F:  MOVLB  03
1F70:  GOTO   76B
1F71:  MOVLB  03
1F72:  MOVWF  1A
....................       DTMF_IN_FLAG=0; 
1F73:  MOVLB  01
1F74:  BCF    5B.3
....................       PROMPT_FLAG=1; 
1F75:  BSF    5B.5
....................       lcd_send(2,LCD_str); // Send DTMF on line 3 
1F76:  MOVLW  02
1F77:  MOVLB  02
1F78:  MOVWF  50
1F79:  MOVLW  20
1F7A:  MOVWF  52
1F7B:  MOVLW  74
1F7C:  MOVWF  51
1F7D:  MOVLP  08
1F7E:  MOVLB  00
1F7F:  CALL   1DB
1F80:  MOVLP  18
....................     restart_wdt(); 
1F81:  CLRWDT
1F82:  MOVLB  01
....................     } 
....................     if ( DTMF_FLAG ) { 
1F83:  BTFSS  5B.2
1F84:  GOTO   78A
....................       process_dtmf(); 
1F85:  MOVLB  00
1F86:  GOTO   4BD
....................       DTMF_FLAG=0; 
1F87:  MOVLB  01
1F88:  BCF    5B.2
....................     restart_wdt(); 
1F89:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1F8A:  BTFSS  5B.4
1F8B:  GOTO   792
....................       clear_dtmf_array(); 
1F8C:  MOVLP  10
1F8D:  MOVLB  00
1F8E:  GOTO   7B2
1F8F:  MOVLP  18
....................       CLEAR_DTMF_FLAG=0; 
1F90:  MOVLB  01
1F91:  BCF    5B.4
....................     } 
....................     if ( PROMPT_FLAG ) { 
1F92:  BTFSS  5B.5
1F93:  GOTO   79B
....................       prompt(); 
1F94:  MOVLP  10
1F95:  MOVLB  00
1F96:  CALL   049
1F97:  MOVLP  18
....................       PROMPT_FLAG=0; 
1F98:  MOVLB  01
1F99:  BCF    5B.5
....................     restart_wdt(); 
1F9A:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1F9B:  GOTO   5DD
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0BE3:  CLRWDT
*
1F9C:  SLEEP
....................   delay_ms(1000); 
*
0BE4:  MOVLW  04
0BE5:  MOVLB  02
0BE6:  MOVWF  45
0BE7:  MOVLW  FA
0BE8:  MOVWF  50
0BE9:  MOVLP  00
0BEA:  MOVLB  00
0BEB:  CALL   7CB
0BEC:  MOVLP  08
0BED:  MOVLB  02
0BEE:  DECFSZ 45,F
0BEF:  GOTO   3E7
....................   if ( ConfirmChar!=0 ) { 
0BF0:  MOVLB  00
0BF1:  MOVF   69,F
0BF2:  BTFSC  03.2
0BF3:  GOTO   408
....................     morse(ConfirmChar); 
0BF4:  MOVF   69,W
0BF5:  MOVLB  02
0BF6:  MOVWF  45
0BF7:  MOVLB  00
0BF8:  CALL   0E9
....................     ConfirmChar=0; 
0BF9:  CLRF   69
....................     restart_wdt(); 
0BFA:  CLRWDT
....................     delay_ms(500); 
0BFB:  MOVLW  02
0BFC:  MOVLB  02
0BFD:  MOVWF  45
0BFE:  MOVLW  FA
0BFF:  MOVWF  50
0C00:  MOVLP  00
0C01:  MOVLB  00
0C02:  CALL   7CB
0C03:  MOVLP  08
0C04:  MOVLB  02
0C05:  DECFSZ 45,F
0C06:  GOTO   3FE
0C07:  MOVLB  00
....................   } 
....................   if (TailChar != 0) { 
0C08:  MOVF   68,F
0C09:  BTFSC  03.2
0C0A:  GOTO   41F
....................     morse(TailChar); 
0C0B:  MOVF   68,W
0C0C:  MOVLB  02
0C0D:  MOVWF  45
0C0E:  MOVLB  00
0C0F:  CALL   0E9
....................     TailChar=0; 
0C10:  CLRF   68
....................     restart_wdt(); 
0C11:  CLRWDT
....................     delay_ms(500); 
0C12:  MOVLW  02
0C13:  MOVLB  02
0C14:  MOVWF  45
0C15:  MOVLW  FA
0C16:  MOVWF  50
0C17:  MOVLP  00
0C18:  MOVLB  00
0C19:  CALL   7CB
0C1A:  MOVLP  08
0C1B:  MOVLB  02
0C1C:  DECFSZ 45,F
0C1D:  GOTO   415
0C1E:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0C1F:  CLRWDT
0C20:  MOVLB  02
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
0FAE:  MOVLB  01
0FAF:  BTFSS  5B.6
0FB0:  GOTO   7B3
....................     admin_timer = ADMIN_TIMEOUT; 
0FB1:  MOVLW  FF
0FB2:  MOVWF  73
....................   } 
....................   return(AdminMode||rs232_mode); 
0FB3:  BTFSC  5B.6
0FB4:  GOTO   7B9
0FB5:  BTFSC  5B.7
0FB6:  GOTO   7B9
0FB7:  MOVLW  00
0FB8:  GOTO   7BA
0FB9:  MOVLW  01
0FBA:  MOVWF  78
.................... } // }}} 
0FBB:  MOVLB  00
0FBC:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0D06:  MOVLB  01
0D07:  BCF    5B.6
0D08:  MOVLB  02
0D09:  MOVF   46,F
0D0A:  BTFSC  03.2
0D0B:  GOTO   50F
0D0C:  MOVLB  01
0D0D:  BSF    5B.6
0D0E:  MOVLB  02
....................   if (AdminMode) { 
0D0F:  MOVLB  01
0D10:  BTFSS  5B.6
0D11:  GOTO   519
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0D12:  MOVLW  0A
0D13:  MOVLB  00
0D14:  MOVWF  69
....................     admin_timer = ADMIN_TIMEOUT; 
0D15:  MOVLW  FF
0D16:  MOVWF  73
....................   } else { 
0D17:  GOTO   51C
0D18:  MOVLB  01
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0D19:  MOVLW  18
0D1A:  MOVLB  00
0D1B:  MOVWF  69
....................   }  
.................... } // }}} 
0D1C:  RETURN
....................  
.................... // string matchnig function with case insensitive match. 
.................... int1 my_stricmp(char *s1,char *s2) { // {{{ 
*
0F43:  MOVLB  02
0F44:  CLRF   49
0F45:  BCF    4A.0
....................   unsigned int x=0; 
....................   int1 done=0; 
....................   const char AMASK=0xDF; 
....................   while((AMASK&s1[x])==(AMASK&s2[x])) { 
0F46:  MOVF   49,W
0F47:  ADDWF  45,W
0F48:  MOVWF  04
0F49:  MOVLW  00
0F4A:  ADDWFC 46,W
0F4B:  MOVWF  05
0F4C:  MOVF   00,W
0F4D:  ANDLW  DF
0F4E:  MOVWF  4B
0F4F:  MOVF   49,W
0F50:  ADDWF  47,W
0F51:  MOVWF  04
0F52:  MOVLW  00
0F53:  ADDWFC 48,W
0F54:  MOVWF  05
0F55:  MOVF   00,W
0F56:  ANDLW  DF
0F57:  SUBWF  4B,W
0F58:  BTFSS  03.2
0F59:  GOTO   768
....................     if(s1[x]==0) { 
0F5A:  MOVF   49,W
0F5B:  ADDWF  45,W
0F5C:  MOVWF  04
0F5D:  MOVLW  00
0F5E:  ADDWFC 46,W
0F5F:  MOVWF  05
0F60:  MOVF   00,F
0F61:  BTFSS  03.2
0F62:  GOTO   766
....................       return 0; 
0F63:  MOVLW  00
0F64:  MOVWF  78
0F65:  GOTO   76A
....................     } 
....................     x++; 
0F66:  INCF   49,F
....................   } 
0F67:  GOTO   746
....................   // Strings don't match. Return 1. 
....................   return 1; 
0F68:  MOVLW  01
0F69:  MOVWF  78
.................... } // }}} 
0F6A:  MOVLB  00
0F6B:  RETURN

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
