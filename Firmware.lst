CCS PCM C Compiler, Version 4.140, 64991               14-Jan-24 20:34

               Filename:   C:\Users\m3n2bn\Projects\MBPAB IDE\RC2Ga\52_Buckingham\Firmware.lst

               ROM used:   8050 words (98%)
                           Largest free fragment is 112
               RAM used:   165 (32%) at main() level
                           232 (45%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   6DD
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   348
002D:  MOVLP  00
002E:  GOTO   35F
002F:  MOVLP  00
0030:  GOTO   2EB
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
16B8:  MOVLB  02
16B9:  MOVF   29,W
16BA:  MOVWF  2D
16BB:  MOVF   28,W
16BC:  MOVWF  2C
16BD:  MOVF   2D,W
16BE:  MOVWF  7A
16BF:  MOVF   2C,W
16C0:  MOVWF  04
16C1:  MOVF   7A,W
16C2:  MOVWF  05
16C3:  MOVF   00,F
16C4:  BTFSC  03.2
16C5:  GOTO   6CA
16C6:  INCF   2C,F
16C7:  BTFSC  03.2
16C8:  INCF   2D,F
16C9:  GOTO   6BD
....................    while(*s2 != '\0') 
....................    { 
16CA:  MOVF   2B,W
16CB:  MOVWF  7A
16CC:  MOVF   2A,W
16CD:  MOVWF  04
16CE:  MOVF   7A,W
16CF:  MOVWF  05
16D0:  MOVF   00,F
16D1:  BTFSC  03.2
16D2:  GOTO   6E6
....................       *s = *s2; 
16D3:  MOVF   2A,W
16D4:  MOVWF  04
16D5:  MOVF   2B,W
16D6:  MOVWF  05
16D7:  MOVF   00,W
16D8:  MOVWF  30
16D9:  MOVF   2D,W
16DA:  MOVWF  05
16DB:  MOVF   2C,W
16DC:  MOVWF  04
16DD:  MOVF   30,W
16DE:  MOVWF  00
....................       ++s; 
16DF:  INCF   2C,F
16E0:  BTFSC  03.2
16E1:  INCF   2D,F
....................       ++s2; 
16E2:  INCF   2A,F
16E3:  BTFSC  03.2
16E4:  INCF   2B,F
....................    } 
16E5:  GOTO   6CA
....................  
....................    *s = '\0'; 
16E6:  MOVF   2C,W
16E7:  MOVWF  04
16E8:  MOVF   2D,W
16E9:  MOVWF  05
16EA:  CLRF   00
....................    return(s1); 
16EB:  MOVF   28,W
16EC:  MOVWF  78
16ED:  MOVF   29,W
16EE:  MOVWF  79
.................... } 
16EF:  MOVLB  00
16F0:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0DD9:  MOVF   48,W
0DDA:  MOVWF  4C
0DDB:  MOVF   47,W
0DDC:  MOVWF  4B
0DDD:  MOVF   4C,W
0DDE:  MOVWF  7A
0DDF:  MOVF   4B,W
0DE0:  MOVWF  04
0DE1:  MOVF   7A,W
0DE2:  MOVWF  05
0DE3:  MOVF   00,F
0DE4:  BTFSC  03.2
0DE5:  GOTO   612
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0DE6:  MOVF   4A,W
0DE7:  MOVWF  4E
0DE8:  MOVF   49,W
0DE9:  MOVWF  4D
0DEA:  MOVF   4E,W
0DEB:  MOVWF  7A
0DEC:  MOVF   4D,W
0DED:  MOVWF  04
0DEE:  MOVF   7A,W
0DEF:  MOVWF  05
0DF0:  MOVF   00,F
0DF1:  BTFSC  03.2
0DF2:  GOTO   60E
....................          if (*sc1 == *sc2) 
0DF3:  MOVF   4C,W
0DF4:  MOVWF  7A
0DF5:  MOVF   4B,W
0DF6:  MOVWF  04
0DF7:  MOVF   7A,W
0DF8:  MOVWF  05
0DF9:  MOVF   00,W
0DFA:  MOVWF  4F
0DFB:  MOVF   4E,W
0DFC:  MOVWF  7A
0DFD:  MOVF   4D,W
0DFE:  MOVWF  04
0DFF:  MOVF   7A,W
0E00:  MOVWF  05
0E01:  MOVF   00,W
0E02:  SUBWF  4F,W
0E03:  BTFSS  03.2
0E04:  GOTO   60A
....................             return(sc1); 
0E05:  MOVF   4B,W
0E06:  MOVWF  78
0E07:  MOVF   4C,W
0E08:  MOVWF  79
0E09:  GOTO   615
0E0A:  INCF   4D,F
0E0B:  BTFSC  03.2
0E0C:  INCF   4E,F
0E0D:  GOTO   5EA
0E0E:  INCF   4B,F
0E0F:  BTFSC  03.2
0E10:  INCF   4C,F
0E11:  GOTO   5DD
....................    return(0); 
0E12:  MOVLW  00
0E13:  MOVWF  78
0E14:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0D72:  MOVF   48,W
0D73:  MOVWF  4C
0D74:  MOVF   47,W
0D75:  MOVWF  4B
0D76:  MOVF   4C,W
0D77:  MOVWF  7A
0D78:  MOVF   4B,W
0D79:  MOVWF  04
0D7A:  MOVF   7A,W
0D7B:  MOVWF  05
0D7C:  MOVF   00,F
0D7D:  BTFSC  03.2
0D7E:  GOTO   5B0
....................       for (sc2 = s2; ; sc2++) 
0D7F:  MOVF   4A,W
0D80:  MOVWF  4E
0D81:  MOVF   49,W
0D82:  MOVWF  4D
....................     if (*sc2 == '\0') 
0D83:  MOVF   4E,W
0D84:  MOVWF  7A
0D85:  MOVF   4D,W
0D86:  MOVWF  04
0D87:  MOVF   7A,W
0D88:  MOVWF  05
0D89:  MOVF   00,F
0D8A:  BTFSS  03.2
0D8B:  GOTO   596
....................        return(sc1 - s1); 
0D8C:  MOVF   47,W
0D8D:  SUBWF  4B,W
0D8E:  MOVWF  77
0D8F:  MOVF   48,W
0D90:  SUBWFC 4C,W
0D91:  MOVWF  7A
0D92:  MOVF   77,W
0D93:  MOVWF  78
0D94:  GOTO   5B8
....................          else if (*sc1 == *sc2) 
0D95:  GOTO   5A8
0D96:  MOVF   4C,W
0D97:  MOVWF  7A
0D98:  MOVF   4B,W
0D99:  MOVWF  04
0D9A:  MOVF   7A,W
0D9B:  MOVWF  05
0D9C:  MOVF   00,W
0D9D:  MOVWF  4F
0D9E:  MOVF   4E,W
0D9F:  MOVWF  7A
0DA0:  MOVF   4D,W
0DA1:  MOVWF  04
0DA2:  MOVF   7A,W
0DA3:  MOVWF  05
0DA4:  MOVF   00,W
0DA5:  SUBWF  4F,W
0DA6:  BTFSC  03.2
....................             break; 
0DA7:  GOTO   5AC
0DA8:  INCF   4D,F
0DA9:  BTFSC  03.2
0DAA:  INCF   4E,F
0DAB:  GOTO   583
0DAC:  INCF   4B,F
0DAD:  BTFSC  03.2
0DAE:  INCF   4C,F
0DAF:  GOTO   576
....................    return(sc1 - s1); 
0DB0:  MOVF   47,W
0DB1:  SUBWF  4B,W
0DB2:  MOVWF  77
0DB3:  MOVF   48,W
0DB4:  SUBWFC 4C,W
0DB5:  MOVWF  7A
0DB6:  MOVF   77,W
0DB7:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1F0B:  MOVLB  00
1F0C:  CLRF   26
1F0D:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0D59:  MOVLB  02
0D5A:  MOVF   3F,W
0D5B:  IORWF  40,W
0D5C:  BTFSC  03.2
0D5D:  GOTO   562
0D5E:  MOVF   40,W
0D5F:  MOVWF  7A
0D60:  MOVF   3F,W
0D61:  GOTO   567
0D62:  MOVLB  00
0D63:  MOVF   27,W
0D64:  MOVWF  7A
0D65:  MOVF   26,W
0D66:  MOVLB  02
0D67:  MOVWF  43
0D68:  MOVF   7A,W
0D69:  MOVWF  44
....................    beg += strspn(beg, s2); 
0D6A:  MOVF   44,W
0D6B:  MOVWF  48
0D6C:  MOVF   43,W
0D6D:  MOVWF  47
0D6E:  MOVF   42,W
0D6F:  MOVWF  4A
0D70:  MOVF   41,W
0D71:  MOVWF  49
*
0DB8:  MOVF   78,W
0DB9:  ADDWF  43,F
0DBA:  MOVLW  00
0DBB:  ADDWFC 44,F
....................    if (*beg == '\0') 
0DBC:  MOVF   44,W
0DBD:  MOVWF  7A
0DBE:  MOVF   43,W
0DBF:  MOVWF  04
0DC0:  MOVF   7A,W
0DC1:  MOVWF  05
0DC2:  MOVF   00,F
0DC3:  BTFSS  03.2
0DC4:  GOTO   5D1
....................    { 
....................       *save = ' '; 
0DC5:  MOVLB  00
0DC6:  MOVF   26,W
0DC7:  MOVWF  04
0DC8:  MOVF   27,W
0DC9:  MOVWF  05
0DCA:  MOVLW  20
0DCB:  MOVWF  00
....................       return(0); 
0DCC:  MOVLW  00
0DCD:  MOVWF  78
0DCE:  MOVWF  79
0DCF:  GOTO   636
0DD0:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0DD1:  MOVF   44,W
0DD2:  MOVWF  48
0DD3:  MOVF   43,W
0DD4:  MOVWF  47
0DD5:  MOVF   42,W
0DD6:  MOVWF  4A
0DD7:  MOVF   41,W
0DD8:  MOVWF  49
*
0E15:  MOVF   79,W
0E16:  MOVWF  46
0E17:  MOVF   78,W
0E18:  MOVWF  45
....................    if (*end != '\0') 
0E19:  MOVF   46,W
0E1A:  MOVWF  7A
0E1B:  MOVF   45,W
0E1C:  MOVWF  04
0E1D:  MOVF   7A,W
0E1E:  MOVWF  05
0E1F:  MOVF   00,F
0E20:  BTFSC  03.2
0E21:  GOTO   62A
....................    { 
....................       *end = '\0'; 
0E22:  MOVF   45,W
0E23:  MOVWF  04
0E24:  MOVF   46,W
0E25:  MOVWF  05
0E26:  CLRF   00
....................       end++; 
0E27:  INCF   45,F
0E28:  BTFSC  03.2
0E29:  INCF   46,F
....................    } 
....................    save = end; 
0E2A:  MOVF   46,W
0E2B:  MOVLB  00
0E2C:  MOVWF  27
0E2D:  MOVLB  02
0E2E:  MOVF   45,W
0E2F:  MOVLB  00
0E30:  MOVWF  26
....................    return(beg); 
0E31:  MOVLB  02
0E32:  MOVF   43,W
0E33:  MOVWF  78
0E34:  MOVF   44,W
0E35:  MOVWF  79
0E36:  MOVLB  00
.................... } 
0E37:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
....................  
.................... #define POT_MAX 63 
....................  
.................... #define RS 0x01 
.................... #define LCD_READ 0x02   
.................... #define LCD_WRITE 0x00   
.................... #define E 0x04 
.................... #define BT 0x08 
.................... #define CHANGE_LINE 0x80 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
07C0:  MOVLW  20
07C1:  MOVWF  05
07C2:  MOVLW  CA
07C3:  MOVWF  04
07C4:  MOVF   00,W
07C5:  BTFSC  03.2
07C6:  GOTO   7D8
07C7:  MOVLW  02
07C8:  MOVWF  78
07C9:  MOVLW  BF
07CA:  MOVWF  77
07CB:  CLRWDT
07CC:  DECFSZ 77,F
07CD:  GOTO   7CB
07CE:  DECFSZ 78,F
07CF:  GOTO   7C9
07D0:  MOVLW  96
07D1:  MOVWF  77
07D2:  DECFSZ 77,F
07D3:  GOTO   7D2
07D4:  GOTO   7D5
07D5:  CLRWDT
07D6:  DECFSZ 00,F
07D7:  GOTO   7C7
07D8:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
067D:  MOVLB  04
067E:  BCF    15.7
067F:  MOVLB  00
0680:  BCF    11.3
0681:  MOVLB  02
0682:  MOVF   50,W
0683:  MOVLB  04
0684:  MOVWF  11
0685:  MOVLW  02
0686:  BTFSC  15.7
0687:  GOTO   68F
0688:  MOVLB  00
0689:  BTFSS  11.3
068A:  GOTO   689
068B:  MOVLW  00
068C:  MOVLB  04
068D:  BTFSC  16.6
068E:  MOVLW  01
068F:  MOVWF  78
0690:  MOVLB  00
0691:  RETURN
*
0A77:  MOVLB  04
0A78:  BCF    15.6
0A79:  BSF    16.3
0A7A:  BTFSC  16.3
0A7B:  GOTO   27A
0A7C:  BTFSC  77.0
0A7D:  BCF    16.5
0A7E:  BTFSS  77.0
0A7F:  BSF    16.5
0A80:  BSF    16.4
0A81:  BTFSC  16.4
0A82:  GOTO   281
0A83:  MOVF   11,W
0A84:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02E4:  CLRWDT
02E5:  BTFSS  11.4
02E6:  GOTO   2E4
02E7:  MOVLB  03
02E8:  MOVWF  1A
02E9:  MOVLB  00
02EA:  RETURN
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void process_dtmf_interrupt(void); 
.................... void init_lcd(void); 
.................... int1 read_cor_in_ports(void); 
.................... void send_tail(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... #if __DEVICE__==1939 
.................... void set_bit(void); 
.................... void clear_bit(void); 
.................... #endif 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
.................... void print_dfmf_info(void); 
.................... void do_delay_counters(void); 
.................... int1 my_stricmp(char *, char *); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN_HW; 
.................... unsigned int COR_IN; 
.................... unsigned int COR_IN_EFFECTIVE; 
.................... unsigned int Enable; 
.................... unsigned int Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned long TOT_Min; 
.................... unsigned int TOT_FLAG_Mask; 
.................... unsigned long QSO_Duration; 
.................... unsigned int Link_TOT,LinkDurationTimer; 
.................... unsigned int COR_EMUL; 
.................... unsigned int COR_AUX; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... #define LINK_CMD 1 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
.................... #define SET_BIT 14 
.................... #define CLEAR_BIT 15 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... #define QSO_DURATION_DELAY 5 
.................... // This command operates the same way as AUX_OUT_FOLLOW_COR but 
.................... // it extends the aux output by 1 minute. 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT_OUTPUT 0x10 
.................... #define AUX_OUT_FOLLOW_COR_OFF_DELAY     0x20 
.................... #define AUX_OUT_FOLLOW_COR_ON_DELAY      0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... #define AUXI_EMULATE_COR1 0x01 
.................... #define AUXI_EMULATE_COR2 0x02 
.................... #define AUXI_EMULATE_COR3 0x04 
.................... #define AUXI_EMULATE_COR4 0x08 
.................... #define AUXI_EMULATE_COR5 0x10 // COR from AUX only for DTMF control (No audio feed-thru) 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x20 
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... unsigned int AuxOutDelayCnt; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... unsigned int command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
....................   int  usage : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1       PROCESS_COR_FLAG; 
.................... int1       COR_IN_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int1 	   AUX_OUT_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1       DTMF_INTERRUPT_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... // PROTECTED -- Must be in admin mode to set value 
.................... // PUBLIC    -- Register can be set in any mode 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
.................... #define PROTECTED 1 
.................... #define PUBLIC    0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 
.................... 	{"XI2"},	  // 19 
.................... 	{"XI3"},	  // 20 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"LTO"},  // 54 
....................     {"COR"},  // 55 
....................     {"CPOT"}  // 56 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
....................  
.................... #define SITE_ID_VAL  	52 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... #define ENABLE_DEFAULT 0xEF 
.................... #define TOT_MIN 5 
.................... #define LINK_TOT 0 
.................... #define DEFAULT_GAIN 32 
.................... //#define LCD_TYPE_PI 1 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('e') 
.................... #define MORSEID5	MCHAR('h') 
....................  
.................... #define AUXOUTOP0  AUX_OUT_FOLLOW_COR 
.................... #define AUXOUTARG0 AUX_OUT_FOLLOW_COR1 | AUX_OUT_FOLLOW_COR_INVERT_OUTPUT 
.................... // AuxOut2 connected to RPT Disable 
.................... #define AUXOUTOP1  0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2  AUX_OUT_FOLLOW_COR 
.................... #define AUXOUTARG2 AUX_OUT_FOLLOW_COR1 | AUX_OUT_FOLLOW_COR2 | AUX_OUT_FOLLOW_COR3 | AUX_OUT_FOLLOW_COR4 | AUX_OUT_FOLLOW_COR_INVERT_OUTPUT | AUX_OUT_FOLLOW_COR_OFF_DELAY | AUX_OUT_FOLLOW_COR_ON_DELAY 
....................  
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  AUXI_EMULATE_COR 
.................... #define AUXINARG0 AUXI_EMULATE_COR1 | AUXI_EMULATE_COR_ACTIVE_LO 
.................... #define AUXINOP1  AUXI_TAIL_WHEN_LO 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
.................... #define RX1_PTT 0x0E 
.................... #define RX2_PTT 0x0D 
.................... #define RX3_PTT 0x0B 
.................... #define RX4_PTT 0x07 
....................  
.................... // Define default variables {{{ 
.................... #ifdef LCD_TYPE_PI 
....................   #define LCD_I2C_ADD 0x27 
.................... #else 
....................   #define LCD_I2C_ADD 0x60 
.................... #endif 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... #ifndef RX1_PTT 
....................   #define RX1_PTT 0x0E 
.................... #endif 
.................... #ifndef RX2_PTT 
....................   #define RX2_PTT 0x0D 
.................... #endif 
.................... #ifndef RX3_PTT 
....................   #define RX3_PTT 0x0B  
.................... #endif 
.................... #ifndef RX4_PTT 
....................   #define RX4_PTT 0x07 
.................... #endif 
.................... #ifndef DEFAULT_GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  , EEPROM,PUBLIC}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL, EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&AuxIn[0]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[1]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[2]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[0]     ,PO_AUX_OUT0     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[1]     ,PO_AUX_OUT1     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[2]     ,PO_AUX_OUT2     , EEPROM,PUBLIC}, 
.................... 	{&RXPriority[0] ,4               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[1] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[2] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[3] ,2               , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[0]     ,RX1_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[1]     ,RX2_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[2]     ,RX3_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[3]     ,RX4_PTT         , EEPROM,PROTECTED}, 
.................... 	{&SiteID        ,SITE_ID_VAL     , EEPROM,PROTECTED}, 
.................... 	{&TXSiteID      ,0x12            , EEPROM,PROTECTED}, 
....................   {&Morse[0]      ,MORSEID0        , EEPROM,PROTECTED}, 
....................   {&Morse[1]      ,MORSEID1        , EEPROM,PROTECTED}, 
....................   {&Morse[2]      ,MORSEID2        , EEPROM,PROTECTED}, 
....................   {&Morse[3]      ,MORSEID3        , EEPROM,PROTECTED}, 
....................   {&Morse[4]      ,MORSEID4        , EEPROM,PROTECTED}, 
....................   {&Morse[5]      ,MORSEID5        , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2      , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2        , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2       , EEPROM,PROTECTED}, 
....................   {&Tail          ,TAIL_CHAR       , EEPROM,PROTECTED}, 
....................   {&TOT_Min       ,TOT_MIN         , EEPROM,PROTECTED}, 
....................   {&Link_TOT      ,LINK_TOT        , EEPROM,PROTECTED}, 
.................... 	{&COR_EMUL      ,0x00            , RAM   ,PUBLIC}, 
.................... 	{&CurrentTrimPot,0x00            , RAM   ,PROTECTED}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02EB:  BTFSS  11.5
02EC:  GOTO   342
....................     c = getc(); 
02ED:  CLRWDT
02EE:  BTFSS  11.5
02EF:  GOTO   2ED
02F0:  MOVLB  03
02F1:  MOVF   19,W
02F2:  MOVLB  02
02F3:  MOVWF  55
....................     if ( c == '\b' ) { 
02F4:  MOVF   55,W
02F5:  SUBLW  08
02F6:  BTFSS  03.2
02F7:  GOTO   320
....................       if ( sBufferIndex > 0 ) { 
02F8:  MOVF   7C,F
02F9:  BTFSC  03.2
02FA:  GOTO   31A
....................         sBufferIndex--; 
02FB:  DECF   7C,F
....................         sBuffer[sBufferIndex]='\0'; 
02FC:  MOVLW  50
02FD:  ADDWF  7C,W
02FE:  MOVWF  04
02FF:  MOVLW  20
0300:  MOVWF  05
0301:  BTFSC  03.0
0302:  INCF   05,F
0303:  CLRF   00
....................         putc('\b'); 
0304:  MOVLW  08
0305:  MOVLB  00
0306:  CALL   2E4
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
0307:  MOVLW  1B
0308:  CALL   2E4
....................   printf("[K"); 
0309:  MOVLW  5B
030A:  CLRWDT
030B:  BTFSS  11.4
030C:  GOTO   30A
030D:  MOVLB  03
030E:  MOVWF  1A
030F:  MOVLW  4B
0310:  CLRWDT
0311:  MOVLB  00
0312:  BTFSC  11.4
0313:  GOTO   316
0314:  MOVLB  03
0315:  GOTO   310
0316:  MOVLB  03
0317:  MOVWF  1A
....................       } else { 
0318:  GOTO   31E
0319:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
031A:  MOVLW  07
031B:  MOVLB  00
031C:  CALL   2E4
031D:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
031E:  GOTO   344
031F:  MOVLB  02
0320:  MOVF   7C,W
0321:  SUBLW  0F
0322:  BTFSS  03.0
0323:  GOTO   33F
....................       putc(c); // echo the character 
0324:  MOVF   55,W
0325:  MOVLB  00
0326:  CALL   2E4
....................       sBuffer[sBufferIndex++] = c; 
0327:  MOVF   7C,W
0328:  INCF   7C,F
0329:  ADDLW  50
032A:  MOVWF  04
032B:  MOVLW  20
032C:  MOVWF  05
032D:  BTFSC  03.0
032E:  INCF   05,F
032F:  MOVLB  02
0330:  MOVF   55,W
0331:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0332:  MOVF   55,W
0333:  SUBLW  0D
0334:  BTFSC  03.2
0335:  GOTO   33D
0336:  MOVF   55,W
0337:  SUBLW  2B
0338:  BTFSC  03.2
0339:  GOTO   33D
033A:  MOVF   55,W
033B:  SUBLW  2D
033C:  BTFSC  03.2
....................         sBufferFlag=1; 
033D:  BSF    7D.0
....................       } 
....................     } else { 
033E:  GOTO   343
....................       putc('\a'); // Send alert. Avoid buffer overflow 
033F:  MOVLW  07
0340:  MOVLB  00
0341:  CALL   2E4
0342:  MOVLB  02
0343:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
....................  
0344:  MOVLB  00
0345:  BCF    11.5
0346:  MOVLP  00
0347:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if( IOCBF & 0x0F ) { // Check for interrupts on RB[3:0] only 
0348:  MOVLB  07
0349:  MOVF   16,W
034A:  ANDLW  0F
034B:  BTFSC  03.2
034C:  GOTO   350
....................     // COR_IN_HW = actual COR_IN values from controller input ports. 
....................     COR_IN_FLAG=1; 
034D:  BSF    7D.2
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
034E:  MOVLW  F0
034F:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
0350:  BTFSS  0B.0
0351:  GOTO   356
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     DTMF_INTERRUPT_FLAG = 1; 
0352:  MOVLB  01
0353:  BSF    5F.3
....................     clear_interrupt(INT_RB4_H2L); 
0354:  MOVLB  07
0355:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
0356:  BTFSS  0B.0
0357:  GOTO   35B
....................     AUX_IN_FLAG=1; 
0358:  BSF    7D.7
....................     clear_interrupt(INT_RB6|INT_RB7); 
0359:  MOVLW  3F
035A:  ANDWF  16,F
....................   } 
.................... } // }}} 
....................  
035B:  BCF    0B.0
035C:  MOVLP  00
035D:  MOVLB  00
035E:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
035F:  MOVLB  01
0360:  MOVF   31,W
0361:  IORWF  32,W
0362:  BTFSC  03.2
0363:  GOTO   369
....................     rtcc_cnt--; 
0364:  MOVF   31,W
0365:  BTFSC  03.2
0366:  DECF   32,F
0367:  DECF   31,F
....................   } else { 
0368:  GOTO   36F
....................     COR_IN_FLAG = 1; 
0369:  BSF    7D.2
....................     SECOND_FLAG=1; 
036A:  BSF    7D.3
....................     AUX_IN_FLAG=1; 
036B:  BSF    7D.7
....................     rtcc_cnt=30; 
036C:  CLRF   32
036D:  MOVLW  1E
036E:  MOVWF  31
....................   } 
....................   if (aux_timer ) { 
036F:  MOVF   33,W
0370:  IORWF  34,W
0371:  BTFSC  03.2
0372:  GOTO   377
....................     aux_timer--; 
0373:  MOVF   33,W
0374:  BTFSC  03.2
0375:  DECF   34,F
0376:  DECF   33,F
....................   } 
.................... } // }}} 
....................  
0377:  BCF    0B.2
0378:  MOVLP  00
0379:  MOVLB  00
037A:  GOTO   020
.................... int1 read_cor_in_ports (void) { // {{{ 
....................   // Updates COR_IN_HW and COR_IN variables 
....................   // Returns a 1 if a new COR is detected. 
....................   unsigned int LAST_COR_IN; 
....................   LAST_COR_IN = COR_IN; 
*
15B1:  MOVF   60,W
15B2:  MOVLB  01
15B3:  MOVWF  65
....................   COR_IN_HW   = ((input_b() ^ Polarity)&0x0F); 
15B4:  MOVLB  00
15B5:  MOVF   0D,W
15B6:  XORWF  64,W
15B7:  ANDLW  0F
15B8:  MOVWF  5F
....................   COR_IN      = COR_IN_HW | (COR_EMUL & 0x1F) | (COR_AUX&0x0F); 
15B9:  MOVF   6F,W
15BA:  ANDLW  1F
15BB:  IORWF  5F,W
15BC:  MOVLB  01
15BD:  MOVWF  66
15BE:  MOVF   71,W
15BF:  ANDLW  0F
15C0:  IORWF  66,W
15C1:  MOVLB  00
15C2:  MOVWF  60
....................   if ( LAST_COR_IN != COR_IN ) { 
15C3:  MOVF   60,W
15C4:  MOVLB  01
15C5:  SUBWF  65,W
15C6:  BTFSC  03.2
15C7:  GOTO   5CC
....................     return(1); 
15C8:  MOVLW  01
15C9:  MOVWF  78
15CA:  GOTO   5CE
....................   } else { 
15CB:  GOTO   5CE
....................     return(0); 
15CC:  MOVLW  00
15CD:  MOVWF  78
....................   } 
.................... } // }}} 
15CE:  MOVLP  18
15CF:  MOVLB  00
15D0:  GOTO   72B (RETURN)
.................... int1 warn_no_lcd = 1; 
....................  
.................... void lcd_strobe(char data) { // {{{ 
....................   i2c_write(data | E); 
....................   i2c_write(data & ~E); 
.................... } // }}} 
....................  
.................... void lcd_write(char rs, char data) { // {{{ 
....................   char lcd_word_a,lcd_word_b; 
....................   lcd_word_a = LCD_WRITE | BT | (data&0xF0); 
....................   lcd_word_b = LCD_WRITE | BT | ((data<<4)&0xF0); 
....................   if ( rs ) { 
....................     lcd_word_a |= RS; 
....................     lcd_word_b |= RS; 
....................   }  
....................   lcd_strobe(lcd_word_a); 
....................   lcd_strobe(lcd_word_b); 
.................... } // }}} 
....................  
.................... void lcd_send(char line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   i2c_start(); 
*
0959:  MOVLB  04
095A:  BSF    16.0
095B:  BTFSC  16.0
095C:  GOTO   15B
....................   #ifdef LCD_TYPE_PI 
....................   ack=i2c_write(LCD_I2C_ADD << 1); 
.................... //  ack=i2c_write(line&0x03); 
.................... // Change line 
....................   switch(line&0x03) { 
....................     case 0x00: lcd_write(0,CHANGE_LINE);break; 
....................     case 0x01: lcd_write(0,CHANGE_LINE+0x40);break; 
....................     case 0x02: lcd_write(0,CHANGE_LINE+0x14);break; 
....................     case 0x03: lcd_write(0,CHANGE_LINE+0x54);break; 
....................   } 
....................   restart_wdt(); 
....................   #else 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
095D:  BCF    03.0
095E:  MOVLB  02
095F:  RLF    4A,W
0960:  ANDLW  0E
0961:  IORLW  60
0962:  MOVWF  4D
....................   ack=i2c_write(lcd_cmd); 
0963:  MOVF   4D,W
0964:  MOVWF  50
0965:  MOVLP  00
0966:  MOVLB  00
0967:  CALL   67D
0968:  MOVLP  08
0969:  MOVF   78,W
096A:  MOVLB  02
096B:  BCF    4E.0
096C:  BTFSC  78.0
096D:  BSF    4E.0
....................   #endif 
....................   if ( ack!=0 ) { 
096E:  BTFSS  4E.0
096F:  GOTO   192
....................     if ( warn_no_lcd ) { 
0970:  MOVLB  01
0971:  BTFSS  62.0
0972:  GOTO   190
....................       printf("\n\rI2C : No ACK from LCD : %u",ack); 
0973:  MOVLW  00
0974:  MOVLB  02
0975:  BTFSC  4E.0
0976:  MOVLW  01
0977:  MOVWF  4F
0978:  MOVLW  7B
0979:  MOVLB  03
097A:  MOVWF  11
097B:  MOVLW  03
097C:  MOVWF  12
097D:  BCF    03.0
097E:  MOVLW  1A
097F:  MOVLB  02
0980:  MOVWF  50
0981:  MOVLP  00
0982:  MOVLB  00
0983:  CALL   692
0984:  MOVLP  08
0985:  MOVLB  02
0986:  MOVF   4F,W
0987:  MOVWF  50
0988:  MOVLW  1B
0989:  MOVWF  51
098A:  MOVLP  00
098B:  MOVLB  00
098C:  CALL   706
098D:  MOVLP  08
....................       warn_no_lcd = 0; 
098E:  MOVLB  01
098F:  BCF    62.0
....................     } 
....................   } else { 
0990:  GOTO   194
0991:  MOVLB  02
....................     warn_no_lcd = 1; 
0992:  MOVLB  01
0993:  BSF    62.0
....................   } 
....................   while(*s) { 
0994:  MOVLB  02
0995:  MOVF   4C,W
0996:  MOVWF  7A
0997:  MOVF   4B,W
0998:  MOVWF  04
0999:  MOVF   7A,W
099A:  MOVWF  05
099B:  MOVF   00,F
099C:  BTFSC  03.2
099D:  GOTO   1B1
.................... #ifdef LCD_TYPE_PI 
....................     if ( *s != '\r' && *s != '\n') { 
....................       lcd_write(1,*s); 
....................     } 
....................     s++; 
.................... #else 
....................    i2c_write(*s++); 
099E:  MOVF   4C,W
099F:  MOVWF  7A
09A0:  MOVF   4B,W
09A1:  INCF   4B,F
09A2:  BTFSC  03.2
09A3:  INCF   4C,F
09A4:  MOVWF  04
09A5:  MOVF   7A,W
09A6:  MOVWF  05
09A7:  MOVF   00,W
09A8:  MOVWF  4F
09A9:  MOVWF  50
09AA:  MOVLP  00
09AB:  MOVLB  00
09AC:  CALL   67D
09AD:  MOVLP  08
.................... #endif 
....................   } 
09AE:  MOVLB  01
09AF:  GOTO   194
09B0:  MOVLB  02
.................... #ifndef LCD_TYPE_PI 
....................   i2c_write(0); // EOL 
09B1:  CLRF   50
09B2:  MOVLP  00
09B3:  MOVLB  00
09B4:  CALL   67D
09B5:  MOVLP  08
.................... #endif 
....................   i2c_stop(); 
09B6:  MOVLB  04
09B7:  BSF    16.2
09B8:  BTFSC  16.2
09B9:  GOTO   1B8
.................... #endif 
.................... } // }}} 
09BA:  MOVLB  00
09BB:  RETURN
....................  
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
1000:  MOVF   70,F
1001:  BTFSC  03.2
1002:  GOTO   066
....................     printf("\n\rProcessing Command:"); 
1003:  MOVLW  8A
1004:  MOVLB  03
1005:  MOVWF  11
1006:  MOVLW  03
1007:  MOVWF  12
1008:  MOVLP  00
1009:  MOVLB  00
100A:  CALL   4A1
100B:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
100C:  MOVLW  95
100D:  MOVLB  03
100E:  MOVWF  11
100F:  MOVLW  03
1010:  MOVWF  12
1011:  BCF    03.0
1012:  MOVLW  0E
1013:  MOVLB  02
1014:  MOVWF  50
1015:  MOVLP  00
1016:  MOVLB  00
1017:  CALL   692
1018:  MOVLP  10
1019:  MOVF   65,W
101A:  MOVLB  02
101B:  MOVWF  50
101C:  MOVLW  1B
101D:  MOVWF  51
101E:  MOVLP  00
101F:  MOVLB  00
1020:  CALL   706
1021:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
1022:  MOVLW  9E
1023:  MOVLB  03
1024:  MOVWF  11
1025:  MOVLW  03
1026:  MOVWF  12
1027:  BCF    03.0
1028:  MOVLW  0E
1029:  MOVLB  02
102A:  MOVWF  50
102B:  MOVLP  00
102C:  MOVLB  00
102D:  CALL   692
102E:  MOVLP  10
102F:  MOVF   70,W
1030:  MOVLB  02
1031:  MOVWF  50
1032:  MOVLW  1B
1033:  MOVWF  51
1034:  MOVLP  00
1035:  MOVLB  00
1036:  CALL   706
1037:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
1038:  MOVLW  A7
1039:  MOVLB  03
103A:  MOVWF  11
103B:  MOVLW  03
103C:  MOVWF  12
103D:  BCF    03.0
103E:  MOVLW  0E
103F:  MOVLB  02
1040:  MOVWF  50
1041:  MOVLP  00
1042:  MOVLB  00
1043:  CALL   692
1044:  MOVLP  10
1045:  MOVLB  01
1046:  MOVF   42,W
1047:  MOVLB  02
1048:  MOVWF  50
1049:  MOVLW  1B
104A:  MOVWF  51
104B:  MOVLP  00
104C:  MOVLB  00
104D:  CALL   706
104E:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
104F:  MOVLW  B0
1050:  MOVLB  03
1051:  MOVWF  11
1052:  MOVLW  03
1053:  MOVWF  12
1054:  BCF    03.0
1055:  MOVLW  0E
1056:  MOVLB  02
1057:  MOVWF  50
1058:  MOVLP  00
1059:  MOVLB  00
105A:  CALL   692
105B:  MOVLP  10
105C:  MOVLB  01
105D:  MOVF   43,W
105E:  MOVLB  02
105F:  MOVWF  50
1060:  MOVLW  1B
1061:  MOVWF  51
1062:  MOVLP  00
1063:  MOVLB  00
1064:  CALL   706
1065:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
1066:  MOVLW  02
1067:  SUBWF  70,W
1068:  ADDLW  F5
1069:  BTFSC  03.0
106A:  GOTO   49E
106B:  ADDLW  0B
106C:  GOTO   49F
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
1143:  GOTO   49E
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
1144:  MOVLB  01
1145:  RLF    42,W
1146:  MOVWF  77
1147:  RLF    77,F
1148:  MOVLW  FC
1149:  ANDWF  77,F
114A:  MOVF   77,W
114B:  MOVLB  02
114C:  MOVWF  2C
114D:  INCF   2C,W
114E:  MOVLP  00
114F:  MOVLB  00
1150:  CALL   043
1151:  MOVLP  10
1152:  MOVWF  7A
1153:  MOVLB  02
1154:  MOVF   2C,W
1155:  MOVLP  00
1156:  MOVLB  00
1157:  CALL   043
1158:  MOVLP  10
1159:  MOVLB  02
115A:  MOVWF  20
115B:  MOVF   7A,W
115C:  MOVWF  21
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
115D:  MOVLW  01
115E:  MOVWF  7A
115F:  MOVLW  8F
1160:  MOVWF  2C
1161:  MOVF   7A,W
1162:  MOVWF  2D
1163:  CLRF   2F
1164:  MOVLB  01
1165:  MOVF   42,W
1166:  MOVLB  02
1167:  MOVWF  2E
1168:  MOVF   2F,W
1169:  MOVWF  3E
116A:  MOVF   2E,W
116B:  MOVWF  3D
116C:  CLRF   40
116D:  MOVLW  06
116E:  MOVWF  3F
116F:  MOVLP  08
1170:  MOVLB  00
1171:  CALL   6C0
1172:  MOVLP  10
1173:  MOVF   78,W
1174:  MOVLB  02
1175:  ADDWF  2C,W
1176:  MOVWF  24
1177:  MOVF   79,W
1178:  ADDWFC 2D,W
1179:  MOVWF  25
....................       romstrcpy(rname,cPtr); 
117A:  MOVLW  20
117B:  MOVWF  3C
117C:  MOVLW  A6
117D:  MOVWF  3B
117E:  MOVF   25,W
117F:  MOVWF  3E
1180:  MOVF   24,W
1181:  MOVWF  3D
1182:  MOVLP  08
1183:  MOVLB  00
1184:  CALL   6D7
1185:  MOVLP  10
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
1186:  MOVLB  02
1187:  MOVF   21,W
1188:  MOVWF  7A
1189:  MOVF   20,W
118A:  MOVWF  04
118B:  MOVF   21,W
118C:  MOVWF  05
118D:  MOVF   00,W
118E:  MOVWF  2C
118F:  MOVLW  20
1190:  MOVLB  01
1191:  MOVWF  64
1192:  MOVLW  7A
1193:  MOVWF  63
1194:  MOVLW  5B
1195:  MOVLB  02
1196:  MOVWF  50
1197:  MOVLP  00
1198:  MOVLB  00
1199:  CALL   7EC
119A:  MOVLP  10
119B:  MOVLB  01
119C:  MOVF   42,W
119D:  MOVLB  02
119E:  MOVWF  2D
119F:  MOVLW  01
11A0:  MOVWF  2E
11A1:  MOVLP  08
11A2:  MOVLB  00
11A3:  CALL   753
11A4:  MOVLP  10
11A5:  MOVLW  5D
11A6:  MOVLB  02
11A7:  MOVWF  50
11A8:  MOVLP  00
11A9:  MOVLB  00
11AA:  CALL   7EC
11AB:  MOVLP  10
11AC:  MOVLW  20
11AD:  MOVLB  02
11AE:  MOVWF  50
11AF:  MOVLP  00
11B0:  MOVLB  00
11B1:  CALL   7EC
11B2:  MOVLP  10
11B3:  MOVLW  20
11B4:  MOVWF  05
11B5:  MOVLW  A6
11B6:  MOVWF  04
11B7:  MOVLP  08
11B8:  CALL   142
11B9:  MOVLP  10
11BA:  MOVLW  20
11BB:  MOVLB  02
11BC:  MOVWF  50
11BD:  MOVLP  00
11BE:  MOVLB  00
11BF:  CALL   7EC
11C0:  MOVLP  10
11C1:  MOVLB  02
11C2:  MOVF   2C,W
11C3:  MOVWF  2D
11C4:  MOVLW  1B
11C5:  MOVWF  2E
11C6:  MOVLP  08
11C7:  MOVLB  00
11C8:  CALL   753
11C9:  MOVLP  10
11CA:  MOVLW  0A
11CB:  MOVLB  02
11CC:  MOVWF  50
11CD:  MOVLP  00
11CE:  MOVLB  00
11CF:  CALL   7EC
11D0:  MOVLP  10
11D1:  MOVLW  0D
11D2:  MOVLB  02
11D3:  MOVWF  50
11D4:  MOVLP  00
11D5:  MOVLB  00
11D6:  CALL   7EC
11D7:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
11D8:  MOVLW  0A
11D9:  CLRWDT
11DA:  BTFSS  11.4
11DB:  GOTO   1D9
11DC:  MOVLB  03
11DD:  MOVWF  1A
11DE:  MOVLW  0D
11DF:  CLRWDT
11E0:  MOVLB  00
11E1:  BTFSC  11.4
11E2:  GOTO   1E5
11E3:  MOVLB  03
11E4:  GOTO   1DF
11E5:  MOVLB  03
11E6:  MOVWF  1A
11E7:  MOVLW  20
11E8:  MOVWF  05
11E9:  MOVLW  7A
11EA:  MOVWF  04
11EB:  MOVLP  08
11EC:  MOVLB  00
11ED:  CALL   22B
11EE:  MOVLP  10
....................       lcd_send(2,LCD_str); 
11EF:  MOVLW  02
11F0:  MOVLB  02
11F1:  MOVWF  4A
11F2:  MOVLW  20
11F3:  MOVWF  4C
11F4:  MOVLW  7A
11F5:  MOVWF  4B
11F6:  MOVLP  08
11F7:  MOVLB  00
11F8:  CALL   159
11F9:  MOVLP  10
....................       prompt(); 
11FA:  MOVLP  08
11FB:  CALL   79C
11FC:  MOVLP  10
....................       break; 
11FD:  GOTO   49E
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
11FE:  MOVLP  08
11FF:  CALL   702
1200:  MOVLP  10
1201:  MOVF   78,F
1202:  BTFSC  03.2
1203:  GOTO   207
....................         store_variables(); 
1204:  MOVLP  00
1205:  CALL   594
1206:  MOVLP  10
....................       } 
....................       break; 
1207:  GOTO   49E
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
1208:  MOVLB  01
1209:  DECFSZ 43,W
120A:  GOTO   20F
....................         init_src=USE_EEPROM_VARS; 
120B:  MOVLB  02
120C:  BSF    22.0
....................       } else { 
120D:  GOTO   211
120E:  MOVLB  01
....................         init_src=USE_DEFAULT_VARS; 
120F:  MOVLB  02
1210:  BCF    22.0
....................       } 
....................       if ( in_admin_mode() ) { 
1211:  MOVLP  08
1212:  MOVLB  00
1213:  CALL   702
1214:  MOVLP  10
1215:  MOVF   78,F
1216:  BTFSC  03.2
1217:  GOTO   222
....................         init_variables(init_src); 
1218:  MOVLW  00
1219:  MOVLB  02
121A:  BTFSC  22.0
121B:  MOVLW  01
121C:  MOVWF  2C
121D:  MOVWF  2D
121E:  MOVLP  00
121F:  MOVLB  00
1220:  CALL   60F
1221:  MOVLP  10
....................       } 
....................       break; 
1222:  GOTO   49E
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1223:  MOVLB  01
1224:  MOVF   42,W
1225:  ANDLW  03
1226:  MOVWF  30
....................       increment(value); 
1227:  MOVF   43,W
1228:  MOVLB  02
1229:  MOVWF  2F
122A:  MOVLP  08
122B:  MOVLB  00
122C:  CALL   711
122D:  MOVLP  10
....................       PROMPT_FLAG=1; 
122E:  MOVLB  01
122F:  BSF    5F.5
....................       break; 
1230:  MOVLB  00
1231:  GOTO   49E
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1232:  MOVLB  01
1233:  MOVF   42,W
1234:  ANDLW  03
1235:  MOVWF  30
....................       increment(-1*value); 
1236:  MOVLW  FF
1237:  MOVLB  02
1238:  MOVWF  43
1239:  MOVLB  01
123A:  MOVF   43,W
123B:  MOVLB  02
123C:  MOVWF  44
123D:  MOVLP  08
123E:  MOVLB  00
123F:  CALL   638
1240:  MOVLP  10
1241:  MOVF   78,W
1242:  MOVLB  02
1243:  MOVWF  2C
1244:  MOVWF  2F
1245:  MOVLP  08
1246:  MOVLB  00
1247:  CALL   711
1248:  MOVLP  10
....................       PROMPT_FLAG=1; 
1249:  MOVLB  01
124A:  BSF    5F.5
....................       break; 
124B:  MOVLB  00
124C:  GOTO   49E
....................     case STATUS: 
....................       status(); 
....................       break; 
*
1413:  MOVLB  00
1414:  GOTO   49E
....................     case ADMIN: 
....................       switch(argument) { 
1415:  MOVLB  01
1416:  MOVF   42,W
1417:  XORLW  02
1418:  MOVLB  00
1419:  BTFSC  03.2
141A:  GOTO   422
141B:  XORLW  03
141C:  BTFSC  03.2
141D:  GOTO   429
141E:  XORLW  02
141F:  BTFSC  03.2
1420:  GOTO   431
1421:  GOTO   435
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
1422:  MOVLP  08
1423:  CALL   702
1424:  MOVLP  10
1425:  MOVF   78,F
1426:  BTFSS  03.2
....................             reset_cpu(); 
1427:  RESET
....................           } 
....................           break; 
1428:  GOTO   43B
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
1429:  MOVLW  01
142A:  MOVLB  02
142B:  MOVWF  40
142C:  MOVLP  08
142D:  MOVLB  00
142E:  CALL   487
142F:  MOVLP  10
....................           break; 
1430:  GOTO   43B
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
1431:  MOVLP  08
1432:  CALL   7B4
1433:  MOVLP  10
....................         break; 
1434:  GOTO   43B
....................         default: 
....................           set_admin_mode(0); 
1435:  MOVLB  02
1436:  CLRF   40
1437:  MOVLP  08
1438:  MOVLB  00
1439:  CALL   487
143A:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
143B:  GOTO   49E
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
.................... #ifdef LCD_TYPE_PI 
....................       switch(value) { 
....................         case 0 : init_lcd();break;   
....................         case 1 : lcd_write(0,0x01); 
....................       } 
.................... #else 
....................       lcd_cmd=4+(value&0x03); 
143C:  MOVLB  01
143D:  MOVF   43,W
143E:  ANDLW  03
143F:  ADDLW  04
1440:  MOVLB  02
1441:  MOVWF  23
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
1442:  MOVLW  20
1443:  MOVLB  01
1444:  MOVWF  64
1445:  MOVLW  7A
1446:  MOVWF  63
1447:  MOVLW  B9
1448:  MOVLB  03
1449:  MOVWF  11
144A:  MOVLW  03
144B:  MOVWF  12
144C:  BCF    03.0
144D:  MOVLW  04
144E:  MOVLB  02
144F:  MOVWF  4A
1450:  MOVLP  08
1451:  MOVLB  00
1452:  CALL   0EB
1453:  MOVLP  10
1454:  MOVLW  60
1455:  MOVLB  02
1456:  MOVWF  4A
1457:  MOVLW  18
1458:  MOVWF  4B
1459:  MOVLP  08
145A:  MOVLB  00
145B:  CALL   1BC
145C:  MOVLP  10
145D:  MOVLW  BC
145E:  MOVLB  03
145F:  MOVWF  11
1460:  MOVLW  03
1461:  MOVWF  12
1462:  BCF    03.0
1463:  MOVLW  08
1464:  MOVLB  02
1465:  MOVWF  4A
1466:  MOVLP  08
1467:  MOVLB  00
1468:  CALL   0EB
1469:  MOVLP  10
146A:  MOVLB  02
146B:  MOVF   23,W
146C:  MOVWF  4A
146D:  MOVLW  18
146E:  MOVWF  4B
146F:  MOVLP  08
1470:  MOVLB  00
1471:  CALL   1BC
1472:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
1473:  MOVLW  0A
1474:  CLRWDT
1475:  BTFSS  11.4
1476:  GOTO   474
1477:  MOVLB  03
1478:  MOVWF  1A
1479:  MOVLW  0D
147A:  CLRWDT
147B:  MOVLB  00
147C:  BTFSC  11.4
147D:  GOTO   480
147E:  MOVLB  03
147F:  GOTO   47A
1480:  MOVLB  03
1481:  MOVWF  1A
1482:  MOVLW  20
1483:  MOVWF  05
1484:  MOVLW  7A
1485:  MOVWF  04
1486:  MOVLP  08
1487:  MOVLB  00
1488:  CALL   22B
1489:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
148A:  MOVLB  02
148B:  MOVF   23,W
148C:  MOVWF  4A
148D:  MOVLW  20
148E:  MOVWF  4C
148F:  MOVLW  7A
1490:  MOVWF  4B
1491:  MOVLP  08
1492:  MOVLB  00
1493:  CALL   159
1494:  MOVLP  10
.................... #endif 
....................       break; 
1495:  GOTO   49E
.................... #if __DEVICE__  == 1939 
....................     case SET_BIT: 
....................       set_bit(); 
....................       break; 
....................     case CLEAR_BIT: 
....................       clear_bit(); 
....................       break; 
.................... #endif 
....................     case MORSE_SEND: 
....................       morse(value); 
1496:  MOVLB  01
1497:  MOVF   43,W
1498:  MOVLB  02
1499:  MOVWF  3F
149A:  MOVLP  08
149B:  MOVLB  00
149C:  CALL   070
149D:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
149E:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  4A
1803:  MOVLW  20
1804:  MOVWF  4C
1805:  MOVLW  50
1806:  MOVWF  4B
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   159
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVLB  01
180D:  MOVWF  42
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B6C:  MOVLB  01
1B6D:  CLRF   66
1B6E:  CLRF   65
1B6F:  MOVF   66,F
1B70:  BTFSS  03.2
1B71:  GOTO   3C0
1B72:  MOVF   65,W
1B73:  SUBLW  38
1B74:  BTFSS  03.0
1B75:  GOTO   3C0
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B76:  MOVLW  01
1B77:  MOVWF  7A
1B78:  MOVLW  8F
1B79:  MOVLB  02
1B7A:  MOVWF  20
1B7B:  MOVF   7A,W
1B7C:  MOVWF  21
1B7D:  MOVLB  01
1B7E:  MOVF   66,W
1B7F:  MOVLB  02
1B80:  MOVWF  3E
1B81:  MOVLB  01
1B82:  MOVF   65,W
1B83:  MOVLB  02
1B84:  MOVWF  3D
1B85:  CLRF   40
1B86:  MOVLW  06
1B87:  MOVWF  3F
1B88:  MOVLP  08
1B89:  MOVLB  00
1B8A:  CALL   6C0
1B8B:  MOVLP  18
1B8C:  MOVF   78,W
1B8D:  MOVLB  02
1B8E:  ADDWF  20,W
1B8F:  MOVLB  01
1B90:  MOVWF  67
1B91:  MOVF   79,W
1B92:  MOVLB  02
1B93:  ADDWFC 21,W
1B94:  MOVLB  01
1B95:  MOVWF  68
....................     romstrcpy(rname,cPtr); 
1B96:  MOVLW  20
1B97:  MOVLB  02
1B98:  MOVWF  3C
1B99:  MOVLW  99
1B9A:  MOVWF  3B
1B9B:  MOVLB  01
1B9C:  MOVF   68,W
1B9D:  MOVLB  02
1B9E:  MOVWF  3E
1B9F:  MOVLB  01
1BA0:  MOVF   67,W
1BA1:  MOVLB  02
1BA2:  MOVWF  3D
1BA3:  MOVLP  08
1BA4:  MOVLB  00
1BA5:  CALL   6D7
1BA6:  MOVLP  18
....................     if(my_stricmp(argument_name,rname)==0) { 
1BA7:  MOVLW  20
1BA8:  MOVLB  02
1BA9:  MOVWF  40
1BAA:  MOVLW  74
1BAB:  MOVWF  3F
1BAC:  MOVLW  20
1BAD:  MOVWF  42
1BAE:  MOVLW  99
1BAF:  MOVWF  41
1BB0:  MOVLP  08
1BB1:  MOVLB  00
1BB2:  CALL   698
1BB3:  MOVLP  18
1BB4:  MOVF   78,F
1BB5:  BTFSS  03.2
1BB6:  GOTO   3BB
....................       argument=x; 
1BB7:  MOVLB  01
1BB8:  MOVF   65,W
1BB9:  MOVWF  42
1BBA:  MOVLB  00
....................     } 
....................   } 
1BBB:  MOVLB  01
1BBC:  INCF   65,F
1BBD:  BTFSC  03.2
1BBE:  INCF   66,F
1BBF:  GOTO   36F
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BC0:  MOVF   42,W
1BC1:  SUBLW  FF
1BC2:  BTFSS  03.2
1BC3:  GOTO   428
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BC4:  MOVLW  20
1BC5:  MOVLB  02
1BC6:  MOVWF  40
1BC7:  MOVLW  74
1BC8:  MOVWF  3F
1BC9:  MOVLP  08
1BCA:  MOVLB  00
1BCB:  CALL   65F
1BCC:  MOVLP  18
1BCD:  MOVF   78,W
1BCE:  MOVLB  01
1BCF:  MOVWF  43
....................     strcpy(rname,"eeprom"); 
1BD0:  MOVLB  02
1BD1:  CLRF   20
1BD2:  CLRF   21
1BD3:  MOVLW  20
1BD4:  MOVWF  05
1BD5:  MOVLW  99
1BD6:  MOVWF  04
1BD7:  MOVF   20,W
1BD8:  ADDWF  04,F
1BD9:  MOVLW  00
1BDA:  ADDWFC 05,F
1BDB:  MOVF   21,W
1BDC:  MOVLP  00
1BDD:  MOVLB  00
1BDE:  CALL   128
1BDF:  MOVLP  18
1BE0:  MOVWF  00
1BE1:  IORLW  00
1BE2:  BTFSC  03.2
1BE3:  GOTO   3E9
1BE4:  MOVLB  02
1BE5:  INCF   21,F
1BE6:  INCF   20,F
1BE7:  GOTO   3D3
1BE8:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1BE9:  MOVLW  20
1BEA:  MOVLB  02
1BEB:  MOVWF  40
1BEC:  MOVLW  74
1BED:  MOVWF  3F
1BEE:  MOVLW  20
1BEF:  MOVWF  42
1BF0:  MOVLW  99
1BF1:  MOVWF  41
1BF2:  MOVLP  08
1BF3:  MOVLB  00
1BF4:  CALL   698
1BF5:  MOVLP  18
1BF6:  MOVF   78,F
1BF7:  BTFSS  03.2
1BF8:  GOTO   3FD
....................       value=USE_EEPROM_VARS; 
1BF9:  MOVLW  01
1BFA:  MOVLB  01
1BFB:  MOVWF  43
1BFC:  MOVLB  00
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BFD:  MOVLB  02
1BFE:  CLRF   20
1BFF:  CLRF   21
1C00:  MOVLW  20
1C01:  MOVWF  05
1C02:  MOVLW  99
1C03:  MOVWF  04
1C04:  MOVF   20,W
1C05:  ADDWF  04,F
1C06:  MOVLW  00
1C07:  ADDWFC 05,F
1C08:  MOVF   21,W
1C09:  MOVLP  00
1C0A:  MOVLB  00
1C0B:  CALL   130
1C0C:  MOVLP  18
1C0D:  MOVWF  00
1C0E:  IORLW  00
1C0F:  BTFSC  03.2
1C10:  GOTO   416
1C11:  MOVLB  02
1C12:  INCF   21,F
1C13:  INCF   20,F
1C14:  GOTO   400
1C15:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C16:  MOVLW  20
1C17:  MOVLB  02
1C18:  MOVWF  40
1C19:  MOVLW  74
1C1A:  MOVWF  3F
1C1B:  MOVLW  20
1C1C:  MOVWF  42
1C1D:  MOVLW  99
1C1E:  MOVWF  41
1C1F:  MOVLP  08
1C20:  MOVLB  00
1C21:  CALL   698
1C22:  MOVLP  18
1C23:  MOVF   78,F
1C24:  BTFSS  03.2
1C25:  GOTO   429
....................       value=USE_DEFAULT_VARS; 
1C26:  MOVLB  01
1C27:  CLRF   43
1C28:  MOVLB  00
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C29:  MOVF   70,W
1C2A:  SUBLW  06
1C2B:  BTFSC  03.2
1C2C:  GOTO   431
1C2D:  MOVF   70,W
1C2E:  SUBLW  07
1C2F:  BTFSS  03.2
1C30:  GOTO   437
....................     value = 1; 
1C31:  MOVLW  01
1C32:  MOVLB  01
1C33:  MOVWF  43
....................     argument = CurrentTrimPot; 
1C34:  MOVF   30,W
1C35:  MOVWF  42
1C36:  MOVLB  00
....................   } 
....................   rs232_mode = 1; 
1C37:  MOVLB  01
1C38:  BSF    5F.7
....................   execute_command(); 
1C39:  MOVLP  10
1C3A:  MOVLB  00
1C3B:  CALL   000
1C3C:  MOVLP  18
....................   rs232_mode = 0; 
1C3D:  MOVLB  01
1C3E:  BCF    5F.7
.................... } // }}} 
1C3F:  MOVLP  18
1C40:  MOVLB  00
1C41:  GOTO   715 (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
124D:  MOVLW  1B
124E:  MOVLP  00
124F:  CALL   2E4
1250:  MOVLP  10
....................   printf("[2J"); 
1251:  MOVLW  5B
1252:  CLRWDT
1253:  BTFSS  11.4
1254:  GOTO   252
1255:  MOVLB  03
1256:  MOVWF  1A
1257:  MOVLW  32
1258:  CLRWDT
1259:  MOVLB  00
125A:  BTFSC  11.4
125B:  GOTO   25E
125C:  MOVLB  03
125D:  GOTO   258
125E:  MOVLB  03
125F:  MOVWF  1A
1260:  MOVLW  4A
1261:  CLRWDT
1262:  MOVLB  00
1263:  BTFSC  11.4
1264:  GOTO   267
1265:  MOVLB  03
1266:  GOTO   261
1267:  MOVLB  03
1268:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
1269:  MOVLW  1B
126A:  MOVLP  00
126B:  MOVLB  00
126C:  CALL   2E4
126D:  MOVLP  10
....................   printf("[0;0H"); 
126E:  MOVLW  C2
126F:  MOVLB  03
1270:  MOVWF  11
1271:  MOVLW  03
1272:  MOVWF  12
1273:  MOVLP  00
1274:  MOVLB  00
1275:  CALL   4A1
1276:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
0755:  MOVLB  02
0756:  SWAPF  3F,W
0757:  MOVWF  41
0758:  RLF    41,F
0759:  RLF    41,F
075A:  MOVLW  C0
075B:  ANDWF  41,F
....................   tx_value=tx_value + (value & 0x3F); 
075C:  MOVF   40,W
075D:  ANDLW  3F
075E:  ADDWF  41,F
....................   i2c_start(); 
075F:  MOVLB  04
0760:  BSF    16.0
0761:  BTFSC  16.0
0762:  GOTO   761
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
0763:  MOVLW  50
0764:  MOVLB  02
0765:  MOVWF  50
0766:  MOVLB  00
0767:  CALL   67D
0768:  MOVF   78,W
0769:  MOVLB  02
076A:  BCF    42.0
076B:  BTFSC  78.0
076C:  BSF    42.0
....................   if ( ack != 0) { 
076D:  BTFSS  42.0
076E:  GOTO   786
....................     printf("\n\rI2C : No ACK : %u",ack); 
076F:  MOVLW  00
0770:  BTFSC  42.0
0771:  MOVLW  01
0772:  MOVWF  43
0773:  MOVLW  C5
0774:  MOVLB  03
0775:  MOVWF  11
0776:  MOVLW  03
0777:  MOVWF  12
0778:  BCF    03.0
0779:  MOVLW  11
077A:  MOVLB  02
077B:  MOVWF  50
077C:  MOVLB  00
077D:  CALL   692
077E:  MOVLB  02
077F:  MOVF   43,W
0780:  MOVWF  50
0781:  MOVLW  1B
0782:  MOVWF  51
0783:  MOVLB  00
0784:  CALL   706
0785:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
0786:  MOVF   41,W
0787:  MOVWF  50
0788:  MOVLB  00
0789:  CALL   67D
....................   i2c_stop();   
078A:  MOVLB  04
078B:  BSF    16.2
078C:  BTFSC  16.2
078D:  GOTO   78C
....................   printf("\n\rPot(%u)<=%u",pot,value); 
078E:  MOVLW  CF
078F:  MOVLB  03
0790:  MOVWF  11
0791:  MOVLW  03
0792:  MOVWF  12
0793:  BCF    03.0
0794:  MOVLW  06
0795:  MOVLB  02
0796:  MOVWF  50
0797:  MOVLB  00
0798:  CALL   692
0799:  MOVLB  02
079A:  MOVF   3F,W
079B:  MOVWF  50
079C:  MOVLW  1B
079D:  MOVWF  51
079E:  MOVLB  00
079F:  CALL   706
07A0:  MOVLW  29
07A1:  CLRWDT
07A2:  BTFSS  11.4
07A3:  GOTO   7A1
07A4:  MOVLB  03
07A5:  MOVWF  1A
07A6:  MOVLW  3C
07A7:  CLRWDT
07A8:  MOVLB  00
07A9:  BTFSC  11.4
07AA:  GOTO   7AD
07AB:  MOVLB  03
07AC:  GOTO   7A7
07AD:  MOVLB  03
07AE:  MOVWF  1A
07AF:  MOVLW  3D
07B0:  CLRWDT
07B1:  MOVLB  00
07B2:  BTFSC  11.4
07B3:  GOTO   7B6
07B4:  MOVLB  03
07B5:  GOTO   7B0
07B6:  MOVLB  03
07B7:  MOVWF  1A
07B8:  MOVLB  02
07B9:  MOVF   40,W
07BA:  MOVWF  50
07BB:  MOVLW  1B
07BC:  MOVWF  51
07BD:  MOVLB  00
07BE:  CALL   706
....................  
.................... } // }}} 
07BF:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
0870:  MOVLW  DB
0871:  MOVLB  02
0872:  ADDWF  3F,W
0873:  MOVWF  43
0874:  MOVLW  1F
0875:  MOVWF  44
0876:  BTFSC  03.0
0877:  INCF   44,F
0878:  MOVF   44,W
0879:  MOVLB  03
087A:  MOVWF  12
087B:  MOVLB  02
087C:  MOVF   43,W
087D:  MOVLB  03
087E:  MOVWF  11
087F:  MOVLW  20
0880:  MOVWF  05
0881:  MOVLW  C0
0882:  MOVWF  04
0883:  MOVLW  01
0884:  MOVLB  02
0885:  MOVWF  45
0886:  MOVLP  00
0887:  MOVLB  00
0888:  CALL   7D9
0889:  MOVLP  08
....................    
....................   PROMPT_FLAG=1; 
088A:  MOVLB  01
088B:  BSF    5F.5
....................   for(x=0;x<4;x++) { 
088C:  MOVLB  02
088D:  CLRF   41
088E:  MOVF   41,W
088F:  SUBLW  03
0890:  BTFSS  03.0
0891:  GOTO   0B8
....................     do_delay=1; 
0892:  BSF    42.0
....................     switch(mc & 0xc0) { // Check two MSB's 
0893:  MOVF   40,W
0894:  ANDLW  C0
0895:  XORLW  40
0896:  MOVLB  00
0897:  BTFSC  03.2
0898:  GOTO   09D
0899:  XORLW  C0
089A:  BTFSC  03.2
089B:  GOTO   09F
089C:  GOTO   0A1
....................       case(0x40): 
....................         dit(); 
089D:  CALL   000
....................         break; 
089E:  GOTO   0A4
....................       case(0x80): 
....................         dah(); 
089F:  CALL   038
....................         break; 
08A0:  GOTO   0A4
....................       default: 
....................         do_delay=0; 
08A1:  MOVLB  02
08A2:  BCF    42.0
....................         break; 
08A3:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
08A4:  MOVLB  02
08A5:  RLF    40,F
08A6:  RLF    40,F
08A7:  MOVLW  FC
08A8:  ANDWF  40,F
....................     if ( do_delay ) { 
08A9:  BTFSS  42.0
08AA:  GOTO   0B6
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
08AB:  MOVLB  01
08AC:  CLRF   34
08AD:  MOVLW  02
08AE:  MOVWF  33
....................       while(aux_timer) { 
08AF:  MOVF   33,W
08B0:  IORWF  34,W
08B1:  BTFSC  03.2
08B2:  GOTO   0B5
....................         delay_cycles(1); 
08B3:  NOP
....................       } 
08B4:  GOTO   0AF
08B5:  MOVLB  02
....................     } 
....................   } 
08B6:  INCF   41,F
08B7:  GOTO   08E
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
08B8:  MOVF   3F,W
08B9:  SUBLW  09
08BA:  BTFSS  03.0
08BB:  GOTO   0C7
....................     if ( c < 5 ) { 
08BC:  MOVF   3F,W
08BD:  SUBLW  04
08BE:  BTFSS  03.0
08BF:  GOTO   0C4
....................       dah(); 
08C0:  MOVLB  00
08C1:  CALL   038
....................     } 
....................     else { 
08C2:  GOTO   0C6
08C3:  MOVLB  02
....................       dit(); 
08C4:  MOVLB  00
08C5:  CALL   000
08C6:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
08C7:  MOVLB  00
08C8:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0B49:  MOVLW  30
0B4A:  MOVLB  02
0B4B:  MOVWF  34
0B4C:  MOVWF  35
0B4D:  MOVWF  36
0B4E:  MOVWF  37
0B4F:  CLRF   38
....................   char PTT_s[5]={'0','0','0','0',0}; 
0B50:  MOVWF  39
0B51:  MOVWF  3A
0B52:  MOVWF  3B
0B53:  MOVWF  3C
0B54:  CLRF   3D
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0B55:  MOVF   2E,W
0B56:  MOVWF  75
....................  
....................   if ( cor ) { 
0B57:  MOVF   2E,F
0B58:  BTFSC  03.2
0B59:  GOTO   36B
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0B5A:  MOVLW  01
0B5B:  SUBWF  2E,W
0B5C:  ADDLW  29
0B5D:  MOVWF  04
0B5E:  MOVLW  20
0B5F:  MOVWF  05
0B60:  BTFSC  03.0
0B61:  INCF   05,F
0B62:  MOVF   00,W
0B63:  MOVWF  3F
0B64:  MOVLB  00
0B65:  MOVF   62,W
0B66:  ANDWF  63,W
0B67:  MOVLB  02
0B68:  ANDWF  3F,W
0B69:  MOVWF  33
....................   } else { 
0B6A:  GOTO   3AC
....................     ptt=0; 
0B6B:  CLRF   33
....................     //COR_EMUL=0; 
....................     if ( COR_DROP_FLAG ) { 
0B6C:  BTFSS  7D.6
0B6D:  GOTO   3AC
....................       COR_DROP_FLAG=0; 
0B6E:  BCF    7D.6
....................       if ( ConfirmChar || TailChar ) { 
0B6F:  MOVF   73,F
0B70:  BTFSS  03.2
0B71:  GOTO   375
0B72:  MOVF   72,F
0B73:  BTFSC  03.2
0B74:  GOTO   3AC
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0BAC:  MOVLW  01
0BAD:  MOVWF  32
....................   for(x=0;x<4;x++) { 
0BAE:  CLRF   2F
0BAF:  MOVF   2F,W
0BB0:  SUBLW  03
0BB1:  BTFSS  03.0
0BB2:  GOTO   413
....................     if ( !cor ) { 
0BB3:  MOVF   2E,F
0BB4:  BTFSS  03.2
0BB5:  GOTO   3B9
....................       rx_bit=0; 
0BB6:  BCF    3E.0
....................       ptt_bit=0; 
0BB7:  BCF    3E.1
....................     } else { 
0BB8:  GOTO   3C8
....................       if ( cor == (x+1) ) { 
0BB9:  MOVLW  01
0BBA:  ADDWF  2F,W
0BBB:  SUBWF  2E,W
0BBC:  BTFSS  03.2
0BBD:  GOTO   3C2
....................         rx_bit=1; 
0BBE:  BSF    3E.0
....................         CurrentCorMask=mask; 
0BBF:  MOVF   32,W
0BC0:  MOVWF  74
....................       } else { 
0BC1:  GOTO   3C3
....................         rx_bit=0; 
0BC2:  BCF    3E.0
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0BC3:  BCF    3E.1
0BC4:  MOVF   33,W
0BC5:  ANDWF  32,W
0BC6:  BTFSS  03.2
0BC7:  BSF    3E.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0BC8:  MOVF   2F,W
0BC9:  MOVLP  00
0BCA:  MOVLB  00
0BCB:  CALL   031
0BCC:  MOVLP  08
0BCD:  MOVLB  02
0BCE:  MOVWF  3F
0BCF:  MOVLW  00
0BD0:  BTFSC  3E.0
0BD1:  MOVLW  01
0BD2:  MOVWF  77
0BD3:  MOVF   3F,W
0BD4:  MOVWF  40
0BD5:  MOVF   77,W
0BD6:  MOVWF  41
0BD7:  MOVLW  01
0BD8:  MOVWF  43
0BD9:  CLRF   42
0BDA:  MOVLB  00
0BDB:  CALL   0C9
0BDC:  MOVLB  02
0BDD:  MOVF   3F,W
0BDE:  MOVWF  40
0BDF:  CLRF   41
0BE0:  CLRF   43
0BE1:  MOVLW  80
0BE2:  MOVWF  42
0BE3:  MOVLB  00
0BE4:  CALL   0C9
....................     output_bit(PTT_PIN[x],ptt_bit); 
0BE5:  MOVLB  02
0BE6:  MOVF   2F,W
0BE7:  MOVLP  00
0BE8:  MOVLB  00
0BE9:  CALL   036
0BEA:  MOVLP  08
0BEB:  MOVLB  02
0BEC:  MOVWF  3F
0BED:  MOVLW  00
0BEE:  BTFSC  3E.1
0BEF:  MOVLW  01
0BF0:  MOVWF  77
0BF1:  MOVF   3F,W
0BF2:  MOVWF  40
0BF3:  MOVF   77,W
0BF4:  MOVWF  41
0BF5:  MOVLW  01
0BF6:  MOVWF  43
0BF7:  CLRF   42
0BF8:  MOVLB  00
0BF9:  CALL   0C9
0BFA:  MOVLB  02
0BFB:  MOVF   3F,W
0BFC:  MOVWF  40
0BFD:  CLRF   41
0BFE:  CLRF   43
0BFF:  MOVLW  80
0C00:  MOVWF  42
0C01:  MOVLB  00
0C02:  CALL   0C9
....................     if(ptt_bit) { 
0C03:  MOVLB  02
0C04:  BTFSS  3E.1
0C05:  GOTO   40F
....................       PTT_s[x]='1'; 
0C06:  MOVLW  B9
0C07:  ADDWF  2F,W
0C08:  MOVWF  04
0C09:  MOVLW  20
0C0A:  MOVWF  05
0C0B:  BTFSC  03.0
0C0C:  INCF   05,F
0C0D:  MOVLW  31
0C0E:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C0F:  BCF    03.0
0C10:  RLF    32,F
....................   }  
0C11:  INCF   2F,F
0C12:  GOTO   3AF
....................   if(!cor) { 
0C13:  MOVF   2E,F
0C14:  BTFSS  03.2
0C15:  GOTO   418
....................     CurrentCorPriority=0; 
0C16:  CLRF   76
....................   } else { 
0C17:  GOTO   446
....................     CurrentCorPriority=RXPriority[cor-1]; 
0C18:  MOVLW  01
0C19:  SUBWF  2E,W
0C1A:  ADDLW  25
0C1B:  MOVWF  04
0C1C:  MOVLW  20
0C1D:  MOVWF  05
0C1E:  BTFSC  03.0
0C1F:  INCF   05,F
0C20:  MOVF   00,W
0C21:  MOVWF  76
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0C22:  CLRF   30
0C23:  MOVF   30,W
0C24:  SUBLW  03
0C25:  BTFSS  03.0
0C26:  GOTO   443
....................       pot_val=RX_GAIN[cor-1][pot]; 
0C27:  MOVLW  01
0C28:  SUBWF  2E,W
0C29:  MOVWF  77
0C2A:  RLF    77,F
0C2B:  RLF    77,F
0C2C:  MOVLW  FC
0C2D:  ANDWF  77,F
0C2E:  MOVF   77,W
0C2F:  ADDWF  30,W
0C30:  ADDLW  0C
0C31:  MOVWF  04
0C32:  MOVLW  20
0C33:  MOVWF  05
0C34:  BTFSC  03.0
0C35:  INCF   05,F
0C36:  MOVF   00,W
0C37:  MOVWF  31
....................       set_trimpot(pot,pot_val); 
0C38:  MOVF   30,W
0C39:  MOVWF  3F
0C3A:  MOVF   31,W
0C3B:  MOVWF  40
0C3C:  MOVLP  00
0C3D:  MOVLB  00
0C3E:  CALL   755
0C3F:  MOVLP  08
....................     } 
0C40:  MOVLB  02
0C41:  INCF   30,F
0C42:  GOTO   423
....................     PROMPT_FLAG=1; 
0C43:  MOVLB  01
0C44:  BSF    5F.5
0C45:  MOVLB  02
....................   } 
....................   COR_s[cor-1]='1'; 
0C46:  MOVLW  01
0C47:  SUBWF  2E,W
0C48:  ADDLW  B4
0C49:  MOVWF  04
0C4A:  MOVLW  20
0C4B:  MOVWF  05
0C4C:  BTFSC  03.0
0C4D:  INCF   05,F
0C4E:  MOVLW  31
0C4F:  MOVWF  00
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0C50:  MOVLW  20
0C51:  MOVLB  01
0C52:  MOVWF  64
0C53:  MOVLW  7A
0C54:  MOVWF  63
0C55:  MOVLW  D6
0C56:  MOVLB  03
0C57:  MOVWF  11
0C58:  MOVLW  03
0C59:  MOVWF  12
0C5A:  BCF    03.0
0C5B:  MOVLW  04
0C5C:  MOVLB  02
0C5D:  MOVWF  4A
0C5E:  MOVLB  00
0C5F:  CALL   0EB
0C60:  MOVLW  20
0C61:  MOVWF  05
0C62:  MOVLW  B4
0C63:  MOVWF  04
0C64:  CALL   142
0C65:  MOVLW  D9
0C66:  MOVLB  03
0C67:  MOVWF  11
0C68:  MOVLW  03
0C69:  MOVWF  12
0C6A:  BCF    03.0
0C6B:  MOVLW  05
0C6C:  MOVLB  02
0C6D:  MOVWF  4A
0C6E:  MOVLB  00
0C6F:  CALL   0EB
0C70:  MOVLW  20
0C71:  MOVWF  05
0C72:  MOVLW  B9
0C73:  MOVWF  04
0C74:  CALL   142
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0C75:  MOVLW  01
0C76:  MOVLB  02
0C77:  MOVWF  4A
0C78:  MOVLW  20
0C79:  MOVWF  4C
0C7A:  MOVLW  7A
0C7B:  MOVWF  4B
0C7C:  MOVLB  00
0C7D:  CALL   159
....................   delay_ms(50); 
0C7E:  MOVLW  32
0C7F:  MOVLB  02
0C80:  MOVWF  4A
0C81:  MOVLP  00
0C82:  MOVLB  00
0C83:  CALL   7C0
0C84:  MOVLP  08
....................   pot_values_to_lcd(); 
0C85:  CALL   245
.................... }// }}} 
0C86:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1E1B:  MOVF   67,W
1E1C:  SUBLW  0A
1E1D:  BTFSS  03.0
1E1E:  GOTO   639
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1E1F:  MOVLW  66
1E20:  ADDWF  67,W
1E21:  MOVWF  04
1E22:  MOVLW  20
1E23:  MOVWF  05
1E24:  BTFSC  03.0
1E25:  INCF   05,F
1E26:  BTFSS  00.4
1E27:  GOTO   637
1E28:  MOVLW  66
1E29:  ADDWF  67,W
1E2A:  MOVWF  04
1E2B:  MOVLW  20
1E2C:  MOVWF  05
1E2D:  BTFSC  03.0
1E2E:  INCF   05,F
1E2F:  MOVF   00,W
1E30:  ANDLW  0F
1E31:  SUBLW  0C
1E32:  BTFSC  03.2
1E33:  GOTO   637
....................       strobe=1; 
1E34:  MOVLW  01
1E35:  MOVWF  68
....................      } else { 
1E36:  GOTO   638
....................       strobe = 0; 
1E37:  CLRF   68
....................     }  
....................   } else { 
1E38:  GOTO   63A
....................     strobe=0; 
1E39:  CLRF   68
....................   } 
....................   return(strobe); 
1E3A:  MOVF   68,W
1E3B:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
17C5:  MOVLB  01
17C6:  MOVF   67,W
17C7:  SUBWF  68,W
17C8:  BTFSS  03.0
17C9:  GOTO   7EF
17CA:  MOVF   67,W
17CB:  SUBLW  09
17CC:  BTFSS  03.0
17CD:  GOTO   7EF
....................     valid=1; 
17CE:  BSF    6B.0
....................     for(x=a;x<=b;x++) { 
17CF:  MOVF   67,W
17D0:  MOVWF  6A
17D1:  MOVF   6A,W
17D2:  SUBWF  68,W
17D3:  BTFSS  03.0
17D4:  GOTO   7EE
....................       key=(int)DTMF_ARRAY[x].Key; 
17D5:  MOVLW  66
17D6:  ADDWF  6A,W
17D7:  MOVWF  04
17D8:  MOVLW  20
17D9:  MOVWF  05
17DA:  BTFSC  03.0
17DB:  INCF   05,F
17DC:  MOVF   00,W
17DD:  ANDLW  0F
17DE:  MOVWF  69
....................       if(! DTMF_ARRAY[x].Strobe ) { 
17DF:  MOVLW  66
17E0:  ADDWF  6A,W
17E1:  MOVWF  04
17E2:  MOVLW  20
17E3:  MOVWF  05
17E4:  BTFSC  03.0
17E5:  INCF   05,F
17E6:  BTFSS  00.4
....................         valid=0; 
17E7:  BCF    6B.0
....................       } 
....................      if(key==dp) { 
17E8:  MOVF   69,W
17E9:  SUBLW  0C
17EA:  BTFSC  03.2
....................         valid=0; 
17EB:  BCF    6B.0
....................       } 
....................     } 
17EC:  INCF   6A,F
17ED:  GOTO   7D1
....................   } else { 
17EE:  GOTO   7F0
....................     valid=0; 
17EF:  BCF    6B.0
....................   } 
....................   return(valid); 
17F0:  MOVLW  00
17F1:  BTFSC  6B.0
17F2:  MOVLW  01
17F3:  MOVWF  78
.................... } // }}} 
17F4:  MOVLB  00
17F5:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   unsigned site_id; 
....................   unsigned digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 01 : Link commands 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : Disable Link Radio 
....................   // 11 : Enable Link Radio 
....................   // 12 : Send to I2C 
....................   // 14 : SetBit   (*52 14 <reg> <bit>) 
....................   // 15 : ClearBit (*52 15 <reg> <bit>) 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Save Settings	    : 52 04 00 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   // -- User Functions -- 
....................   // Disable AuxOut0        : 51 02 21 0 #  
....................   // Disable AuxOut0 (!Arg) : 51 02 21 #  
....................   // Enable  AuxOut1        : 51 02 22 1 # 
....................   command=0; 
*
1DC7:  CLRF   70
....................   value=0; 
1DC8:  MOVLB  01
1DC9:  CLRF   43
....................   if ( ValidKeyRange(0,3)) { 
1DCA:  CLRF   67
1DCB:  MOVLW  03
1DCC:  MOVWF  68
1DCD:  MOVLP  10
1DCE:  MOVLB  00
1DCF:  CALL   7C5
1DD0:  MOVLP  18
1DD1:  MOVF   78,F
1DD2:  BTFSC  03.2
1DD3:  GOTO   688
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1DD4:  MOVLB  01
1DD5:  MOVF   36,W
1DD6:  ANDLW  0F
1DD7:  MOVWF  68
1DD8:  MOVLB  02
1DD9:  MOVWF  43
1DDA:  MOVLW  0A
1DDB:  MOVWF  44
1DDC:  MOVLP  08
1DDD:  MOVLB  00
1DDE:  CALL   638
1DDF:  MOVLP  18
1DE0:  MOVF   78,W
1DE1:  MOVLB  01
1DE2:  MOVWF  67
1DE3:  MOVF   37,W
1DE4:  ANDLW  0F
1DE5:  ADDWF  67,W
1DE6:  MOVWF  65
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1DE7:  MOVF   38,W
1DE8:  ANDLW  0F
1DE9:  MOVWF  68
1DEA:  MOVLB  02
1DEB:  MOVWF  43
1DEC:  MOVLW  0A
1DED:  MOVWF  44
1DEE:  MOVLP  08
1DEF:  MOVLB  00
1DF0:  CALL   638
1DF1:  MOVLP  18
1DF2:  MOVF   78,W
1DF3:  MOVLB  01
1DF4:  MOVWF  67
1DF5:  MOVF   39,W
1DF6:  ANDLW  0F
1DF7:  ADDWF  67,W
1DF8:  MOVWF  70
....................     if ( ValidKeyRange(4,5) ) { 
1DF9:  MOVLW  04
1DFA:  MOVWF  67
1DFB:  MOVLW  05
1DFC:  MOVWF  68
1DFD:  MOVLP  10
1DFE:  MOVLB  00
1DFF:  CALL   7C5
1E00:  MOVLP  18
1E01:  MOVF   78,F
1E02:  BTFSC  03.2
1E03:  GOTO   65A
....................       // Admin mode {{{ 
....................       argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1E04:  MOVLB  01
1E05:  MOVF   3A,W
1E06:  ANDLW  0F
1E07:  MOVWF  68
1E08:  MOVLB  02
1E09:  MOVWF  43
1E0A:  MOVLW  0A
1E0B:  MOVWF  44
1E0C:  MOVLP  08
1E0D:  MOVLB  00
1E0E:  CALL   638
1E0F:  MOVLP  18
1E10:  MOVF   78,W
1E11:  MOVLB  01
1E12:  MOVWF  67
1E13:  MOVF   3B,W
1E14:  ANDLW  0F
1E15:  ADDWF  67,W
1E16:  MOVWF  42
....................       digit=6; 
1E17:  MOVLW  06
1E18:  MOVWF  66
....................       while(ValidKey(digit)) { 
1E19:  MOVF   66,W
1E1A:  MOVWF  67
*
1E3C:  MOVF   78,F
1E3D:  BTFSC  03.2
1E3E:  GOTO   658
....................        value = value * 10 + DTMF_ARRAY[digit].Key; 
1E3F:  MOVF   43,W
1E40:  MOVLB  02
1E41:  MOVWF  43
1E42:  MOVLW  0A
1E43:  MOVWF  44
1E44:  MOVLP  08
1E45:  MOVLB  00
1E46:  CALL   638
1E47:  MOVLP  18
1E48:  MOVF   78,W
1E49:  MOVLB  01
1E4A:  MOVWF  67
1E4B:  MOVLW  66
1E4C:  ADDWF  66,W
1E4D:  MOVWF  04
1E4E:  MOVLW  20
1E4F:  MOVWF  05
1E50:  BTFSC  03.0
1E51:  INCF   05,F
1E52:  MOVF   00,W
1E53:  ANDLW  0F
1E54:  ADDWF  67,W
1E55:  MOVWF  43
....................        digit++; 
1E56:  INCF   66,F
....................       } 
1E57:  GOTO   619
....................       // Admin mode }}} 
....................     } else { 
1E58:  GOTO   673
1E59:  MOVLB  00
....................       // User function {{{ 
....................       // Only 4 digits were entered.  
....................       // Use 'command' value as user function. 
....................       switch(command) { 
1E5A:  MOVF   70,W
1E5B:  XORLW  0A
1E5C:  BTFSC  03.2
1E5D:  GOTO   662
1E5E:  XORLW  01
1E5F:  BTFSC  03.2
1E60:  GOTO   669
1E61:  GOTO   671
....................         // Commands 10 (disable link) and 11 (enable link) 
....................         case(10): 
....................           argument = 0; 
1E62:  MOVLB  01
1E63:  CLRF   42
....................           value = 0x0E; 
1E64:  MOVLW  0E
1E65:  MOVWF  43
.................... 	  command=SET_REG; 
1E66:  MOVLW  02
1E67:  MOVWF  70
....................   	      break; 
1E68:  GOTO   673
....................         case(11): 
....................           argument = 0; 
1E69:  MOVLB  01
1E6A:  CLRF   42
....................           value = 0x0F; 
1E6B:  MOVLW  0F
1E6C:  MOVWF  43
.................... 	  command=SET_REG; 
1E6D:  MOVLW  02
1E6E:  MOVWF  70
....................    		    break; 
1E6F:  GOTO   673
1E70:  MOVLB  00
.................... 	default: 
.................... 	  command=0; 
1E71:  CLRF   70
1E72:  MOVLB  01
....................       } 
....................       // User function }}} 
....................     } 
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1E73:  MOVF   70,W
1E74:  XORLW  04
1E75:  MOVLB  00
1E76:  BTFSC  03.2
1E77:  GOTO   67B
1E78:  XORLW  01
1E79:  BTFSS  03.2
1E7A:  GOTO   67F
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1E7B:  MOVLB  01
1E7C:  MOVF   42,W
1E7D:  MOVWF  43
....................         break; 
1E7E:  MOVLB  00
....................     } 
....................     if ( site_id == SiteID ) { 
1E7F:  MOVF   65,W
1E80:  MOVLB  01
1E81:  SUBWF  65,W
1E82:  BTFSS  03.2
1E83:  GOTO   689
....................       execute_command(); 
1E84:  MOVLP  10
1E85:  MOVLB  00
1E86:  CALL   000
1E87:  MOVLP  18
1E88:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1E89:  MOVF   36,W
1E8A:  ANDLW  0F
1E8B:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1E8C:  BTFSS  5F.6
1E8D:  GOTO   6C2
1E8E:  CLRF   67
1E8F:  CLRF   68
1E90:  MOVLP  10
1E91:  MOVLB  00
1E92:  CALL   7C5
1E93:  MOVLP  18
1E94:  MOVF   78,F
1E95:  BTFSS  03.2
1E96:  GOTO   699
1E97:  MOVLB  01
1E98:  GOTO   6C2
....................     restart_wdt(); 
1E99:  CLRWDT
....................     switch(command) { 
1E9A:  MOVF   70,W
1E9B:  XORLW  0E
1E9C:  BTFSC  03.2
1E9D:  GOTO   6A5
1E9E:  XORLW  01
1E9F:  BTFSC  03.2
1EA0:  GOTO   6AF
1EA1:  XORLW  05
1EA2:  BTFSC  03.2
1EA3:  GOTO   6B7
1EA4:  GOTO   6BE
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1EA5:  MOVLW  01
1EA6:  MOVLB  01
1EA7:  ADDWF  30,W
1EA8:  ANDLW  03
1EA9:  MOVWF  30
....................         pot_values_to_lcd(); 
1EAA:  MOVLP  08
1EAB:  MOVLB  00
1EAC:  CALL   245
1EAD:  MOVLP  18
....................         break; 
1EAE:  GOTO   6BE
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1EAF:  MOVLW  FF
1EB0:  MOVLB  02
1EB1:  MOVWF  2F
1EB2:  MOVLP  08
1EB3:  MOVLB  00
1EB4:  CALL   711
1EB5:  MOVLP  18
....................         break; 
1EB6:  GOTO   6BE
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1EB7:  MOVLW  01
1EB8:  MOVLB  02
1EB9:  MOVWF  2F
1EBA:  MOVLP  08
1EBB:  MOVLB  00
1EBC:  CALL   711
1EBD:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1EBE:  MOVLP  08
1EBF:  CALL   702
1EC0:  MOVLP  18
1EC1:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1EC2:  BSF    5F.4
.................... } // }}} 
1EC3:  MOVLP  18
1EC4:  MOVLB  00
1EC5:  GOTO   756 (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int cor_index; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
15D1:  MOVLW  01
15D2:  MOVLB  01
15D3:  MOVWF  65
....................   do_update_ptt=0; 
15D4:  CLRF   68
....................   // Allow emulated COR[4] for DTMF control (No audio feed-thru) 
....................   cor_in = COR_IN ; 
15D5:  MOVLB  00
15D6:  MOVF   60,W
15D7:  MOVLB  01
15D8:  MOVWF  67
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in & CurrentCorMask) ) { 
15D9:  MOVF   76,F
15DA:  BTFSC  03.2
15DB:  GOTO   5F1
15DC:  MOVF   67,W
15DD:  ANDWF  74,W
15DE:  BTFSS  03.2
15DF:  GOTO   5F1
....................     CurrentCorPriority=0; 
15E0:  CLRF   76
....................     CurrentCorMask=0; 
15E1:  CLRF   74
....................     do_update_ptt=1; 
15E2:  MOVLW  01
15E3:  MOVWF  68
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
15E4:  MOVF   67,W
15E5:  MOVLB  00
15E6:  ANDWF  62,W
15E7:  ANDWF  63,W
15E8:  BTFSS  03.2
15E9:  GOTO   5F0
....................       COR_DROP_FLAG=1; 
15EA:  BSF    7D.6
....................       if ( Tail ) { 
15EB:  MOVF   67,F
15EC:  BTFSC  03.2
15ED:  GOTO   5F0
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
15EE:  MOVF   67,W
15EF:  MOVWF  72
15F0:  MOVLB  01
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
15F1:  CLRF   69
....................   for(x=0;x<4;x++) { 
15F2:  CLRF   6A
15F3:  MOVF   6A,W
15F4:  SUBLW  03
15F5:  BTFSS  03.0
15F6:  GOTO   62F
....................     if ( cor_in & cor_mask & (~TOT_FLAG_Mask) ) { 
15F7:  MOVF   67,W
15F8:  ANDWF  65,W
15F9:  MOVWF  6B
15FA:  MOVLB  00
15FB:  MOVF   6A,W
15FC:  XORLW  FF
15FD:  MOVLB  01
15FE:  ANDWF  6B,W
15FF:  BTFSC  03.2
1600:  GOTO   62B
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
1601:  MOVLB  00
1602:  MOVF   62,W
1603:  ANDWF  63,W
1604:  MOVLB  01
1605:  ANDWF  65,W
1606:  BTFSC  03.2
1607:  GOTO   612
....................         rx_priority=RXPriority[x]; 
1608:  MOVLW  25
1609:  ADDWF  6A,W
160A:  MOVWF  04
160B:  MOVLW  20
160C:  MOVWF  05
160D:  BTFSC  03.0
160E:  INCF   05,F
160F:  MOVF   00,W
1610:  MOVWF  66
....................       } else { 
1611:  GOTO   614
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
1612:  MOVLW  01
1613:  MOVWF  66
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1614:  MOVF   66,W
1615:  SUBWF  76,W
1616:  BTFSC  03.0
1617:  GOTO   62B
....................         if ( ! CurrentCorPriority ) { 
1618:  MOVF   76,F
1619:  BTFSS  03.2
161A:  GOTO   61D
....................           CurrentCorPriority = rx_priority; 
161B:  MOVF   66,W
161C:  MOVWF  76
....................         } 
....................         cor_index=x+1; 
161D:  MOVLW  01
161E:  ADDWF  6A,W
161F:  MOVWF  69
....................         do_update_ptt=1; 
1620:  MOVLW  01
1621:  MOVWF  68
.................... 	TOT_FLAG_Mask=0; 
1622:  MOVLB  00
1623:  CLRF   6A
.................... 	QSO_Duration = 0; 
1624:  CLRF   6C
1625:  CLRF   6B
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
1626:  MOVLB  01
1627:  MOVF   65,W
1628:  MOVLB  00
1629:  MOVWF  61
162A:  MOVLB  01
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
162B:  BCF    03.0
162C:  RLF    65,F
....................   } 
162D:  INCF   6A,F
162E:  GOTO   5F3
....................   if ( do_update_ptt ) { 
162F:  MOVF   68,F
1630:  BTFSC  03.2
1631:  GOTO   63B
....................     update_ptt(cor_index); 
1632:  MOVF   69,W
1633:  MOVLB  02
1634:  MOVWF  2E
1635:  MOVLP  08
1636:  MOVLB  00
1637:  CALL   349
1638:  MOVLP  10
....................     PROMPT_FLAG=1; 
1639:  MOVLB  01
163A:  BSF    5F.5
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
163B:  MOVF   67,F
163C:  BTFSS  03.2
163D:  GOTO   643
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
163E:  BSF    5F.4
....................     COR_IN_EFFECTIVE=0; 
163F:  MOVLB  00
1640:  CLRF   61
....................     TOT_FLAG_Mask=0; 
1641:  CLRF   6A
1642:  MOVLB  01
....................   } 
....................   // Refresh Link Time-out timer when COR is received. 
....................   // Any COR value refreshes the link TOT timer. 
....................   if ( Link_TOT != 0 && (cor_in)!=0 ) { 
1643:  MOVLB  00
1644:  MOVF   6D,F
1645:  BTFSC  03.2
1646:  GOTO   650
1647:  MOVLB  01
1648:  MOVF   67,F
1649:  BTFSS  03.2
164A:  GOTO   64D
164B:  MOVLB  00
164C:  GOTO   650
....................     LinkDurationTimer = Link_TOT; 
164D:  MOVLB  00
164E:  MOVF   6D,W
164F:  MOVWF  6E
....................   } 
.................... } // }}} 
1650:  MOVLP  18
1651:  GOTO   734 (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
1EC6:  MOVLB  01
1EC7:  CLRF   65
1EC8:  MOVF   65,W
1EC9:  SUBLW  09
1ECA:  BTFSS  03.0
1ECB:  GOTO   6D6
....................     DTMF_ARRAY[x]=(sDTMF)0; 
1ECC:  MOVLW  66
1ECD:  ADDWF  65,W
1ECE:  MOVWF  04
1ECF:  MOVLW  20
1ED0:  MOVWF  05
1ED1:  BTFSC  03.0
1ED2:  INCF   05,F
1ED3:  CLRF   00
....................   } 
1ED4:  INCF   65,F
1ED5:  GOTO   6C8
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
1ED6:  MOVLW  20
1ED7:  MOVWF  41
1ED8:  MOVLW  66
1ED9:  MOVWF  40
.................... } // }}} 
1EDA:  MOVLP  18
1EDB:  MOVLB  00
1EDC:  GOTO   75D (RETURN)
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   dtmf_in=dtmf_read(CONTROL_REG); 
*
1277:  MOVLW  01
1278:  MOVLB  02
1279:  MOVWF  3B
127A:  MOVLP  00
127B:  MOVLB  00
127C:  CALL   664
127D:  MOVLP  10
127E:  MOVF   78,W
127F:  MOVLB  02
1280:  MOVWF  33
....................   aux_in = 0; 
1281:  CLRF   34
....................   for(x=0;x<RegMapNum;x++) { 
1282:  CLRF   2D
1283:  CLRF   2C
1284:  MOVF   2D,F
1285:  BTFSS  03.2
1286:  GOTO   38B
1287:  MOVF   2C,W
1288:  SUBLW  38
1289:  BTFSS  03.0
128A:  GOTO   38B
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
128B:  MOVLW  01
128C:  MOVWF  7A
128D:  MOVLW  8F
128E:  MOVWF  3B
128F:  MOVF   7A,W
1290:  MOVWF  3C
1291:  MOVF   2D,W
1292:  MOVWF  3E
1293:  MOVF   2C,W
1294:  MOVWF  3D
1295:  CLRF   40
1296:  MOVLW  06
1297:  MOVWF  3F
1298:  MOVLP  08
1299:  MOVLB  00
129A:  CALL   6C0
129B:  MOVLP  10
129C:  MOVF   78,W
129D:  MOVLB  02
129E:  ADDWF  3B,W
129F:  MOVWF  2F
12A0:  MOVF   79,W
12A1:  ADDWFC 3C,W
12A2:  MOVWF  30
....................     romstrcpy(rname,cPtr); 
12A3:  MOVLW  20
12A4:  MOVWF  3C
12A5:  MOVLW  B5
12A6:  MOVWF  3B
12A7:  MOVF   30,W
12A8:  MOVWF  3E
12A9:  MOVF   2F,W
12AA:  MOVWF  3D
12AB:  MOVLP  08
12AC:  MOVLB  00
12AD:  CALL   6D7
12AE:  MOVLP  10
....................   regPtr=RegMap[x].reg_ptr; 
12AF:  MOVLB  02
12B0:  RLF    2C,W
12B1:  MOVWF  3B
12B2:  RLF    2D,W
12B3:  MOVWF  3C
12B4:  RLF    3B,F
12B5:  RLF    3C,F
12B6:  MOVLW  FC
12B7:  ANDWF  3B,F
12B8:  MOVF   3C,W
12B9:  MOVWF  7A
12BA:  MOVF   3B,W
12BB:  MOVWF  3D
12BC:  INCF   3B,W
12BD:  MOVLP  00
12BE:  MOVLB  00
12BF:  CALL   043
12C0:  MOVLP  10
12C1:  MOVWF  7A
12C2:  MOVLB  02
12C3:  MOVF   3D,W
12C4:  MOVLP  00
12C5:  MOVLB  00
12C6:  CALL   043
12C7:  MOVLP  10
12C8:  MOVLB  02
12C9:  MOVWF  31
12CA:  MOVF   7A,W
12CB:  MOVWF  32
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
12CC:  MOVF   32,W
12CD:  MOVWF  7A
12CE:  MOVF   31,W
12CF:  MOVWF  04
12D0:  MOVF   7A,W
12D1:  MOVWF  05
12D2:  MOVF   00,W
12D3:  MOVWF  3B
12D4:  MOVLW  5B
12D5:  CLRWDT
12D6:  MOVLB  00
12D7:  BTFSC  11.4
12D8:  GOTO   2DB
12D9:  MOVLB  02
12DA:  GOTO   2D5
12DB:  MOVLB  03
12DC:  MOVWF  1A
12DD:  MOVLW  0B
12DE:  MOVWF  04
12DF:  MOVLB  02
12E0:  MOVF   2D,W
12E1:  MOVWF  3D
12E2:  MOVF   2C,W
12E3:  MOVWF  3C
*
1341:  MOVLW  5D
1342:  CLRWDT
1343:  MOVLB  00
1344:  BTFSC  11.4
1345:  GOTO   348
1346:  MOVLB  02
1347:  GOTO   342
1348:  MOVLB  03
1349:  MOVWF  1A
134A:  MOVLW  20
134B:  CLRWDT
134C:  MOVLB  00
134D:  BTFSC  11.4
134E:  GOTO   351
134F:  MOVLB  03
1350:  GOTO   34B
1351:  MOVLB  03
1352:  MOVWF  1A
1353:  MOVLW  20
1354:  MOVWF  05
1355:  MOVLW  B5
1356:  MOVWF  04
1357:  MOVLP  08
1358:  MOVLB  00
1359:  CALL   22B
135A:  MOVLP  10
135B:  MOVLW  20
135C:  CLRWDT
135D:  BTFSS  11.4
135E:  GOTO   35C
135F:  MOVLB  03
1360:  MOVWF  1A
1361:  MOVLB  02
1362:  MOVF   3B,W
1363:  MOVWF  50
1364:  MOVLW  1B
1365:  MOVWF  51
1366:  MOVLP  00
1367:  MOVLB  00
1368:  CALL   706
1369:  MOVLP  10
136A:  MOVLW  09
136B:  CLRWDT
136C:  BTFSS  11.4
136D:  GOTO   36B
136E:  MOVLB  03
136F:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
1370:  MOVLB  02
1371:  MOVF   2C,W
1372:  ANDLW  03
1373:  MOVWF  3B
1374:  CLRF   3C
1375:  MOVF   3B,W
1376:  SUBLW  03
1377:  BTFSS  03.2
1378:  GOTO   386
1379:  MOVF   3C,F
137A:  BTFSS  03.2
137B:  GOTO   386
....................       putc('\n'); 
137C:  MOVLW  0A
137D:  MOVLP  00
137E:  MOVLB  00
137F:  CALL   2E4
1380:  MOVLP  10
....................       putc('\r'); 
1381:  MOVLW  0D
1382:  MOVLP  00
1383:  CALL   2E4
1384:  MOVLP  10
1385:  MOVLB  02
....................     } 
....................     restart_wdt(); 
1386:  CLRWDT
....................   } 
1387:  INCF   2C,F
1388:  BTFSC  03.2
1389:  INCF   2D,F
138A:  GOTO   284
....................   for(y=0;y<3;y++) { 
138B:  CLRF   2E
138C:  MOVF   2E,W
138D:  SUBLW  02
138E:  BTFSS  03.0
138F:  GOTO   3A6
....................     if(AuxInSW[y]==1) { 
1390:  MOVLW  1F
1391:  ADDWF  2E,W
1392:  MOVWF  04
1393:  MOVLW  20
1394:  MOVWF  05
1395:  BTFSC  03.0
1396:  INCF   05,F
1397:  DECFSZ 00,W
1398:  GOTO   3A4
....................       aux_in += (1<<y); 
1399:  MOVLW  01
139A:  MOVWF  77
139B:  MOVF   2E,W
139C:  MOVWF  78
139D:  BTFSC  03.2
139E:  GOTO   3A2
139F:  LSLF   77,F
13A0:  DECFSZ 78,F
13A1:  GOTO   39F
13A2:  MOVF   77,W
13A3:  ADDWF  34,F
....................     } 
....................   } 
13A4:  INCF   2E,F
13A5:  GOTO   38C
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u",COR_IN,COR_EMUL,aux_in); 
13A6:  MOVLW  DD
13A7:  MOVLB  03
13A8:  MOVWF  11
13A9:  MOVLW  03
13AA:  MOVWF  12
13AB:  BCF    03.0
13AC:  MOVLW  07
13AD:  MOVLB  02
13AE:  MOVWF  50
13AF:  MOVLP  00
13B0:  MOVLB  00
13B1:  CALL   692
13B2:  MOVLP  10
13B3:  MOVF   60,W
13B4:  MOVLB  02
13B5:  MOVWF  50
13B6:  MOVLW  1B
13B7:  MOVWF  51
13B8:  MOVLP  00
13B9:  MOVLB  00
13BA:  CALL   706
13BB:  MOVLP  10
13BC:  MOVLW  E1
13BD:  MOVLB  03
13BE:  MOVWF  11
13BF:  MOVLW  03
13C0:  MOVWF  12
13C1:  BSF    03.0
13C2:  MOVLW  07
13C3:  MOVLB  02
13C4:  MOVWF  50
13C5:  MOVLP  00
13C6:  MOVLB  00
13C7:  CALL   692
13C8:  MOVLP  10
13C9:  MOVF   6F,W
13CA:  MOVLB  02
13CB:  MOVWF  50
13CC:  MOVLW  1B
13CD:  MOVWF  51
13CE:  MOVLP  00
13CF:  MOVLB  00
13D0:  CALL   706
13D1:  MOVLP  10
13D2:  MOVLW  E6
13D3:  MOVLB  03
13D4:  MOVWF  11
13D5:  MOVLW  03
13D6:  MOVWF  12
13D7:  BCF    03.0
13D8:  MOVLW  09
13D9:  MOVLB  02
13DA:  MOVWF  50
13DB:  MOVLP  00
13DC:  MOVLB  00
13DD:  CALL   692
13DE:  MOVLP  10
13DF:  MOVLB  02
13E0:  MOVF   34,W
13E1:  MOVWF  50
13E2:  MOVLW  1B
13E3:  MOVWF  51
13E4:  MOVLP  00
13E5:  MOVLB  00
13E6:  CALL   706
13E7:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
13E8:  MOVLW  EC
13E9:  MOVLB  03
13EA:  MOVWF  11
13EB:  MOVLW  03
13EC:  MOVWF  12
13ED:  BCF    03.0
13EE:  MOVLW  10
13EF:  MOVLB  02
13F0:  MOVWF  50
13F1:  MOVLP  00
13F2:  MOVLB  00
13F3:  CALL   692
13F4:  MOVLP  10
13F5:  MOVLB  02
13F6:  MOVF   33,W
13F7:  MOVWF  50
13F8:  MOVLW  1B
13F9:  MOVWF  51
13FA:  MOVLP  00
13FB:  MOVLB  00
13FC:  CALL   706
13FD:  MOVLP  10
13FE:  MOVLW  0A
13FF:  CLRWDT
1400:  BTFSS  11.4
1401:  GOTO   3FF
1402:  MOVLB  03
1403:  MOVWF  1A
1404:  MOVLW  0D
1405:  CLRWDT
1406:  MOVLB  00
1407:  BTFSC  11.4
1408:  GOTO   40B
1409:  MOVLB  03
140A:  GOTO   405
140B:  MOVLB  03
140C:  MOVWF  1A
....................   pot_values_to_lcd(); 
140D:  MOVLP  08
140E:  MOVLB  00
140F:  CALL   245
1410:  MOVLP  10
....................   PROMPT_FLAG=1; 
1411:  MOVLB  01
1412:  BSF    5F.5
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0A45:  MOVLW  20
0A46:  MOVLB  02
0A47:  MOVWF  42
0A48:  MOVWF  43
0A49:  MOVWF  44
0A4A:  MOVWF  45
....................   unsigned pval[4]={0,0,0,0}; 
0A4B:  CLRF   46
0A4C:  CLRF   47
0A4D:  CLRF   48
0A4E:  CLRF   49
....................   delay_ms(40); 
0A4F:  MOVLW  28
0A50:  MOVWF  4A
0A51:  MOVLP  00
0A52:  MOVLB  00
0A53:  CALL   7C0
0A54:  MOVLP  08
....................   i2c_start(); 
0A55:  MOVLB  04
0A56:  BSF    16.0
0A57:  BTFSC  16.0
0A58:  GOTO   257
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0A59:  MOVLW  51
0A5A:  MOVLB  02
0A5B:  MOVWF  50
0A5C:  MOVLP  00
0A5D:  MOVLB  00
0A5E:  CALL   67D
0A5F:  MOVLP  08
0A60:  MOVF   78,W
0A61:  MOVLB  02
0A62:  BCF    41.1
0A63:  BTFSC  78.0
0A64:  BSF    41.1
....................   for(x=0;x<4;x++) { 
0A65:  CLRF   3F
0A66:  MOVF   3F,W
0A67:  SUBLW  03
0A68:  BTFSS  03.0
0A69:  GOTO   2A5
....................     if(x==3) { 
0A6A:  MOVF   3F,W
0A6B:  SUBLW  03
0A6C:  BTFSS  03.2
0A6D:  GOTO   270
....................       ack=0; 
0A6E:  BCF    41.0
....................     } else { 
0A6F:  GOTO   271
....................       ack=1; 
0A70:  BSF    41.0
....................     } 
....................     pot_val=i2c_read(ack); 
0A71:  MOVLW  00
0A72:  BTFSC  41.0
0A73:  MOVLW  01
0A74:  MOVWF  4A
0A75:  MOVF   4A,W
0A76:  MOVWF  77
*
0A85:  MOVF   78,W
0A86:  MOVLB  02
0A87:  MOVWF  40
....................     pot_val=pot_val&0x3F; 
0A88:  MOVLW  3F
0A89:  ANDWF  40,F
....................     pval[x]=pot_val; 
0A8A:  MOVLW  C6
0A8B:  ADDWF  3F,W
0A8C:  MOVWF  04
0A8D:  MOVLW  20
0A8E:  MOVWF  05
0A8F:  BTFSC  03.0
0A90:  INCF   05,F
0A91:  MOVF   40,W
0A92:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0A93:  MOVLB  01
0A94:  MOVF   30,W
0A95:  ANDLW  03
0A96:  MOVLB  02
0A97:  SUBWF  3F,W
0A98:  BTFSS  03.2
0A99:  GOTO   2A3
....................       c[x] = '*'; 
0A9A:  MOVLW  C2
0A9B:  ADDWF  3F,W
0A9C:  MOVWF  04
0A9D:  MOVLW  20
0A9E:  MOVWF  05
0A9F:  BTFSC  03.0
0AA0:  INCF   05,F
0AA1:  MOVLW  2A
0AA2:  MOVWF  00
....................     } 
....................   } 
0AA3:  INCF   3F,F
0AA4:  GOTO   266
....................   i2c_stop(); 
0AA5:  MOVLB  04
0AA6:  BSF    16.2
0AA7:  BTFSC  16.2
0AA8:  GOTO   2A7
....................   delay_ms(50); 
0AA9:  MOVLW  32
0AAA:  MOVLB  02
0AAB:  MOVWF  4A
0AAC:  MOVLP  00
0AAD:  MOVLB  00
0AAE:  CALL   7C0
0AAF:  MOVLP  08
....................   if ( ack_in!=0 ) { 
0AB0:  MOVLB  02
0AB1:  BTFSS  41.1
0AB2:  GOTO   2CE
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0AB3:  MOVLW  00
0AB4:  BTFSC  41.0
0AB5:  MOVLW  01
0AB6:  MOVWF  4A
0AB7:  MOVLW  F7
0AB8:  MOVLB  03
0AB9:  MOVWF  11
0ABA:  MOVLW  03
0ABB:  MOVWF  12
0ABC:  BCF    03.0
0ABD:  MOVLW  25
0ABE:  MOVLB  02
0ABF:  MOVWF  50
0AC0:  MOVLP  00
0AC1:  MOVLB  00
0AC2:  CALL   692
0AC3:  MOVLP  08
0AC4:  MOVLB  02
0AC5:  MOVF   4A,W
0AC6:  MOVWF  50
0AC7:  MOVLW  1B
0AC8:  MOVWF  51
0AC9:  MOVLP  00
0ACA:  MOVLB  00
0ACB:  CALL   706
0ACC:  MOVLP  08
0ACD:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0ACE:  MOVLW  20
0ACF:  MOVLB  01
0AD0:  MOVWF  64
0AD1:  MOVLW  7A
0AD2:  MOVWF  63
0AD3:  MOVLW  0B
0AD4:  MOVLB  03
0AD5:  MOVWF  11
0AD6:  MOVLW  04
0AD7:  MOVWF  12
0AD8:  BCF    03.0
0AD9:  MOVLW  04
0ADA:  MOVLB  02
0ADB:  MOVWF  4A
0ADC:  MOVLB  00
0ADD:  CALL   0EB
0ADE:  MOVLB  02
0ADF:  MOVF   42,W
0AE0:  MOVWF  50
0AE1:  MOVLP  00
0AE2:  MOVLB  00
0AE3:  CALL   7EC
0AE4:  MOVLP  08
0AE5:  MOVLB  02
0AE6:  MOVF   46,W
0AE7:  MOVWF  4A
0AE8:  MOVLW  18
0AE9:  MOVWF  4B
0AEA:  MOVLB  00
0AEB:  CALL   1BC
0AEC:  MOVLW  20
0AED:  MOVLB  02
0AEE:  MOVWF  50
0AEF:  MOVLP  00
0AF0:  MOVLB  00
0AF1:  CALL   7EC
0AF2:  MOVLP  08
0AF3:  MOVLB  02
0AF4:  MOVF   43,W
0AF5:  MOVWF  50
0AF6:  MOVLP  00
0AF7:  MOVLB  00
0AF8:  CALL   7EC
0AF9:  MOVLP  08
0AFA:  MOVLB  02
0AFB:  MOVF   47,W
0AFC:  MOVWF  4A
0AFD:  MOVLW  18
0AFE:  MOVWF  4B
0AFF:  MOVLB  00
0B00:  CALL   1BC
0B01:  MOVLW  20
0B02:  MOVLB  02
0B03:  MOVWF  50
0B04:  MOVLP  00
0B05:  MOVLB  00
0B06:  CALL   7EC
0B07:  MOVLP  08
0B08:  MOVLB  02
0B09:  MOVF   44,W
0B0A:  MOVWF  50
0B0B:  MOVLP  00
0B0C:  MOVLB  00
0B0D:  CALL   7EC
0B0E:  MOVLP  08
0B0F:  MOVLB  02
0B10:  MOVF   48,W
0B11:  MOVWF  4A
0B12:  MOVLW  18
0B13:  MOVWF  4B
0B14:  MOVLB  00
0B15:  CALL   1BC
0B16:  MOVLW  20
0B17:  MOVLB  02
0B18:  MOVWF  50
0B19:  MOVLP  00
0B1A:  MOVLB  00
0B1B:  CALL   7EC
0B1C:  MOVLP  08
0B1D:  MOVLB  02
0B1E:  MOVF   45,W
0B1F:  MOVWF  50
0B20:  MOVLP  00
0B21:  MOVLB  00
0B22:  CALL   7EC
0B23:  MOVLP  08
0B24:  MOVLB  02
0B25:  MOVF   49,W
0B26:  MOVWF  4A
0B27:  MOVLW  18
0B28:  MOVWF  4B
0B29:  MOVLB  00
0B2A:  CALL   1BC
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0B2B:  MOVLB  02
0B2C:  CLRF   4A
0B2D:  MOVLW  20
0B2E:  MOVWF  4C
0B2F:  MOVLW  7A
0B30:  MOVWF  4B
0B31:  MOVLB  00
0B32:  CALL   159
....................   printf("\n\r%s",LCD_str); 
0B33:  MOVLW  0A
0B34:  CLRWDT
0B35:  BTFSS  11.4
0B36:  GOTO   334
0B37:  MOVLB  03
0B38:  MOVWF  1A
0B39:  MOVLW  0D
0B3A:  CLRWDT
0B3B:  MOVLB  00
0B3C:  BTFSC  11.4
0B3D:  GOTO   340
0B3E:  MOVLB  03
0B3F:  GOTO   33A
0B40:  MOVLB  03
0B41:  MOVWF  1A
0B42:  MOVLW  20
0B43:  MOVWF  05
0B44:  MOVLW  7A
0B45:  MOVWF  04
0B46:  MOVLB  00
0B47:  CALL   22B
....................  
.................... } // }}} 
0B48:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
0F9C:  MOVLB  01
0F9D:  BTFSS  5F.6
0F9E:  GOTO   7AA
....................     printf("\n\n\rADMIN> "); 
0F9F:  MOVLW  17
0FA0:  MOVLB  03
0FA1:  MOVWF  11
0FA2:  MOVLW  04
0FA3:  MOVWF  12
0FA4:  MOVLP  00
0FA5:  MOVLB  00
0FA6:  CALL   4A1
0FA7:  MOVLP  08
....................   } else { 
0FA8:  GOTO   7B3
0FA9:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
0FAA:  MOVLW  1D
0FAB:  MOVLB  03
0FAC:  MOVWF  11
0FAD:  MOVLW  04
0FAE:  MOVWF  12
0FAF:  MOVLP  00
0FB0:  MOVLB  00
0FB1:  CALL   4A1
0FB2:  MOVLP  08
....................   } 
.................... } // }}} 
0FB3:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
0487:  MOVLW  10
0488:  MOVLB  01
0489:  MOVWF  66
....................   for (x=0;x<char_num;x++) { 
048A:  CLRF   65
048B:  MOVF   66,W
048C:  SUBWF  65,W
048D:  BTFSC  03.0
048E:  GOTO   499
....................     sBuffer[x]='\0'; 
048F:  MOVLW  50
0490:  ADDWF  65,W
0491:  MOVWF  04
0492:  MOVLW  20
0493:  MOVWF  05
0494:  BTFSC  03.0
0495:  INCF   05,F
0496:  CLRF   00
....................   } 
0497:  INCF   65,F
0498:  GOTO   48B
....................   sBufferIndex=0; 
0499:  CLRF   7C
....................   sBufferFlag=0;   
049A:  BCF    7D.0
....................   argument=-1; 
049B:  MOVLW  FF
049C:  MOVWF  42
....................   argument_name[0]='\0'; 
049D:  CLRF   44
....................   command=0; 
049E:  CLRF   70
.................... } // }}} 
049F:  MOVLB  00
04A0:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
0624:  MOVLW  00
0625:  MOVLB  01
0626:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
0627:  MOVLB  02
0628:  BCF    45.0
0629:  MOVF   43,W
062A:  ANDLW  0F
062B:  ANDLW  01
062C:  BTFSS  03.2
062D:  BSF    45.0
....................   output_bit(DTMF_D0,dbit); 
062E:  BTFSC  45.0
062F:  GOTO   632
0630:  BCF    0F.0
0631:  GOTO   633
0632:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
0633:  BCF    45.0
0634:  MOVF   43,W
0635:  ANDLW  0F
0636:  ANDLW  02
0637:  BTFSS  03.2
0638:  BSF    45.0
....................   output_bit(DTMF_D1,dbit); 
0639:  BTFSC  45.0
063A:  GOTO   63D
063B:  BCF    0F.1
063C:  GOTO   63E
063D:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
063E:  BCF    45.0
063F:  MOVF   43,W
0640:  ANDLW  0F
0641:  ANDLW  04
0642:  BTFSS  03.2
0643:  BSF    45.0
....................   output_bit(DTMF_D2,dbit); 
0644:  BTFSC  45.0
0645:  GOTO   648
0646:  BCF    0F.2
0647:  GOTO   649
0648:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
0649:  BCF    45.0
064A:  MOVF   43,W
064B:  ANDLW  0F
064C:  ANDLW  08
064D:  BTFSS  03.2
064E:  BSF    45.0
....................   output_bit(DTMF_D3,dbit); 
064F:  BTFSC  45.0
0650:  GOTO   653
0651:  BCF    0F.3
0652:  GOTO   654
0653:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
0654:  MOVF   44,F
0655:  BTFSS  03.2
0656:  GOTO   659
0657:  BCF    0F.6
0658:  GOTO   65A
0659:  BSF    0F.6
....................   delay_cycles(2); 
065A:  GOTO   65B
....................   output_bit(DTMF_WEB,0); 
065B:  BCF    0F.5
....................   delay_cycles(2); 
065C:  GOTO   65D
....................   output_bit(DTMF_WEB,1);   
065D:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
065E:  GOTO   65F
....................   set_tris_d(0x0F); 
065F:  MOVLW  0F
0660:  MOVLB  01
0661:  MOVWF  0F
.................... } // }}} 
0662:  MOVLB  00
0663:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
0664:  MOVLW  0F
0665:  MOVLB  01
0666:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
0667:  MOVLB  02
0668:  MOVF   3B,F
0669:  BTFSS  03.2
066A:  GOTO   66D
066B:  BCF    0F.6
066C:  GOTO   66E
066D:  BSF    0F.6
....................   delay_cycles(1); 
066E:  NOP
....................   output_bit(DTMF_REB,0); 
066F:  BCF    0F.4
....................   delay_cycles(1); 
0670:  NOP
....................   value=input_d(); 
0671:  MOVLB  00
0672:  MOVF   0F,W
0673:  MOVLB  02
0674:  MOVWF  3C
....................   value&=0x0F; 
0675:  MOVLW  0F
0676:  ANDWF  3C,F
....................   output_bit(DTMF_REB,1); 
0677:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
0678:  NOP
....................   return(value); 
0679:  MOVF   3C,W
067A:  MOVWF  78
.................... } // }}} 
067B:  MOVLB  00
067C:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0CD8:  MOVLB  02
0CD9:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0CDA:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0CDB:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0CDC:  CLRF   43
0CDD:  MOVLW  01
0CDE:  MOVWF  44
0CDF:  MOVLP  00
0CE0:  MOVLB  00
0CE1:  CALL   624
0CE2:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0CE3:  MOVLB  02
0CE4:  CLRF   43
0CE5:  MOVLW  01
0CE6:  MOVWF  44
0CE7:  MOVLP  00
0CE8:  MOVLB  00
0CE9:  CALL   624
0CEA:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0CEB:  MOVLW  0C
0CEC:  MOVLB  02
0CED:  MOVWF  43
0CEE:  MOVLW  01
0CEF:  MOVWF  44
0CF0:  MOVLP  00
0CF1:  MOVLB  00
0CF2:  CALL   624
0CF3:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0CF4:  MOVLW  01
0CF5:  MOVLB  02
0CF6:  MOVWF  43
0CF7:  MOVWF  44
0CF8:  MOVLP  00
0CF9:  MOVLB  00
0CFA:  CALL   624
0CFB:  MOVLP  08
....................     dtmf_read(CONTROL_REG); 
0CFC:  MOVLW  01
0CFD:  MOVLB  02
0CFE:  MOVWF  3B
0CFF:  MOVLP  00
0D00:  MOVLB  00
0D01:  CALL   664
0D02:  MOVLP  08
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19F3:  MOVF   40,W
19F4:  MOVWF  43
19F5:  CLRF   44
19F6:  MOVLP  00
19F7:  MOVLB  00
19F8:  CALL   624
19F9:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19FA:  MOVLW  0C
19FB:  MOVLB  02
19FC:  MOVWF  43
19FD:  MOVLW  01
19FE:  MOVWF  44
19FF:  MOVLP  00
1A00:  MOVLB  00
1A01:  CALL   624
1A02:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
1A03:  MOVLW  01
1A04:  MOVLB  02
1A05:  MOVWF  43
1A06:  MOVWF  44
1A07:  MOVLP  00
1A08:  MOVLB  00
1A09:  CALL   624
1A0A:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A0B:  MOVLW  05
1A0C:  MOVLB  02
1A0D:  MOVWF  43
1A0E:  MOVLW  01
1A0F:  MOVWF  44
1A10:  MOVLP  00
1A11:  MOVLB  00
1A12:  CALL   624
1A13:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A14:  MOVLB  01
1A15:  CLRF   34
1A16:  MOVLW  10
1A17:  MOVWF  33
....................   while(aux_timer) { 
1A18:  MOVF   33,W
1A19:  IORWF  34,W
1A1A:  BTFSC  03.2
1A1B:  GOTO   21E
....................     delay_cycles(1); 
1A1C:  NOP
....................   } 
1A1D:  GOTO   218
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A1E:  MOVLW  04
1A1F:  MOVLB  02
1A20:  MOVWF  43
1A21:  MOVLW  01
1A22:  MOVWF  44
1A23:  MOVLP  00
1A24:  MOVLB  00
1A25:  CALL   624
1A26:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
0800:  MOVLW  01
0801:  MOVLB  02
0802:  MOVWF  43
0803:  CLRF   44
0804:  MOVLP  00
0805:  MOVLB  00
0806:  CALL   624
0807:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0808:  MOVLW  0C
0809:  MOVLB  02
080A:  MOVWF  43
080B:  MOVLW  01
080C:  MOVWF  44
080D:  MOVLP  00
080E:  MOVLB  00
080F:  CALL   624
0810:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0811:  MOVLW  05
0812:  MOVLB  02
0813:  MOVWF  43
0814:  MOVLW  01
0815:  MOVWF  44
0816:  MOVLP  00
0817:  MOVLB  00
0818:  CALL   624
0819:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
081A:  MOVLW  05
081B:  MOVLB  02
081C:  MOVWF  43
081D:  MOVLW  01
081E:  MOVWF  44
081F:  MOVLP  00
0820:  MOVLB  00
0821:  CALL   624
0822:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
0823:  MOVLB  01
0824:  CLRF   34
0825:  MOVLW  02
0826:  MOVWF  33
....................   while(aux_timer) { 
0827:  MOVF   33,W
0828:  IORWF  34,W
0829:  BTFSC  03.2
082A:  GOTO   02D
....................     delay_cycles(1); 
082B:  NOP
....................   } 
082C:  GOTO   027
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
082D:  MOVLW  04
082E:  MOVLB  02
082F:  MOVWF  43
0830:  MOVLW  01
0831:  MOVWF  44
0832:  MOVLP  00
0833:  MOVLB  00
0834:  CALL   624
0835:  MOVLP  08
....................   restart_wdt(); 
0836:  CLRWDT
.................... } // }}} 
0837:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
0838:  MOVLW  01
0839:  MOVLB  02
083A:  MOVWF  43
083B:  CLRF   44
083C:  MOVLP  00
083D:  MOVLB  00
083E:  CALL   624
083F:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0840:  MOVLW  0C
0841:  MOVLB  02
0842:  MOVWF  43
0843:  MOVLW  01
0844:  MOVWF  44
0845:  MOVLP  00
0846:  MOVLB  00
0847:  CALL   624
0848:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0849:  MOVLW  05
084A:  MOVLB  02
084B:  MOVWF  43
084C:  MOVLW  01
084D:  MOVWF  44
084E:  MOVLP  00
084F:  MOVLB  00
0850:  CALL   624
0851:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0852:  MOVLW  05
0853:  MOVLB  02
0854:  MOVWF  43
0855:  MOVLW  01
0856:  MOVWF  44
0857:  MOVLP  00
0858:  MOVLB  00
0859:  CALL   624
085A:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
085B:  MOVLB  01
085C:  CLRF   34
085D:  MOVLW  06
085E:  MOVWF  33
....................   while(aux_timer) { 
085F:  MOVF   33,W
0860:  IORWF  34,W
0861:  BTFSC  03.2
0862:  GOTO   065
....................     delay_cycles(1); 
0863:  NOP
....................   } 
0864:  GOTO   05F
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0865:  MOVLW  04
0866:  MOVLB  02
0867:  MOVWF  43
0868:  MOVLW  01
0869:  MOVWF  44
086A:  MOVLP  00
086B:  MOVLB  00
086C:  CALL   624
086D:  MOVLP  08
....................   restart_wdt(); 
086E:  CLRWDT
.................... } // }}} 
086F:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
04F6:  MOVLB  02
04F7:  MOVF   38,W
04F8:  MOVWF  04
04F9:  MOVF   39,W
04FA:  MOVWF  05
04FB:  MOVF   00,W
04FC:  MOVWF  3B
....................   if ( tmp > 127 ) { 
04FD:  MOVF   3B,W
04FE:  SUBLW  7F
04FF:  BTFSS  03.0
....................     tmp++; 
0500:  INCF   3B,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
0501:  BCF    03.0
0502:  RLF    3B,W
0503:  XORLW  09
0504:  ADDWF  3A,W
0505:  MOVWF  3B
....................   *cksum=tmp; 
0506:  MOVF   38,W
0507:  MOVWF  04
0508:  MOVF   39,W
0509:  MOVWF  05
050A:  MOVF   3B,W
050B:  MOVWF  00
.................... } // }}} 
050C:  MOVLB  00
050D:  RETURN
.................... void print_dtmf_info(void) { // {{{ 
....................   unsigned int x; 
....................   char dtmf; 
....................   char tmp[5]; 
....................   strcpy(LCD_str,"DTMF:"); 
*
1743:  MOVLB  01
1744:  CLRF   6C
1745:  CLRF   6D
1746:  MOVLW  20
1747:  MOVWF  05
1748:  MOVLW  7A
1749:  MOVWF  04
174A:  MOVF   6C,W
174B:  ADDWF  04,F
174C:  MOVLW  00
174D:  ADDWFC 05,F
174E:  MOVF   6D,W
174F:  MOVLP  00
1750:  MOVLB  00
1751:  CALL   139
1752:  MOVLP  10
1753:  MOVWF  00
1754:  IORLW  00
1755:  BTFSC  03.2
1756:  GOTO   75C
1757:  MOVLB  01
1758:  INCF   6D,F
1759:  INCF   6C,F
175A:  GOTO   746
175B:  MOVLB  00
....................   printf("\n\rDTMF="); 
175C:  MOVLW  24
175D:  MOVLB  03
175E:  MOVWF  11
175F:  MOVLW  04
1760:  MOVWF  12
1761:  MOVLP  00
1762:  MOVLB  00
1763:  CALL   4A1
1764:  MOVLP  10
....................   for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1765:  MOVLB  01
1766:  CLRF   65
1767:  MOVF   65,W
1768:  SUBLW  09
1769:  BTFSS  03.0
176A:  GOTO   7A4
....................     if(DTMF_ARRAY[x].Strobe) { 
176B:  MOVLW  66
176C:  ADDWF  65,W
176D:  MOVWF  04
176E:  MOVLW  20
176F:  MOVWF  05
1770:  BTFSC  03.0
1771:  INCF   05,F
1772:  BTFSS  00.4
1773:  GOTO   7A1
....................       dtmf=(int)DTMF_ARRAY[x].Key; 
1774:  MOVLW  66
1775:  ADDWF  65,W
1776:  MOVWF  04
1777:  MOVLW  20
1778:  MOVWF  05
1779:  BTFSC  03.0
177A:  INCF   05,F
177B:  MOVF   00,W
177C:  ANDLW  0F
177D:  MOVWF  66
....................       sprintf(tmp,"%d",dtmf); 
177E:  MOVLW  20
177F:  MOVWF  64
1780:  MOVLW  97
1781:  MOVWF  63
1782:  MOVF   66,W
1783:  MOVLB  02
1784:  MOVWF  4A
1785:  MOVLW  18
1786:  MOVWF  4B
1787:  MOVLP  08
1788:  MOVLB  00
1789:  CALL   1BC
178A:  MOVLP  10
....................       strcat(LCD_str,tmp); 
178B:  MOVLW  20
178C:  MOVLB  02
178D:  MOVWF  29
178E:  MOVLW  7A
178F:  MOVWF  28
1790:  MOVLW  20
1791:  MOVWF  2B
1792:  MOVLW  97
1793:  MOVWF  2A
1794:  MOVLB  00
1795:  CALL   6B8
....................       printf("%u",dtmf); 
1796:  MOVLB  01
1797:  MOVF   66,W
1798:  MOVLB  02
1799:  MOVWF  50
179A:  MOVLW  1B
179B:  MOVWF  51
179C:  MOVLP  00
179D:  MOVLB  00
179E:  CALL   706
179F:  MOVLP  10
17A0:  MOVLB  01
....................     } 
....................   restart_wdt(); 
17A1:  CLRWDT
....................   } 
17A2:  INCF   65,F
17A3:  GOTO   767
....................   printf("\n\r"); 
17A4:  MOVLW  0A
17A5:  CLRWDT
17A6:  MOVLB  00
17A7:  BTFSC  11.4
17A8:  GOTO   7AB
17A9:  MOVLB  01
17AA:  GOTO   7A5
17AB:  MOVLB  03
17AC:  MOVWF  1A
17AD:  MOVLW  0D
17AE:  CLRWDT
17AF:  MOVLB  00
17B0:  BTFSC  11.4
17B1:  GOTO   7B4
17B2:  MOVLB  03
17B3:  GOTO   7AE
17B4:  MOVLB  03
17B5:  MOVWF  1A
....................   PROMPT_FLAG=1; 
17B6:  MOVLB  01
17B7:  BSF    5F.5
....................   lcd_send(2,LCD_str); // Send DTMF on line 3 
17B8:  MOVLW  02
17B9:  MOVLB  02
17BA:  MOVWF  4A
17BB:  MOVLW  20
17BC:  MOVWF  4C
17BD:  MOVLW  7A
17BE:  MOVWF  4B
17BF:  MOVLP  08
17C0:  MOVLB  00
17C1:  CALL   159
17C2:  MOVLP  10
.................... } // }}} 
17C3:  MOVLP  18
17C4:  GOTO   74E (RETURN)
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
*
050E:  MOVLW  01
050F:  MOVLB  02
0510:  MOVWF  32
....................   eeprom_index=0; 
0511:  CLRF   33
....................   retVal = 1; 
0512:  MOVWF  35
....................   if ( source == USE_EEPROM_VARS ) { 
0513:  DECFSZ 2E,W
0514:  GOTO   51E
....................     printf("\n\rInit RAM <= EEPROM"); 
0515:  MOVLW  28
0516:  MOVLB  03
0517:  MOVWF  11
0518:  MOVLW  04
0519:  MOVWF  12
051A:  MOVLB  00
051B:  CALL   4A1
....................   } else { 
051C:  GOTO   525
051D:  MOVLB  02
....................     printf("\n\rInit RAM <= HW Defaults"); 
051E:  MOVLW  33
051F:  MOVLB  03
0520:  MOVWF  11
0521:  MOVLW  04
0522:  MOVWF  12
0523:  MOVLB  00
0524:  CALL   4A1
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
0525:  MOVLB  02
0526:  CLRF   2F
0527:  MOVF   2F,W
0528:  SUBLW  38
0529:  BTFSS  03.0
052A:  GOTO   584
....................     regPtr=RegMap[x].reg_ptr; 
052B:  RLF    2F,W
052C:  MOVWF  77
052D:  RLF    77,F
052E:  MOVLW  FC
052F:  ANDWF  77,F
0530:  MOVF   77,W
0531:  MOVWF  37
0532:  INCF   37,W
0533:  MOVLB  00
0534:  CALL   043
0535:  MOVWF  7A
0536:  MOVLB  02
0537:  MOVF   37,W
0538:  MOVLB  00
0539:  CALL   043
053A:  MOVLB  02
053B:  MOVWF  30
053C:  MOVF   7A,W
053D:  MOVWF  31
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
053E:  DECFSZ 2E,W
053F:  GOTO   570
0540:  RLF    2F,W
0541:  MOVWF  77
0542:  RLF    77,F
0543:  MOVLW  FC
0544:  ANDWF  77,F
0545:  MOVF   77,W
0546:  ADDLW  03
0547:  MOVLB  00
0548:  CALL   043
0549:  MOVWF  78
054A:  BTFSC  78.0
054B:  GOTO   54E
054C:  MOVLB  02
054D:  GOTO   570
....................       eeprom_val=read_eeprom(eeprom_index); 
054E:  MOVLB  02
054F:  MOVF   33,W
0550:  MOVLB  03
0551:  MOVWF  11
0552:  BCF    15.7
0553:  BSF    15.0
0554:  MOVF   13,W
0555:  MOVLB  02
0556:  MOVWF  36
....................       *regPtr=eeprom_val; 
0557:  MOVF   30,W
0558:  MOVWF  04
0559:  MOVF   31,W
055A:  MOVWF  05
055B:  MOVF   36,W
055C:  MOVWF  00
....................       update_checksum(&cksum,*regPtr);     
055D:  MOVF   31,W
055E:  MOVWF  7A
055F:  MOVF   30,W
0560:  MOVWF  04
0561:  MOVF   31,W
0562:  MOVWF  05
0563:  MOVF   00,W
0564:  MOVWF  37
0565:  MOVLW  20
0566:  MOVWF  39
0567:  MOVLW  B2
0568:  MOVWF  38
0569:  MOVF   37,W
056A:  MOVWF  3A
056B:  MOVLB  00
056C:  CALL   4F6
....................       eeprom_index++; 
056D:  MOVLB  02
056E:  INCF   33,F
....................     } else { 
056F:  GOTO   582
....................       default_value=(int8)RegMap[x].default_value; 
0570:  RLF    2F,W
0571:  MOVWF  77
0572:  RLF    77,F
0573:  MOVLW  FC
0574:  ANDWF  77,F
0575:  MOVF   77,W
0576:  ADDLW  02
0577:  MOVLB  00
0578:  CALL   043
0579:  MOVWF  78
057A:  MOVLB  02
057B:  MOVWF  34
....................       *regPtr=default_value; 
057C:  MOVF   30,W
057D:  MOVWF  04
057E:  MOVF   31,W
057F:  MOVWF  05
0580:  MOVF   34,W
0581:  MOVWF  00
....................     } 
....................   } 
0582:  INCF   2F,F
0583:  GOTO   527
....................   if ( source == USE_EEPROM_VARS ) { 
0584:  DECFSZ 2E,W
0585:  GOTO   590
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
0586:  MOVF   33,W
0587:  MOVLB  03
0588:  MOVWF  11
0589:  BCF    15.7
058A:  BSF    15.0
058B:  MOVF   13,W
058C:  MOVLB  02
058D:  SUBWF  32,W
058E:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
058F:  CLRF   35
....................     } 
....................   } 
....................   return (retVal); 
0590:  MOVF   35,W
0591:  MOVWF  78
.................... } // }}} 
0592:  MOVLB  00
0593:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
0594:  MOVLW  01
0595:  MOVLB  02
0596:  MOVWF  32
....................  
....................   eeprom_index=0; 
0597:  CLRF   2F
....................   for(x=0;x<RegMapNum;x++) { 
0598:  CLRF   2E
0599:  MOVF   2E,W
059A:  SUBLW  38
059B:  BTFSS  03.0
059C:  GOTO   5F2
....................     regPtr=RegMap[x].reg_ptr; 
059D:  RLF    2E,W
059E:  MOVWF  77
059F:  RLF    77,F
05A0:  MOVLW  FC
05A1:  ANDWF  77,F
05A2:  MOVF   77,W
05A3:  MOVWF  34
05A4:  INCF   34,W
05A5:  MOVLB  00
05A6:  CALL   043
05A7:  MOVWF  7A
05A8:  MOVLB  02
05A9:  MOVF   34,W
05AA:  MOVLB  00
05AB:  CALL   043
05AC:  MOVLB  02
05AD:  MOVWF  30
05AE:  MOVF   7A,W
05AF:  MOVWF  31
....................     if ( RegMap[x].non_volatile ) { 
05B0:  RLF    2E,W
05B1:  MOVWF  77
05B2:  RLF    77,F
05B3:  MOVLW  FC
05B4:  ANDWF  77,F
05B5:  MOVF   77,W
05B6:  ADDLW  03
05B7:  MOVLB  00
05B8:  CALL   043
05B9:  MOVWF  78
05BA:  BTFSS  78.0
05BB:  GOTO   5EF
....................      value=*regPtr; 
05BC:  MOVLB  02
05BD:  MOVF   30,W
05BE:  MOVWF  04
05BF:  MOVF   31,W
05C0:  MOVWF  05
05C1:  MOVF   00,W
05C2:  MOVWF  33
....................      if ( read_eeprom(eeprom_index) != value ) { 
05C3:  MOVF   2F,W
05C4:  MOVLB  03
05C5:  MOVWF  11
05C6:  BCF    15.7
05C7:  BSF    15.0
05C8:  MOVF   13,W
05C9:  MOVLB  02
05CA:  SUBWF  33,W
05CB:  BTFSC  03.2
05CC:  GOTO   5E4
....................        write_eeprom(eeprom_index,value); 
05CD:  MOVF   0B,W
05CE:  MOVWF  77
05CF:  BCF    0B.7
05D0:  MOVF   2F,W
05D1:  MOVLB  03
05D2:  MOVWF  11
05D3:  MOVLB  02
05D4:  MOVF   33,W
05D5:  MOVLB  03
05D6:  MOVWF  13
05D7:  BCF    15.7
05D8:  BSF    15.2
05D9:  MOVLW  55
05DA:  MOVWF  16
05DB:  MOVLW  AA
05DC:  MOVWF  16
05DD:  BSF    15.1
05DE:  BTFSC  15.1
05DF:  GOTO   5DE
05E0:  BCF    15.2
05E1:  MOVF   77,W
05E2:  IORWF  0B,F
05E3:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
05E4:  MOVLW  20
05E5:  MOVWF  39
05E6:  MOVLW  B2
05E7:  MOVWF  38
05E8:  MOVF   33,W
05E9:  MOVWF  3A
05EA:  MOVLB  00
05EB:  CALL   4F6
....................      eeprom_index++; 
05EC:  MOVLB  02
05ED:  INCF   2F,F
05EE:  MOVLB  00
....................     } 
....................   } 
05EF:  MOVLB  02
05F0:  INCF   2E,F
05F1:  GOTO   599
....................   write_eeprom(eeprom_index,cksum); 
05F2:  MOVF   0B,W
05F3:  MOVWF  77
05F4:  BCF    0B.7
05F5:  MOVF   2F,W
05F6:  MOVLB  03
05F7:  MOVWF  11
05F8:  MOVLB  02
05F9:  MOVF   32,W
05FA:  MOVLB  03
05FB:  MOVWF  13
05FC:  BCF    15.7
05FD:  BSF    15.2
05FE:  MOVLW  55
05FF:  MOVWF  16
0600:  MOVLW  AA
0601:  MOVWF  16
0602:  BSF    15.1
0603:  BTFSC  15.1
0604:  GOTO   603
0605:  BCF    15.2
0606:  MOVF   77,W
0607:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
0608:  MOVLW  40
0609:  MOVWF  11
060A:  MOVLW  04
060B:  MOVWF  12
060C:  MOVLB  00
060D:  CALL   4A1
.................... } // }}} 
060E:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
060F:  MOVLB  02
0610:  MOVF   2D,W
0611:  MOVWF  2E
0612:  MOVLB  00
0613:  CALL   50E
0614:  MOVF   78,F
0615:  BTFSS  03.2
0616:  GOTO   623
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
0617:  MOVLW  53
0618:  MOVLB  03
0619:  MOVWF  11
061A:  MOVLW  04
061B:  MOVWF  12
061C:  MOVLB  00
061D:  CALL   4A1
....................         _init_variables(USE_DEFAULT_VARS); 
061E:  MOVLB  02
061F:  CLRF   2E
0620:  MOVLB  00
0621:  CALL   50E
....................     store_variables(); 
0622:  CALL   594
....................     } 
.................... } // }}} 
0623:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0D13:  MOVLB  02
0D14:  CLRF   3F
0D15:  CLRF   40
0D16:  MOVLP  00
0D17:  MOVLB  00
0D18:  CALL   755
0D19:  MOVLP  08
....................   set_trimpot(1,0); 
0D1A:  MOVLW  01
0D1B:  MOVLB  02
0D1C:  MOVWF  3F
0D1D:  CLRF   40
0D1E:  MOVLP  00
0D1F:  MOVLB  00
0D20:  CALL   755
0D21:  MOVLP  08
....................   set_trimpot(2,0); 
0D22:  MOVLW  02
0D23:  MOVLB  02
0D24:  MOVWF  3F
0D25:  CLRF   40
0D26:  MOVLP  00
0D27:  MOVLB  00
0D28:  CALL   755
0D29:  MOVLP  08
....................   set_trimpot(3,0); 
0D2A:  MOVLW  03
0D2B:  MOVLB  02
0D2C:  MOVWF  3F
0D2D:  CLRF   40
0D2E:  MOVLP  00
0D2F:  MOVLB  00
0D30:  CALL   755
0D31:  MOVLP  08
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0C9C:  MOVLP  00
0C9D:  CALL   487
0C9E:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0C9F:  MOVLB  02
0CA0:  CLRF   12
0CA1:  CLRF   11
0CA2:  CLRF   14
0CA3:  CLRF   13
....................   setup_wdt(WDT_2S); 
0CA4:  MOVLW  17
0CA5:  MOVLB  01
0CA6:  MOVWF  17
....................   PROCESS_COR_FLAG=0; 
0CA7:  BCF    7D.1
....................   COR_IN_FLAG=0; 
0CA8:  BCF    7D.2
....................   COR_IN=0; 
0CA9:  MOVLB  00
0CAA:  CLRF   60
....................   COR_EMUL=0; 
0CAB:  CLRF   6F
....................   COR_AUX=0; 
0CAC:  CLRF   71
....................   COR_DROP_FLAG=0; 
0CAD:  BCF    7D.6
....................   DTMF_IN_FLAG=0; 
0CAE:  MOVLB  01
0CAF:  BCF    5F.2
....................   DTMF_INTERRUPT_FLAG=0; 
0CB0:  BCF    5F.3
....................   TOT_FLAG_Mask=0; 
0CB1:  MOVLB  00
0CB2:  CLRF   6A
....................   AuxOutDelayCnt=0; 
0CB3:  MOVLB  01
0CB4:  CLRF   35
....................   CurrentCorMask=0; 
0CB5:  CLRF   74
....................   CurrentCorPriority=0; 
0CB6:  CLRF   76
....................   CurrentCorIndex=0; 
0CB7:  CLRF   75
....................   CurrentTrimPot=0; 
0CB8:  CLRF   30
....................   setup_adc(NO_ANALOGS); 
0CB9:  BCF    1D.0
....................   set_tris_b(0xFF); 
0CBA:  MOVLW  FF
0CBB:  TRIS   6
....................   set_tris_d(0x00); 
0CBC:  MOVLW  00
0CBD:  MOVWF  0F
....................   set_tris_e(0xF8); 
0CBE:  BCF    10.0
0CBF:  BCF    10.1
0CC0:  BCF    10.2
0CC1:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0CC2:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0CC3:  BSF    0B.3
0CC4:  MOVLW  CF
0CC5:  MOVLB  07
0CC6:  IORWF  14,F
0CC7:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0CC8:  BSF    0B.3
0CC9:  BSF    15.4
0CCA:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0CCB:  MOVLW  C0
0CCC:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0CCD:  MOVLB  02
0CCE:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0CCF:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0CD0:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0CD1:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0CD2:  MOVLW  01
0CD3:  MOVWF  2D
0CD4:  MOVLP  00
0CD5:  MOVLB  00
0CD6:  CALL   60F
0CD7:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D03:  MOVLB  01
0D04:  BSF    5F.4
....................   Enable_Mask = 0x0F; 
0D05:  MOVLW  0F
0D06:  MOVLB  00
0D07:  MOVWF  63
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D08:  MOVF   64,W
0D09:  ANDLW  0F
0D0A:  IORLW  C0
0D0B:  MOVLB  04
0D0C:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D0D:  MOVLB  01
0D0E:  BCF    15.7
....................   // }}} 
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D0F:  MOVLW  9D
0D10:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0D11:  MOVLW  80
0D12:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0D32:  MOVLB  01
0D33:  CLRF   32
0D34:  MOVLW  1E
0D35:  MOVWF  31
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0D36:  MOVF   15,W
0D37:  ANDLW  C0
0D38:  IORLW  07
0D39:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0D3A:  BSF    0B.5
....................   update_ptt(0); 
0D3B:  MOVLB  02
0D3C:  CLRF   2E
0D3D:  MOVLB  00
0D3E:  CALL   349
....................   MinuteCounter=MIN_COUNTER; 
0D3F:  MOVLW  1D
0D40:  MOVLB  01
0D41:  MOVWF  61
....................   SecondCounter=SEC_COUNTER; 
0D42:  MOVLW  3B
0D43:  MOVWF  60
....................   THIRTY_MIN_FLAG=0; 
0D44:  BCF    7D.5
....................   MINUTE_FLAG=0; 
0D45:  BCF    7D.4
....................   PROMPT_FLAG=1; 
0D46:  BSF    5F.5
....................   TailChar=Tail; 
0D47:  MOVLB  00
0D48:  MOVF   67,W
0D49:  MOVWF  72
....................   ConfirmChar=0; 
0D4A:  CLRF   73
....................   //AuxOut[0] = PO_AUX_OUT0; 
....................   //AuxOut[1] = PO_AUX_OUT1; 
....................   //AuxOut[2] = PO_AUX_OUT2; 
....................   AuxInSW[0] = 0; 
0D4B:  CLRF   3F
....................   AuxInSW[1] = 0; 
0D4C:  CLRF   40
....................   AuxInSW[2] = 0; 
0D4D:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0D4E:  BCF    7D.7
....................   COR_IN_EFFECTIVE=0; 
0D4F:  CLRF   61
....................   set_admin_mode(0); 
0D50:  MOVLB  02
0D51:  CLRF   40
0D52:  MOVLB  00
0D53:  CALL   487
....................   rs232_mode=0; 
0D54:  MOVLB  01
0D55:  BCF    5F.7
.................... #ifdef LCD_TYPE_PI 
....................   init_lcd(); 
.................... #endif 
.................... } // }}} 
0D56:  MOVLP  18
0D57:  MOVLB  00
0D58:  GOTO   710 (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180E:  MOVLB  02
180F:  BCF    28.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
1810:  CLRF   3F
1811:  CLRF   40
1812:  MOVLW  20
1813:  MOVWF  05
1814:  MOVLW  AB
1815:  MOVWF  04
1816:  MOVF   3F,W
1817:  ADDWF  04,F
1818:  MOVLW  00
1819:  ADDWFC 05,F
181A:  MOVF   40,W
181B:  MOVLP  00
181C:  MOVLB  00
181D:  CALL   140
181E:  MOVLP  18
181F:  MOVWF  00
1820:  IORLW  00
1821:  BTFSC  03.2
1822:  GOTO   028
1823:  MOVLB  02
1824:  INCF   40,F
1825:  INCF   3F,F
1826:  GOTO   012
1827:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1828:  MOVLW  20
1829:  MOVLB  02
182A:  MOVWF  40
182B:  MOVLW  50
182C:  MOVWF  3F
182D:  MOVLW  20
182E:  MOVWF  42
182F:  MOVLW  AB
1830:  MOVWF  41
1831:  MOVLP  08
1832:  MOVLB  00
1833:  CALL   559
1834:  MOVLP  18
1835:  MOVF   79,W
1836:  MOVLB  02
1837:  MOVWF  2A
1838:  MOVF   78,W
1839:  MOVWF  29
....................   if (sptr!=0) {; 
183A:  MOVF   29,F
183B:  BTFSS  03.2
183C:  GOTO   040
183D:  MOVF   2A,F
183E:  BTFSC  03.2
183F:  GOTO   05A
....................     strcpy(verb,sptr); 
1840:  MOVF   2A,W
1841:  MOVWF  42
1842:  MOVF   29,W
1843:  MOVWF  41
1844:  MOVLW  20
1845:  MOVWF  40
1846:  MOVLW  A0
1847:  MOVWF  3F
1848:  MOVF   42,W
1849:  MOVWF  05
184A:  MOVF   41,W
184B:  MOVWF  04
184C:  MOVF   00,W
184D:  MOVWF  43
184E:  MOVF   40,W
184F:  MOVWF  05
1850:  MOVF   3F,W
1851:  MOVWF  04
1852:  MOVF   43,W
1853:  MOVWF  00
1854:  MOVF   00,F
1855:  BTFSC  03.2
1856:  GOTO   05A
1857:  INCF   3F,F
1858:  INCF   41,F
1859:  GOTO   048
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
185A:  CLRF   40
185B:  CLRF   3F
185C:  MOVLW  20
185D:  MOVWF  42
185E:  MOVLW  AB
185F:  MOVWF  41
1860:  MOVLP  08
1861:  MOVLB  00
1862:  CALL   559
1863:  MOVLP  18
1864:  MOVF   79,W
1865:  MOVLB  02
1866:  MOVWF  2A
1867:  MOVF   78,W
1868:  MOVWF  29
....................   if (sptr!=0) {; 
1869:  MOVF   29,F
186A:  BTFSS  03.2
186B:  GOTO   06F
186C:  MOVF   2A,F
186D:  BTFSC  03.2
186E:  GOTO   089
....................     strcpy(argument_name,sptr); 
186F:  MOVF   2A,W
1870:  MOVWF  42
1871:  MOVF   29,W
1872:  MOVWF  41
1873:  MOVLW  20
1874:  MOVWF  40
1875:  MOVLW  74
1876:  MOVWF  3F
1877:  MOVF   42,W
1878:  MOVWF  05
1879:  MOVF   41,W
187A:  MOVWF  04
187B:  MOVF   00,W
187C:  MOVWF  43
187D:  MOVF   40,W
187E:  MOVWF  05
187F:  MOVF   3F,W
1880:  MOVWF  04
1881:  MOVF   43,W
1882:  MOVWF  00
1883:  MOVF   00,F
1884:  BTFSC  03.2
1885:  GOTO   089
1886:  INCF   3F,F
1887:  INCF   41,F
1888:  GOTO   077
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1889:  CLRF   40
188A:  CLRF   3F
188B:  MOVLW  20
188C:  MOVWF  42
188D:  MOVLW  AB
188E:  MOVWF  41
188F:  MOVLP  08
1890:  MOVLB  00
1891:  CALL   559
1892:  MOVLP  18
1893:  MOVF   79,W
1894:  MOVLB  02
1895:  MOVWF  2A
1896:  MOVF   78,W
1897:  MOVWF  29
....................   if (sptr!=0) {; 
1898:  MOVF   29,F
1899:  BTFSS  03.2
189A:  GOTO   09E
189B:  MOVF   2A,F
189C:  BTFSC  03.2
189D:  GOTO   0C5
....................     strcpy(match_val,sptr); 
189E:  MOVF   2A,W
189F:  MOVWF  42
18A0:  MOVF   29,W
18A1:  MOVWF  41
18A2:  MOVLW  20
18A3:  MOVWF  40
18A4:  MOVLW  B3
18A5:  MOVWF  3F
18A6:  MOVF   42,W
18A7:  MOVWF  05
18A8:  MOVF   41,W
18A9:  MOVWF  04
18AA:  MOVF   00,W
18AB:  MOVWF  43
18AC:  MOVF   40,W
18AD:  MOVWF  05
18AE:  MOVF   3F,W
18AF:  MOVWF  04
18B0:  MOVF   43,W
18B1:  MOVWF  00
18B2:  MOVF   00,F
18B3:  BTFSC  03.2
18B4:  GOTO   0B8
18B5:  INCF   3F,F
18B6:  INCF   41,F
18B7:  GOTO   0A6
....................     value = str_to_decimal(match_val); 
18B8:  MOVLW  20
18B9:  MOVWF  40
18BA:  MOVLW  B3
18BB:  MOVWF  3F
18BC:  MOVLP  08
18BD:  MOVLB  00
18BE:  CALL   65F
18BF:  MOVLP  18
18C0:  MOVF   78,W
18C1:  MOVLB  01
18C2:  MOVWF  43
....................   } else { 
18C3:  GOTO   0CA
18C4:  MOVLB  02
....................     value = 0; 
18C5:  MOVLB  01
18C6:  CLRF   43
....................     do_get_var = 1; 
18C7:  MOVLB  02
18C8:  BSF    28.0
18C9:  MOVLB  01
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18CA:  MOVLB  02
18CB:  CLRF   3F
18CC:  CLRF   40
18CD:  MOVLW  20
18CE:  MOVWF  05
18CF:  MOVLW  B7
18D0:  MOVWF  04
18D1:  MOVF   3F,W
18D2:  ADDWF  04,F
18D3:  MOVLW  00
18D4:  ADDWFC 05,F
18D5:  MOVF   40,W
18D6:  MOVLP  00
18D7:  MOVLB  00
18D8:  CALL   146
18D9:  MOVLP  18
18DA:  MOVWF  00
18DB:  IORLW  00
18DC:  BTFSC  03.2
18DD:  GOTO   0E3
18DE:  MOVLB  02
18DF:  INCF   40,F
18E0:  INCF   3F,F
18E1:  GOTO   0CD
18E2:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
18E3:  MOVLW  20
18E4:  MOVLB  02
18E5:  MOVWF  40
18E6:  MOVLW  B7
18E7:  MOVWF  3F
18E8:  MOVLW  20
18E9:  MOVWF  42
18EA:  MOVLW  A0
18EB:  MOVWF  41
18EC:  MOVLP  08
18ED:  MOVLB  00
18EE:  CALL   698
18EF:  MOVLP  18
18F0:  MOVF   78,F
18F1:  BTFSS  03.2
18F2:  GOTO   0FC
....................     if ( do_get_var ) { 
18F3:  MOVLB  02
18F4:  BTFSS  28.0
18F5:  GOTO   0F9
....................       command=GET_REG; 
18F6:  MOVLW  03
18F7:  MOVWF  70
....................     } else { 
18F8:  GOTO   0FB
....................       command=SET_REG; 
18F9:  MOVLW  02
18FA:  MOVWF  70
18FB:  MOVLB  00
....................     } 
....................   } // }}} 
.................... #if __DEVICE__  == 1939 
....................   // Check for "setb" command {{{ 
....................   strcpy(smatch_reg,"setb");   
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
....................       command=SET_BIT; 
....................   } // }}} 
....................   // Check for "setb" command {{{ 
....................   strcpy(smatch_reg,"clrb");   
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
....................       command=CLEAR_BIT; 
....................   } // }}} 
.................... #endif 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18FC:  MOVLB  02
18FD:  CLRF   3F
18FE:  CLRF   40
18FF:  MOVLW  20
1900:  MOVWF  05
1901:  MOVLW  B7
1902:  MOVWF  04
1903:  MOVF   3F,W
1904:  ADDWF  04,F
1905:  MOVLW  00
1906:  ADDWFC 05,F
1907:  MOVF   40,W
1908:  MOVLP  00
1909:  MOVLB  00
190A:  CALL   14B
190B:  MOVLP  18
190C:  MOVWF  00
190D:  IORLW  00
190E:  BTFSC  03.2
190F:  GOTO   115
1910:  MOVLB  02
1911:  INCF   40,F
1912:  INCF   3F,F
1913:  GOTO   0FF
1914:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1915:  MOVLW  20
1916:  MOVLB  02
1917:  MOVWF  40
1918:  MOVLW  B7
1919:  MOVWF  3F
191A:  MOVLW  20
191B:  MOVWF  42
191C:  MOVLW  A0
191D:  MOVWF  41
191E:  MOVLP  08
191F:  MOVLB  00
1920:  CALL   698
1921:  MOVLP  18
1922:  MOVF   78,F
1923:  BTFSS  03.2
1924:  GOTO   127
....................       command=SAVE_SETTINGS; 
1925:  MOVLW  04
1926:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1927:  MOVLB  02
1928:  CLRF   3F
1929:  CLRF   40
192A:  MOVLW  20
192B:  MOVWF  05
192C:  MOVLW  B7
192D:  MOVWF  04
192E:  MOVF   3F,W
192F:  ADDWF  04,F
1930:  MOVLW  00
1931:  ADDWFC 05,F
1932:  MOVF   40,W
1933:  MOVLP  00
1934:  MOVLB  00
1935:  CALL   151
1936:  MOVLP  18
1937:  MOVWF  00
1938:  IORLW  00
1939:  BTFSC  03.2
193A:  GOTO   140
193B:  MOVLB  02
193C:  INCF   40,F
193D:  INCF   3F,F
193E:  GOTO   12A
193F:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1940:  MOVLW  20
1941:  MOVLB  02
1942:  MOVWF  40
1943:  MOVLW  B7
1944:  MOVWF  3F
1945:  MOVLW  20
1946:  MOVWF  42
1947:  MOVLW  A0
1948:  MOVWF  41
1949:  MOVLP  08
194A:  MOVLB  00
194B:  CALL   698
194C:  MOVLP  18
194D:  MOVF   78,F
194E:  BTFSS  03.2
194F:  GOTO   152
....................       command=RESTORE_SETTINGS; 
1950:  MOVLW  05
1951:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
1952:  MOVLB  02
1953:  CLRF   3F
1954:  CLRF   40
1955:  MOVLW  20
1956:  MOVWF  05
1957:  MOVLW  B7
1958:  MOVWF  04
1959:  MOVF   3F,W
195A:  ADDWF  04,F
195B:  MOVLW  00
195C:  ADDWFC 05,F
195D:  MOVF   40,W
195E:  MOVLP  00
195F:  MOVLB  00
1960:  CALL   15A
1961:  MOVLP  18
1962:  MOVWF  00
1963:  IORLW  00
1964:  BTFSC  03.2
1965:  GOTO   16B
1966:  MOVLB  02
1967:  INCF   40,F
1968:  INCF   3F,F
1969:  GOTO   155
196A:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
196B:  MOVLW  20
196C:  MOVLB  02
196D:  MOVWF  40
196E:  MOVLW  B7
196F:  MOVWF  3F
1970:  MOVLW  20
1971:  MOVWF  42
1972:  MOVLW  A0
1973:  MOVWF  41
1974:  MOVLP  08
1975:  MOVLB  00
1976:  CALL   698
1977:  MOVLP  18
1978:  MOVF   78,F
1979:  BTFSS  03.2
197A:  GOTO   17D
....................     command=STATUS; 
197B:  MOVLW  08
197C:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
197D:  MOVLB  02
197E:  CLRF   3F
197F:  CLRF   40
1980:  MOVLW  20
1981:  MOVWF  05
1982:  MOVLW  B7
1983:  MOVWF  04
1984:  MOVF   3F,W
1985:  ADDWF  04,F
1986:  MOVLW  00
1987:  ADDWFC 05,F
1988:  MOVF   40,W
1989:  MOVLP  00
198A:  MOVLB  00
198B:  CALL   162
198C:  MOVLP  18
198D:  MOVWF  00
198E:  IORLW  00
198F:  BTFSC  03.2
1990:  GOTO   196
1991:  MOVLB  02
1992:  INCF   40,F
1993:  INCF   3F,F
1994:  GOTO   180
1995:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1996:  MOVLW  20
1997:  MOVLB  02
1998:  MOVWF  40
1999:  MOVLW  B7
199A:  MOVWF  3F
199B:  MOVLW  20
199C:  MOVWF  42
199D:  MOVLW  A0
199E:  MOVWF  41
199F:  MOVLP  08
19A0:  MOVLB  00
19A1:  CALL   698
19A2:  MOVLP  18
19A3:  MOVF   78,F
19A4:  BTFSS  03.2
19A5:  GOTO   1AC
....................     command=ADMIN; 
19A6:  MOVLW  09
19A7:  MOVWF  70
....................     argument=REBOOT; 
19A8:  MOVLW  02
19A9:  MOVLB  01
19AA:  MOVWF  42
19AB:  MOVLB  00
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19AC:  MOVLB  02
19AD:  CLRF   3F
19AE:  CLRF   40
19AF:  MOVLW  20
19B0:  MOVWF  05
19B1:  MOVLW  B7
19B2:  MOVWF  04
19B3:  MOVF   3F,W
19B4:  ADDWF  04,F
19B5:  MOVLW  00
19B6:  ADDWFC 05,F
19B7:  MOVF   40,W
19B8:  MOVLP  00
19B9:  MOVLB  00
19BA:  CALL   16A
19BB:  MOVLP  18
19BC:  MOVWF  00
19BD:  IORLW  00
19BE:  BTFSC  03.2
19BF:  GOTO   1C5
19C0:  MOVLB  02
19C1:  INCF   40,F
19C2:  INCF   3F,F
19C3:  GOTO   1AF
19C4:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19C5:  MOVLW  20
19C6:  MOVLB  02
19C7:  MOVWF  40
19C8:  MOVLW  B7
19C9:  MOVWF  3F
19CA:  MOVLW  20
19CB:  MOVWF  42
19CC:  MOVLW  A0
19CD:  MOVWF  41
19CE:  MOVLP  08
19CF:  MOVLB  00
19D0:  CALL   698
19D1:  MOVLP  18
19D2:  MOVF   78,F
19D3:  BTFSS  03.2
19D4:  GOTO   227
....................     //command=DTMF_SEND; 
....................     command=0; 
19D5:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D6:  MOVLW  20
19D7:  MOVLB  02
19D8:  MOVWF  40
19D9:  MOVLW  74
19DA:  MOVWF  3F
19DB:  MOVLP  08
19DC:  MOVLB  00
19DD:  CALL   65F
19DE:  MOVLP  18
19DF:  MOVF   78,W
19E0:  MOVLB  01
19E1:  MOVWF  43
....................     if ( value == d0 ) { 
19E2:  MOVF   43,W
19E3:  SUBLW  0A
19E4:  BTFSS  03.2
19E5:  GOTO   1E8
....................       value = dd; 
19E6:  CLRF   43
....................     } else if (value == dd) { 
19E7:  GOTO   1ED
19E8:  MOVF   43,F
19E9:  BTFSS  03.2
19EA:  GOTO   1ED
....................       value = d0; 
19EB:  MOVLW  0A
19EC:  MOVWF  43
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19ED:  MOVF   43,W
19EE:  ANDLW  0F
19EF:  MOVLB  02
19F0:  MOVWF  3F
19F1:  MOVF   3F,W
19F2:  MOVWF  40
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A27:  MOVLB  02
1A28:  CLRF   3F
1A29:  CLRF   40
1A2A:  MOVLW  20
1A2B:  MOVWF  05
1A2C:  MOVLW  B7
1A2D:  MOVWF  04
1A2E:  MOVF   3F,W
1A2F:  ADDWF  04,F
1A30:  MOVLW  00
1A31:  ADDWFC 05,F
1A32:  MOVF   40,W
1A33:  MOVLP  00
1A34:  MOVLB  00
1A35:  CALL   16D
1A36:  MOVLP  18
1A37:  MOVWF  00
1A38:  IORLW  00
1A39:  BTFSC  03.2
1A3A:  GOTO   240
1A3B:  MOVLB  02
1A3C:  INCF   40,F
1A3D:  INCF   3F,F
1A3E:  GOTO   22A
1A3F:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A40:  MOVLW  20
1A41:  MOVLB  02
1A42:  MOVWF  40
1A43:  MOVLW  B7
1A44:  MOVWF  3F
1A45:  MOVLW  20
1A46:  MOVWF  42
1A47:  MOVLW  A0
1A48:  MOVWF  41
1A49:  MOVLP  08
1A4A:  MOVLB  00
1A4B:  CALL   698
1A4C:  MOVLP  18
1A4D:  MOVF   78,F
1A4E:  BTFSS  03.2
1A4F:  GOTO   252
....................     command=I2C_SEND; 
1A50:  MOVLW  0C
1A51:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A52:  MOVLB  02
1A53:  CLRF   3F
1A54:  CLRF   40
1A55:  MOVLW  20
1A56:  MOVWF  05
1A57:  MOVLW  B7
1A58:  MOVWF  04
1A59:  MOVF   3F,W
1A5A:  ADDWF  04,F
1A5B:  MOVLW  00
1A5C:  ADDWFC 05,F
1A5D:  MOVF   40,W
1A5E:  MOVLP  00
1A5F:  MOVLB  00
1A60:  CALL   172
1A61:  MOVLP  18
1A62:  MOVWF  00
1A63:  IORLW  00
1A64:  BTFSC  03.2
1A65:  GOTO   26B
1A66:  MOVLB  02
1A67:  INCF   40,F
1A68:  INCF   3F,F
1A69:  GOTO   255
1A6A:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A6B:  MOVLW  20
1A6C:  MOVLB  02
1A6D:  MOVWF  40
1A6E:  MOVLW  B7
1A6F:  MOVWF  3F
1A70:  MOVLW  20
1A71:  MOVWF  42
1A72:  MOVLW  A0
1A73:  MOVWF  41
1A74:  MOVLP  08
1A75:  MOVLB  00
1A76:  CALL   698
1A77:  MOVLP  18
1A78:  MOVF   78,F
1A79:  BTFSS  03.2
1A7A:  GOTO   294
....................     value = str_to_decimal(argument_name); 
1A7B:  MOVLW  20
1A7C:  MOVLB  02
1A7D:  MOVWF  40
1A7E:  MOVLW  74
1A7F:  MOVWF  3F
1A80:  MOVLP  08
1A81:  MOVLB  00
1A82:  CALL   65F
1A83:  MOVLP  18
1A84:  MOVF   78,W
1A85:  MOVLB  01
1A86:  MOVWF  43
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A87:  MOVF   43,W
1A88:  SUBLW  24
1A89:  BTFSS  03.0
1A8A:  GOTO   28F
....................       argument = 0; 
1A8B:  CLRF   42
....................       command  = MORSE_SEND; 
1A8C:  MOVLW  0B
1A8D:  MOVWF  70
....................     } else { 
1A8E:  GOTO   293
....................       command  = ADMIN; 
1A8F:  MOVLW  09
1A90:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A91:  MOVLW  03
1A92:  MOVWF  42
1A93:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A94:  MOVLB  02
1A95:  CLRF   3F
1A96:  CLRF   40
1A97:  MOVLW  20
1A98:  MOVWF  05
1A99:  MOVLW  B7
1A9A:  MOVWF  04
1A9B:  MOVF   3F,W
1A9C:  ADDWF  04,F
1A9D:  MOVLW  00
1A9E:  ADDWFC 05,F
1A9F:  MOVF   40,W
1AA0:  MOVLP  00
1AA1:  MOVLB  00
1AA2:  CALL   179
1AA3:  MOVLP  18
1AA4:  MOVWF  00
1AA5:  IORLW  00
1AA6:  BTFSC  03.2
1AA7:  GOTO   2AD
1AA8:  MOVLB  02
1AA9:  INCF   40,F
1AAA:  INCF   3F,F
1AAB:  GOTO   297
1AAC:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AAD:  MOVLW  20
1AAE:  MOVLB  02
1AAF:  MOVWF  40
1AB0:  MOVLW  B7
1AB1:  MOVWF  3F
1AB2:  MOVLW  20
1AB3:  MOVWF  42
1AB4:  MOVLW  A0
1AB5:  MOVWF  41
1AB6:  MOVLP  08
1AB7:  MOVLB  00
1AB8:  CALL   698
1AB9:  MOVLP  18
1ABA:  MOVF   78,F
1ABB:  BTFSS  03.2
1ABC:  GOTO   2BF
....................     command=INCREMENT_REG; 
1ABD:  MOVLW  06
1ABE:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1ABF:  MOVLB  02
1AC0:  CLRF   3F
1AC1:  CLRF   40
1AC2:  MOVLW  20
1AC3:  MOVWF  05
1AC4:  MOVLW  B7
1AC5:  MOVWF  04
1AC6:  MOVF   3F,W
1AC7:  ADDWF  04,F
1AC8:  MOVLW  00
1AC9:  ADDWFC 05,F
1ACA:  MOVF   40,W
1ACB:  MOVLP  00
1ACC:  MOVLB  00
1ACD:  CALL   17C
1ACE:  MOVLP  18
1ACF:  MOVWF  00
1AD0:  IORLW  00
1AD1:  BTFSC  03.2
1AD2:  GOTO   2D8
1AD3:  MOVLB  02
1AD4:  INCF   40,F
1AD5:  INCF   3F,F
1AD6:  GOTO   2C2
1AD7:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AD8:  MOVLW  20
1AD9:  MOVLB  02
1ADA:  MOVWF  40
1ADB:  MOVLW  B7
1ADC:  MOVWF  3F
1ADD:  MOVLW  20
1ADE:  MOVWF  42
1ADF:  MOVLW  A0
1AE0:  MOVWF  41
1AE1:  MOVLP  08
1AE2:  MOVLB  00
1AE3:  CALL   698
1AE4:  MOVLP  18
1AE5:  MOVF   78,F
1AE6:  BTFSS  03.2
1AE7:  GOTO   2EA
....................     command=DECREMENT_REG; 
1AE8:  MOVLW  07
1AE9:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AEA:  MOVLB  02
1AEB:  CLRF   3F
1AEC:  CLRF   40
1AED:  MOVLW  20
1AEE:  MOVWF  05
1AEF:  MOVLW  B7
1AF0:  MOVWF  04
1AF1:  MOVF   3F,W
1AF2:  ADDWF  04,F
1AF3:  MOVLW  00
1AF4:  ADDWFC 05,F
1AF5:  MOVF   40,W
1AF6:  MOVLP  00
1AF7:  MOVLB  00
1AF8:  CALL   17F
1AF9:  MOVLP  18
1AFA:  MOVWF  00
1AFB:  IORLW  00
1AFC:  BTFSC  03.2
1AFD:  GOTO   303
1AFE:  MOVLB  02
1AFF:  INCF   40,F
1B00:  INCF   3F,F
1B01:  GOTO   2ED
1B02:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B03:  MOVLW  20
1B04:  MOVLB  02
1B05:  MOVWF  40
1B06:  MOVLW  B7
1B07:  MOVWF  3F
1B08:  MOVLW  20
1B09:  MOVWF  42
1B0A:  MOVLW  A0
1B0B:  MOVWF  41
1B0C:  MOVLP  08
1B0D:  MOVLB  00
1B0E:  CALL   698
1B0F:  MOVLP  18
1B10:  MOVF   78,F
1B11:  BTFSS  03.2
1B12:  GOTO   333
....................     command=SET_REG; 
1B13:  MOVLW  02
1B14:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B15:  MOVLW  01
1B16:  MOVLB  01
1B17:  ADDWF  30,W
1B18:  ANDLW  03
1B19:  MOVWF  43
....................     strcpy(argument_name,"CPOT"); 
1B1A:  MOVLB  02
1B1B:  CLRF   3F
1B1C:  CLRF   40
1B1D:  MOVLW  20
1B1E:  MOVWF  05
1B1F:  MOVLW  74
1B20:  MOVWF  04
1B21:  MOVF   3F,W
1B22:  ADDWF  04,F
1B23:  MOVLW  00
1B24:  ADDWFC 05,F
1B25:  MOVF   40,W
1B26:  MOVLP  00
1B27:  MOVLB  00
1B28:  CALL   182
1B29:  MOVLP  18
1B2A:  MOVWF  00
1B2B:  IORLW  00
1B2C:  BTFSC  03.2
1B2D:  GOTO   333
1B2E:  MOVLB  02
1B2F:  INCF   40,F
1B30:  INCF   3F,F
1B31:  GOTO   31D
1B32:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B33:  MOVLB  02
1B34:  CLRF   3F
1B35:  CLRF   40
1B36:  MOVLW  20
1B37:  MOVWF  05
1B38:  MOVLW  B7
1B39:  MOVWF  04
1B3A:  MOVF   3F,W
1B3B:  ADDWF  04,F
1B3C:  MOVLW  00
1B3D:  ADDWFC 05,F
1B3E:  MOVF   40,W
1B3F:  MOVLP  00
1B40:  MOVLB  00
1B41:  CALL   188
1B42:  MOVLP  18
1B43:  MOVWF  00
1B44:  IORLW  00
1B45:  BTFSC  03.2
1B46:  GOTO   34C
1B47:  MOVLB  02
1B48:  INCF   40,F
1B49:  INCF   3F,F
1B4A:  GOTO   336
1B4B:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B4C:  MOVLW  20
1B4D:  MOVLB  02
1B4E:  MOVWF  40
1B4F:  MOVLW  B7
1B50:  MOVWF  3F
1B51:  MOVLW  20
1B52:  MOVWF  42
1B53:  MOVLW  A0
1B54:  MOVWF  41
1B55:  MOVLP  08
1B56:  MOVLB  00
1B57:  CALL   698
1B58:  MOVLP  18
1B59:  MOVF   78,F
1B5A:  BTFSS  03.2
1B5B:  GOTO   36C
....................     AdminMode = ~AdminMode; 
1B5C:  MOVLW  40
1B5D:  MOVLB  01
1B5E:  XORWF  5F,F
....................     set_admin_mode(AdminMode); 
1B5F:  MOVLW  00
1B60:  BTFSC  5F.6
1B61:  MOVLW  01
1B62:  MOVLB  02
1B63:  MOVWF  3F
1B64:  MOVWF  40
1B65:  MOVLP  08
1B66:  MOVLB  00
1B67:  CALL   487
1B68:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B69:  MOVLB  01
1B6A:  BSF    5F.5
1B6B:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... #if __DEVICE__  == 1939 
.................... void set_bit (void) { // {{{ 
....................   int *pObj; 
....................     pObj=RegMap[argument].reg_ptr; 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
....................       *pObj=bit_set(*pObj,(value&0x1F)); 
....................     } 
....................     PROMPT_FLAG; 
.................... } // }}} 
.................... void clear_bit (void) { // {{{ 
....................   int *pObj; 
....................     pObj=RegMap[argument].reg_ptr; 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
....................       *pObj=bit_clear(*pObj,(value&0x1F)); 
....................     } 
....................     PROMPT_FLAG=1; 
.................... } // }}} 
.................... #endif 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
106D:  MOVLB  01
106E:  MOVF   43,W
106F:  SUBLW  FF
1070:  BTFSS  03.2
1071:  GOTO   09E
....................     printf ("\n\r%s %u",argument,value); 
1072:  MOVLW  0A
1073:  CLRWDT
1074:  MOVLB  00
1075:  BTFSC  11.4
1076:  GOTO   079
1077:  MOVLB  01
1078:  GOTO   073
1079:  MOVLB  03
107A:  MOVWF  1A
107B:  MOVLW  0D
107C:  CLRWDT
107D:  MOVLB  00
107E:  BTFSC  11.4
107F:  GOTO   082
1080:  MOVLB  03
1081:  GOTO   07C
1082:  MOVLB  03
1083:  MOVWF  1A
1084:  CLRF   05
1085:  MOVLB  01
1086:  MOVF   42,W
1087:  MOVWF  04
1088:  MOVLP  08
1089:  MOVLB  00
108A:  CALL   22B
108B:  MOVLP  10
108C:  MOVLW  20
108D:  CLRWDT
108E:  BTFSS  11.4
108F:  GOTO   08D
1090:  MOVLB  03
1091:  MOVWF  1A
1092:  MOVLB  01
1093:  MOVF   43,W
1094:  MOVLB  02
1095:  MOVWF  50
1096:  MOVLW  1B
1097:  MOVWF  51
1098:  MOVLP  00
1099:  MOVLB  00
109A:  CALL   706
109B:  MOVLP  10
....................   } else { 
109C:  GOTO   143
109D:  MOVLB  01
....................     pObj=RegMap[argument].reg_ptr; 
109E:  RLF    42,W
109F:  MOVWF  77
10A0:  RLF    77,F
10A1:  MOVLW  FC
10A2:  ANDWF  77,F
10A3:  MOVF   77,W
10A4:  MOVLB  02
10A5:  MOVWF  2F
10A6:  INCF   2F,W
10A7:  MOVLP  00
10A8:  MOVLB  00
10A9:  CALL   043
10AA:  MOVLP  10
10AB:  MOVWF  7A
10AC:  MOVLB  02
10AD:  MOVF   2F,W
10AE:  MOVLP  00
10AF:  MOVLB  00
10B0:  CALL   043
10B1:  MOVLP  10
10B2:  MOVLB  02
10B3:  MOVWF  2C
10B4:  MOVF   7A,W
10B5:  MOVWF  2D
....................     // Consider allowing some registers to be updated outside AdminMode. 
....................     // Example : AuxOut registers, Enable 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
10B6:  MOVLP  08
10B7:  MOVLB  00
10B8:  CALL   702
10B9:  MOVLP  10
10BA:  MOVF   78,F
10BB:  BTFSS  03.2
10BC:  GOTO   0CC
10BD:  MOVLB  01
10BE:  RLF    42,W
10BF:  MOVWF  77
10C0:  RLF    77,F
10C1:  MOVLW  FC
10C2:  ANDWF  77,F
10C3:  MOVF   77,W
10C4:  ADDLW  03
10C5:  MOVLP  00
10C6:  MOVLB  00
10C7:  CALL   043
10C8:  MOVLP  10
10C9:  MOVWF  78
10CA:  BTFSC  78.1
10CB:  GOTO   0D5
....................       *pObj=value; 
10CC:  MOVLB  02
10CD:  MOVF   2C,W
10CE:  MOVWF  04
10CF:  MOVF   2D,W
10D0:  MOVWF  05
10D1:  MOVLB  01
10D2:  MOVF   43,W
10D3:  MOVWF  00
10D4:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
10D5:  MOVLB  02
10D6:  MOVF   2C,W
10D7:  MOVWF  04
10D8:  MOVF   2D,W
10D9:  MOVWF  05
10DA:  MOVF   00,W
10DB:  MOVWF  2E
....................     printf ("\n\r%s(%u) <= %u",argument_name,argument,lVar); 
10DC:  MOVLW  0A
10DD:  CLRWDT
10DE:  MOVLB  00
10DF:  BTFSC  11.4
10E0:  GOTO   0E3
10E1:  MOVLB  02
10E2:  GOTO   0DD
10E3:  MOVLB  03
10E4:  MOVWF  1A
10E5:  MOVLW  0D
10E6:  CLRWDT
10E7:  MOVLB  00
10E8:  BTFSC  11.4
10E9:  GOTO   0EC
10EA:  MOVLB  03
10EB:  GOTO   0E6
10EC:  MOVLB  03
10ED:  MOVWF  1A
10EE:  MOVLW  20
10EF:  MOVWF  05
10F0:  MOVLW  74
10F1:  MOVWF  04
10F2:  MOVLP  08
10F3:  MOVLB  00
10F4:  CALL   22B
10F5:  MOVLP  10
10F6:  MOVLW  28
10F7:  CLRWDT
10F8:  BTFSS  11.4
10F9:  GOTO   0F7
10FA:  MOVLB  03
10FB:  MOVWF  1A
10FC:  MOVLB  01
10FD:  MOVF   42,W
10FE:  MOVLB  02
10FF:  MOVWF  50
1100:  MOVLW  1B
1101:  MOVWF  51
1102:  MOVLP  00
1103:  MOVLB  00
1104:  CALL   706
1105:  MOVLP  10
1106:  MOVLW  6F
1107:  MOVLB  03
1108:  MOVWF  11
1109:  MOVLW  04
110A:  MOVWF  12
110B:  BSF    03.0
110C:  MOVLW  05
110D:  MOVLB  02
110E:  MOVWF  50
110F:  MOVLP  00
1110:  MOVLB  00
1111:  CALL   692
1112:  MOVLP  10
1113:  MOVLB  02
1114:  MOVF   2E,W
1115:  MOVWF  50
1116:  MOVLW  1B
1117:  MOVWF  51
1118:  MOVLP  00
1119:  MOVLB  00
111A:  CALL   706
111B:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
111C:  MOVLB  02
111D:  MOVF   2D,W
111E:  SUBLW  1F
111F:  BTFSC  03.0
1120:  GOTO   132
1121:  XORLW  FF
1122:  BTFSS  03.2
1123:  GOTO   128
1124:  MOVF   2C,W
1125:  SUBLW  0B
1126:  BTFSC  03.0
1127:  GOTO   132
1128:  MOVF   2D,W
1129:  SUBLW  20
112A:  BTFSS  03.0
112B:  GOTO   132
112C:  BTFSS  03.2
112D:  GOTO   13A
112E:  MOVF   2C,W
112F:  SUBLW  1B
1130:  BTFSC  03.0
1131:  GOTO   13A
1132:  MOVF   2C,W
1133:  SUBLW  60
1134:  BTFSS  03.2
1135:  GOTO   140
1136:  MOVF   2D,W
1137:  SUBLW  20
1138:  BTFSS  03.2
1139:  GOTO   140
....................       increment(0); // Increment is done in this function. Only update trim pot. 
113A:  CLRF   2F
113B:  MOVLP  08
113C:  MOVLB  00
113D:  CALL   711
113E:  MOVLP  10
113F:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
1140:  MOVLB  01
1141:  BSF    5F.5
1142:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
0F11:  MOVLB  01
0F12:  MOVF   30,W
0F13:  ANDLW  03
0F14:  MOVLB  02
0F15:  MOVWF  33
....................   if ( CurrentCorIndex ) { 
0F16:  MOVF   75,F
0F17:  BTFSC  03.2
0F18:  GOTO   750
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
0F19:  MOVLW  01
0F1A:  SUBWF  75,W
0F1B:  MOVWF  77
0F1C:  RLF    77,F
0F1D:  RLF    77,F
0F1E:  MOVLW  FC
0F1F:  ANDWF  77,F
0F20:  MOVF   77,W
0F21:  ADDWF  33,W
0F22:  ADDLW  0C
0F23:  MOVWF  78
0F24:  MOVLW  20
0F25:  MOVWF  7A
0F26:  BTFSC  03.0
0F27:  INCF   7A,F
0F28:  MOVF   78,W
0F29:  MOVWF  30
0F2A:  MOVF   7A,W
0F2B:  MOVWF  31
....................     value = *pot_ptr; 
0F2C:  MOVF   30,W
0F2D:  MOVWF  04
0F2E:  MOVF   31,W
0F2F:  MOVWF  05
0F30:  MOVF   00,W
0F31:  MOVWF  32
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
0F32:  MOVF   30,W
0F33:  MOVWF  04
0F34:  MOVF   31,W
0F35:  MOVWF  05
0F36:  MOVF   2F,W
0F37:  ADDWF  32,W
0F38:  MOVWF  00
....................     if ( in_admin_mode() ) { 
0F39:  MOVLB  00
0F3A:  CALL   702
0F3B:  MOVF   78,F
0F3C:  BTFSC  03.2
0F3D:  GOTO   74F
....................       set_trimpot(CPotPtr,*pot_ptr); 
0F3E:  MOVLB  02
0F3F:  MOVF   31,W
0F40:  MOVWF  7A
0F41:  MOVF   30,W
0F42:  MOVWF  04
0F43:  MOVF   31,W
0F44:  MOVWF  05
0F45:  MOVF   00,W
0F46:  MOVWF  34
0F47:  MOVF   33,W
0F48:  MOVWF  3F
0F49:  MOVF   34,W
0F4A:  MOVWF  40
0F4B:  MOVLP  00
0F4C:  MOVLB  00
0F4D:  CALL   755
0F4E:  MOVLP  08
0F4F:  MOVLB  02
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
0F50:  MOVLB  00
0F51:  CALL   245
.................... } // }}} 
0F52:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
0ED7:  MOVLB  02
0ED8:  CLRF   3F
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
0ED9:  MOVF   3F,W
0EDA:  SUBLW  05
0EDB:  BTFSS  03.0
0EDC:  GOTO   700
....................     dest[c]=src[c]; 
0EDD:  MOVF   3F,W
0EDE:  ADDWF  3B,W
0EDF:  MOVWF  78
0EE0:  MOVLW  00
0EE1:  ADDWFC 3C,W
0EE2:  MOVWF  7A
0EE3:  MOVF   78,W
0EE4:  MOVWF  40
0EE5:  MOVF   7A,W
0EE6:  MOVWF  41
0EE7:  MOVF   3F,W
0EE8:  ADDWF  3D,W
0EE9:  MOVWF  78
0EEA:  MOVLW  00
0EEB:  ADDWFC 3E,W
0EEC:  MOVWF  7A
0EED:  MOVF   78,W
0EEE:  MOVLB  03
0EEF:  MOVWF  11
0EF0:  MOVF   7A,W
0EF1:  MOVWF  12
0EF2:  MOVLB  02
0EF3:  MOVF   41,W
0EF4:  MOVWF  05
0EF5:  MOVF   40,W
0EF6:  MOVWF  04
0EF7:  MOVLW  01
0EF8:  MOVWF  45
0EF9:  MOVLP  00
0EFA:  MOVLB  00
0EFB:  CALL   7D9
0EFC:  MOVLP  08
....................   c++; 
0EFD:  MOVLB  02
0EFE:  INCF   3F,F
....................   } 
0EFF:  GOTO   6D9
.................... } // }}} 
0F00:  MOVLB  00
0F01:  RETURN
.................... void ExecAuxOutOp(char op,char arg,char ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
1C7D:  MOVF   29,W
1C7E:  ANDLW  0F
1C7F:  MOVWF  2B
....................   uarg = (arg & 0xF0) >> 4; 
1C80:  MOVF   29,W
1C81:  ANDLW  F0
1C82:  MOVWF  77
1C83:  SWAPF  77,W
1C84:  MOVWF  2C
1C85:  MOVLW  0F
1C86:  ANDWF  2C,F
....................   switch(op) { 
1C87:  MOVF   28,W
1C88:  XORLW  02
1C89:  MOVLB  00
1C8A:  BTFSC  03.2
1C8B:  GOTO   490
1C8C:  XORLW  03
1C8D:  BTFSC  03.2
1C8E:  GOTO   4AA
1C8F:  GOTO   4FE
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
1C90:  MOVLW  22
1C91:  MOVLB  02
1C92:  ADDWF  2A,W
1C93:  MOVWF  04
1C94:  MOVLW  20
1C95:  MOVWF  05
1C96:  BTFSC  03.0
1C97:  INCF   05,F
1C98:  MOVF   2B,W
1C99:  ANDLW  1F
1C9A:  MOVWF  30
1C9B:  MOVF   7A,W
1C9C:  MOVWF  31
1C9D:  MOVF   2C,W
1C9E:  XORWF  30,F
1C9F:  BTFSS  03.2
1CA0:  GOTO   4A6
1CA1:  MOVF   31,F
1CA2:  BTFSS  03.2
1CA3:  GOTO   4A6
1CA4:  MOVLW  00
1CA5:  GOTO   4A7
1CA6:  MOVLW  01
1CA7:  MOVWF  00
....................     break; 
1CA8:  MOVLB  00
1CA9:  GOTO   4FE
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       // Only COR_IN_HW is used which corresponds to the COR inputs on the controller. 
....................       // Emulated COR_IN are ignored. 
....................       int1 invert_output = ((arg & AUX_OUT_FOLLOW_COR_INVERT_OUTPUT)!=0); 
....................       int1 cor_active = ((COR_IN_HW & ~TOT_FLAG_Mask & larg) != 0); 
....................       int1 disable_delay_en = ((arg & AUX_OUT_FOLLOW_COR_OFF_DELAY) !=0); 
....................       int1 enable_delay = ((arg & AUX_OUT_FOLLOW_COR_ON_DELAY) !=0); 
....................       int1 disable_delay = (disable_delay_en && (AuxOutDelayCnt != 0)); 
....................       int1 pin_value; 
1CAA:  MOVLB  02
1CAB:  BCF    2D.0
1CAC:  MOVF   29,W
1CAD:  ANDLW  10
1CAE:  BTFSS  03.2
1CAF:  BSF    2D.0
1CB0:  BCF    2D.1
1CB1:  MOVLB  00
1CB2:  MOVF   6A,W
1CB3:  XORLW  FF
1CB4:  ANDWF  5F,W
1CB5:  MOVLB  02
1CB6:  ANDWF  2B,W
1CB7:  BTFSS  03.2
1CB8:  BSF    2D.1
1CB9:  BCF    2D.2
1CBA:  MOVF   29,W
1CBB:  ANDLW  20
1CBC:  BTFSS  03.2
1CBD:  BSF    2D.2
1CBE:  BCF    2D.3
1CBF:  MOVF   29,W
1CC0:  ANDLW  40
1CC1:  BTFSS  03.2
1CC2:  BSF    2D.3
1CC3:  BCF    2D.4
1CC4:  BTFSS  2D.2
1CC5:  GOTO   4CE
1CC6:  MOVLB  01
1CC7:  MOVF   35,F
1CC8:  BTFSS  03.2
1CC9:  GOTO   4CC
1CCA:  MOVLB  02
1CCB:  GOTO   4CE
1CCC:  MOVLB  02
1CCD:  BSF    2D.4
....................       if ( cor_active ) { 
1CCE:  BTFSS  2D.1
1CCF:  GOTO   4EA
....................         // Activate output after several seconds of active QSO 
....................         // or keep the pin active if servicing a disable delay. 
....................         if (enable_delay) { 
1CD0:  BTFSS  2D.3
1CD1:  GOTO   4E8
....................           pin_value = (QSO_Duration > QSO_DURATION_DELAY) || disable_delay; 
1CD2:  BCF    2D.5
1CD3:  MOVLB  00
1CD4:  MOVF   6C,F
1CD5:  BTFSS  03.2
1CD6:  GOTO   4DF
1CD7:  MOVF   6B,W
1CD8:  SUBLW  05
1CD9:  BTFSS  03.0
1CDA:  GOTO   4DF
1CDB:  MOVLB  02
1CDC:  BTFSS  2D.4
1CDD:  GOTO   4E1
1CDE:  MOVLB  00
1CDF:  MOVLB  02
1CE0:  BSF    2D.5
....................           if ( pin_value ) { 
1CE1:  BTFSS  2D.5
1CE2:  GOTO   4E7
....................             AuxOutDelayCnt = 60; 
1CE3:  MOVLW  3C
1CE4:  MOVLB  01
1CE5:  MOVWF  35
1CE6:  MOVLB  02
....................           } 
....................         } else { 
1CE7:  GOTO   4E9
....................           pin_value = 1; 
1CE8:  BSF    2D.5
....................         } 
....................       } else { 
1CE9:  GOTO   4ED
....................         pin_value = disable_delay; 
1CEA:  BCF    2D.5
1CEB:  BTFSC  2D.4
1CEC:  BSF    2D.5
....................       } 
....................       AuxOut[ID] = pin_value ^ invert_output; 
1CED:  MOVLW  22
1CEE:  ADDWF  2A,W
1CEF:  MOVWF  04
1CF0:  MOVLW  20
1CF1:  MOVWF  05
1CF2:  BTFSC  03.0
1CF3:  INCF   05,F
1CF4:  MOVLW  00
1CF5:  BTFSC  2D.5
1CF6:  MOVLW  01
1CF7:  MOVWF  31
1CF8:  MOVLW  00
1CF9:  BTFSC  2D.0
1CFA:  MOVLW  01
1CFB:  XORWF  31,W
1CFC:  MOVWF  00
....................     break; 
1CFD:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0E5F:  MOVLB  02
0E60:  CLRF   41
0E61:  CLRF   42
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0E62:  MOVF   41,W
0E63:  ADDWF  3F,W
0E64:  MOVWF  04
0E65:  MOVLW  00
0E66:  ADDWFC 40,W
0E67:  MOVWF  05
0E68:  MOVF   00,F
0E69:  BTFSC  03.2
0E6A:  GOTO   694
0E6B:  MOVF   41,W
0E6C:  ADDWF  3F,W
0E6D:  MOVWF  04
0E6E:  MOVLW  00
0E6F:  ADDWFC 40,W
0E70:  MOVWF  05
0E71:  MOVF   00,W
0E72:  SUBLW  2F
0E73:  BTFSC  03.0
0E74:  GOTO   694
0E75:  MOVF   41,W
0E76:  ADDWF  3F,W
0E77:  MOVWF  04
0E78:  MOVLW  00
0E79:  ADDWFC 40,W
0E7A:  MOVWF  05
0E7B:  MOVF   00,W
0E7C:  SUBLW  39
0E7D:  BTFSS  03.0
0E7E:  GOTO   694
....................     value = (value * 10) + (str[x]-'0'); 
0E7F:  MOVF   42,W
0E80:  MOVWF  43
0E81:  MOVLW  0A
0E82:  MOVWF  44
0E83:  MOVLB  00
0E84:  CALL   638
0E85:  MOVF   78,W
0E86:  MOVLB  02
0E87:  MOVWF  43
0E88:  MOVF   41,W
0E89:  ADDWF  3F,W
0E8A:  MOVWF  04
0E8B:  MOVLW  00
0E8C:  ADDWFC 40,W
0E8D:  MOVWF  05
0E8E:  MOVLW  30
0E8F:  SUBWF  00,W
0E90:  ADDWF  43,W
0E91:  MOVWF  42
....................     x++; 
0E92:  INCF   41,F
....................   } 
0E93:  GOTO   662
....................   return(value); 
0E94:  MOVF   42,W
0E95:  MOVWF  78
.................... } // }}} 
0E96:  MOVLB  00
0E97:  RETURN
.................... void ExecAuxInOp(char op,char arg,char ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
1652:  MOVLB  02
1653:  BCF    2B.0
1654:  MOVLW  1F
1655:  ADDWF  2A,W
1656:  MOVWF  04
1657:  MOVLW  20
1658:  MOVWF  05
1659:  BTFSC  03.0
165A:  INCF   05,F
165B:  MOVF   00,F
165C:  BTFSS  03.2
165D:  BSF    2B.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   // Include arg[4] for COR4 emulation 
....................   larg = arg & 0x1F; 
165E:  MOVF   29,W
165F:  ANDLW  1F
1660:  MOVWF  2C
....................   uarg = (arg & 0xF0) >> 4; 
1661:  MOVF   29,W
1662:  ANDLW  F0
1663:  MOVWF  77
1664:  SWAPF  77,W
1665:  MOVWF  2D
1666:  MOVLW  0F
1667:  ANDWF  2D,F
....................   switch(op) { 
1668:  MOVLW  01
1669:  SUBWF  28,W
166A:  ADDLW  FC
166B:  BTFSC  03.0
166C:  GOTO   6AD
166D:  ADDLW  04
166E:  MOVLB  00
166F:  GOTO   6B0
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
1670:  MOVLB  02
1671:  BTFSS  2B.0
1672:  GOTO   678
....................         Enable_Mask &= arg; 
1673:  MOVF   29,W
1674:  MOVLB  00
1675:  ANDWF  63,F
....................       } else { // AuxIn is not enabled 
1676:  GOTO   67D
1677:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
1678:  MOVF   29,W
1679:  XORLW  FF
167A:  ANDLW  0F
167B:  MOVLB  00
167C:  IORWF  63,F
....................       } 
....................       break; 
167D:  MOVLB  02
167E:  GOTO   6AD
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
167F:  MOVLB  02
1680:  BTFSS  2B.0
1681:  GOTO   686
....................         COR_DROP_FLAG=1; 
1682:  BSF    7D.6
....................         TailChar=arg; 
1683:  MOVF   29,W
1684:  MOVWF  72
....................       } else { 
1685:  GOTO   687
....................         TailChar=0; 
1686:  CLRF   72
....................       } 
....................     break; 
1687:  GOTO   6AD
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
1688:  MOVLB  02
1689:  BTFSC  2B.0
168A:  GOTO   68F
....................         COR_DROP_FLAG=1; 
168B:  BSF    7D.6
....................         TailChar=arg; 
168C:  MOVF   29,W
168D:  MOVWF  72
....................       } else { 
168E:  GOTO   690
....................         TailChar=0; 
168F:  CLRF   72
....................       } 
....................     break; 
1690:  GOTO   6AD
....................     case AUXI_EMULATE_COR: 
....................       int1 active_low = (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0; 
1691:  MOVLB  02
1692:  BCF    2B.2
1693:  MOVF   29,W
1694:  ANDLW  20
1695:  BTFSS  03.2
1696:  BSF    2B.2
....................       tmp_bit = (active_low ^ in_bit); 
1697:  MOVLW  00
1698:  BTFSC  2B.2
1699:  MOVLW  01
169A:  MOVWF  2F
169B:  MOVLW  00
169C:  BTFSC  2B.0
169D:  MOVLW  01
169E:  XORWF  2F,W
169F:  MOVWF  78
16A0:  BCF    2B.1
16A1:  BTFSC  78.0
16A2:  BSF    2B.1
....................       if ( tmp_bit ) { 
16A3:  BTFSS  2B.1
16A4:  GOTO   6A8
....................         COR_AUX |= larg; 
16A5:  MOVF   2C,W
16A6:  IORWF  71,F
....................       } else { 
16A7:  GOTO   6AB
....................         COR_AUX &= ~larg; 
16A8:  MOVF   2C,W
16A9:  XORLW  FF
16AA:  ANDWF  71,F
....................       } 
....................     break; 
16AB:  GOTO   6AD
16AC:  MOVLB  02
....................   } 
.................... } // }}} 
16AD:  MOVLP  18
16AE:  MOVLB  00
16AF:  GOTO   570 (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
14C8:  MOVLB  01
14C9:  CLRF   65
14CA:  MOVF   65,W
14CB:  SUBLW  02
14CC:  BTFSS  03.0
14CD:  GOTO   50F
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = ((input(AUX_IN_PIN[x])!=0 )|| (AuxIn[x]!=0)); 
14CE:  MOVLW  1F
14CF:  ADDWF  65,W
14D0:  MOVWF  78
14D1:  MOVLW  20
14D2:  MOVWF  7A
14D3:  BTFSC  03.0
14D4:  INCF   7A,F
14D5:  MOVF   78,W
14D6:  MOVWF  66
14D7:  MOVF   7A,W
14D8:  MOVWF  67
14D9:  MOVF   65,W
14DA:  MOVLP  00
14DB:  MOVLB  00
14DC:  CALL   03F
14DD:  MOVLP  10
14DE:  MOVLB  01
14DF:  MOVWF  68
14E0:  MOVLB  02
14E1:  MOVWF  40
14E2:  MOVLW  01
14E3:  MOVWF  41
14E4:  CLRF   43
14E5:  MOVLW  80
14E6:  MOVWF  42
14E7:  MOVLP  08
14E8:  MOVLB  00
14E9:  CALL   0C9
14EA:  MOVLP  10
14EB:  MOVLB  01
14EC:  MOVF   68,W
14ED:  MOVWF  69
14EE:  CLRF   6B
14EF:  CLRF   6A
14F0:  MOVLB  00
14F1:  GOTO   4AE
14F2:  BTFSC  78.0
14F3:  GOTO   504
14F4:  MOVLW  1C
14F5:  MOVLB  01
14F6:  ADDWF  65,W
14F7:  MOVWF  04
14F8:  MOVLW  20
14F9:  MOVWF  05
14FA:  BTFSC  03.0
14FB:  INCF   05,F
14FC:  MOVF   00,F
14FD:  BTFSC  03.2
14FE:  GOTO   501
14FF:  MOVLB  00
1500:  GOTO   504
1501:  MOVLW  00
1502:  GOTO   506
1503:  MOVLB  00
1504:  MOVLW  01
1505:  MOVLB  01
1506:  MOVWF  69
1507:  MOVF   67,W
1508:  MOVWF  05
1509:  MOVF   66,W
150A:  MOVWF  04
150B:  MOVF   69,W
150C:  MOVWF  00
....................   } 
150D:  INCF   65,F
150E:  GOTO   4CA
.................... } // }}} 
150F:  MOVLP  18
1510:  MOVLB  00
1511:  GOTO   71E (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
1C42:  MOVLW  30
1C43:  MOVLB  01
1C44:  MOVWF  68
1C45:  MOVWF  69
1C46:  MOVWF  6A
1C47:  CLRF   6B
....................   char AuxOut_s[4]={'0','0','0',0}; 
1C48:  MOVWF  6C
1C49:  MOVWF  6D
1C4A:  MOVWF  6E
1C4B:  CLRF   6F
....................   char ADM[]=" ADMIN"; 
1C4C:  MOVLW  20
1C4D:  MOVLB  02
1C4E:  MOVWF  20
1C4F:  MOVLW  41
1C50:  MOVWF  21
1C51:  MOVLW  44
1C52:  MOVWF  22
1C53:  MOVLW  4D
1C54:  MOVWF  23
1C55:  MOVLW  49
1C56:  MOVWF  24
1C57:  MOVLW  4E
1C58:  MOVWF  25
1C59:  CLRF   26
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
1C5A:  MOVLB  01
1C5B:  CLRF   65
1C5C:  MOVF   65,W
1C5D:  SUBLW  02
1C5E:  BTFSS  03.0
1C5F:  GOTO   574
....................     AuxOp = AuxOutOp[x]; 
1C60:  MOVLW  33
1C61:  ADDWF  65,W
1C62:  MOVWF  04
1C63:  MOVLW  20
1C64:  MOVWF  05
1C65:  BTFSC  03.0
1C66:  INCF   05,F
1C67:  MOVF   00,W
1C68:  MOVWF  66
....................     AuxArg = AuxOutArg[x]; 
1C69:  MOVLW  36
1C6A:  ADDWF  65,W
1C6B:  MOVWF  04
1C6C:  MOVLW  20
1C6D:  MOVWF  05
1C6E:  BTFSC  03.0
1C6F:  INCF   05,F
1C70:  MOVF   00,W
1C71:  MOVWF  67
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
1C72:  MOVF   66,W
1C73:  MOVLB  02
1C74:  MOVWF  28
1C75:  MOVLB  01
1C76:  MOVF   67,W
1C77:  MOVLB  02
1C78:  MOVWF  29
1C79:  MOVLB  01
1C7A:  MOVF   65,W
1C7B:  MOVLB  02
1C7C:  MOVWF  2A
....................     out_bit = (AuxOut[x])==0; 
*
1CFE:  MOVLB  02
1CFF:  BCF    27.0
1D00:  MOVLW  22
1D01:  MOVLB  01
1D02:  ADDWF  65,W
1D03:  MOVWF  04
1D04:  MOVLW  20
1D05:  MOVWF  05
1D06:  BTFSC  03.0
1D07:  INCF   05,F
1D08:  MOVF   00,F
1D09:  BTFSS  03.2
1D0A:  GOTO   50E
1D0B:  MOVLB  02
1D0C:  BSF    27.0
1D0D:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
1D0E:  MOVF   65,W
1D0F:  MOVLP  00
1D10:  MOVLB  00
1D11:  CALL   03B
1D12:  MOVLP  18
1D13:  MOVLB  02
1D14:  MOVWF  28
1D15:  MOVLW  00
1D16:  BTFSC  27.0
1D17:  MOVLW  01
1D18:  MOVWF  77
1D19:  MOVF   28,W
1D1A:  MOVWF  40
1D1B:  MOVF   77,W
1D1C:  MOVWF  41
1D1D:  MOVLW  01
1D1E:  MOVWF  43
1D1F:  CLRF   42
1D20:  MOVLP  08
1D21:  MOVLB  00
1D22:  CALL   0C9
1D23:  MOVLP  18
1D24:  MOVLB  02
1D25:  MOVF   28,W
1D26:  MOVWF  40
1D27:  CLRF   41
1D28:  CLRF   43
1D29:  MOVLW  80
1D2A:  MOVWF  42
1D2B:  MOVLP  08
1D2C:  MOVLB  00
1D2D:  CALL   0C9
1D2E:  MOVLP  18
....................     if(out_bit==0) { 
1D2F:  MOVLB  02
1D30:  BTFSC  27.0
1D31:  GOTO   53D
....................       AuxOut_s[x]='1'; 
1D32:  MOVLW  9C
1D33:  MOVLB  01
1D34:  ADDWF  65,W
1D35:  MOVWF  04
1D36:  MOVLW  20
1D37:  MOVWF  05
1D38:  BTFSC  03.0
1D39:  INCF   05,F
1D3A:  MOVLW  31
1D3B:  MOVWF  00
1D3C:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
1D3D:  MOVLW  39
1D3E:  MOVLB  01
1D3F:  ADDWF  65,W
1D40:  MOVWF  04
1D41:  MOVLW  20
1D42:  MOVWF  05
1D43:  BTFSC  03.0
1D44:  INCF   05,F
1D45:  MOVF   00,W
1D46:  MOVWF  66
....................     AuxArg = AuxInArg[x]; 
1D47:  MOVLW  3C
1D48:  ADDWF  65,W
1D49:  MOVWF  04
1D4A:  MOVLW  20
1D4B:  MOVWF  05
1D4C:  BTFSC  03.0
1D4D:  INCF   05,F
1D4E:  MOVF   00,W
1D4F:  MOVWF  67
....................     if(AuxInSW[x]==1) { 
1D50:  MOVLW  1F
1D51:  ADDWF  65,W
1D52:  MOVWF  04
1D53:  MOVLW  20
1D54:  MOVWF  05
1D55:  BTFSC  03.0
1D56:  INCF   05,F
1D57:  DECFSZ 00,W
1D58:  GOTO   562
....................       AuxIn_s[x]='1'; 
1D59:  MOVLW  98
1D5A:  ADDWF  65,W
1D5B:  MOVWF  04
1D5C:  MOVLW  20
1D5D:  MOVWF  05
1D5E:  BTFSC  03.0
1D5F:  INCF   05,F
1D60:  MOVLW  31
1D61:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
1D62:  MOVF   66,W
1D63:  MOVLB  02
1D64:  MOVWF  28
1D65:  MOVLB  01
1D66:  MOVF   67,W
1D67:  MOVLB  02
1D68:  MOVWF  29
1D69:  MOVLB  01
1D6A:  MOVF   65,W
1D6B:  MOVLB  02
1D6C:  MOVWF  2A
1D6D:  MOVLP  10
1D6E:  MOVLB  00
1D6F:  GOTO   652
1D70:  MOVLP  18
....................     // }}} 
....................   } 
1D71:  MOVLB  01
1D72:  INCF   65,F
1D73:  GOTO   45C
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
1D74:  MOVLW  20
1D75:  MOVWF  64
1D76:  MOVLW  7A
1D77:  MOVWF  63
1D78:  MOVLW  49
1D79:  MOVLB  02
1D7A:  MOVWF  50
1D7B:  MOVLP  00
1D7C:  MOVLB  00
1D7D:  CALL   7EC
1D7E:  MOVLP  18
1D7F:  MOVLW  3A
1D80:  MOVLB  02
1D81:  MOVWF  50
1D82:  MOVLP  00
1D83:  MOVLB  00
1D84:  CALL   7EC
1D85:  MOVLP  18
1D86:  MOVLW  20
1D87:  MOVWF  05
1D88:  MOVLW  98
1D89:  MOVWF  04
1D8A:  MOVLP  08
1D8B:  CALL   142
1D8C:  MOVLP  18
1D8D:  MOVLW  20
1D8E:  MOVLB  02
1D8F:  MOVWF  50
1D90:  MOVLP  00
1D91:  MOVLB  00
1D92:  CALL   7EC
1D93:  MOVLP  18
1D94:  MOVLW  4F
1D95:  MOVLB  02
1D96:  MOVWF  50
1D97:  MOVLP  00
1D98:  MOVLB  00
1D99:  CALL   7EC
1D9A:  MOVLP  18
1D9B:  MOVLW  3A
1D9C:  MOVLB  02
1D9D:  MOVWF  50
1D9E:  MOVLP  00
1D9F:  MOVLB  00
1DA0:  CALL   7EC
1DA1:  MOVLP  18
1DA2:  MOVLW  20
1DA3:  MOVWF  05
1DA4:  MOVLW  9C
1DA5:  MOVWF  04
1DA6:  MOVLP  08
1DA7:  CALL   142
1DA8:  MOVLP  18
....................   if ( AdminMode ) { 
1DA9:  MOVLB  01
1DAA:  BTFSS  5F.6
1DAB:  GOTO   5BA
....................     strcat(LCD_str,ADM); 
1DAC:  MOVLW  20
1DAD:  MOVLB  02
1DAE:  MOVWF  29
1DAF:  MOVLW  7A
1DB0:  MOVWF  28
1DB1:  MOVLW  20
1DB2:  MOVWF  2B
1DB3:  MOVLW  A0
1DB4:  MOVWF  2A
1DB5:  MOVLP  10
1DB6:  MOVLB  00
1DB7:  CALL   6B8
1DB8:  MOVLP  18
1DB9:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
1DBA:  MOVLW  03
1DBB:  MOVLB  02
1DBC:  MOVWF  4A
1DBD:  MOVLW  20
1DBE:  MOVWF  4C
1DBF:  MOVLW  7A
1DC0:  MOVWF  4B
1DC1:  MOVLP  08
1DC2:  MOVLB  00
1DC3:  CALL   159
1DC4:  MOVLP  18
.................... } // }}} 
1DC5:  MOVLP  18
1DC6:  GOTO   73F (RETURN)
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
0FB4:  MOVLW  01
0FB5:  MOVLB  02
0FB6:  MOVWF  2E
0FB7:  MOVLB  00
0FB8:  CALL   349
....................   delay_ms(1000); 
0FB9:  MOVLW  04
0FBA:  MOVLB  02
0FBB:  MOVWF  2E
0FBC:  MOVLW  FA
0FBD:  MOVWF  4A
0FBE:  MOVLP  00
0FBF:  MOVLB  00
0FC0:  CALL   7C0
0FC1:  MOVLP  08
0FC2:  MOVLB  02
0FC3:  DECFSZ 2E,F
0FC4:  GOTO   7BC
....................   for(x=0;x<6;x++) { 
0FC5:  CLRF   2C
0FC6:  MOVF   2C,W
0FC7:  SUBLW  05
0FC8:  BTFSS  03.0
0FC9:  GOTO   7E4
....................     mchar=Morse[x]; 
0FCA:  MOVLW  2D
0FCB:  ADDWF  2C,W
0FCC:  MOVWF  04
0FCD:  MOVLW  20
0FCE:  MOVWF  05
0FCF:  BTFSC  03.0
0FD0:  INCF   05,F
0FD1:  MOVF   00,W
0FD2:  MOVWF  2D
....................     morse(mchar); 
0FD3:  MOVF   2D,W
0FD4:  MOVWF  3F
0FD5:  MOVLB  00
0FD6:  CALL   070
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
0FD7:  MOVLB  01
0FD8:  CLRF   34
0FD9:  MOVLW  06
0FDA:  MOVWF  33
....................     while(aux_timer) { 
0FDB:  MOVF   33,W
0FDC:  IORWF  34,W
0FDD:  BTFSC  03.2
0FDE:  GOTO   7E1
....................       delay_cycles(1); 
0FDF:  NOP
....................     } 
0FE0:  GOTO   7DB
....................   } 
0FE1:  MOVLB  02
0FE2:  INCF   2C,F
0FE3:  GOTO   7C6
....................   delay_ms(1000); 
0FE4:  MOVLW  04
0FE5:  MOVWF  2E
0FE6:  MOVLW  FA
0FE7:  MOVWF  4A
0FE8:  MOVLP  00
0FE9:  MOVLB  00
0FEA:  CALL   7C0
0FEB:  MOVLP  08
0FEC:  MOVLB  02
0FED:  DECFSZ 2E,F
0FEE:  GOTO   7E6
....................   PROCESS_COR_FLAG=1; 
0FEF:  BSF    7D.1
.................... } // }}} 
0FF0:  MOVLB  00
0FF1:  RETURN
.................... void main (void) { // {{{ 
*
1EDD:  CLRF   05
1EDE:  CLRF   04
1EDF:  MOVLW  1F
1EE0:  ANDWF  03,F
1EE1:  MOVLW  72
1EE2:  MOVLB  01
1EE3:  MOVWF  19
1EE4:  BSF    0E.3
1EE5:  BSF    0E.4
1EE6:  MOVLB  04
1EE7:  BCF    17.0
1EE8:  BCF    17.1
1EE9:  BCF    17.3
1EEA:  MOVLW  13
1EEB:  MOVWF  12
1EEC:  MOVLW  28
1EED:  MOVWF  15
1EEE:  BSF    14.7
1EEF:  BCF    14.6
1EF0:  MOVLW  0C
1EF1:  MOVLB  03
1EF2:  MOVWF  1B
1EF3:  MOVLW  A2
1EF4:  MOVWF  1E
1EF5:  MOVLW  90
1EF6:  MOVWF  1D
1EF7:  MOVLB  01
1EF8:  BSF    62.0
1EF9:  CLRF   64
1EFA:  CLRF   63
1EFB:  MOVLB  0F
1EFC:  CLRF   11
1EFD:  CLRF   12
1EFE:  CLRF   18
1EFF:  CLRF   19
1F00:  CLRF   1A
1F01:  MOVLB  03
1F02:  CLRF   0C
1F03:  CLRF   0D
1F04:  CLRF   0F
1F05:  CLRF   10
1F06:  MOVLB  02
1F07:  CLRF   12
1F08:  CLRF   11
1F09:  CLRF   14
1F0A:  CLRF   13
....................   initialize(); 
*
1F0E:  MOVLP  08
1F0F:  GOTO   49C
1F10:  MOVLP  18
.................... #ignore_warnings 203 
....................   while(1) { // {{{ 
.................... #ignore_warnings none 
....................     restart_wdt(); 
1F11:  CLRWDT
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "\r" or "+" or "-" is received. 
....................     if ( sBufferFlag ) { 
1F12:  BTFSS  7D.0
1F13:  GOTO   719
....................       process_sBuffer(); 
1F14:  GOTO   000
....................       clear_sBuffer(); 
1F15:  MOVLP  00
1F16:  CALL   487
1F17:  MOVLP  18
....................       sBufferFlag=0; 
1F18:  BCF    7D.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1F19:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1F1A:  BTFSS  7D.7
1F1B:  GOTO   723
....................       update_aux_in(); 
1F1C:  MOVLP  10
1F1D:  GOTO   4C8
1F1E:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1F1F:  BCF    7D.7
....................       AUX_OUT_FLAG=1; 
1F20:  MOVLB  01
1F21:  BSF    5F.0
1F22:  MOVLB  00
....................     } 
....................     do_delay_counters(); 
1F23:  MOVLP  10
1F24:  GOTO   512
1F25:  MOVLP  18
....................     restart_wdt(); 
1F26:  CLRWDT
....................     if ( COR_IN_FLAG ) { 
1F27:  BTFSS  7D.2
1F28:  GOTO   730
....................       PROCESS_COR_FLAG = read_cor_in_ports(); 
1F29:  MOVLP  10
1F2A:  GOTO   5B1
1F2B:  MOVLP  18
1F2C:  BCF    7D.1
1F2D:  BTFSC  78.0
1F2E:  BSF    7D.1
....................       COR_IN_FLAG = 0; 
1F2F:  BCF    7D.2
....................     } 
....................     if ( PROCESS_COR_FLAG ) { 
1F30:  BTFSS  7D.1
1F31:  GOTO   73A
....................       process_cor(); 
1F32:  MOVLP  10
1F33:  GOTO   5D1
1F34:  MOVLP  18
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       AUX_OUT_FLAG=1; 
1F35:  MOVLB  01
1F36:  BSF    5F.0
....................       PROCESS_COR_FLAG=0; 
1F37:  BCF    7D.1
....................       restart_wdt(); 
1F38:  CLRWDT
1F39:  MOVLB  00
....................     } 
....................     if ( AUX_OUT_FLAG ) { 
1F3A:  MOVLB  01
1F3B:  BTFSS  5F.0
1F3C:  GOTO   741
....................       update_aux_out();  
1F3D:  MOVLB  00
1F3E:  GOTO   442
....................       AUX_OUT_FLAG=0; 
1F3F:  MOVLB  01
1F40:  BCF    5F.0
....................     } 
....................     if ( DTMF_INTERRUPT_FLAG ) { 
1F41:  BTFSS  5F.3
1F42:  GOTO   749
....................       // Extract data from DTMF device 
....................       process_dtmf_interrupt(); 
1F43:  MOVLP  10
1F44:  MOVLB  00
1F45:  GOTO   6F1
1F46:  MOVLP  18
....................       DTMF_INTERRUPT_FLAG=0; 
1F47:  MOVLB  01
1F48:  BCF    5F.3
....................     } 
....................     if ( DTMF_IN_FLAG ) { 
1F49:  BTFSS  5F.2
1F4A:  GOTO   752
....................       print_dtmf_info(); 
1F4B:  MOVLP  10
1F4C:  MOVLB  00
1F4D:  GOTO   743
1F4E:  MOVLP  18
....................       DTMF_IN_FLAG=0; 
1F4F:  MOVLB  01
1F50:  BCF    5F.2
....................       restart_wdt(); 
1F51:  CLRWDT
....................     } 
....................     if ( DTMF_FLAG ) { 
1F52:  BTFSS  5F.1
1F53:  GOTO   759
....................       process_dtmf(); 
1F54:  MOVLB  00
1F55:  GOTO   5C7
....................       DTMF_FLAG=0; 
1F56:  MOVLB  01
1F57:  BCF    5F.1
....................     restart_wdt(); 
1F58:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1F59:  BTFSS  5F.4
1F5A:  GOTO   75F
....................       clear_dtmf_array(); 
1F5B:  MOVLB  00
1F5C:  GOTO   6C6
....................       CLEAR_DTMF_FLAG=0; 
1F5D:  MOVLB  01
1F5E:  BCF    5F.4
....................     } 
....................     if ( PROMPT_FLAG ) { 
1F5F:  BTFSS  5F.5
1F60:  GOTO   768
....................       prompt(); 
1F61:  MOVLP  08
1F62:  MOVLB  00
1F63:  CALL   79C
1F64:  MOVLP  18
....................       PROMPT_FLAG=0; 
1F65:  MOVLB  01
1F66:  BCF    5F.5
....................     restart_wdt(); 
1F67:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1F68:  MOVLB  00
1F69:  GOTO   711
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0B75:  CLRWDT
*
1F6A:  SLEEP
....................   delay_ms(1000); 
*
0B76:  MOVLW  04
0B77:  MOVWF  3F
0B78:  MOVLW  FA
0B79:  MOVWF  4A
0B7A:  MOVLP  00
0B7B:  MOVLB  00
0B7C:  CALL   7C0
0B7D:  MOVLP  08
0B7E:  MOVLB  02
0B7F:  DECFSZ 3F,F
0B80:  GOTO   378
....................   if ( ConfirmChar!=0 ) { 
0B81:  MOVF   73,F
0B82:  BTFSC  03.2
0B83:  GOTO   396
....................     morse(ConfirmChar); 
0B84:  MOVF   73,W
0B85:  MOVWF  3F
0B86:  MOVLB  00
0B87:  CALL   070
....................     ConfirmChar=0; 
0B88:  CLRF   73
....................     restart_wdt(); 
0B89:  CLRWDT
....................     delay_ms(500); 
0B8A:  MOVLW  02
0B8B:  MOVLB  02
0B8C:  MOVWF  3F
0B8D:  MOVLW  FA
0B8E:  MOVWF  4A
0B8F:  MOVLP  00
0B90:  MOVLB  00
0B91:  CALL   7C0
0B92:  MOVLP  08
0B93:  MOVLB  02
0B94:  DECFSZ 3F,F
0B95:  GOTO   38D
....................   } 
....................   if (TailChar != 0) { 
0B96:  MOVF   72,F
0B97:  BTFSC  03.2
0B98:  GOTO   3AB
....................     morse(TailChar); 
0B99:  MOVF   72,W
0B9A:  MOVWF  3F
0B9B:  MOVLB  00
0B9C:  CALL   070
....................     TailChar=0; 
0B9D:  CLRF   72
....................     restart_wdt(); 
0B9E:  CLRWDT
....................     delay_ms(500); 
0B9F:  MOVLW  02
0BA0:  MOVLB  02
0BA1:  MOVWF  3F
0BA2:  MOVLW  FA
0BA3:  MOVWF  4A
0BA4:  MOVLP  00
0BA5:  MOVLB  00
0BA6:  CALL   7C0
0BA7:  MOVLP  08
0BA8:  MOVLB  02
0BA9:  DECFSZ 3F,F
0BAA:  GOTO   3A2
....................   } 
....................   restart_wdt(); 
0BAB:  CLRWDT
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
0F02:  MOVLB  01
0F03:  BTFSS  5F.6
0F04:  GOTO   707
....................     admin_timer = ADMIN_TIMEOUT; 
0F05:  MOVLW  FF
0F06:  MOVWF  7E
....................   } 
....................   return(AdminMode||rs232_mode); 
0F07:  BTFSC  5F.6
0F08:  GOTO   70D
0F09:  BTFSC  5F.7
0F0A:  GOTO   70D
0F0B:  MOVLW  00
0F0C:  GOTO   70E
0F0D:  MOVLW  01
0F0E:  MOVWF  78
.................... } // }}} 
0F0F:  MOVLB  00
0F10:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0C87:  MOVLB  01
0C88:  BCF    5F.6
0C89:  MOVLB  02
0C8A:  MOVF   40,F
0C8B:  BTFSC  03.2
0C8C:  GOTO   490
0C8D:  MOVLB  01
0C8E:  BSF    5F.6
0C8F:  MOVLB  02
....................   if (AdminMode) { 
0C90:  MOVLB  01
0C91:  BTFSS  5F.6
0C92:  GOTO   498
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0C93:  MOVLW  0A
0C94:  MOVWF  73
....................     admin_timer = ADMIN_TIMEOUT; 
0C95:  MOVLW  FF
0C96:  MOVWF  7E
....................   } else { 
0C97:  GOTO   49A
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0C98:  MOVLW  18
0C99:  MOVWF  73
....................   }  
.................... } // }}} 
0C9A:  MOVLB  00
0C9B:  RETURN
.................... // string matchnig function with case insensitive match. 
.................... int1 my_stricmp(char *s1,char *s2) { // {{{ 
*
0E98:  MOVLB  02
0E99:  CLRF   43
....................   unsigned int x=0; 
....................   const char AMASK=0xDF; 
....................   while((AMASK&s1[x])==(AMASK&s2[x])) { 
0E9A:  MOVF   43,W
0E9B:  ADDWF  3F,W
0E9C:  MOVWF  04
0E9D:  MOVLW  00
0E9E:  ADDWFC 40,W
0E9F:  MOVWF  05
0EA0:  MOVF   00,W
0EA1:  ANDLW  DF
0EA2:  MOVWF  44
0EA3:  MOVF   43,W
0EA4:  ADDWF  41,W
0EA5:  MOVWF  04
0EA6:  MOVLW  00
0EA7:  ADDWFC 42,W
0EA8:  MOVWF  05
0EA9:  MOVF   00,W
0EAA:  ANDLW  DF
0EAB:  SUBWF  44,W
0EAC:  BTFSS  03.2
0EAD:  GOTO   6BC
....................     if(s1[x]==0) { 
0EAE:  MOVF   43,W
0EAF:  ADDWF  3F,W
0EB0:  MOVWF  04
0EB1:  MOVLW  00
0EB2:  ADDWFC 40,W
0EB3:  MOVWF  05
0EB4:  MOVF   00,F
0EB5:  BTFSS  03.2
0EB6:  GOTO   6BA
....................       return 0; 
0EB7:  MOVLW  00
0EB8:  MOVWF  78
0EB9:  GOTO   6BE
....................     } 
....................     x++; 
0EBA:  INCF   43,F
....................   } 
0EBB:  GOTO   69A
....................   // Strings don't match. Return 1. 
....................   return 1; 
0EBC:  MOVLW  01
0EBD:  MOVWF  78
.................... } // }}} 
0EBE:  MOVLB  00
0EBF:  RETURN
.................... // Fetches data from MC8888 device upon interrupt 
.................... void process_dtmf_interrupt(void) { // {{{ 
....................   int value,dtmf_status; 
....................   dtmf_status = dtmf_read(CONTROL_REG); 
*
16F1:  MOVLW  01
16F2:  MOVLB  02
16F3:  MOVWF  3B
16F4:  MOVLP  00
16F5:  MOVLB  00
16F6:  CALL   664
16F7:  MOVLP  10
16F8:  MOVF   78,W
16F9:  MOVLB  01
16FA:  MOVWF  66
....................   if ( dtmf_status & DTMF_BUFFER_FULL) { 
16FB:  BTFSS  66.2
16FC:  GOTO   740
....................     value=dtmf_read(DATA_REG); 
16FD:  MOVLB  02
16FE:  CLRF   3B
16FF:  MOVLP  00
1700:  MOVLB  00
1701:  CALL   664
1702:  MOVLP  10
1703:  MOVF   78,W
1704:  MOVLB  01
1705:  MOVWF  65
....................     DTMF_IN_FLAG=1; 
1706:  BSF    5F.2
....................     if ( value == dd ) { 
1707:  MOVF   65,F
1708:  BTFSS  03.2
1709:  GOTO   70D
....................       value=d0; 
170A:  MOVLW  0A
170B:  MOVWF  65
....................     } else if ( value == d0 ) { 
170C:  GOTO   711
170D:  MOVF   65,W
170E:  SUBLW  0A
170F:  BTFSC  03.2
....................       value=dd; 
1710:  CLRF   65
....................     } 
....................     if ( value == ds ) { 
1711:  MOVF   65,W
1712:  SUBLW  0B
1713:  BTFSC  03.2
....................       CLEAR_DTMF_FLAG=1; 
1714:  BSF    5F.4
....................     } 
....................     // Check for '#' 
....................     if ( value == dp ) { 
1715:  MOVF   65,W
1716:  SUBLW  0C
1717:  BTFSS  03.2
1718:  GOTO   721
....................       DTMF_FLAG = 1; 
1719:  BSF    5F.1
....................       DTMF_ptr->Last=1; 
171A:  MOVF   40,W
171B:  MOVWF  04
171C:  MOVF   41,W
171D:  MOVWF  05
171E:  ADDFSR 00,FSR0
171F:  BSF    00.5
....................     } else { 
1720:  GOTO   740
....................       if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
1721:  MOVF   41,W
1722:  SUBLW  20
1723:  BTFSS  03.0
1724:  GOTO   740
1725:  BTFSS  03.2
1726:  GOTO   72B
1727:  MOVF   40,W
1728:  SUBLW  6F
1729:  BTFSS  03.0
172A:  GOTO   740
....................         DTMF_ptr->Key=value; 
172B:  MOVF   40,W
172C:  MOVWF  04
172D:  MOVF   41,W
172E:  MOVWF  05
172F:  ADDFSR 00,FSR0
1730:  MOVF   65,W
1731:  ANDLW  0F
1732:  MOVWF  77
1733:  MOVLW  F0
1734:  ANDWF  00,W
1735:  IORWF  77,W
1736:  MOVWF  00
....................         DTMF_ptr->Strobe=1; 
1737:  MOVF   40,W
1738:  MOVWF  04
1739:  MOVF   41,W
173A:  MOVWF  05
173B:  ADDFSR 00,FSR0
173C:  BSF    00.4
....................         DTMF_ptr++; 
173D:  INCF   40,F
173E:  BTFSC  03.2
173F:  INCF   41,F
....................       } 
....................     } 
....................   } 
.................... } // }}} 
1740:  MOVLP  18
1741:  MOVLB  00
1742:  GOTO   746 (RETURN)
.................... void init_lcd(void) { // {{{ 
.................... #define INIT 0x18 
.................... #define MODE_SET 0x1C 
.................... #define ENABLE 0x04 
....................   i2c_start(); 
....................   i2c_write(LCD_I2C_ADD<<1); 
....................   // Function set 
....................   // Initialize in 8-bit mode first for 3 clock cycles 
....................   lcd_strobe(0x30);lcd_strobe(0x30);lcd_strobe(0x30); 
....................   // Init 4-bit interface mode 
....................   lcd_strobe(0x20); 
....................   lcd_write(0,0x2C); 
....................   // Display On/Off, Cursor off 
....................   lcd_write(0,0x0C); 
....................   // Display clear 
....................   lcd_write(0,0x01); 
....................   // Entry mode set 
....................   lcd_write(0,0x04); 
....................   i2c_stop(); 
.................... } // }}} 
....................  
.................... void do_delay_counters(void) { 
....................   // Second Flag {{{ 
....................   if ( SECOND_FLAG ) { 
*
1512:  BTFSS  7D.3
1513:  GOTO   575
....................     if ((COR_IN_EFFECTIVE != 0x00) && (QSO_Duration != 0xFFFF )) { 
1514:  MOVF   61,F
1515:  BTFSC  03.2
1516:  GOTO   51F
1517:  INCFSZ 6B,W
1518:  GOTO   51C
1519:  INCFSZ 6C,W
151A:  GOTO   51C
151B:  GOTO   51F
....................       QSO_Duration++;  
151C:  INCF   6B,F
151D:  BTFSC  03.2
151E:  INCF   6C,F
....................     } 
....................     AUX_OUT_FLAG=1; 
151F:  MOVLB  01
1520:  BSF    5F.0
....................     // Time Out PTT {{{ 
....................     if ( (TOT_Min > 0) && (QSO_Duration >= (TOT_Min*60))) { 
1521:  MOVLB  00
1522:  MOVF   68,F
1523:  BTFSS  03.2
1524:  GOTO   528
1525:  MOVF   69,F
1526:  BTFSC  03.2
1527:  GOTO   558
1528:  MOVF   69,W
1529:  MOVLB  02
152A:  MOVWF  3E
152B:  MOVLB  00
152C:  MOVF   68,W
152D:  MOVLB  02
152E:  MOVWF  3D
152F:  CLRF   40
1530:  MOVLW  3C
1531:  MOVWF  3F
1532:  MOVLP  08
1533:  MOVLB  00
1534:  CALL   6C0
1535:  MOVLP  10
1536:  MOVF   79,W
1537:  MOVWF  7A
1538:  MOVF   7A,W
1539:  SUBWF  6C,W
153A:  BTFSS  03.0
153B:  GOTO   558
153C:  BTFSS  03.2
153D:  GOTO   542
153E:  MOVF   78,W
153F:  SUBWF  6B,W
1540:  BTFSS  03.0
1541:  GOTO   558
....................       if ( TOT_FLAG_Mask == 0 ) { 
1542:  MOVF   6A,F
1543:  BTFSS  03.2
1544:  GOTO   556
....................         printf("\n\r# PTT Timeout!\n"); 
1545:  MOVLW  74
1546:  MOVLB  03
1547:  MOVWF  11
1548:  MOVLW  04
1549:  MOVWF  12
154A:  MOVLP  00
154B:  MOVLB  00
154C:  CALL   4A1
154D:  MOVLP  10
....................         PROMPT_FLAG=1; 
154E:  MOVLB  01
154F:  BSF    5F.5
....................         update_ptt(0); 
1550:  MOVLB  02
1551:  CLRF   2E
1552:  MOVLP  08
1553:  MOVLB  00
1554:  CALL   349
1555:  MOVLP  10
....................       } 
....................       TOT_FLAG_Mask=COR_IN_EFFECTIVE; 
1556:  MOVF   61,W
1557:  MOVWF  6A
....................     } 
....................     // }}} 
....................     // AuxOutDelayCnt {{{ 
....................     if ( AuxOutDelayCnt ) { 
1558:  MOVLB  01
1559:  MOVF   35,F
155A:  BTFSS  03.2
....................       AuxOutDelayCnt--; 
155B:  DECF   35,F
....................     } 
....................     // }}} 
....................     // Admin mode timeout {{{ 
....................     if ( admin_timer ) { 
155C:  MOVF   7E,F
155D:  BTFSC  03.2
155E:  GOTO   561
....................       admin_timer--; 
155F:  DECF   7E,F
....................     } else { 
1560:  GOTO   56A
....................       // Exit admin mode. 
....................       if ( AdminMode ) { 
1561:  BTFSS  5F.6
1562:  GOTO   56A
....................         set_admin_mode(0); 
1563:  MOVLB  02
1564:  CLRF   40
1565:  MOVLP  08
1566:  MOVLB  00
1567:  CALL   487
1568:  MOVLP  10
1569:  MOVLB  01
....................       } 
....................     } 
....................     // }}} 
....................     restart_wdt(); 
156A:  CLRWDT
....................     if ( SecondCounter ) { 
156B:  MOVF   60,F
156C:  BTFSC  03.2
156D:  GOTO   570
....................       SecondCounter--; 
156E:  DECF   60,F
....................     } else { 
156F:  GOTO   573
....................       SecondCounter=SEC_COUNTER; 
1570:  MOVLW  3B
1571:  MOVWF  60
....................       MINUTE_FLAG = 1; 
1572:  BSF    7D.4
....................     } 
....................     SECOND_FLAG=0; 
1573:  BCF    7D.3
1574:  MOVLB  00
....................   } 
....................   // Second Flag }}} 
....................   // Minute flag {{{ 
....................   if ( MINUTE_FLAG ) { 
1575:  BTFSS  7D.4
1576:  GOTO   594
....................     if ( MinuteCounter ) { 
1577:  MOVLB  01
1578:  MOVF   61,F
1579:  BTFSC  03.2
157A:  GOTO   57D
....................       MinuteCounter--; 
157B:  DECF   61,F
....................     } else { 
157C:  GOTO   580
....................       THIRTY_MIN_FLAG=1; 
157D:  BSF    7D.5
....................       MinuteCounter = MIN_COUNTER; 
157E:  MOVLW  1D
157F:  MOVWF  61
....................     } 
....................     MINUTE_FLAG = 0; 
1580:  BCF    7D.4
....................     // Link timeout timer {{{ 
....................     if ( Link_TOT != 0 ) { 
1581:  MOVLB  00
1582:  MOVF   6D,F
1583:  BTFSC  03.2
1584:  GOTO   594
....................       if ( LinkDurationTimer ) { 
1585:  MOVF   6E,F
1586:  BTFSC  03.2
1587:  GOTO   58A
....................         LinkDurationTimer--; 
1588:  DECF   6E,F
....................       } else { 
1589:  GOTO   594
....................         // Disable Link 
....................         printf("\n\r# Link Timeout!\n"); 
158A:  MOVLW  7D
158B:  MOVLB  03
158C:  MOVWF  11
158D:  MOVLW  04
158E:  MOVWF  12
158F:  MOVLP  00
1590:  MOVLB  00
1591:  CALL   4A1
1592:  MOVLP  10
....................         Enable&=0xFE; 
1593:  BCF    62.0
....................       } 
....................     } 
....................     // Link timeout timer }}} 
....................   } 
....................   // Minute flag }}} 
....................   if ( THIRTY_MIN_FLAG ) { // {{{ 
1594:  BTFSS  7D.5
1595:  GOTO   5AF
....................     if ( (TXSiteID&0x03) !=0 ) { 
1596:  MOVF   66,W
1597:  ANDLW  03
1598:  BTFSC  03.2
1599:  GOTO   5AE
....................       // Transmit Site ID every 30 mins when: 
....................       // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................       // E = Transmit every 30 mins 
....................       // M = Transmit only if EnableMask is off 
....................       if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
159A:  MOVF   66,W
159B:  ANDLW  01
159C:  BTFSS  03.2
159D:  GOTO   5AB
159E:  MOVF   66,W
159F:  ANDLW  02
15A0:  BTFSC  03.2
15A1:  GOTO   5AE
15A2:  SWAPF  66,W
15A3:  MOVWF  77
15A4:  MOVLW  0F
15A5:  ANDWF  77,F
15A6:  MOVF   77,W
15A7:  ANDLW  0F
15A8:  ANDWF  62,W
15A9:  BTFSS  03.2
15AA:  GOTO   5AE
....................         send_morse_id(); 
15AB:  MOVLP  08
15AC:  CALL   7B4
15AD:  MOVLP  10
....................       } 
....................     } 
....................     THIRTY_MIN_FLAG=0; 
15AE:  BCF    7D.5
....................   } // }}} 
.................... } 
15AF:  MOVLP  18
15B0:  GOTO   725 (RETURN)
....................  

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
