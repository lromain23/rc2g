CCS PCM C Compiler, Version 4.140, 64991               10-Jan-21 12:05

               Filename:   C:\Users\Luc\Projects\RC2G Branches\RC2G_a\54_Nicolas\Firmware.lst

               ROM used:   8171 words (100%)
                           Largest free fragment is 10
               RAM used:   172 (34%) at main() level
                           243 (47%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   5C7
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   357
002D:  MOVLP  00
002E:  GOTO   3CA
002F:  MOVLP  00
0030:  GOTO   2E1
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #device ADC=8; 
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
1666:  MOVLB  02
1667:  MOVF   30,W
1668:  MOVWF  34
1669:  MOVF   2F,W
166A:  MOVWF  33
166B:  MOVF   34,W
166C:  MOVWF  7A
166D:  MOVF   33,W
166E:  MOVWF  04
166F:  MOVF   7A,W
1670:  MOVWF  05
1671:  MOVF   00,F
1672:  BTFSC  03.2
1673:  GOTO   678
1674:  INCF   33,F
1675:  BTFSC  03.2
1676:  INCF   34,F
1677:  GOTO   66B
....................    while(*s2 != '\0') 
....................    { 
1678:  MOVF   32,W
1679:  MOVWF  7A
167A:  MOVF   31,W
167B:  MOVWF  04
167C:  MOVF   7A,W
167D:  MOVWF  05
167E:  MOVF   00,F
167F:  BTFSC  03.2
1680:  GOTO   694
....................       *s = *s2; 
1681:  MOVF   31,W
1682:  MOVWF  04
1683:  MOVF   32,W
1684:  MOVWF  05
1685:  MOVF   00,W
1686:  MOVWF  37
1687:  MOVF   34,W
1688:  MOVWF  05
1689:  MOVF   33,W
168A:  MOVWF  04
168B:  MOVF   37,W
168C:  MOVWF  00
....................       ++s; 
168D:  INCF   33,F
168E:  BTFSC  03.2
168F:  INCF   34,F
....................       ++s2; 
1690:  INCF   31,F
1691:  BTFSC  03.2
1692:  INCF   32,F
....................    } 
1693:  GOTO   678
....................  
....................    *s = '\0'; 
1694:  MOVF   33,W
1695:  MOVWF  04
1696:  MOVF   34,W
1697:  MOVWF  05
1698:  CLRF   00
....................    return(s1); 
1699:  MOVF   2F,W
169A:  MOVWF  78
169B:  MOVF   30,W
169C:  MOVWF  79
.................... } 
169D:  MOVLB  00
169E:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E91:  MOVF   4E,W
0E92:  MOVWF  52
0E93:  MOVF   4D,W
0E94:  MOVWF  51
0E95:  MOVF   52,W
0E96:  MOVWF  7A
0E97:  MOVF   51,W
0E98:  MOVWF  04
0E99:  MOVF   7A,W
0E9A:  MOVWF  05
0E9B:  MOVF   00,F
0E9C:  BTFSC  03.2
0E9D:  GOTO   6CA
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0E9E:  MOVF   50,W
0E9F:  MOVWF  54
0EA0:  MOVF   4F,W
0EA1:  MOVWF  53
0EA2:  MOVF   54,W
0EA3:  MOVWF  7A
0EA4:  MOVF   53,W
0EA5:  MOVWF  04
0EA6:  MOVF   7A,W
0EA7:  MOVWF  05
0EA8:  MOVF   00,F
0EA9:  BTFSC  03.2
0EAA:  GOTO   6C6
....................          if (*sc1 == *sc2) 
0EAB:  MOVF   52,W
0EAC:  MOVWF  7A
0EAD:  MOVF   51,W
0EAE:  MOVWF  04
0EAF:  MOVF   7A,W
0EB0:  MOVWF  05
0EB1:  MOVF   00,W
0EB2:  MOVWF  55
0EB3:  MOVF   54,W
0EB4:  MOVWF  7A
0EB5:  MOVF   53,W
0EB6:  MOVWF  04
0EB7:  MOVF   7A,W
0EB8:  MOVWF  05
0EB9:  MOVF   00,W
0EBA:  SUBWF  55,W
0EBB:  BTFSS  03.2
0EBC:  GOTO   6C2
....................             return(sc1); 
0EBD:  MOVF   51,W
0EBE:  MOVWF  78
0EBF:  MOVF   52,W
0EC0:  MOVWF  79
0EC1:  GOTO   6CD
0EC2:  INCF   53,F
0EC3:  BTFSC  03.2
0EC4:  INCF   54,F
0EC5:  GOTO   6A2
0EC6:  INCF   51,F
0EC7:  BTFSC  03.2
0EC8:  INCF   52,F
0EC9:  GOTO   695
....................    return(0); 
0ECA:  MOVLW  00
0ECB:  MOVWF  78
0ECC:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E2A:  MOVF   4E,W
0E2B:  MOVWF  52
0E2C:  MOVF   4D,W
0E2D:  MOVWF  51
0E2E:  MOVF   52,W
0E2F:  MOVWF  7A
0E30:  MOVF   51,W
0E31:  MOVWF  04
0E32:  MOVF   7A,W
0E33:  MOVWF  05
0E34:  MOVF   00,F
0E35:  BTFSC  03.2
0E36:  GOTO   668
....................       for (sc2 = s2; ; sc2++) 
0E37:  MOVF   50,W
0E38:  MOVWF  54
0E39:  MOVF   4F,W
0E3A:  MOVWF  53
....................     if (*sc2 == '\0') 
0E3B:  MOVF   54,W
0E3C:  MOVWF  7A
0E3D:  MOVF   53,W
0E3E:  MOVWF  04
0E3F:  MOVF   7A,W
0E40:  MOVWF  05
0E41:  MOVF   00,F
0E42:  BTFSS  03.2
0E43:  GOTO   64E
....................        return(sc1 - s1); 
0E44:  MOVF   4D,W
0E45:  SUBWF  51,W
0E46:  MOVWF  77
0E47:  MOVF   4E,W
0E48:  SUBWFC 52,W
0E49:  MOVWF  7A
0E4A:  MOVF   77,W
0E4B:  MOVWF  78
0E4C:  GOTO   670
....................          else if (*sc1 == *sc2) 
0E4D:  GOTO   660
0E4E:  MOVF   52,W
0E4F:  MOVWF  7A
0E50:  MOVF   51,W
0E51:  MOVWF  04
0E52:  MOVF   7A,W
0E53:  MOVWF  05
0E54:  MOVF   00,W
0E55:  MOVWF  55
0E56:  MOVF   54,W
0E57:  MOVWF  7A
0E58:  MOVF   53,W
0E59:  MOVWF  04
0E5A:  MOVF   7A,W
0E5B:  MOVWF  05
0E5C:  MOVF   00,W
0E5D:  SUBWF  55,W
0E5E:  BTFSC  03.2
....................             break; 
0E5F:  GOTO   664
0E60:  INCF   53,F
0E61:  BTFSC  03.2
0E62:  INCF   54,F
0E63:  GOTO   63B
0E64:  INCF   51,F
0E65:  BTFSC  03.2
0E66:  INCF   52,F
0E67:  GOTO   62E
....................    return(sc1 - s1); 
0E68:  MOVF   4D,W
0E69:  SUBWF  51,W
0E6A:  MOVWF  77
0E6B:  MOVF   4E,W
0E6C:  SUBWFC 52,W
0E6D:  MOVWF  7A
0E6E:  MOVF   77,W
0E6F:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1DF5:  MOVLB  00
1DF6:  CLRF   26
1DF7:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0E11:  MOVLB  02
0E12:  MOVF   45,W
0E13:  IORWF  46,W
0E14:  BTFSC  03.2
0E15:  GOTO   61A
0E16:  MOVF   46,W
0E17:  MOVWF  7A
0E18:  MOVF   45,W
0E19:  GOTO   61F
0E1A:  MOVLB  00
0E1B:  MOVF   27,W
0E1C:  MOVWF  7A
0E1D:  MOVF   26,W
0E1E:  MOVLB  02
0E1F:  MOVWF  49
0E20:  MOVF   7A,W
0E21:  MOVWF  4A
....................    beg += strspn(beg, s2); 
0E22:  MOVF   4A,W
0E23:  MOVWF  4E
0E24:  MOVF   49,W
0E25:  MOVWF  4D
0E26:  MOVF   48,W
0E27:  MOVWF  50
0E28:  MOVF   47,W
0E29:  MOVWF  4F
*
0E70:  MOVF   78,W
0E71:  ADDWF  49,F
0E72:  MOVLW  00
0E73:  ADDWFC 4A,F
....................    if (*beg == '\0') 
0E74:  MOVF   4A,W
0E75:  MOVWF  7A
0E76:  MOVF   49,W
0E77:  MOVWF  04
0E78:  MOVF   7A,W
0E79:  MOVWF  05
0E7A:  MOVF   00,F
0E7B:  BTFSS  03.2
0E7C:  GOTO   689
....................    { 
....................       *save = ' '; 
0E7D:  MOVLB  00
0E7E:  MOVF   26,W
0E7F:  MOVWF  04
0E80:  MOVF   27,W
0E81:  MOVWF  05
0E82:  MOVLW  20
0E83:  MOVWF  00
....................       return(0); 
0E84:  MOVLW  00
0E85:  MOVWF  78
0E86:  MOVWF  79
0E87:  GOTO   6EE
0E88:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0E89:  MOVF   4A,W
0E8A:  MOVWF  4E
0E8B:  MOVF   49,W
0E8C:  MOVWF  4D
0E8D:  MOVF   48,W
0E8E:  MOVWF  50
0E8F:  MOVF   47,W
0E90:  MOVWF  4F
*
0ECD:  MOVF   79,W
0ECE:  MOVWF  4C
0ECF:  MOVF   78,W
0ED0:  MOVWF  4B
....................    if (*end != '\0') 
0ED1:  MOVF   4C,W
0ED2:  MOVWF  7A
0ED3:  MOVF   4B,W
0ED4:  MOVWF  04
0ED5:  MOVF   7A,W
0ED6:  MOVWF  05
0ED7:  MOVF   00,F
0ED8:  BTFSC  03.2
0ED9:  GOTO   6E2
....................    { 
....................       *end = '\0'; 
0EDA:  MOVF   4B,W
0EDB:  MOVWF  04
0EDC:  MOVF   4C,W
0EDD:  MOVWF  05
0EDE:  CLRF   00
....................       end++; 
0EDF:  INCF   4B,F
0EE0:  BTFSC  03.2
0EE1:  INCF   4C,F
....................    } 
....................    save = end; 
0EE2:  MOVF   4C,W
0EE3:  MOVLB  00
0EE4:  MOVWF  27
0EE5:  MOVLB  02
0EE6:  MOVF   4B,W
0EE7:  MOVLB  00
0EE8:  MOVWF  26
....................    return(beg); 
0EE9:  MOVLB  02
0EEA:  MOVF   49,W
0EEB:  MOVWF  78
0EEC:  MOVF   4A,W
0EED:  MOVWF  79
0EEE:  MOVLB  00
.................... } 
0EEF:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
0F50:  MOVLB  02
0F51:  MOVF   46,W
0F52:  MOVWF  7A
0F53:  MOVF   45,W
0F54:  MOVWF  04
0F55:  MOVF   7A,W
0F56:  MOVWF  05
0F57:  MOVF   00,W
0F58:  MOVWF  49
0F59:  MOVF   48,W
0F5A:  MOVWF  7A
0F5B:  MOVF   47,W
0F5C:  MOVWF  04
0F5D:  MOVF   7A,W
0F5E:  MOVWF  05
0F5F:  MOVF   00,W
0F60:  SUBWF  49,W
0F61:  BTFSC  03.2
0F62:  GOTO   7B9
0F63:  MOVF   46,W
0F64:  MOVWF  7A
0F65:  MOVF   45,W
0F66:  MOVWF  04
0F67:  MOVF   7A,W
0F68:  MOVWF  05
0F69:  MOVF   00,W
0F6A:  MOVWF  49
0F6B:  MOVF   49,W
0F6C:  SUBLW  40
0F6D:  BTFSC  03.0
0F6E:  GOTO   773
0F6F:  MOVF   49,W
0F70:  SUBLW  5A
0F71:  BTFSC  03.0
0F72:  GOTO   77B
0F73:  MOVF   49,W
0F74:  SUBLW  60
0F75:  BTFSC  03.0
0F76:  GOTO   7CF
0F77:  MOVF   49,W
0F78:  SUBLW  7A
0F79:  BTFSS  03.0
0F7A:  GOTO   7CF
0F7B:  MOVF   48,W
0F7C:  MOVWF  7A
0F7D:  MOVF   47,W
0F7E:  MOVWF  04
0F7F:  MOVF   7A,W
0F80:  MOVWF  05
0F81:  MOVF   00,W
0F82:  MOVWF  49
0F83:  MOVF   49,W
0F84:  SUBLW  40
0F85:  BTFSC  03.0
0F86:  GOTO   78B
0F87:  MOVF   49,W
0F88:  SUBLW  5A
0F89:  BTFSC  03.0
0F8A:  GOTO   793
0F8B:  MOVF   49,W
0F8C:  SUBLW  60
0F8D:  BTFSC  03.0
0F8E:  GOTO   7CF
0F8F:  MOVF   49,W
0F90:  SUBLW  7A
0F91:  BTFSS  03.0
0F92:  GOTO   7CF
0F93:  MOVF   46,W
0F94:  MOVWF  7A
0F95:  MOVF   45,W
0F96:  MOVWF  04
0F97:  MOVF   7A,W
0F98:  MOVWF  05
0F99:  MOVF   00,W
0F9A:  MOVWF  49
0F9B:  MOVF   48,W
0F9C:  MOVWF  7A
0F9D:  MOVF   47,W
0F9E:  MOVWF  04
0F9F:  MOVF   7A,W
0FA0:  MOVWF  05
0FA1:  MOVLW  20
0FA2:  ADDWF  00,W
0FA3:  SUBWF  49,W
0FA4:  BTFSC  03.2
0FA5:  GOTO   7B9
0FA6:  MOVF   48,W
0FA7:  MOVWF  7A
0FA8:  MOVF   47,W
0FA9:  MOVWF  04
0FAA:  MOVF   7A,W
0FAB:  MOVWF  05
0FAC:  MOVF   00,W
0FAD:  MOVWF  49
0FAE:  MOVF   46,W
0FAF:  MOVWF  7A
0FB0:  MOVF   45,W
0FB1:  MOVWF  04
0FB2:  MOVF   7A,W
0FB3:  MOVWF  05
0FB4:  MOVLW  20
0FB5:  ADDWF  00,W
0FB6:  SUBWF  49,W
0FB7:  BTFSS  03.2
0FB8:  GOTO   7CF
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
0FB9:  MOVF   46,W
0FBA:  MOVWF  7A
0FBB:  MOVF   45,W
0FBC:  MOVWF  04
0FBD:  MOVF   7A,W
0FBE:  MOVWF  05
0FBF:  MOVF   00,F
0FC0:  BTFSS  03.2
0FC1:  GOTO   7C5
....................        return(0); 
0FC2:  MOVLW  00
0FC3:  MOVWF  78
0FC4:  GOTO   7E5
0FC5:  MOVF   46,W
0FC6:  MOVWF  7A
0FC7:  MOVF   45,W
0FC8:  INCF   45,F
0FC9:  BTFSC  03.2
0FCA:  INCF   46,F
0FCB:  INCF   47,F
0FCC:  BTFSC  03.2
0FCD:  INCF   48,F
0FCE:  GOTO   751
....................  return((*s1 < *s2) ? -1: 1); 
0FCF:  MOVF   46,W
0FD0:  MOVWF  7A
0FD1:  MOVF   45,W
0FD2:  MOVWF  04
0FD3:  MOVF   46,W
0FD4:  MOVWF  05
0FD5:  MOVF   00,W
0FD6:  MOVWF  49
0FD7:  MOVF   48,W
0FD8:  MOVWF  7A
0FD9:  MOVF   47,W
0FDA:  MOVWF  04
0FDB:  MOVF   48,W
0FDC:  MOVWF  05
0FDD:  MOVF   00,W
0FDE:  SUBWF  49,W
0FDF:  BTFSC  03.0
0FE0:  GOTO   7E3
0FE1:  MOVLW  FF
0FE2:  GOTO   7E4
0FE3:  MOVLW  01
0FE4:  MOVWF  78
.................... } 
0FE5:  MOVLB  00
0FE6:  RETURN
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
.................... #define BUTTON_STATES 
.................... #define POT_MAX 63 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
07C4:  MOVLW  20
07C5:  MOVWF  05
07C6:  MOVLW  D0
07C7:  MOVWF  04
07C8:  MOVF   00,W
07C9:  BTFSC  03.2
07CA:  GOTO   7DC
07CB:  MOVLW  02
07CC:  MOVWF  78
07CD:  MOVLW  BF
07CE:  MOVWF  77
07CF:  CLRWDT
07D0:  DECFSZ 77,F
07D1:  GOTO   7CF
07D2:  DECFSZ 78,F
07D3:  GOTO   7CD
07D4:  MOVLW  96
07D5:  MOVWF  77
07D6:  DECFSZ 77,F
07D7:  GOTO   7D6
07D8:  GOTO   7D9
07D9:  CLRWDT
07DA:  DECFSZ 00,F
07DB:  GOTO   7CB
07DC:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
06EC:  MOVLB  04
06ED:  BCF    15.7
06EE:  MOVLB  00
06EF:  BCF    11.3
06F0:  MOVLB  02
06F1:  MOVF   56,W
06F2:  MOVLB  04
06F3:  MOVWF  11
06F4:  MOVLW  02
06F5:  BTFSC  15.7
06F6:  GOTO   6FE
06F7:  MOVLB  00
06F8:  BTFSS  11.3
06F9:  GOTO   6F8
06FA:  MOVLW  00
06FB:  MOVLB  04
06FC:  BTFSC  16.6
06FD:  MOVLW  01
06FE:  MOVWF  78
06FF:  MOVLB  00
0700:  RETURN
*
0AF1:  MOVLB  04
0AF2:  BCF    15.6
0AF3:  BSF    16.3
0AF4:  BTFSC  16.3
0AF5:  GOTO   2F4
0AF6:  BTFSC  77.0
0AF7:  BCF    16.5
0AF8:  BTFSS  77.0
0AF9:  BSF    16.5
0AFA:  BSF    16.4
0AFB:  BTFSC  16.4
0AFC:  GOTO   2FB
0AFD:  MOVF   11,W
0AFE:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02DA:  CLRWDT
02DB:  BTFSS  11.4
02DC:  GOTO   2DA
02DD:  MOVLB  03
02DE:  MOVWF  1A
02DF:  MOVLB  00
02E0:  RETURN
.................... //#use fast_io (a) 
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void send_tail(void); 
.................... void status_led(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN; 
.................... unsigned int Enable,Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned int TOT_Min; 
.................... unsigned int COR_EMUL; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... char COR_IN_EFFECTIVE; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define DEBOUNCE_COUNT 8 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... //#define DTMF_SEND_OLD 10 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x10 
.................... #define AUXI_EMULATE_COR0 0x01 
.................... #define AUXI_EMULATE_COR1 0x02 
.................... #define AUXI_EMULATE_COR2 0x04 
.................... #define AUXI_EMULATE_COR3 0x08 
....................  
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... #define LCD_I2C_ADD 0x60 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... char command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... unsigned int  LastRegisterIndex; 
.................... unsigned int  LastRegisterIndexValid; 
....................  
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... //	int      reg_name_index; 
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1 ENTER_PRESSED; 
.................... int1 SELECT_PRESSED; 
.................... int  adj_value_a,adj_value_b; 
.................... char button_state; 
.................... int1       COR_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... int1       STATUS_LED; 
.................... unsigned long TOT_SecondCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... #define PTT_TIMEOUT_SECS 60 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... #ifndef GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 
.................... 	{"XI2"},	  // 19 
.................... 	{"XI3"},	  // 20 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"COR"},  // 54 
....................     {"CPOT"}  // 55 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
....................  
.................... #define SITE_ID_VAL  	54 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... // All radios ON except Radio3 (147.105) 
.................... #define ENABLE_DEFAULT 0x0B 
.................... #define TOT_MIN 5 
.................... #define DEFAULT_GAIN 20 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('e') 
.................... #define MORSEID5	MCHAR('h') 
....................  
.................... #define AUXOUTOP0 AUX_OUT_FOLLOW_COR 
.................... #define AUXOUTARG0 AUX_OUT_FOLLOW_COR2|AUX_OUT_FOLLOW_COR_INVERT2 
.................... #define AUXOUTOP1 0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2 0 
.................... #define AUXOUTARG2 0 
....................  
.................... //#define AUXINOP0 AUXI_ENABLE 
.................... //#define AUXINARG0 AUXI_ENABLE2|AUXI_ENABLE3|AUXI_ENABLE4 
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  0 
.................... #define AUXINARG0 0 
.................... #define AUXINOP1  AUXI_TAIL_WHEN_LO 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
....................  
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  ,EEPROM}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL,EEPROM}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&AuxIn[0]      ,0           , EEPROM}, 
.................... 	{&AuxIn[1]      ,0           , EEPROM}, 
.................... 	{&AuxIn[2]      ,0           , EEPROM}, 
.................... 	{&AuxOut[0]     ,0           , EEPROM}, 
.................... 	{&AuxOut[1]     ,0           , EEPROM}, 
.................... 	{&AuxOut[2]     ,0           , EEPROM}, 
.................... 	{&RXPriority[0] ,4           , EEPROM}, 
.................... 	{&RXPriority[1] ,6           , EEPROM}, 
.................... 	{&RXPriority[2] ,6           , EEPROM}, 
.................... 	{&RXPriority[3] ,2           , EEPROM}, 
.................... 	{&RX_PTT[0]     ,0x0E        , EEPROM}, 
.................... 	{&RX_PTT[1]     ,0x0D        , EEPROM}, 
.................... 	{&RX_PTT[2]     ,0x0B        , EEPROM}, 
.................... 	{&RX_PTT[3]     ,0x07        , EEPROM}, 
.................... 	{&SiteID        ,SITE_ID_VAL , EEPROM}, 
.................... 	{&TXSiteID      ,0x12        , EEPROM}, 
....................     {&Morse[0]      ,MORSEID0    , EEPROM}, 
....................     {&Morse[1]      ,MORSEID1    , EEPROM}, 
....................     {&Morse[2]      ,MORSEID2    , EEPROM}, 
....................     {&Morse[3]      ,MORSEID3    , EEPROM}, 
....................     {&Morse[4]      ,MORSEID4    , EEPROM}, 
....................     {&Morse[5]      ,MORSEID5    , EEPROM}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0   , EEPROM}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1   , EEPROM}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2   , EEPROM}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0  , EEPROM}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1  , EEPROM}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2  , EEPROM}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0    , EEPROM}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1    , EEPROM}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2    , EEPROM}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0   , EEPROM}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1   , EEPROM}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2   , EEPROM}, 
....................   {&Tail          ,TAIL_CHAR   , EEPROM}, 
....................   {&TOT_Min       ,TOT_MIN     , EEPROM}, 
.................... 	{&COR_EMUL      ,0x00        , RAM}, 
.................... 	{&CurrentTrimPot,0x00        , RAM}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02E1:  BTFSS  11.5
02E2:  GOTO   338
....................     c = getc(); 
02E3:  CLRWDT
02E4:  BTFSS  11.5
02E5:  GOTO   2E3
02E6:  MOVLB  03
02E7:  MOVF   19,W
02E8:  MOVLB  02
02E9:  MOVWF  5E
....................     if ( c == '\b' ) { 
02EA:  MOVF   5E,W
02EB:  SUBLW  08
02EC:  BTFSS  03.2
02ED:  GOTO   316
....................       if ( sBufferIndex > 0 ) { 
02EE:  MOVF   71,F
02EF:  BTFSC  03.2
02F0:  GOTO   310
....................         sBufferIndex--; 
02F1:  DECF   71,F
....................         sBuffer[sBufferIndex]='\0'; 
02F2:  MOVLW  4E
02F3:  ADDWF  71,W
02F4:  MOVWF  04
02F5:  MOVLW  20
02F6:  MOVWF  05
02F7:  BTFSC  03.0
02F8:  INCF   05,F
02F9:  CLRF   00
....................         putc('\b'); 
02FA:  MOVLW  08
02FB:  MOVLB  00
02FC:  CALL   2DA
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
02FD:  MOVLW  1B
02FE:  CALL   2DA
....................   printf("[K"); 
02FF:  MOVLW  5B
0300:  CLRWDT
0301:  BTFSS  11.4
0302:  GOTO   300
0303:  MOVLB  03
0304:  MOVWF  1A
0305:  MOVLW  4B
0306:  CLRWDT
0307:  MOVLB  00
0308:  BTFSC  11.4
0309:  GOTO   30C
030A:  MOVLB  03
030B:  GOTO   306
030C:  MOVLB  03
030D:  MOVWF  1A
....................       } else { 
030E:  GOTO   314
030F:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
0310:  MOVLW  07
0311:  MOVLB  00
0312:  CALL   2DA
0313:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
0314:  GOTO   33A
0315:  MOVLB  02
0316:  MOVF   71,W
0317:  SUBLW  0F
0318:  BTFSS  03.0
0319:  GOTO   335
....................       putc(c); // echo the character 
031A:  MOVF   5E,W
031B:  MOVLB  00
031C:  CALL   2DA
....................       sBuffer[sBufferIndex++] = c; 
031D:  MOVF   71,W
031E:  INCF   71,F
031F:  ADDLW  4E
0320:  MOVWF  04
0321:  MOVLW  20
0322:  MOVWF  05
0323:  BTFSC  03.0
0324:  INCF   05,F
0325:  MOVLB  02
0326:  MOVF   5E,W
0327:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0328:  MOVF   5E,W
0329:  SUBLW  0D
032A:  BTFSC  03.2
032B:  GOTO   333
032C:  MOVF   5E,W
032D:  SUBLW  2B
032E:  BTFSC  03.2
032F:  GOTO   333
0330:  MOVF   5E,W
0331:  SUBLW  2D
0332:  BTFSC  03.2
....................         sBufferFlag=1; 
0333:  BSF    72.0
....................       } 
....................     } else { 
0334:  GOTO   339
....................       putc('\a'); // Send alert. Avoid buffer overflow 
0335:  MOVLW  07
0336:  MOVLB  00
0337:  CALL   2DA
0338:  MOVLB  02
0339:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
033A:  MOVLB  00
033B:  BCF    11.5
033C:  MOVLP  00
033D:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   int value,dtmf_status; 
....................   int LAST_COR_IN; 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if(IOCBF&0x0F) { // Check for interrupts on RB[3:0] only 
*
0357:  MOVLB  07
0358:  MOVF   16,W
0359:  ANDLW  0F
035A:  BTFSC  03.2
035B:  GOTO   36D
....................     LAST_COR_IN=COR_IN; 
035C:  MOVLB  00
035D:  MOVF   5F,W
035E:  MOVLB  02
035F:  MOVWF  60
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
0360:  MOVLB  00
0361:  MOVF   0D,W
0362:  XORWF  62,W
0363:  ANDLW  0F
0364:  MOVWF  5F
....................     if ( LAST_COR_IN != COR_IN ) { 
0365:  MOVF   5F,W
0366:  MOVLB  02
0367:  SUBWF  60,W
0368:  BTFSS  03.2
....................       COR_FLAG = 1; 
0369:  BSF    72.3
....................     } 
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
036A:  MOVLW  F0
036B:  MOVLB  07
036C:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
036D:  BTFSS  0B.0
036E:  GOTO   3BF
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     dtmf_status = dtmf_read(CONTROL_REG); 
036F:  MOVLW  01
0370:  MOVLB  02
0371:  MOVWF  61
0372:  MOVLB  00
0373:  CALL   33E
0374:  MOVF   78,W
0375:  MOVLB  02
0376:  MOVWF  5F
....................     if ( dtmf_status & DTMF_BUFFER_FULL) { 
0377:  BTFSS  5F.2
0378:  GOTO   3BD
....................       value=dtmf_read(DATA_REG); 
0379:  CLRF   61
037A:  MOVLB  00
037B:  CALL   33E
037C:  MOVF   78,W
037D:  MOVLB  02
037E:  MOVWF  5E
....................       DTMF_IN_FLAG=1; 
037F:  MOVLB  01
0380:  BSF    5B.3
....................       if ( value == dd ) { 
0381:  MOVLB  02
0382:  MOVF   5E,F
0383:  BTFSS  03.2
0384:  GOTO   388
....................         value=d0; 
0385:  MOVLW  0A
0386:  MOVWF  5E
....................       } else if ( value == d0 ) { 
0387:  GOTO   38C
0388:  MOVF   5E,W
0389:  SUBLW  0A
038A:  BTFSC  03.2
....................         value=dd; 
038B:  CLRF   5E
....................       } 
....................       // Check for '#' 
....................       if ( value == dp ) { 
038C:  MOVF   5E,W
038D:  SUBLW  0C
038E:  BTFSS  03.2
038F:  GOTO   39A
....................         DTMF_FLAG = 1; 
0390:  MOVLB  01
0391:  BSF    5B.2
....................         DTMF_ptr->Last=1; 
0392:  MOVF   3C,W
0393:  MOVWF  04
0394:  MOVF   3D,W
0395:  MOVWF  05
0396:  ADDFSR 00,FSR0
0397:  BSF    00.5
....................       } else { 
0398:  GOTO   3BC
0399:  MOVLB  02
....................         if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
039A:  MOVLB  01
039B:  MOVF   3D,W
039C:  SUBLW  20
039D:  BTFSS  03.0
039E:  GOTO   3BC
039F:  BTFSS  03.2
03A0:  GOTO   3A5
03A1:  MOVF   3C,W
03A2:  SUBLW  6B
03A3:  BTFSS  03.0
03A4:  GOTO   3BC
....................           DTMF_ptr->Key=value; 
03A5:  MOVF   3C,W
03A6:  MOVWF  04
03A7:  MOVF   3D,W
03A8:  MOVWF  05
03A9:  ADDFSR 00,FSR0
03AA:  MOVLB  02
03AB:  MOVF   5E,W
03AC:  ANDLW  0F
03AD:  MOVWF  77
03AE:  MOVLW  F0
03AF:  ANDWF  00,W
03B0:  IORWF  77,W
03B1:  MOVWF  00
....................           DTMF_ptr->Strobe=1; 
03B2:  MOVLB  01
03B3:  MOVF   3C,W
03B4:  MOVWF  04
03B5:  MOVF   3D,W
03B6:  MOVWF  05
03B7:  ADDFSR 00,FSR0
03B8:  BSF    00.4
....................           DTMF_ptr++; 
03B9:  INCF   3C,F
03BA:  BTFSC  03.2
03BB:  INCF   3D,F
03BC:  MOVLB  02
....................         } 
....................       } 
....................     } 
....................   clear_interrupt(INT_RB4_H2L); 
03BD:  MOVLB  07
03BE:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
03BF:  BTFSS  0B.0
03C0:  GOTO   3C6
....................     AUX_IN_FLAG=1; 
03C1:  MOVLB  01
03C2:  BSF    5B.0
....................     clear_interrupt(INT_RB6|INT_RB7); 
03C3:  MOVLW  3F
03C4:  MOVLB  07
03C5:  ANDWF  16,F
....................   } 
.................... } // }}} 
03C6:  BCF    0B.0
03C7:  MOVLP  00
03C8:  MOVLB  00
03C9:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
03CA:  MOVLB  01
03CB:  MOVF   2E,W
03CC:  IORWF  2F,W
03CD:  BTFSC  03.2
03CE:  GOTO   3D4
....................     rtcc_cnt--; 
03CF:  MOVF   2E,W
03D0:  BTFSC  03.2
03D1:  DECF   2F,F
03D2:  DECF   2E,F
....................   } else { 
03D3:  GOTO   3E0
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
03D4:  MOVLB  00
03D5:  MOVF   0D,W
03D6:  XORWF  62,W
03D7:  ANDLW  0F
03D8:  MOVWF  5F
....................     COR_FLAG=1; 
03D9:  BSF    72.3
....................     SECOND_FLAG=1; 
03DA:  BSF    72.4
....................     AUX_IN_FLAG=1; 
03DB:  MOVLB  01
03DC:  BSF    5B.0
....................     rtcc_cnt=30; 
03DD:  CLRF   2F
03DE:  MOVLW  1E
03DF:  MOVWF  2E
....................   } 
....................   if (aux_timer ) { 
03E0:  MOVF   30,W
03E1:  IORWF  31,W
03E2:  BTFSC  03.2
03E3:  GOTO   3E8
....................     aux_timer--; 
03E4:  MOVF   30,W
03E5:  BTFSC  03.2
03E6:  DECF   31,F
03E7:  DECF   30,F
....................   } 
.................... } // }}} 
03E8:  BCF    0B.2
03E9:  MOVLP  00
03EA:  MOVLB  00
03EB:  GOTO   020
.................... int1 warn_no_lcd = 1; 
.................... void lcd_send(int line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
*
09D2:  BCF    03.0
09D3:  MOVLB  02
09D4:  RLF    50,W
09D5:  ANDLW  0E
09D6:  IORLW  60
09D7:  MOVWF  53
....................   i2c_start(); 
09D8:  MOVLB  04
09D9:  BSF    16.0
09DA:  BTFSC  16.0
09DB:  GOTO   1DA
....................   ack=i2c_write(lcd_cmd); 
09DC:  MOVLB  02
09DD:  MOVF   53,W
09DE:  MOVWF  56
09DF:  MOVLP  00
09E0:  MOVLB  00
09E1:  CALL   6EC
09E2:  MOVLP  08
09E3:  MOVF   78,W
09E4:  MOVLB  02
09E5:  BCF    54.0
09E6:  BTFSC  78.0
09E7:  BSF    54.0
....................   if ( ack!=0 ) { 
09E8:  BTFSS  54.0
09E9:  GOTO   20C
....................     if ( warn_no_lcd ) { 
09EA:  MOVLB  01
09EB:  BTFSS  60.0
09EC:  GOTO   20A
....................       printf("\n\rI2C ERROR : No ACK from LCD : %u",ack); 
09ED:  MOVLW  00
09EE:  MOVLB  02
09EF:  BTFSC  54.0
09F0:  MOVLW  01
09F1:  MOVWF  55
09F2:  MOVLW  EC
09F3:  MOVLB  03
09F4:  MOVWF  11
09F5:  MOVLW  03
09F6:  MOVWF  12
09F7:  BCF    03.0
09F8:  MOVLW  20
09F9:  MOVLB  02
09FA:  MOVWF  56
09FB:  MOVLP  00
09FC:  MOVLB  00
09FD:  CALL   701
09FE:  MOVLP  08
09FF:  MOVLB  02
0A00:  MOVF   55,W
0A01:  MOVWF  56
0A02:  MOVLW  1B
0A03:  MOVWF  57
0A04:  MOVLP  00
0A05:  MOVLB  00
0A06:  CALL   775
0A07:  MOVLP  08
....................       warn_no_lcd = 0; 
0A08:  MOVLB  01
0A09:  BCF    60.0
....................     } 
....................   } else { 
0A0A:  GOTO   20E
0A0B:  MOVLB  02
....................     warn_no_lcd = 1; 
0A0C:  MOVLB  01
0A0D:  BSF    60.0
....................   } 
....................   while(*s) { 
0A0E:  MOVLB  02
0A0F:  MOVF   52,W
0A10:  MOVWF  7A
0A11:  MOVF   51,W
0A12:  MOVWF  04
0A13:  MOVF   7A,W
0A14:  MOVWF  05
0A15:  MOVF   00,F
0A16:  BTFSC  03.2
0A17:  GOTO   22B
....................     i2c_write(*s++); 
0A18:  MOVF   52,W
0A19:  MOVWF  7A
0A1A:  MOVF   51,W
0A1B:  INCF   51,F
0A1C:  BTFSC  03.2
0A1D:  INCF   52,F
0A1E:  MOVWF  04
0A1F:  MOVF   7A,W
0A20:  MOVWF  05
0A21:  MOVF   00,W
0A22:  MOVWF  55
0A23:  MOVWF  56
0A24:  MOVLP  00
0A25:  MOVLB  00
0A26:  CALL   6EC
0A27:  MOVLP  08
....................   } 
0A28:  MOVLB  01
0A29:  GOTO   20E
0A2A:  MOVLB  02
....................   i2c_write(0); // EOL 
0A2B:  CLRF   56
0A2C:  MOVLP  00
0A2D:  MOVLB  00
0A2E:  CALL   6EC
0A2F:  MOVLP  08
....................   i2c_stop(); 
0A30:  MOVLB  04
0A31:  BSF    16.2
0A32:  BTFSC  16.2
0A33:  GOTO   232
.................... #endif 
.................... } // }}} 
0A34:  MOVLB  00
0A35:  RETURN
.................... #ifdef BUTTON_STATES 
.................... void status_led(void) { // {{{ 
....................   char cnt_val; 
....................   STATUS_LED=0; 
*
0DE7:  MOVLB  01
0DE8:  BCF    5B.1
....................   cnt_val = rtcc_cnt>>3; 
0DE9:  RRF    2F,W
0DEA:  MOVWF  7A
0DEB:  RRF    2E,W
0DEC:  MOVWF  79
0DED:  RRF    7A,F
0DEE:  RRF    79,F
0DEF:  RRF    7A,F
0DF0:  RRF    79,F
0DF1:  MOVF   79,W
0DF2:  MOVWF  6C
....................   if ( button_state!=0 ) { 
0DF3:  MOVF   5A,F
0DF4:  BTFSC  03.2
0DF5:  GOTO   604
....................     if ( (rtcc_cnt & 0x04) ) { 
0DF6:  MOVF   2E,W
0DF7:  ANDLW  04
0DF8:  MOVWF  77
0DF9:  CLRF   7A
0DFA:  MOVF   77,W
0DFB:  IORWF  7A,W
0DFC:  BTFSC  03.2
0DFD:  GOTO   604
....................       STATUS_LED = (cnt_val < (CurrentTrimPot+1));  
0DFE:  BCF    5B.1
0DFF:  MOVLW  01
0E00:  ADDWF  74,W
0E01:  SUBWF  6C,W
0E02:  BTFSS  03.0
0E03:  BSF    5B.1
....................     } 
....................   }  
....................   output_bit(STATUS_LED_PIN,STATUS_LED); 
0E04:  BTFSC  5B.1
0E05:  GOTO   60A
0E06:  MOVLB  02
0E07:  BCF    0C.6
0E08:  GOTO   60C
0E09:  MOVLB  01
0E0A:  MOVLB  02
0E0B:  BSF    0C.6
0E0C:  MOVLB  01
0E0D:  BCF    0C.6
.................... } // }}} 
0E0E:  MOVLP  18
0E0F:  MOVLB  00
0E10:  GOTO   6A1 (RETURN)
.................... #endif 
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
111C:  MOVF   70,F
111D:  BTFSC  03.2
111E:  GOTO   180
....................     printf("\n\rProcessing Command:"); 
111F:  MOVLW  FE
1120:  MOVLB  03
1121:  MOVWF  11
1122:  MOVLW  03
1123:  MOVWF  12
1124:  MOVLP  00
1125:  MOVLB  00
1126:  CALL   529
1127:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
1128:  MOVLW  09
1129:  MOVLB  03
112A:  MOVWF  11
112B:  MOVLW  04
112C:  MOVWF  12
112D:  BCF    03.0
112E:  MOVLW  0E
112F:  MOVLB  02
1130:  MOVWF  56
1131:  MOVLP  00
1132:  MOVLB  00
1133:  CALL   701
1134:  MOVLP  10
1135:  MOVF   63,W
1136:  MOVLB  02
1137:  MOVWF  56
1138:  MOVLW  1B
1139:  MOVWF  57
113A:  MOVLP  00
113B:  MOVLB  00
113C:  CALL   775
113D:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
113E:  MOVLW  12
113F:  MOVLB  03
1140:  MOVWF  11
1141:  MOVLW  04
1142:  MOVWF  12
1143:  BCF    03.0
1144:  MOVLW  0E
1145:  MOVLB  02
1146:  MOVWF  56
1147:  MOVLP  00
1148:  MOVLB  00
1149:  CALL   701
114A:  MOVLP  10
114B:  MOVF   70,W
114C:  MOVLB  02
114D:  MOVWF  56
114E:  MOVLW  1B
114F:  MOVWF  57
1150:  MOVLP  00
1151:  MOVLB  00
1152:  CALL   775
1153:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
1154:  MOVLW  1B
1155:  MOVLB  03
1156:  MOVWF  11
1157:  MOVLW  04
1158:  MOVWF  12
1159:  BCF    03.0
115A:  MOVLW  0E
115B:  MOVLB  02
115C:  MOVWF  56
115D:  MOVLP  00
115E:  MOVLB  00
115F:  CALL   701
1160:  MOVLP  10
1161:  MOVF   75,W
1162:  MOVLB  02
1163:  MOVWF  56
1164:  MOVLW  1B
1165:  MOVWF  57
1166:  MOVLP  00
1167:  MOVLB  00
1168:  CALL   775
1169:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
116A:  MOVLW  24
116B:  MOVLB  03
116C:  MOVWF  11
116D:  MOVLW  04
116E:  MOVWF  12
116F:  BCF    03.0
1170:  MOVLW  0E
1171:  MOVLB  02
1172:  MOVWF  56
1173:  MOVLP  00
1174:  MOVLB  00
1175:  CALL   701
1176:  MOVLP  10
1177:  MOVF   76,W
1178:  MOVLB  02
1179:  MOVWF  56
117A:  MOVLW  1B
117B:  MOVWF  57
117C:  MOVLP  00
117D:  MOVLB  00
117E:  CALL   775
117F:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
1180:  MOVLW  02
1181:  SUBWF  70,W
1182:  ADDLW  F5
1183:  BTFSC  03.0
1184:  GOTO   583
1185:  ADDLW  0B
1186:  GOTO   584
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
123E:  GOTO   583
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
123F:  RLF    75,W
1240:  MOVWF  77
1241:  RLF    77,F
1242:  MOVLW  FC
1243:  ANDWF  77,F
1244:  MOVF   77,W
1245:  MOVLB  02
1246:  MOVWF  32
1247:  INCF   32,W
1248:  MOVLP  00
1249:  MOVLB  00
124A:  CALL   043
124B:  MOVLP  10
124C:  MOVWF  7A
124D:  MOVLB  02
124E:  MOVF   32,W
124F:  MOVLP  00
1250:  MOVLB  00
1251:  CALL   043
1252:  MOVLP  10
1253:  MOVLB  02
1254:  MOVWF  26
1255:  MOVF   7A,W
1256:  MOVWF  27
....................       LastRegisterIndex = argument; 
1257:  MOVF   75,W
1258:  MOVWF  7C
....................       LastRegisterIndexValid=1; 
1259:  MOVLW  01
125A:  MOVWF  7D
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
125B:  MOVLW  01
125C:  MOVWF  7A
125D:  MOVLW  8B
125E:  MOVWF  32
125F:  MOVF   7A,W
1260:  MOVWF  33
1261:  CLRF   35
1262:  MOVF   75,W
1263:  MOVWF  34
1264:  MOVF   35,W
1265:  MOVWF  44
1266:  MOVF   34,W
1267:  MOVWF  43
1268:  CLRF   46
1269:  MOVLW  06
126A:  MOVWF  45
126B:  MOVLP  08
126C:  MOVLB  00
126D:  CALL   7E7
126E:  MOVLP  10
126F:  MOVF   78,W
1270:  MOVLB  02
1271:  ADDWF  32,W
1272:  MOVWF  2A
1273:  MOVF   79,W
1274:  ADDWFC 33,W
1275:  MOVWF  2B
....................       romstrcpy(rname,cPtr); 
1276:  MOVLW  20
1277:  MOVWF  42
1278:  MOVLW  AC
1279:  MOVWF  41
127A:  MOVF   2B,W
127B:  MOVWF  44
127C:  MOVF   2A,W
127D:  MOVWF  43
127E:  MOVLB  00
127F:  CALL   000
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
1280:  MOVLB  02
1281:  MOVF   27,W
1282:  MOVWF  7A
1283:  MOVF   26,W
1284:  MOVWF  04
1285:  MOVF   27,W
1286:  MOVWF  05
1287:  MOVF   00,W
1288:  MOVWF  32
1289:  MOVLW  20
128A:  MOVLB  01
128B:  MOVWF  62
128C:  MOVLW  74
128D:  MOVWF  61
128E:  MOVLW  5B
128F:  MOVLB  02
1290:  MOVWF  56
1291:  MOVLP  00
1292:  MOVLB  00
1293:  CALL   7F0
1294:  MOVLP  10
1295:  MOVF   75,W
1296:  MOVLB  02
1297:  MOVWF  33
1298:  MOVLW  01
1299:  MOVWF  34
129A:  MOVLB  00
129B:  CALL   079
129C:  MOVLW  5D
129D:  MOVLB  02
129E:  MOVWF  56
129F:  MOVLP  00
12A0:  MOVLB  00
12A1:  CALL   7F0
12A2:  MOVLP  10
12A3:  MOVLW  20
12A4:  MOVLB  02
12A5:  MOVWF  56
12A6:  MOVLP  00
12A7:  MOVLB  00
12A8:  CALL   7F0
12A9:  MOVLP  10
12AA:  MOVLW  20
12AB:  MOVWF  05
12AC:  MOVLW  AC
12AD:  MOVWF  04
12AE:  MOVLP  08
12AF:  CALL   1BB
12B0:  MOVLP  10
12B1:  MOVLW  20
12B2:  MOVLB  02
12B3:  MOVWF  56
12B4:  MOVLP  00
12B5:  MOVLB  00
12B6:  CALL   7F0
12B7:  MOVLP  10
12B8:  MOVLB  02
12B9:  MOVF   32,W
12BA:  MOVWF  33
12BB:  MOVLW  1B
12BC:  MOVWF  34
12BD:  MOVLB  00
12BE:  CALL   079
12BF:  MOVLW  0A
12C0:  MOVLB  02
12C1:  MOVWF  56
12C2:  MOVLP  00
12C3:  MOVLB  00
12C4:  CALL   7F0
12C5:  MOVLP  10
12C6:  MOVLW  0D
12C7:  MOVLB  02
12C8:  MOVWF  56
12C9:  MOVLP  00
12CA:  MOVLB  00
12CB:  CALL   7F0
12CC:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
12CD:  MOVLW  0A
12CE:  CLRWDT
12CF:  BTFSS  11.4
12D0:  GOTO   2CE
12D1:  MOVLB  03
12D2:  MOVWF  1A
12D3:  MOVLW  0D
12D4:  CLRWDT
12D5:  MOVLB  00
12D6:  BTFSC  11.4
12D7:  GOTO   2DA
12D8:  MOVLB  03
12D9:  GOTO   2D4
12DA:  MOVLB  03
12DB:  MOVWF  1A
12DC:  MOVLW  20
12DD:  MOVWF  05
12DE:  MOVLW  74
12DF:  MOVWF  04
12E0:  MOVLP  08
12E1:  MOVLB  00
12E2:  CALL   2A5
12E3:  MOVLP  10
....................       lcd_send(2,LCD_str); 
12E4:  MOVLW  02
12E5:  MOVLB  02
12E6:  MOVWF  50
12E7:  MOVLW  20
12E8:  MOVWF  52
12E9:  MOVLW  74
12EA:  MOVWF  51
12EB:  MOVLP  08
12EC:  MOVLB  00
12ED:  CALL   1D2
12EE:  MOVLP  10
....................       prompt(); 
12EF:  CALL   0C2
....................       break; 
12F0:  GOTO   583
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
12F1:  CALL   027
12F2:  MOVF   78,F
12F3:  BTFSC  03.2
12F4:  GOTO   2F8
....................         store_variables(); 
12F5:  MOVLP  00
12F6:  CALL   61C
12F7:  MOVLP  10
....................       } 
....................       break; 
12F8:  GOTO   583
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
12F9:  DECFSZ 76,W
12FA:  GOTO   2FF
....................         init_src=USE_EEPROM_VARS; 
12FB:  MOVLB  02
12FC:  BSF    28.0
....................       } else { 
12FD:  GOTO   301
12FE:  MOVLB  00
....................         init_src=USE_DEFAULT_VARS; 
12FF:  MOVLB  02
1300:  BCF    28.0
....................       } 
....................       if ( in_admin_mode() ) { 
1301:  MOVLB  00
1302:  CALL   027
1303:  MOVF   78,F
1304:  BTFSC  03.2
1305:  GOTO   310
....................         init_variables(init_src); 
1306:  MOVLW  00
1307:  MOVLB  02
1308:  BTFSC  28.0
1309:  MOVLW  01
130A:  MOVWF  32
130B:  MOVWF  33
130C:  MOVLP  00
130D:  MOVLB  00
130E:  CALL   697
130F:  MOVLP  10
....................       } 
....................       break; 
1310:  GOTO   583
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1311:  MOVF   75,W
1312:  ANDLW  03
1313:  MOVWF  74
....................       increment(value); 
1314:  MOVF   76,W
1315:  MOVLB  02
1316:  MOVWF  35
1317:  MOVLB  00
1318:  CALL   036
....................       PROMPT_FLAG=1; 
1319:  MOVLB  01
131A:  BSF    5B.5
....................       break; 
131B:  MOVLB  00
131C:  GOTO   583
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
131D:  MOVF   75,W
131E:  ANDLW  03
131F:  MOVWF  74
....................       increment(-1*value); 
1320:  MOVLW  FF
1321:  MOVLB  02
1322:  MOVWF  49
1323:  MOVF   76,W
1324:  MOVWF  4A
1325:  MOVLP  08
1326:  MOVLB  00
1327:  CALL   6F0
1328:  MOVLP  10
1329:  MOVF   78,W
132A:  MOVLB  02
132B:  MOVWF  32
132C:  MOVWF  35
132D:  MOVLB  00
132E:  CALL   036
....................       PROMPT_FLAG=1; 
132F:  MOVLB  01
1330:  BSF    5B.5
....................       break; 
1331:  MOVLB  00
1332:  GOTO   583
....................     case STATUS: 
....................       status(); 
....................       break; 
*
1500:  MOVLB  00
1501:  GOTO   583
....................     case ADMIN: 
....................       switch(argument) { 
1502:  MOVF   75,W
1503:  XORLW  02
1504:  BTFSC  03.2
1505:  GOTO   50D
1506:  XORLW  03
1507:  BTFSC  03.2
1508:  GOTO   512
1509:  XORLW  02
150A:  BTFSC  03.2
150B:  GOTO   51A
150C:  GOTO   51C
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
150D:  CALL   027
150E:  MOVF   78,F
150F:  BTFSS  03.2
....................             reset_cpu(); 
1510:  RESET
....................           } 
....................           break; 
1511:  GOTO   522
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
1512:  MOVLW  01
1513:  MOVLB  02
1514:  MOVWF  46
1515:  MOVLP  08
1516:  MOVLB  00
1517:  CALL   513
1518:  MOVLP  10
....................           break; 
1519:  GOTO   522
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
151A:  CALL   0DA
....................         break; 
151B:  GOTO   522
....................         default: 
....................           set_admin_mode(0); 
151C:  MOVLB  02
151D:  CLRF   46
151E:  MOVLP  08
151F:  MOVLB  00
1520:  CALL   513
1521:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
1522:  GOTO   583
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
....................       lcd_cmd=4+(value&0x03); 
1523:  MOVF   76,W
1524:  ANDLW  03
1525:  ADDLW  04
1526:  MOVLB  02
1527:  MOVWF  29
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
1528:  MOVLW  20
1529:  MOVLB  01
152A:  MOVWF  62
152B:  MOVLW  74
152C:  MOVWF  61
152D:  MOVLW  2D
152E:  MOVLB  03
152F:  MOVWF  11
1530:  MOVLW  04
1531:  MOVWF  12
1532:  BCF    03.0
1533:  MOVLW  04
1534:  MOVLB  02
1535:  MOVWF  50
1536:  MOVLP  08
1537:  MOVLB  00
1538:  CALL   164
1539:  MOVLP  10
153A:  MOVLW  60
153B:  MOVLB  02
153C:  MOVWF  50
153D:  MOVLW  18
153E:  MOVWF  51
153F:  MOVLP  08
1540:  MOVLB  00
1541:  CALL   236
1542:  MOVLP  10
1543:  MOVLW  30
1544:  MOVLB  03
1545:  MOVWF  11
1546:  MOVLW  04
1547:  MOVWF  12
1548:  BCF    03.0
1549:  MOVLW  08
154A:  MOVLB  02
154B:  MOVWF  50
154C:  MOVLP  08
154D:  MOVLB  00
154E:  CALL   164
154F:  MOVLP  10
1550:  MOVLB  02
1551:  MOVF   29,W
1552:  MOVWF  50
1553:  MOVLW  18
1554:  MOVWF  51
1555:  MOVLP  08
1556:  MOVLB  00
1557:  CALL   236
1558:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
1559:  MOVLW  0A
155A:  CLRWDT
155B:  BTFSS  11.4
155C:  GOTO   55A
155D:  MOVLB  03
155E:  MOVWF  1A
155F:  MOVLW  0D
1560:  CLRWDT
1561:  MOVLB  00
1562:  BTFSC  11.4
1563:  GOTO   566
1564:  MOVLB  03
1565:  GOTO   560
1566:  MOVLB  03
1567:  MOVWF  1A
1568:  MOVLW  20
1569:  MOVWF  05
156A:  MOVLW  74
156B:  MOVWF  04
156C:  MOVLP  08
156D:  MOVLB  00
156E:  CALL   2A5
156F:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
1570:  MOVLB  02
1571:  MOVF   29,W
1572:  MOVWF  50
1573:  MOVLW  20
1574:  MOVWF  52
1575:  MOVLW  74
1576:  MOVWF  51
1577:  MOVLP  08
1578:  MOVLB  00
1579:  CALL   1D2
157A:  MOVLP  10
....................       break; 
157B:  GOTO   583
....................     case MORSE_SEND: 
....................       morse(value); 
157C:  MOVF   76,W
157D:  MOVLB  02
157E:  MOVWF  45
157F:  MOVLP  08
1580:  MOVLB  00
1581:  CALL   0E9
1582:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
1583:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  50
1803:  MOVLW  20
1804:  MOVWF  52
1805:  MOVLW  4E
1806:  MOVWF  51
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   1D2
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVWF  75
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B62:  MOVLB  01
1B63:  CLRF   6D
1B64:  CLRF   6C
1B65:  MOVF   6D,F
1B66:  BTFSS  03.2
1B67:  GOTO   3B6
1B68:  MOVF   6C,W
1B69:  SUBLW  37
1B6A:  BTFSS  03.0
1B6B:  GOTO   3B6
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B6C:  MOVLW  01
1B6D:  MOVWF  7A
1B6E:  MOVLW  8B
1B6F:  MOVLB  02
1B70:  MOVWF  26
1B71:  MOVF   7A,W
1B72:  MOVWF  27
1B73:  MOVLB  01
1B74:  MOVF   6D,W
1B75:  MOVLB  02
1B76:  MOVWF  44
1B77:  MOVLB  01
1B78:  MOVF   6C,W
1B79:  MOVLB  02
1B7A:  MOVWF  43
1B7B:  CLRF   46
1B7C:  MOVLW  06
1B7D:  MOVWF  45
1B7E:  MOVLP  08
1B7F:  MOVLB  00
1B80:  CALL   7E7
1B81:  MOVLP  18
1B82:  MOVF   78,W
1B83:  MOVLB  02
1B84:  ADDWF  26,W
1B85:  MOVLB  01
1B86:  MOVWF  6E
1B87:  MOVF   79,W
1B88:  MOVLB  02
1B89:  ADDWFC 27,W
1B8A:  MOVLB  01
1B8B:  MOVWF  6F
....................     romstrcpy(rname,cPtr); 
1B8C:  MOVLW  20
1B8D:  MOVLB  02
1B8E:  MOVWF  42
1B8F:  MOVLW  A0
1B90:  MOVWF  41
1B91:  MOVLB  01
1B92:  MOVF   6F,W
1B93:  MOVLB  02
1B94:  MOVWF  44
1B95:  MOVLB  01
1B96:  MOVF   6E,W
1B97:  MOVLB  02
1B98:  MOVWF  43
1B99:  MOVLP  10
1B9A:  MOVLB  00
1B9B:  CALL   000
1B9C:  MOVLP  18
....................     if(stricmp(argument_name,rname)==0) { 
1B9D:  MOVLW  20
1B9E:  MOVLB  02
1B9F:  MOVWF  46
1BA0:  MOVLW  6E
1BA1:  MOVWF  45
1BA2:  MOVLW  20
1BA3:  MOVWF  48
1BA4:  MOVLW  A0
1BA5:  MOVWF  47
1BA6:  MOVLP  08
1BA7:  MOVLB  00
1BA8:  CALL   750
1BA9:  MOVLP  18
1BAA:  MOVF   78,F
1BAB:  BTFSS  03.2
1BAC:  GOTO   3B1
....................       argument=x; 
1BAD:  MOVLB  01
1BAE:  MOVF   6C,W
1BAF:  MOVWF  75
1BB0:  MOVLB  00
....................     } 
....................   } 
1BB1:  MOVLB  01
1BB2:  INCF   6C,F
1BB3:  BTFSC  03.2
1BB4:  INCF   6D,F
1BB5:  GOTO   365
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BB6:  MOVF   75,W
1BB7:  SUBLW  FF
1BB8:  BTFSS  03.2
1BB9:  GOTO   41A
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BBA:  MOVLW  20
1BBB:  MOVLB  02
1BBC:  MOVWF  46
1BBD:  MOVLW  6E
1BBE:  MOVWF  45
1BBF:  MOVLP  08
1BC0:  MOVLB  00
1BC1:  CALL   717
1BC2:  MOVLP  18
1BC3:  MOVF   78,W
1BC4:  MOVWF  76
....................     strcpy(rname,"eeprom"); 
1BC5:  MOVLB  02
1BC6:  CLRF   26
1BC7:  CLRF   27
1BC8:  MOVLW  20
1BC9:  MOVWF  05
1BCA:  MOVLW  A0
1BCB:  MOVWF  04
1BCC:  MOVF   26,W
1BCD:  ADDWF  04,F
1BCE:  MOVLW  00
1BCF:  ADDWFC 05,F
1BD0:  MOVF   27,W
1BD1:  MOVLP  00
1BD2:  MOVLB  00
1BD3:  CALL   124
1BD4:  MOVLP  18
1BD5:  MOVWF  00
1BD6:  IORLW  00
1BD7:  BTFSC  03.2
1BD8:  GOTO   3DE
1BD9:  MOVLB  02
1BDA:  INCF   27,F
1BDB:  INCF   26,F
1BDC:  GOTO   3C8
1BDD:  MOVLB  00
....................     if(stricmp(argument_name,rname)==0) { 
1BDE:  MOVLW  20
1BDF:  MOVLB  02
1BE0:  MOVWF  46
1BE1:  MOVLW  6E
1BE2:  MOVWF  45
1BE3:  MOVLW  20
1BE4:  MOVWF  48
1BE5:  MOVLW  A0
1BE6:  MOVWF  47
1BE7:  MOVLP  08
1BE8:  MOVLB  00
1BE9:  CALL   750
1BEA:  MOVLP  18
1BEB:  MOVF   78,F
1BEC:  BTFSS  03.2
1BED:  GOTO   3F0
....................       value=USE_EEPROM_VARS; 
1BEE:  MOVLW  01
1BEF:  MOVWF  76
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BF0:  MOVLB  02
1BF1:  CLRF   26
1BF2:  CLRF   27
1BF3:  MOVLW  20
1BF4:  MOVWF  05
1BF5:  MOVLW  A0
1BF6:  MOVWF  04
1BF7:  MOVF   26,W
1BF8:  ADDWF  04,F
1BF9:  MOVLW  00
1BFA:  ADDWFC 05,F
1BFB:  MOVF   27,W
1BFC:  MOVLP  00
1BFD:  MOVLB  00
1BFE:  CALL   12C
1BFF:  MOVLP  18
1C00:  MOVWF  00
1C01:  IORLW  00
1C02:  BTFSC  03.2
1C03:  GOTO   409
1C04:  MOVLB  02
1C05:  INCF   27,F
1C06:  INCF   26,F
1C07:  GOTO   3F3
1C08:  MOVLB  00
....................     if(stricmp(argument_name,rname)==0) { 
1C09:  MOVLW  20
1C0A:  MOVLB  02
1C0B:  MOVWF  46
1C0C:  MOVLW  6E
1C0D:  MOVWF  45
1C0E:  MOVLW  20
1C0F:  MOVWF  48
1C10:  MOVLW  A0
1C11:  MOVWF  47
1C12:  MOVLP  08
1C13:  MOVLB  00
1C14:  CALL   750
1C15:  MOVLP  18
1C16:  MOVF   78,F
1C17:  BTFSC  03.2
....................       value=USE_DEFAULT_VARS; 
1C18:  CLRF   76
1C19:  MOVLB  01
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C1A:  MOVF   70,W
1C1B:  SUBLW  06
1C1C:  BTFSC  03.2
1C1D:  GOTO   422
1C1E:  MOVF   70,W
1C1F:  SUBLW  07
1C20:  BTFSS  03.2
1C21:  GOTO   426
....................     value = 1; 
1C22:  MOVLW  01
1C23:  MOVWF  76
....................     argument = CurrentTrimPot; 
1C24:  MOVF   74,W
1C25:  MOVWF  75
....................   } 
....................   rs232_mode = 1; 
1C26:  BSF    5B.7
....................   execute_command(); 
1C27:  MOVLP  10
1C28:  MOVLB  00
1C29:  CALL   11C
1C2A:  MOVLP  18
....................   rs232_mode = 0; 
1C2B:  MOVLB  01
1C2C:  BCF    5B.7
.................... } // }}} 
1C2D:  MOVLP  18
1C2E:  MOVLB  00
1C2F:  GOTO   6A5 (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
1333:  MOVLW  1B
1334:  MOVLP  00
1335:  CALL   2DA
1336:  MOVLP  10
....................   printf("[2J"); 
1337:  MOVLW  5B
1338:  CLRWDT
1339:  BTFSS  11.4
133A:  GOTO   338
133B:  MOVLB  03
133C:  MOVWF  1A
133D:  MOVLW  32
133E:  CLRWDT
133F:  MOVLB  00
1340:  BTFSC  11.4
1341:  GOTO   344
1342:  MOVLB  03
1343:  GOTO   33E
1344:  MOVLB  03
1345:  MOVWF  1A
1346:  MOVLW  4A
1347:  CLRWDT
1348:  MOVLB  00
1349:  BTFSC  11.4
134A:  GOTO   34D
134B:  MOVLB  03
134C:  GOTO   347
134D:  MOVLB  03
134E:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
134F:  MOVLW  1B
1350:  MOVLP  00
1351:  MOVLB  00
1352:  CALL   2DA
1353:  MOVLP  10
....................   printf("[0;0H"); 
1354:  MOVLW  36
1355:  MOVLB  03
1356:  MOVWF  11
1357:  MOVLW  04
1358:  MOVWF  12
1359:  MOVLP  00
135A:  MOVLB  00
135B:  CALL   529
135C:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
0800:  MOVLB  02
0801:  SWAPF  45,W
0802:  MOVWF  47
0803:  RLF    47,F
0804:  RLF    47,F
0805:  MOVLW  C0
0806:  ANDWF  47,F
....................   tx_value=tx_value + (value & 0x3F); 
0807:  MOVF   46,W
0808:  ANDLW  3F
0809:  ADDWF  47,F
....................   i2c_start(); 
080A:  MOVLB  04
080B:  BSF    16.0
080C:  BTFSC  16.0
080D:  GOTO   00C
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
080E:  MOVLW  50
080F:  MOVLB  02
0810:  MOVWF  56
0811:  MOVLP  00
0812:  MOVLB  00
0813:  CALL   6EC
0814:  MOVLP  08
0815:  MOVF   78,W
0816:  MOVLB  02
0817:  BCF    48.0
0818:  BTFSC  78.0
0819:  BSF    48.0
....................   if ( ack != 0) { 
081A:  BTFSS  48.0
081B:  GOTO   037
....................     printf("\n\rI2C : No ACK : %u",ack); 
081C:  MOVLW  00
081D:  BTFSC  48.0
081E:  MOVLW  01
081F:  MOVWF  49
0820:  MOVLW  39
0821:  MOVLB  03
0822:  MOVWF  11
0823:  MOVLW  04
0824:  MOVWF  12
0825:  BCF    03.0
0826:  MOVLW  11
0827:  MOVLB  02
0828:  MOVWF  56
0829:  MOVLP  00
082A:  MOVLB  00
082B:  CALL   701
082C:  MOVLP  08
082D:  MOVLB  02
082E:  MOVF   49,W
082F:  MOVWF  56
0830:  MOVLW  1B
0831:  MOVWF  57
0832:  MOVLP  00
0833:  MOVLB  00
0834:  CALL   775
0835:  MOVLP  08
0836:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
0837:  MOVF   47,W
0838:  MOVWF  56
0839:  MOVLP  00
083A:  MOVLB  00
083B:  CALL   6EC
083C:  MOVLP  08
....................   i2c_stop();   
083D:  MOVLB  04
083E:  BSF    16.2
083F:  BTFSC  16.2
0840:  GOTO   03F
....................   printf("\n\rPot(%u)<=%u",pot,value); 
0841:  MOVLW  43
0842:  MOVLB  03
0843:  MOVWF  11
0844:  MOVLW  04
0845:  MOVWF  12
0846:  BCF    03.0
0847:  MOVLW  06
0848:  MOVLB  02
0849:  MOVWF  56
084A:  MOVLP  00
084B:  MOVLB  00
084C:  CALL   701
084D:  MOVLP  08
084E:  MOVLB  02
084F:  MOVF   45,W
0850:  MOVWF  56
0851:  MOVLW  1B
0852:  MOVWF  57
0853:  MOVLP  00
0854:  MOVLB  00
0855:  CALL   775
0856:  MOVLP  08
0857:  MOVLW  29
0858:  CLRWDT
0859:  BTFSS  11.4
085A:  GOTO   058
085B:  MOVLB  03
085C:  MOVWF  1A
085D:  MOVLW  3C
085E:  CLRWDT
085F:  MOVLB  00
0860:  BTFSC  11.4
0861:  GOTO   064
0862:  MOVLB  03
0863:  GOTO   05E
0864:  MOVLB  03
0865:  MOVWF  1A
0866:  MOVLW  3D
0867:  CLRWDT
0868:  MOVLB  00
0869:  BTFSC  11.4
086A:  GOTO   06D
086B:  MOVLB  03
086C:  GOTO   067
086D:  MOVLB  03
086E:  MOVWF  1A
086F:  MOVLB  02
0870:  MOVF   46,W
0871:  MOVWF  56
0872:  MOVLW  1B
0873:  MOVWF  57
0874:  MOVLP  00
0875:  MOVLB  00
0876:  CALL   775
0877:  MOVLP  08
....................  
.................... } // }}} 
0878:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
08E9:  MOVLW  DB
08EA:  MOVLB  02
08EB:  ADDWF  45,W
08EC:  MOVWF  49
08ED:  MOVLW  1F
08EE:  MOVWF  4A
08EF:  BTFSC  03.0
08F0:  INCF   4A,F
08F1:  MOVF   4A,W
08F2:  MOVLB  03
08F3:  MOVWF  12
08F4:  MOVLB  02
08F5:  MOVF   49,W
08F6:  MOVLB  03
08F7:  MOVWF  11
08F8:  MOVLW  20
08F9:  MOVWF  05
08FA:  MOVLW  C6
08FB:  MOVWF  04
08FC:  MOVLW  01
08FD:  MOVLB  02
08FE:  MOVWF  4B
08FF:  MOVLP  00
0900:  MOVLB  00
0901:  CALL   7DD
0902:  MOVLP  08
....................    
....................   PROMPT_FLAG=1; 
0903:  MOVLB  01
0904:  BSF    5B.5
....................   for(x=0;x<4;x++) { 
0905:  MOVLB  02
0906:  CLRF   47
0907:  MOVF   47,W
0908:  SUBLW  03
0909:  BTFSS  03.0
090A:  GOTO   131
....................     do_delay=1; 
090B:  BSF    48.0
....................     switch(mc & 0xc0) { // Check two MSB's 
090C:  MOVF   46,W
090D:  ANDLW  C0
090E:  XORLW  40
090F:  MOVLB  00
0910:  BTFSC  03.2
0911:  GOTO   116
0912:  XORLW  C0
0913:  BTFSC  03.2
0914:  GOTO   118
0915:  GOTO   11A
....................       case(0x40): 
....................         dit(); 
0916:  CALL   079
....................         break; 
0917:  GOTO   11D
....................       case(0x80): 
....................         dah(); 
0918:  CALL   0B1
....................         break; 
0919:  GOTO   11D
....................       default: 
....................         do_delay=0; 
091A:  MOVLB  02
091B:  BCF    48.0
....................         break; 
091C:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
091D:  MOVLB  02
091E:  RLF    46,F
091F:  RLF    46,F
0920:  MOVLW  FC
0921:  ANDWF  46,F
....................     if ( do_delay ) { 
0922:  BTFSS  48.0
0923:  GOTO   12F
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
0924:  MOVLB  01
0925:  CLRF   31
0926:  MOVLW  02
0927:  MOVWF  30
....................       while(aux_timer) { 
0928:  MOVF   30,W
0929:  IORWF  31,W
092A:  BTFSC  03.2
092B:  GOTO   12E
....................         delay_cycles(1); 
092C:  NOP
....................       } 
092D:  GOTO   128
092E:  MOVLB  02
....................     } 
....................   } 
092F:  INCF   47,F
0930:  GOTO   107
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
0931:  MOVF   45,W
0932:  SUBLW  09
0933:  BTFSS  03.0
0934:  GOTO   140
....................     if ( c < 5 ) { 
0935:  MOVF   45,W
0936:  SUBLW  04
0937:  BTFSS  03.0
0938:  GOTO   13D
....................       dah(); 
0939:  MOVLB  00
093A:  CALL   0B1
....................     } 
....................     else { 
093B:  GOTO   13F
093C:  MOVLB  02
....................       dit(); 
093D:  MOVLB  00
093E:  CALL   079
093F:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
0940:  MOVLB  00
0941:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0BC1:  MOVLW  30
0BC2:  MOVLB  02
0BC3:  MOVWF  3A
0BC4:  MOVWF  3B
0BC5:  MOVWF  3C
0BC6:  MOVWF  3D
0BC7:  CLRF   3E
....................   char PTT_s[5]={'0','0','0','0',0}; 
0BC8:  MOVWF  3F
0BC9:  MOVWF  40
0BCA:  MOVWF  41
0BCB:  MOVWF  42
0BCC:  CLRF   43
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0BCD:  MOVF   34,W
0BCE:  MOVLB  00
0BCF:  MOVWF  6B
....................  
....................   if ( cor ) { 
0BD0:  MOVLB  02
0BD1:  MOVF   34,F
0BD2:  BTFSC  03.2
0BD3:  GOTO   3E5
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0BD4:  MOVLW  01
0BD5:  SUBWF  34,W
0BD6:  ADDLW  29
0BD7:  MOVWF  04
0BD8:  MOVLW  20
0BD9:  MOVWF  05
0BDA:  BTFSC  03.0
0BDB:  INCF   05,F
0BDC:  MOVF   00,W
0BDD:  MOVWF  45
0BDE:  MOVLB  00
0BDF:  MOVF   60,W
0BE0:  ANDWF  61,W
0BE1:  MOVLB  02
0BE2:  ANDWF  45,W
0BE3:  MOVWF  39
....................   } else { 
0BE4:  GOTO   42E
....................     ptt=0; 
0BE5:  CLRF   39
....................     if ( COR_DROP_FLAG ) { 
0BE6:  BTFSS  72.7
0BE7:  GOTO   42E
....................       COR_DROP_FLAG=0; 
0BE8:  BCF    72.7
....................       if ( ConfirmChar || TailChar ) { 
0BE9:  MOVLB  00
0BEA:  MOVF   69,F
0BEB:  BTFSS  03.2
0BEC:  GOTO   3F0
0BED:  MOVF   68,F
0BEE:  BTFSC  03.2
0BEF:  GOTO   42D
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0C2E:  MOVLW  01
0C2F:  MOVWF  38
....................   for(x=0;x<4;x++) { 
0C30:  CLRF   35
0C31:  MOVF   35,W
0C32:  SUBLW  03
0C33:  BTFSS  03.0
0C34:  GOTO   499
....................     if ( !cor ) { 
0C35:  MOVF   34,F
0C36:  BTFSS  03.2
0C37:  GOTO   43B
....................       rx_bit=0; 
0C38:  BCF    44.0
....................       ptt_bit=0; 
0C39:  BCF    44.1
....................     } else { 
0C3A:  GOTO   44E
....................       if ( cor == (x+1) ) { 
0C3B:  MOVLW  01
0C3C:  ADDWF  35,W
0C3D:  SUBWF  34,W
0C3E:  BTFSS  03.2
0C3F:  GOTO   446
....................         rx_bit=1; 
0C40:  BSF    44.0
....................         CurrentCorMask=mask; 
0C41:  MOVF   38,W
0C42:  MOVLB  00
0C43:  MOVWF  6A
....................       } else { 
0C44:  GOTO   448
0C45:  MOVLB  02
....................         rx_bit=0; 
0C46:  BCF    44.0
0C47:  MOVLB  00
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0C48:  MOVLB  02
0C49:  BCF    44.1
0C4A:  MOVF   39,W
0C4B:  ANDWF  38,W
0C4C:  BTFSS  03.2
0C4D:  BSF    44.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0C4E:  MOVF   35,W
0C4F:  MOVLP  00
0C50:  MOVLB  00
0C51:  CALL   031
0C52:  MOVLP  08
0C53:  MOVLB  02
0C54:  MOVWF  45
0C55:  MOVLW  00
0C56:  BTFSC  44.0
0C57:  MOVLW  01
0C58:  MOVWF  77
0C59:  MOVF   45,W
0C5A:  MOVWF  46
0C5B:  MOVF   77,W
0C5C:  MOVWF  47
0C5D:  MOVLW  01
0C5E:  MOVWF  49
0C5F:  CLRF   48
0C60:  MOVLB  00
0C61:  CALL   142
0C62:  MOVLB  02
0C63:  MOVF   45,W
0C64:  MOVWF  46
0C65:  CLRF   47
0C66:  CLRF   49
0C67:  MOVLW  80
0C68:  MOVWF  48
0C69:  MOVLB  00
0C6A:  CALL   142
....................     output_bit(PTT_PIN[x],ptt_bit); 
0C6B:  MOVLB  02
0C6C:  MOVF   35,W
0C6D:  MOVLP  00
0C6E:  MOVLB  00
0C6F:  CALL   036
0C70:  MOVLP  08
0C71:  MOVLB  02
0C72:  MOVWF  45
0C73:  MOVLW  00
0C74:  BTFSC  44.1
0C75:  MOVLW  01
0C76:  MOVWF  77
0C77:  MOVF   45,W
0C78:  MOVWF  46
0C79:  MOVF   77,W
0C7A:  MOVWF  47
0C7B:  MOVLW  01
0C7C:  MOVWF  49
0C7D:  CLRF   48
0C7E:  MOVLB  00
0C7F:  CALL   142
0C80:  MOVLB  02
0C81:  MOVF   45,W
0C82:  MOVWF  46
0C83:  CLRF   47
0C84:  CLRF   49
0C85:  MOVLW  80
0C86:  MOVWF  48
0C87:  MOVLB  00
0C88:  CALL   142
....................     if(ptt_bit) { 
0C89:  MOVLB  02
0C8A:  BTFSS  44.1
0C8B:  GOTO   495
....................       PTT_s[x]='1'; 
0C8C:  MOVLW  BF
0C8D:  ADDWF  35,W
0C8E:  MOVWF  04
0C8F:  MOVLW  20
0C90:  MOVWF  05
0C91:  BTFSC  03.0
0C92:  INCF   05,F
0C93:  MOVLW  31
0C94:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C95:  BCF    03.0
0C96:  RLF    38,F
....................   }  
0C97:  INCF   35,F
0C98:  GOTO   431
....................   if(!cor) { 
0C99:  MOVF   34,F
0C9A:  BTFSS  03.2
0C9B:  GOTO   4A0
....................     CurrentCorPriority=0; 
0C9C:  MOVLB  00
0C9D:  CLRF   6C
....................   } else { 
0C9E:  GOTO   4CE
0C9F:  MOVLB  02
....................     CurrentCorPriority=RXPriority[cor-1]; 
0CA0:  MOVLW  01
0CA1:  SUBWF  34,W
0CA2:  ADDLW  25
0CA3:  MOVWF  04
0CA4:  MOVLW  20
0CA5:  MOVWF  05
0CA6:  BTFSC  03.0
0CA7:  INCF   05,F
0CA8:  MOVF   00,W
0CA9:  MOVLB  00
0CAA:  MOVWF  6C
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0CAB:  MOVLB  02
0CAC:  CLRF   36
0CAD:  MOVF   36,W
0CAE:  SUBLW  03
0CAF:  BTFSS  03.0
0CB0:  GOTO   4CB
....................       pot_val=RX_GAIN[cor-1][pot]; 
0CB1:  MOVLW  01
0CB2:  SUBWF  34,W
0CB3:  MOVWF  77
0CB4:  RLF    77,F
0CB5:  RLF    77,F
0CB6:  MOVLW  FC
0CB7:  ANDWF  77,F
0CB8:  MOVF   77,W
0CB9:  ADDWF  36,W
0CBA:  ADDLW  0C
0CBB:  MOVWF  04
0CBC:  MOVLW  20
0CBD:  MOVWF  05
0CBE:  BTFSC  03.0
0CBF:  INCF   05,F
0CC0:  MOVF   00,W
0CC1:  MOVWF  37
....................       set_trimpot(pot,pot_val); 
0CC2:  MOVF   36,W
0CC3:  MOVWF  45
0CC4:  MOVF   37,W
0CC5:  MOVWF  46
0CC6:  MOVLB  00
0CC7:  CALL   000
....................     } 
0CC8:  MOVLB  02
0CC9:  INCF   36,F
0CCA:  GOTO   4AD
....................     PROMPT_FLAG=1; 
0CCB:  MOVLB  01
0CCC:  BSF    5B.5
0CCD:  MOVLB  00
....................   } 
....................   if(cor>0) { 
0CCE:  MOVLB  02
0CCF:  MOVF   34,F
0CD0:  BTFSC  03.2
0CD1:  GOTO   4DC
....................     COR_s[cor-1]='1'; 
0CD2:  MOVLW  01
0CD3:  SUBWF  34,W
0CD4:  ADDLW  BA
0CD5:  MOVWF  04
0CD6:  MOVLW  20
0CD7:  MOVWF  05
0CD8:  BTFSC  03.0
0CD9:  INCF   05,F
0CDA:  MOVLW  31
0CDB:  MOVWF  00
....................   } 
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0CDC:  MOVLW  20
0CDD:  MOVLB  01
0CDE:  MOVWF  62
0CDF:  MOVLW  74
0CE0:  MOVWF  61
0CE1:  MOVLW  4A
0CE2:  MOVLB  03
0CE3:  MOVWF  11
0CE4:  MOVLW  04
0CE5:  MOVWF  12
0CE6:  BCF    03.0
0CE7:  MOVLW  04
0CE8:  MOVLB  02
0CE9:  MOVWF  50
0CEA:  MOVLB  00
0CEB:  CALL   164
0CEC:  MOVLW  20
0CED:  MOVWF  05
0CEE:  MOVLW  BA
0CEF:  MOVWF  04
0CF0:  CALL   1BB
0CF1:  MOVLW  4D
0CF2:  MOVLB  03
0CF3:  MOVWF  11
0CF4:  MOVLW  04
0CF5:  MOVWF  12
0CF6:  BCF    03.0
0CF7:  MOVLW  05
0CF8:  MOVLB  02
0CF9:  MOVWF  50
0CFA:  MOVLB  00
0CFB:  CALL   164
0CFC:  MOVLW  20
0CFD:  MOVWF  05
0CFE:  MOVLW  BF
0CFF:  MOVWF  04
0D00:  CALL   1BB
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0D01:  MOVLW  01
0D02:  MOVLB  02
0D03:  MOVWF  50
0D04:  MOVLW  20
0D05:  MOVWF  52
0D06:  MOVLW  74
0D07:  MOVWF  51
0D08:  MOVLB  00
0D09:  CALL   1D2
....................   delay_ms(50); 
0D0A:  MOVLW  32
0D0B:  MOVLB  02
0D0C:  MOVWF  50
0D0D:  MOVLP  00
0D0E:  MOVLB  00
0D0F:  CALL   7C4
0D10:  MOVLP  08
....................   pot_values_to_lcd(); 
0D11:  CALL   2BF
.................... }// }}} 
0D12:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1D3D:  MOVF   6E,W
1D3E:  SUBLW  0A
1D3F:  BTFSS  03.0
1D40:  GOTO   55B
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1D41:  MOVLW  62
1D42:  ADDWF  6E,W
1D43:  MOVWF  04
1D44:  MOVLW  20
1D45:  MOVWF  05
1D46:  BTFSC  03.0
1D47:  INCF   05,F
1D48:  BTFSS  00.4
1D49:  GOTO   559
1D4A:  MOVLW  62
1D4B:  ADDWF  6E,W
1D4C:  MOVWF  04
1D4D:  MOVLW  20
1D4E:  MOVWF  05
1D4F:  BTFSC  03.0
1D50:  INCF   05,F
1D51:  MOVF   00,W
1D52:  ANDLW  0F
1D53:  SUBLW  0C
1D54:  BTFSC  03.2
1D55:  GOTO   559
....................       strobe=1; 
1D56:  MOVLW  01
1D57:  MOVWF  6F
....................      } else { 
1D58:  GOTO   55A
....................       strobe = 0; 
1D59:  CLRF   6F
....................     }  
....................   } else { 
1D5A:  GOTO   55C
....................     strobe=0; 
1D5B:  CLRF   6F
....................   } 
....................   return(strobe); 
1D5C:  MOVF   6F,W
1D5D:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
1CBD:  MOVLB  01
1CBE:  MOVF   6E,W
1CBF:  SUBWF  6F,W
1CC0:  BTFSS  03.0
1CC1:  GOTO   4ED
1CC2:  MOVF   6E,W
1CC3:  SUBLW  09
1CC4:  BTFSS  03.0
1CC5:  GOTO   4ED
....................     valid=1; 
1CC6:  MOVLB  02
1CC7:  BSF    22.0
....................     for(x=a;x<=b;x++) { 
1CC8:  MOVLB  01
1CC9:  MOVF   6E,W
1CCA:  MOVLB  02
1CCB:  MOVWF  21
1CCC:  MOVF   21,W
1CCD:  MOVLB  01
1CCE:  SUBWF  6F,W
1CCF:  BTFSS  03.0
1CD0:  GOTO   4EC
....................       key=(int)DTMF_ARRAY[x].Key; 
1CD1:  MOVLW  62
1CD2:  MOVLB  02
1CD3:  ADDWF  21,W
1CD4:  MOVWF  04
1CD5:  MOVLW  20
1CD6:  MOVWF  05
1CD7:  BTFSC  03.0
1CD8:  INCF   05,F
1CD9:  MOVF   00,W
1CDA:  ANDLW  0F
1CDB:  MOVWF  20
....................       if(! DTMF_ARRAY[x].Strobe ) { 
1CDC:  MOVLW  62
1CDD:  ADDWF  21,W
1CDE:  MOVWF  04
1CDF:  MOVLW  20
1CE0:  MOVWF  05
1CE1:  BTFSC  03.0
1CE2:  INCF   05,F
1CE3:  BTFSS  00.4
....................         valid=0; 
1CE4:  BCF    22.0
....................       } 
....................      if(key==dp) { 
1CE5:  MOVF   20,W
1CE6:  SUBLW  0C
1CE7:  BTFSC  03.2
....................         valid=0; 
1CE8:  BCF    22.0
....................       } 
....................     } 
1CE9:  INCF   21,F
1CEA:  GOTO   4CC
1CEB:  MOVLB  01
....................   } else { 
1CEC:  GOTO   4F0
....................     valid=0; 
1CED:  MOVLB  02
1CEE:  BCF    22.0
1CEF:  MOVLB  01
....................   } 
....................   return(valid); 
1CF0:  MOVLW  00
1CF1:  MOVLB  02
1CF2:  BTFSC  22.0
1CF3:  MOVLW  01
1CF4:  MOVWF  78
.................... } // }}} 
1CF5:  MOVLB  00
1CF6:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   int site_id; 
....................   int digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : DTMF send 
....................   // 11 : Morse send 
....................   // 12 : Send to I2C 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   value = 0; 
1CF7:  CLRF   76
....................   command=0; 
1CF8:  CLRF   70
....................   if ( ValidKeyRange(0,5)) { 
1CF9:  MOVLB  01
1CFA:  CLRF   6E
1CFB:  MOVLW  05
1CFC:  MOVWF  6F
1CFD:  MOVLB  00
1CFE:  CALL   4BD
1CFF:  MOVF   78,F
1D00:  BTFSC  03.2
1D01:  GOTO   58D
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1D02:  MOVLB  01
1D03:  MOVF   32,W
1D04:  ANDLW  0F
1D05:  MOVWF  6F
1D06:  MOVLB  02
1D07:  MOVWF  49
1D08:  MOVLW  0A
1D09:  MOVWF  4A
1D0A:  MOVLP  08
1D0B:  MOVLB  00
1D0C:  CALL   6F0
1D0D:  MOVLP  18
1D0E:  MOVF   78,W
1D0F:  MOVLB  01
1D10:  MOVWF  6E
1D11:  MOVF   33,W
1D12:  ANDLW  0F
1D13:  ADDWF  6E,W
1D14:  MOVWF  6C
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1D15:  MOVF   34,W
1D16:  ANDLW  0F
1D17:  MOVWF  6F
1D18:  MOVLB  02
1D19:  MOVWF  49
1D1A:  MOVLW  0A
1D1B:  MOVWF  4A
1D1C:  MOVLP  08
1D1D:  MOVLB  00
1D1E:  CALL   6F0
1D1F:  MOVLP  18
1D20:  MOVF   78,W
1D21:  MOVLB  01
1D22:  MOVWF  6E
1D23:  MOVF   35,W
1D24:  ANDLW  0F
1D25:  ADDWF  6E,W
1D26:  MOVWF  70
....................     argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1D27:  MOVF   36,W
1D28:  ANDLW  0F
1D29:  MOVWF  6F
1D2A:  MOVLB  02
1D2B:  MOVWF  49
1D2C:  MOVLW  0A
1D2D:  MOVWF  4A
1D2E:  MOVLP  08
1D2F:  MOVLB  00
1D30:  CALL   6F0
1D31:  MOVLP  18
1D32:  MOVF   78,W
1D33:  MOVLB  01
1D34:  MOVWF  6E
1D35:  MOVF   37,W
1D36:  ANDLW  0F
1D37:  ADDWF  6E,W
1D38:  MOVWF  75
....................     digit=6; 
1D39:  MOVLW  06
1D3A:  MOVWF  6D
....................     while(ValidKey(digit)) { 
1D3B:  MOVF   6D,W
1D3C:  MOVWF  6E
*
1D5E:  MOVF   78,F
1D5F:  BTFSC  03.2
1D60:  GOTO   57A
....................      value = value * 10 + DTMF_ARRAY[digit].Key; 
1D61:  MOVF   76,W
1D62:  MOVLB  02
1D63:  MOVWF  49
1D64:  MOVLW  0A
1D65:  MOVWF  4A
1D66:  MOVLP  08
1D67:  MOVLB  00
1D68:  CALL   6F0
1D69:  MOVLP  18
1D6A:  MOVF   78,W
1D6B:  MOVLB  01
1D6C:  MOVWF  6E
1D6D:  MOVLW  62
1D6E:  ADDWF  6D,W
1D6F:  MOVWF  04
1D70:  MOVLW  20
1D71:  MOVWF  05
1D72:  BTFSC  03.0
1D73:  INCF   05,F
1D74:  MOVF   00,W
1D75:  ANDLW  0F
1D76:  ADDWF  6E,W
1D77:  MOVWF  76
....................      digit++; 
1D78:  INCF   6D,F
....................     } 
1D79:  GOTO   53B
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1D7A:  MOVF   70,W
1D7B:  XORLW  04
1D7C:  MOVLB  00
1D7D:  BTFSC  03.2
1D7E:  GOTO   582
1D7F:  XORLW  01
1D80:  BTFSS  03.2
1D81:  GOTO   584
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1D82:  MOVF   75,W
1D83:  MOVWF  76
....................         break; 
....................     } 
....................     if ( site_id == SiteID ) { 
1D84:  MOVF   63,W
1D85:  MOVLB  01
1D86:  SUBWF  6C,W
1D87:  BTFSS  03.2
1D88:  GOTO   58E
....................       execute_command(); 
1D89:  MOVLP  10
1D8A:  MOVLB  00
1D8B:  CALL   11C
1D8C:  MOVLP  18
1D8D:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1D8E:  MOVF   32,W
1D8F:  ANDLW  0F
1D90:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1D91:  BTFSS  5B.6
1D92:  GOTO   5C3
1D93:  CLRF   6E
1D94:  CLRF   6F
1D95:  MOVLB  00
1D96:  CALL   4BD
1D97:  MOVF   78,F
1D98:  BTFSS  03.2
1D99:  GOTO   59C
1D9A:  MOVLB  01
1D9B:  GOTO   5C3
....................     restart_wdt(); 
1D9C:  CLRWDT
....................     switch(command) { 
1D9D:  MOVF   70,W
1D9E:  XORLW  0E
1D9F:  BTFSC  03.2
1DA0:  GOTO   5A8
1DA1:  XORLW  01
1DA2:  BTFSC  03.2
1DA3:  GOTO   5B0
1DA4:  XORLW  05
1DA5:  BTFSC  03.2
1DA6:  GOTO   5B8
1DA7:  GOTO   5BF
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1DA8:  MOVLW  01
1DA9:  ADDWF  74,W
1DAA:  ANDLW  03
1DAB:  MOVWF  74
....................         pot_values_to_lcd(); 
1DAC:  MOVLP  08
1DAD:  CALL   2BF
1DAE:  MOVLP  18
....................         break; 
1DAF:  GOTO   5BF
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1DB0:  MOVLW  FF
1DB1:  MOVLB  02
1DB2:  MOVWF  35
1DB3:  MOVLP  10
1DB4:  MOVLB  00
1DB5:  CALL   036
1DB6:  MOVLP  18
....................         break; 
1DB7:  GOTO   5BF
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1DB8:  MOVLW  01
1DB9:  MOVLB  02
1DBA:  MOVWF  35
1DBB:  MOVLP  10
1DBC:  MOVLB  00
1DBD:  CALL   036
1DBE:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1DBF:  MOVLP  10
1DC0:  CALL   027
1DC1:  MOVLP  18
1DC2:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1DC3:  BSF    5B.4
.................... } // }}} 
1DC4:  MOVLP  18
1DC5:  MOVLB  00
1DC6:  GOTO   7BD (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask,cor_index; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
1C30:  MOVLW  01
1C31:  MOVLB  01
1C32:  MOVWF  6C
....................   do_update_ptt=0; 
1C33:  MOVLB  02
1C34:  CLRF   20
....................   cor_in = COR_IN | (COR_EMUL&0x0F); 
1C35:  MOVLB  00
1C36:  MOVF   67,W
1C37:  ANDLW  0F
1C38:  IORWF  5F,W
1C39:  MOVLB  01
1C3A:  MOVWF  6F
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in&CurrentCorMask) ) { 
1C3B:  MOVLB  00
1C3C:  MOVF   6C,F
1C3D:  BTFSC  03.2
1C3E:  GOTO   457
1C3F:  MOVLB  01
1C40:  MOVF   6F,W
1C41:  MOVLB  00
1C42:  ANDWF  6A,W
1C43:  BTFSS  03.2
1C44:  GOTO   457
....................     CurrentCorPriority=0; 
1C45:  CLRF   6C
....................     CurrentCorMask=0; 
1C46:  CLRF   6A
....................     do_update_ptt=1; 
1C47:  MOVLW  01
1C48:  MOVLB  02
1C49:  MOVWF  20
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
1C4A:  MOVLB  01
1C4B:  MOVF   6F,W
1C4C:  MOVLB  00
1C4D:  ANDWF  60,W
1C4E:  ANDWF  61,W
1C4F:  BTFSS  03.2
1C50:  GOTO   457
....................       COR_DROP_FLAG=1; 
1C51:  BSF    72.7
....................       if ( Tail ) { 
1C52:  MOVF   65,F
1C53:  BTFSC  03.2
1C54:  GOTO   457
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
1C55:  MOVF   65,W
1C56:  MOVWF  68
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
1C57:  MOVLB  01
1C58:  CLRF   6D
....................   for(x=0;x<4;x++) { 
1C59:  MOVLB  02
1C5A:  CLRF   21
1C5B:  MOVF   21,W
1C5C:  SUBLW  03
1C5D:  BTFSS  03.0
1C5E:  GOTO   4A4
....................     if ( cor_in & cor_mask ) { 
1C5F:  MOVLB  01
1C60:  MOVF   6F,W
1C61:  ANDWF  6C,W
1C62:  BTFSC  03.2
1C63:  GOTO   49F
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
1C64:  MOVLB  00
1C65:  MOVF   60,W
1C66:  ANDWF  61,W
1C67:  MOVLB  01
1C68:  ANDWF  6C,W
1C69:  BTFSC  03.2
1C6A:  GOTO   477
....................         rx_priority=RXPriority[x]; 
1C6B:  MOVLW  25
1C6C:  MOVLB  02
1C6D:  ADDWF  21,W
1C6E:  MOVWF  04
1C6F:  MOVLW  20
1C70:  MOVWF  05
1C71:  BTFSC  03.0
1C72:  INCF   05,F
1C73:  MOVF   00,W
1C74:  MOVLB  01
1C75:  MOVWF  6E
....................       } else { 
1C76:  GOTO   479
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
1C77:  MOVLW  01
1C78:  MOVWF  6E
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1C79:  MOVF   6E,W
1C7A:  MOVLB  00
1C7B:  SUBWF  6C,W
1C7C:  BTFSC  03.0
1C7D:  GOTO   49E
....................         if ( ! CurrentCorPriority ) { 
1C7E:  MOVF   6C,F
1C7F:  BTFSS  03.2
1C80:  GOTO   485
....................           CurrentCorPriority = rx_priority; 
1C81:  MOVLB  01
1C82:  MOVF   6E,W
1C83:  MOVLB  00
1C84:  MOVWF  6C
....................         } 
....................         cor_index=x+1; 
1C85:  MOVLW  01
1C86:  MOVLB  02
1C87:  ADDWF  21,W
1C88:  MOVLB  01
1C89:  MOVWF  6D
....................         do_update_ptt=1; 
1C8A:  MOVLW  01
1C8B:  MOVLB  02
1C8C:  MOVWF  20
....................         TOT_SecondCounter= 60 * TOT_Min; 
1C8D:  MOVLW  3C
1C8E:  MOVWF  49
1C8F:  MOVLB  00
1C90:  MOVF   66,W
1C91:  MOVLB  02
1C92:  MOVWF  4A
1C93:  MOVLP  08
1C94:  MOVLB  00
1C95:  CALL   6F0
1C96:  MOVLP  18
1C97:  MOVLB  01
1C98:  CLRF   5F
1C99:  MOVF   78,W
1C9A:  MOVWF  5E
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
1C9B:  MOVF   6C,W
1C9C:  MOVLB  00
1C9D:  MOVWF  6D
1C9E:  MOVLB  01
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
1C9F:  BCF    03.0
1CA0:  RLF    6C,F
....................   } 
1CA1:  MOVLB  02
1CA2:  INCF   21,F
1CA3:  GOTO   45B
....................   if ( do_update_ptt ) { 
1CA4:  MOVF   20,F
1CA5:  BTFSC  03.2
1CA6:  GOTO   4B2
....................     update_ptt(cor_index); 
1CA7:  MOVLB  01
1CA8:  MOVF   6D,W
1CA9:  MOVLB  02
1CAA:  MOVWF  34
1CAB:  MOVLP  08
1CAC:  MOVLB  00
1CAD:  CALL   3C1
1CAE:  MOVLP  18
....................     PROMPT_FLAG=1; 
1CAF:  MOVLB  01
1CB0:  BSF    5B.5
1CB1:  MOVLB  02
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
1CB2:  MOVLB  01
1CB3:  MOVF   6F,F
1CB4:  BTFSS  03.2
1CB5:  GOTO   4BA
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
1CB6:  BSF    5B.4
....................     COR_IN_EFFECTIVE=0; 
1CB7:  MOVLB  00
1CB8:  CLRF   6D
1CB9:  MOVLB  01
....................   } 
.................... } // }}} 
1CBA:  MOVLP  18
1CBB:  MOVLB  00
1CBC:  GOTO   720 (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
17DF:  MOVLB  01
17E0:  CLRF   6C
17E1:  MOVF   6C,W
17E2:  SUBLW  09
17E3:  BTFSS  03.0
17E4:  GOTO   7EF
....................     DTMF_ARRAY[x]=(sDTMF)0; 
17E5:  MOVLW  62
17E6:  ADDWF  6C,W
17E7:  MOVWF  04
17E8:  MOVLW  20
17E9:  MOVWF  05
17EA:  BTFSC  03.0
17EB:  INCF   05,F
17EC:  CLRF   00
....................   } 
17ED:  INCF   6C,F
17EE:  GOTO   7E1
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
17EF:  MOVLW  20
17F0:  MOVWF  3D
17F1:  MOVLW  62
17F2:  MOVWF  3C
.................... } // }}} 
17F3:  MOVLP  18
17F4:  MOVLB  00
17F5:  GOTO   7C5 (RETURN)
.................... void header (void) { // {{{ 
.................... //  putc(ESC); 
.................... //  printf("[47;34m\n\rRadio Repeater Controller - "); 
.................... //  putc(ESC); 
.................... //  printf("[47;31mVE2LRS"); 
.................... //  putc(ESC); 
.................... //  printf("[47;34m (C) 2013\n\n\r"); 
.................... //  putc(ESC); 
.................... //  printf("[40;37m"); 
.................... } // }}} 
*
0003:  RETURN
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   header(); 
*
135D:  MOVLP  00
135E:  CALL   003
135F:  MOVLP  10
1360:  CLRF   25
1361:  BTFSC  0B.7
1362:  BSF    25.7
1363:  BCF    0B.7
....................   dtmf_in=dtmf_read(CONTROL_REG); 
1364:  MOVLW  01
1365:  MOVLB  02
1366:  MOVWF  61
1367:  MOVLP  00
1368:  MOVLB  00
1369:  CALL   33E
136A:  MOVLP  10
136B:  BTFSC  25.7
136C:  BSF    0B.7
136D:  MOVF   78,W
136E:  MOVLB  02
136F:  MOVWF  39
....................   aux_in = 0; 
1370:  CLRF   3A
....................   for(x=0;x<RegMapNum;x++) { 
1371:  CLRF   33
1372:  CLRF   32
1373:  MOVF   33,F
1374:  BTFSS  03.2
1375:  GOTO   478
1376:  MOVF   32,W
1377:  SUBLW  37
1378:  BTFSS  03.0
1379:  GOTO   478
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
137A:  MOVLW  01
137B:  MOVWF  7A
137C:  MOVLW  8B
137D:  MOVWF  41
137E:  MOVF   7A,W
137F:  MOVWF  42
1380:  MOVF   33,W
1381:  MOVWF  44
1382:  MOVF   32,W
1383:  MOVWF  43
1384:  CLRF   46
1385:  MOVLW  06
1386:  MOVWF  45
1387:  MOVLP  08
1388:  MOVLB  00
1389:  CALL   7E7
138A:  MOVLP  10
138B:  MOVF   78,W
138C:  MOVLB  02
138D:  ADDWF  41,W
138E:  MOVWF  35
138F:  MOVF   79,W
1390:  ADDWFC 42,W
1391:  MOVWF  36
....................     romstrcpy(rname,cPtr); 
1392:  MOVLW  20
1393:  MOVWF  42
1394:  MOVLW  BB
1395:  MOVWF  41
1396:  MOVF   36,W
1397:  MOVWF  44
1398:  MOVF   35,W
1399:  MOVWF  43
139A:  MOVLB  00
139B:  CALL   000
....................   regPtr=RegMap[x].reg_ptr; 
139C:  MOVLB  02
139D:  RLF    32,W
139E:  MOVWF  41
139F:  RLF    33,W
13A0:  MOVWF  42
13A1:  RLF    41,F
13A2:  RLF    42,F
13A3:  MOVLW  FC
13A4:  ANDWF  41,F
13A5:  MOVF   42,W
13A6:  MOVWF  7A
13A7:  MOVF   41,W
13A8:  MOVWF  43
13A9:  INCF   41,W
13AA:  MOVLP  00
13AB:  MOVLB  00
13AC:  CALL   043
13AD:  MOVLP  10
13AE:  MOVWF  7A
13AF:  MOVLB  02
13B0:  MOVF   43,W
13B1:  MOVLP  00
13B2:  MOVLB  00
13B3:  CALL   043
13B4:  MOVLP  10
13B5:  MOVLB  02
13B6:  MOVWF  37
13B7:  MOVF   7A,W
13B8:  MOVWF  38
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
13B9:  MOVF   38,W
13BA:  MOVWF  7A
13BB:  MOVF   37,W
13BC:  MOVWF  04
13BD:  MOVF   7A,W
13BE:  MOVWF  05
13BF:  MOVF   00,W
13C0:  MOVWF  41
13C1:  MOVLW  5B
13C2:  CLRWDT
13C3:  MOVLB  00
13C4:  BTFSC  11.4
13C5:  GOTO   3C8
13C6:  MOVLB  02
13C7:  GOTO   3C2
13C8:  MOVLB  03
13C9:  MOVWF  1A
13CA:  MOVLW  0B
13CB:  MOVWF  04
13CC:  MOVLB  02
13CD:  MOVF   33,W
13CE:  MOVWF  43
13CF:  MOVF   32,W
13D0:  MOVWF  42
*
142E:  MOVLW  5D
142F:  CLRWDT
1430:  MOVLB  00
1431:  BTFSC  11.4
1432:  GOTO   435
1433:  MOVLB  02
1434:  GOTO   42F
1435:  MOVLB  03
1436:  MOVWF  1A
1437:  MOVLW  20
1438:  CLRWDT
1439:  MOVLB  00
143A:  BTFSC  11.4
143B:  GOTO   43E
143C:  MOVLB  03
143D:  GOTO   438
143E:  MOVLB  03
143F:  MOVWF  1A
1440:  MOVLW  20
1441:  MOVWF  05
1442:  MOVLW  BB
1443:  MOVWF  04
1444:  MOVLP  08
1445:  MOVLB  00
1446:  CALL   2A5
1447:  MOVLP  10
1448:  MOVLW  20
1449:  CLRWDT
144A:  BTFSS  11.4
144B:  GOTO   449
144C:  MOVLB  03
144D:  MOVWF  1A
144E:  MOVLB  02
144F:  MOVF   41,W
1450:  MOVWF  56
1451:  MOVLW  1B
1452:  MOVWF  57
1453:  MOVLP  00
1454:  MOVLB  00
1455:  CALL   775
1456:  MOVLP  10
1457:  MOVLW  09
1458:  CLRWDT
1459:  BTFSS  11.4
145A:  GOTO   458
145B:  MOVLB  03
145C:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
145D:  MOVLB  02
145E:  MOVF   32,W
145F:  ANDLW  03
1460:  MOVWF  41
1461:  CLRF   42
1462:  MOVF   41,W
1463:  SUBLW  03
1464:  BTFSS  03.2
1465:  GOTO   473
1466:  MOVF   42,F
1467:  BTFSS  03.2
1468:  GOTO   473
....................       putc('\n'); 
1469:  MOVLW  0A
146A:  MOVLP  00
146B:  MOVLB  00
146C:  CALL   2DA
146D:  MOVLP  10
....................       putc('\r'); 
146E:  MOVLW  0D
146F:  MOVLP  00
1470:  CALL   2DA
1471:  MOVLP  10
1472:  MOVLB  02
....................     } 
....................     restart_wdt(); 
1473:  CLRWDT
....................   } 
1474:  INCF   32,F
1475:  BTFSC  03.2
1476:  INCF   33,F
1477:  GOTO   373
....................   for(y=0;y<3;y++) { 
1478:  CLRF   34
1479:  MOVF   34,W
147A:  SUBLW  02
147B:  BTFSS  03.0
147C:  GOTO   493
....................     if(AuxInSW[y]==1) { 
147D:  MOVLW  1F
147E:  ADDWF  34,W
147F:  MOVWF  04
1480:  MOVLW  20
1481:  MOVWF  05
1482:  BTFSC  03.0
1483:  INCF   05,F
1484:  DECFSZ 00,W
1485:  GOTO   491
....................       aux_in += 2<<y; 
1486:  MOVLW  02
1487:  MOVWF  77
1488:  MOVF   34,W
1489:  MOVWF  78
148A:  BTFSC  03.2
148B:  GOTO   48F
148C:  LSLF   77,F
148D:  DECFSZ 78,F
148E:  GOTO   48C
148F:  MOVF   77,W
1490:  ADDWF  3A,F
....................     } 
....................   } 
1491:  INCF   34,F
1492:  GOTO   479
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u",COR_IN,COR_EMUL,aux_in); 
1493:  MOVLW  51
1494:  MOVLB  03
1495:  MOVWF  11
1496:  MOVLW  04
1497:  MOVWF  12
1498:  BCF    03.0
1499:  MOVLW  07
149A:  MOVLB  02
149B:  MOVWF  56
149C:  MOVLP  00
149D:  MOVLB  00
149E:  CALL   701
149F:  MOVLP  10
14A0:  MOVF   5F,W
14A1:  MOVLB  02
14A2:  MOVWF  56
14A3:  MOVLW  1B
14A4:  MOVWF  57
14A5:  MOVLP  00
14A6:  MOVLB  00
14A7:  CALL   775
14A8:  MOVLP  10
14A9:  MOVLW  55
14AA:  MOVLB  03
14AB:  MOVWF  11
14AC:  MOVLW  04
14AD:  MOVWF  12
14AE:  BSF    03.0
14AF:  MOVLW  07
14B0:  MOVLB  02
14B1:  MOVWF  56
14B2:  MOVLP  00
14B3:  MOVLB  00
14B4:  CALL   701
14B5:  MOVLP  10
14B6:  MOVF   67,W
14B7:  MOVLB  02
14B8:  MOVWF  56
14B9:  MOVLW  1B
14BA:  MOVWF  57
14BB:  MOVLP  00
14BC:  MOVLB  00
14BD:  CALL   775
14BE:  MOVLP  10
14BF:  MOVLW  5A
14C0:  MOVLB  03
14C1:  MOVWF  11
14C2:  MOVLW  04
14C3:  MOVWF  12
14C4:  BCF    03.0
14C5:  MOVLW  09
14C6:  MOVLB  02
14C7:  MOVWF  56
14C8:  MOVLP  00
14C9:  MOVLB  00
14CA:  CALL   701
14CB:  MOVLP  10
14CC:  MOVLB  02
14CD:  MOVF   3A,W
14CE:  MOVWF  56
14CF:  MOVLW  1B
14D0:  MOVWF  57
14D1:  MOVLP  00
14D2:  MOVLB  00
14D3:  CALL   775
14D4:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
14D5:  MOVLW  60
14D6:  MOVLB  03
14D7:  MOVWF  11
14D8:  MOVLW  04
14D9:  MOVWF  12
14DA:  BCF    03.0
14DB:  MOVLW  10
14DC:  MOVLB  02
14DD:  MOVWF  56
14DE:  MOVLP  00
14DF:  MOVLB  00
14E0:  CALL   701
14E1:  MOVLP  10
14E2:  MOVLB  02
14E3:  MOVF   39,W
14E4:  MOVWF  56
14E5:  MOVLW  1B
14E6:  MOVWF  57
14E7:  MOVLP  00
14E8:  MOVLB  00
14E9:  CALL   775
14EA:  MOVLP  10
14EB:  MOVLW  0A
14EC:  CLRWDT
14ED:  BTFSS  11.4
14EE:  GOTO   4EC
14EF:  MOVLB  03
14F0:  MOVWF  1A
14F1:  MOVLW  0D
14F2:  CLRWDT
14F3:  MOVLB  00
14F4:  BTFSC  11.4
14F5:  GOTO   4F8
14F6:  MOVLB  03
14F7:  GOTO   4F2
14F8:  MOVLB  03
14F9:  MOVWF  1A
....................   pot_values_to_lcd(); 
14FA:  MOVLP  08
14FB:  MOVLB  00
14FC:  CALL   2BF
14FD:  MOVLP  10
....................   PROMPT_FLAG=1; 
14FE:  MOVLB  01
14FF:  BSF    5B.5
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0ABF:  MOVLW  20
0AC0:  MOVLB  02
0AC1:  MOVWF  48
0AC2:  MOVWF  49
0AC3:  MOVWF  4A
0AC4:  MOVWF  4B
....................   unsigned pval[4]={0,0,0,0}; 
0AC5:  CLRF   4C
0AC6:  CLRF   4D
0AC7:  CLRF   4E
0AC8:  CLRF   4F
....................   delay_ms(40); 
0AC9:  MOVLW  28
0ACA:  MOVWF  50
0ACB:  MOVLP  00
0ACC:  MOVLB  00
0ACD:  CALL   7C4
0ACE:  MOVLP  08
....................   i2c_start(); 
0ACF:  MOVLB  04
0AD0:  BSF    16.0
0AD1:  BTFSC  16.0
0AD2:  GOTO   2D1
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0AD3:  MOVLW  51
0AD4:  MOVLB  02
0AD5:  MOVWF  56
0AD6:  MOVLP  00
0AD7:  MOVLB  00
0AD8:  CALL   6EC
0AD9:  MOVLP  08
0ADA:  MOVF   78,W
0ADB:  MOVLB  02
0ADC:  BCF    47.1
0ADD:  BTFSC  78.0
0ADE:  BSF    47.1
....................   for(x=0;x<4;x++) { 
0ADF:  CLRF   45
0AE0:  MOVF   45,W
0AE1:  SUBLW  03
0AE2:  BTFSS  03.0
0AE3:  GOTO   31D
....................     if(x==3) { 
0AE4:  MOVF   45,W
0AE5:  SUBLW  03
0AE6:  BTFSS  03.2
0AE7:  GOTO   2EA
....................       ack=0; 
0AE8:  BCF    47.0
....................     } else { 
0AE9:  GOTO   2EB
....................       ack=1; 
0AEA:  BSF    47.0
....................     } 
....................     pot_val=i2c_read(ack); 
0AEB:  MOVLW  00
0AEC:  BTFSC  47.0
0AED:  MOVLW  01
0AEE:  MOVWF  50
0AEF:  MOVF   50,W
0AF0:  MOVWF  77
*
0AFF:  MOVF   78,W
0B00:  MOVLB  02
0B01:  MOVWF  46
....................     pot_val=pot_val&0x3F; 
0B02:  MOVLW  3F
0B03:  ANDWF  46,F
....................     pval[x]=pot_val; 
0B04:  MOVLW  CC
0B05:  ADDWF  45,W
0B06:  MOVWF  04
0B07:  MOVLW  20
0B08:  MOVWF  05
0B09:  BTFSC  03.0
0B0A:  INCF   05,F
0B0B:  MOVF   46,W
0B0C:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0B0D:  MOVF   74,W
0B0E:  ANDLW  03
0B0F:  SUBWF  45,W
0B10:  BTFSS  03.2
0B11:  GOTO   31B
....................       c[x] = '*'; 
0B12:  MOVLW  C8
0B13:  ADDWF  45,W
0B14:  MOVWF  04
0B15:  MOVLW  20
0B16:  MOVWF  05
0B17:  BTFSC  03.0
0B18:  INCF   05,F
0B19:  MOVLW  2A
0B1A:  MOVWF  00
....................     } 
....................   } 
0B1B:  INCF   45,F
0B1C:  GOTO   2E0
....................   i2c_stop(); 
0B1D:  MOVLB  04
0B1E:  BSF    16.2
0B1F:  BTFSC  16.2
0B20:  GOTO   31F
....................   delay_ms(50); 
0B21:  MOVLW  32
0B22:  MOVLB  02
0B23:  MOVWF  50
0B24:  MOVLP  00
0B25:  MOVLB  00
0B26:  CALL   7C4
0B27:  MOVLP  08
....................   if ( ack_in!=0 ) { 
0B28:  MOVLB  02
0B29:  BTFSS  47.1
0B2A:  GOTO   346
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0B2B:  MOVLW  00
0B2C:  BTFSC  47.0
0B2D:  MOVLW  01
0B2E:  MOVWF  50
0B2F:  MOVLW  6B
0B30:  MOVLB  03
0B31:  MOVWF  11
0B32:  MOVLW  04
0B33:  MOVWF  12
0B34:  BCF    03.0
0B35:  MOVLW  25
0B36:  MOVLB  02
0B37:  MOVWF  56
0B38:  MOVLP  00
0B39:  MOVLB  00
0B3A:  CALL   701
0B3B:  MOVLP  08
0B3C:  MOVLB  02
0B3D:  MOVF   50,W
0B3E:  MOVWF  56
0B3F:  MOVLW  1B
0B40:  MOVWF  57
0B41:  MOVLP  00
0B42:  MOVLB  00
0B43:  CALL   775
0B44:  MOVLP  08
0B45:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0B46:  MOVLW  20
0B47:  MOVLB  01
0B48:  MOVWF  62
0B49:  MOVLW  74
0B4A:  MOVWF  61
0B4B:  MOVLW  7F
0B4C:  MOVLB  03
0B4D:  MOVWF  11
0B4E:  MOVLW  04
0B4F:  MOVWF  12
0B50:  BCF    03.0
0B51:  MOVLW  04
0B52:  MOVLB  02
0B53:  MOVWF  50
0B54:  MOVLB  00
0B55:  CALL   164
0B56:  MOVLB  02
0B57:  MOVF   48,W
0B58:  MOVWF  56
0B59:  MOVLP  00
0B5A:  MOVLB  00
0B5B:  CALL   7F0
0B5C:  MOVLP  08
0B5D:  MOVLB  02
0B5E:  MOVF   4C,W
0B5F:  MOVWF  50
0B60:  MOVLW  18
0B61:  MOVWF  51
0B62:  MOVLB  00
0B63:  CALL   236
0B64:  MOVLW  20
0B65:  MOVLB  02
0B66:  MOVWF  56
0B67:  MOVLP  00
0B68:  MOVLB  00
0B69:  CALL   7F0
0B6A:  MOVLP  08
0B6B:  MOVLB  02
0B6C:  MOVF   49,W
0B6D:  MOVWF  56
0B6E:  MOVLP  00
0B6F:  MOVLB  00
0B70:  CALL   7F0
0B71:  MOVLP  08
0B72:  MOVLB  02
0B73:  MOVF   4D,W
0B74:  MOVWF  50
0B75:  MOVLW  18
0B76:  MOVWF  51
0B77:  MOVLB  00
0B78:  CALL   236
0B79:  MOVLW  20
0B7A:  MOVLB  02
0B7B:  MOVWF  56
0B7C:  MOVLP  00
0B7D:  MOVLB  00
0B7E:  CALL   7F0
0B7F:  MOVLP  08
0B80:  MOVLB  02
0B81:  MOVF   4A,W
0B82:  MOVWF  56
0B83:  MOVLP  00
0B84:  MOVLB  00
0B85:  CALL   7F0
0B86:  MOVLP  08
0B87:  MOVLB  02
0B88:  MOVF   4E,W
0B89:  MOVWF  50
0B8A:  MOVLW  18
0B8B:  MOVWF  51
0B8C:  MOVLB  00
0B8D:  CALL   236
0B8E:  MOVLW  20
0B8F:  MOVLB  02
0B90:  MOVWF  56
0B91:  MOVLP  00
0B92:  MOVLB  00
0B93:  CALL   7F0
0B94:  MOVLP  08
0B95:  MOVLB  02
0B96:  MOVF   4B,W
0B97:  MOVWF  56
0B98:  MOVLP  00
0B99:  MOVLB  00
0B9A:  CALL   7F0
0B9B:  MOVLP  08
0B9C:  MOVLB  02
0B9D:  MOVF   4F,W
0B9E:  MOVWF  50
0B9F:  MOVLW  18
0BA0:  MOVWF  51
0BA1:  MOVLB  00
0BA2:  CALL   236
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0BA3:  MOVLB  02
0BA4:  CLRF   50
0BA5:  MOVLW  20
0BA6:  MOVWF  52
0BA7:  MOVLW  74
0BA8:  MOVWF  51
0BA9:  MOVLB  00
0BAA:  CALL   1D2
....................   printf("\n\r%s",LCD_str); 
0BAB:  MOVLW  0A
0BAC:  CLRWDT
0BAD:  BTFSS  11.4
0BAE:  GOTO   3AC
0BAF:  MOVLB  03
0BB0:  MOVWF  1A
0BB1:  MOVLW  0D
0BB2:  CLRWDT
0BB3:  MOVLB  00
0BB4:  BTFSC  11.4
0BB5:  GOTO   3B8
0BB6:  MOVLB  03
0BB7:  GOTO   3B2
0BB8:  MOVLB  03
0BB9:  MOVWF  1A
0BBA:  MOVLW  20
0BBB:  MOVWF  05
0BBC:  MOVLW  74
0BBD:  MOVWF  04
0BBE:  MOVLB  00
0BBF:  CALL   2A5
....................  
.................... } // }}} 
0BC0:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
10C2:  MOVLB  01
10C3:  BTFSS  5B.6
10C4:  GOTO   0D0
....................     printf("\n\n\rADMIN> "); 
10C5:  MOVLW  8B
10C6:  MOVLB  03
10C7:  MOVWF  11
10C8:  MOVLW  04
10C9:  MOVWF  12
10CA:  MOVLP  00
10CB:  MOVLB  00
10CC:  CALL   529
10CD:  MOVLP  10
....................   } else { 
10CE:  GOTO   0D9
10CF:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
10D0:  MOVLW  91
10D1:  MOVLB  03
10D2:  MOVWF  11
10D3:  MOVLW  04
10D4:  MOVWF  12
10D5:  MOVLP  00
10D6:  MOVLB  00
10D7:  CALL   529
10D8:  MOVLP  10
....................   } 
.................... } // }}} 
10D9:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
050F:  MOVLW  10
0510:  MOVLB  01
0511:  MOVWF  6D
....................   for (x=0;x<char_num;x++) { 
0512:  CLRF   6C
0513:  MOVF   6D,W
0514:  SUBWF  6C,W
0515:  BTFSC  03.0
0516:  GOTO   521
....................     sBuffer[x]='\0'; 
0517:  MOVLW  4E
0518:  ADDWF  6C,W
0519:  MOVWF  04
051A:  MOVLW  20
051B:  MOVWF  05
051C:  BTFSC  03.0
051D:  INCF   05,F
051E:  CLRF   00
....................   } 
051F:  INCF   6C,F
0520:  GOTO   513
....................   sBufferIndex=0; 
0521:  CLRF   71
....................   sBufferFlag=0;   
0522:  BCF    72.0
....................   argument=-1; 
0523:  MOVLW  FF
0524:  MOVWF  75
....................   argument_name[0]='\0'; 
0525:  CLRF   3E
....................   command=0; 
0526:  CLRF   70
.................... } // }}} 
0527:  MOVLB  00
0528:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
06AC:  MOVLW  00
06AD:  MOVLB  01
06AE:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
06AF:  MOVLB  02
06B0:  BCF    4B.0
06B1:  MOVF   49,W
06B2:  ANDLW  0F
06B3:  ANDLW  01
06B4:  BTFSS  03.2
06B5:  BSF    4B.0
....................   output_bit(DTMF_D0,dbit); 
06B6:  BTFSC  4B.0
06B7:  GOTO   6BA
06B8:  BCF    0F.0
06B9:  GOTO   6BB
06BA:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
06BB:  BCF    4B.0
06BC:  MOVF   49,W
06BD:  ANDLW  0F
06BE:  ANDLW  02
06BF:  BTFSS  03.2
06C0:  BSF    4B.0
....................   output_bit(DTMF_D1,dbit); 
06C1:  BTFSC  4B.0
06C2:  GOTO   6C5
06C3:  BCF    0F.1
06C4:  GOTO   6C6
06C5:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
06C6:  BCF    4B.0
06C7:  MOVF   49,W
06C8:  ANDLW  0F
06C9:  ANDLW  04
06CA:  BTFSS  03.2
06CB:  BSF    4B.0
....................   output_bit(DTMF_D2,dbit); 
06CC:  BTFSC  4B.0
06CD:  GOTO   6D0
06CE:  BCF    0F.2
06CF:  GOTO   6D1
06D0:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
06D1:  BCF    4B.0
06D2:  MOVF   49,W
06D3:  ANDLW  0F
06D4:  ANDLW  08
06D5:  BTFSS  03.2
06D6:  BSF    4B.0
....................   output_bit(DTMF_D3,dbit); 
06D7:  BTFSC  4B.0
06D8:  GOTO   6DB
06D9:  BCF    0F.3
06DA:  GOTO   6DC
06DB:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
06DC:  MOVF   4A,F
06DD:  BTFSS  03.2
06DE:  GOTO   6E1
06DF:  BCF    0F.6
06E0:  GOTO   6E2
06E1:  BSF    0F.6
....................   delay_cycles(2); 
06E2:  GOTO   6E3
....................   output_bit(DTMF_WEB,0); 
06E3:  BCF    0F.5
....................   delay_cycles(2); 
06E4:  GOTO   6E5
....................   output_bit(DTMF_WEB,1);   
06E5:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
06E6:  GOTO   6E7
....................   set_tris_d(0x0F); 
06E7:  MOVLW  0F
06E8:  MOVLB  01
06E9:  MOVWF  0F
.................... } // }}} 
06EA:  MOVLB  00
06EB:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
*
033E:  MOVLW  0F
033F:  MOVLB  01
0340:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
0341:  MOVLB  02
0342:  MOVF   61,F
0343:  BTFSS  03.2
0344:  GOTO   347
0345:  BCF    0F.6
0346:  GOTO   348
0347:  BSF    0F.6
....................   delay_cycles(1); 
0348:  NOP
....................   output_bit(DTMF_REB,0); 
0349:  BCF    0F.4
....................   delay_cycles(1); 
034A:  NOP
....................   value=input_d(); 
034B:  MOVLB  00
034C:  MOVF   0F,W
034D:  MOVLB  02
034E:  MOVWF  62
....................   value&=0x0F; 
034F:  MOVLW  0F
0350:  ANDWF  62,F
....................   output_bit(DTMF_REB,1); 
0351:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
0352:  NOP
....................   return(value); 
0353:  MOVF   62,W
0354:  MOVWF  78
.................... } // }}} 
0355:  MOVLB  00
0356:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0D5D:  MOVLB  02
0D5E:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0D5F:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0D60:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0D61:  CLRF   49
0D62:  MOVLW  01
0D63:  MOVWF  4A
0D64:  MOVLP  00
0D65:  MOVLB  00
0D66:  CALL   6AC
0D67:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0D68:  MOVLB  02
0D69:  CLRF   49
0D6A:  MOVLW  01
0D6B:  MOVWF  4A
0D6C:  MOVLP  00
0D6D:  MOVLB  00
0D6E:  CALL   6AC
0D6F:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0D70:  MOVLW  0C
0D71:  MOVLB  02
0D72:  MOVWF  49
0D73:  MOVLW  01
0D74:  MOVWF  4A
0D75:  MOVLP  00
0D76:  MOVLB  00
0D77:  CALL   6AC
0D78:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0D79:  MOVLW  01
0D7A:  MOVLB  02
0D7B:  MOVWF  49
0D7C:  MOVWF  4A
0D7D:  MOVLP  00
0D7E:  MOVLB  00
0D7F:  CALL   6AC
0D80:  MOVLP  08
0D81:  CLRF   25
0D82:  BTFSC  0B.7
0D83:  BSF    25.7
0D84:  BCF    0B.7
....................     dtmf_read(CONTROL_REG); 
0D85:  MOVLW  01
0D86:  MOVLB  02
0D87:  MOVWF  61
0D88:  MOVLP  00
0D89:  MOVLB  00
0D8A:  CALL   33E
0D8B:  MOVLP  08
0D8C:  BTFSC  25.7
0D8D:  BSF    0B.7
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19EC:  MOVF   46,W
19ED:  MOVWF  49
19EE:  CLRF   4A
19EF:  MOVLP  00
19F0:  MOVLB  00
19F1:  CALL   6AC
19F2:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19F3:  MOVLW  0C
19F4:  MOVLB  02
19F5:  MOVWF  49
19F6:  MOVLW  01
19F7:  MOVWF  4A
19F8:  MOVLP  00
19F9:  MOVLB  00
19FA:  CALL   6AC
19FB:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
19FC:  MOVLW  01
19FD:  MOVLB  02
19FE:  MOVWF  49
19FF:  MOVWF  4A
1A00:  MOVLP  00
1A01:  MOVLB  00
1A02:  CALL   6AC
1A03:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A04:  MOVLW  05
1A05:  MOVLB  02
1A06:  MOVWF  49
1A07:  MOVLW  01
1A08:  MOVWF  4A
1A09:  MOVLP  00
1A0A:  MOVLB  00
1A0B:  CALL   6AC
1A0C:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A0D:  MOVLB  01
1A0E:  CLRF   31
1A0F:  MOVLW  10
1A10:  MOVWF  30
....................   while(aux_timer) { 
1A11:  MOVF   30,W
1A12:  IORWF  31,W
1A13:  BTFSC  03.2
1A14:  GOTO   217
....................     delay_cycles(1); 
1A15:  NOP
....................   } 
1A16:  GOTO   211
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A17:  MOVLW  04
1A18:  MOVLB  02
1A19:  MOVWF  49
1A1A:  MOVLW  01
1A1B:  MOVWF  4A
1A1C:  MOVLP  00
1A1D:  MOVLB  00
1A1E:  CALL   6AC
1A1F:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
0879:  MOVLW  01
087A:  MOVLB  02
087B:  MOVWF  49
087C:  CLRF   4A
087D:  MOVLP  00
087E:  MOVLB  00
087F:  CALL   6AC
0880:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0881:  MOVLW  0C
0882:  MOVLB  02
0883:  MOVWF  49
0884:  MOVLW  01
0885:  MOVWF  4A
0886:  MOVLP  00
0887:  MOVLB  00
0888:  CALL   6AC
0889:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
088A:  MOVLW  05
088B:  MOVLB  02
088C:  MOVWF  49
088D:  MOVLW  01
088E:  MOVWF  4A
088F:  MOVLP  00
0890:  MOVLB  00
0891:  CALL   6AC
0892:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0893:  MOVLW  05
0894:  MOVLB  02
0895:  MOVWF  49
0896:  MOVLW  01
0897:  MOVWF  4A
0898:  MOVLP  00
0899:  MOVLB  00
089A:  CALL   6AC
089B:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
089C:  MOVLB  01
089D:  CLRF   31
089E:  MOVLW  02
089F:  MOVWF  30
....................   while(aux_timer) { 
08A0:  MOVF   30,W
08A1:  IORWF  31,W
08A2:  BTFSC  03.2
08A3:  GOTO   0A6
....................     delay_cycles(1); 
08A4:  NOP
....................   } 
08A5:  GOTO   0A0
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
08A6:  MOVLW  04
08A7:  MOVLB  02
08A8:  MOVWF  49
08A9:  MOVLW  01
08AA:  MOVWF  4A
08AB:  MOVLP  00
08AC:  MOVLB  00
08AD:  CALL   6AC
08AE:  MOVLP  08
....................   restart_wdt(); 
08AF:  CLRWDT
.................... } // }}} 
08B0:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
08B1:  MOVLW  01
08B2:  MOVLB  02
08B3:  MOVWF  49
08B4:  CLRF   4A
08B5:  MOVLP  00
08B6:  MOVLB  00
08B7:  CALL   6AC
08B8:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
08B9:  MOVLW  0C
08BA:  MOVLB  02
08BB:  MOVWF  49
08BC:  MOVLW  01
08BD:  MOVWF  4A
08BE:  MOVLP  00
08BF:  MOVLB  00
08C0:  CALL   6AC
08C1:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
08C2:  MOVLW  05
08C3:  MOVLB  02
08C4:  MOVWF  49
08C5:  MOVLW  01
08C6:  MOVWF  4A
08C7:  MOVLP  00
08C8:  MOVLB  00
08C9:  CALL   6AC
08CA:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
08CB:  MOVLW  05
08CC:  MOVLB  02
08CD:  MOVWF  49
08CE:  MOVLW  01
08CF:  MOVWF  4A
08D0:  MOVLP  00
08D1:  MOVLB  00
08D2:  CALL   6AC
08D3:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
08D4:  MOVLB  01
08D5:  CLRF   31
08D6:  MOVLW  06
08D7:  MOVWF  30
....................   while(aux_timer) { 
08D8:  MOVF   30,W
08D9:  IORWF  31,W
08DA:  BTFSC  03.2
08DB:  GOTO   0DE
....................     delay_cycles(1); 
08DC:  NOP
....................   } 
08DD:  GOTO   0D8
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
08DE:  MOVLW  04
08DF:  MOVLB  02
08E0:  MOVWF  49
08E1:  MOVLW  01
08E2:  MOVWF  4A
08E3:  MOVLP  00
08E4:  MOVLB  00
08E5:  CALL   6AC
08E6:  MOVLP  08
....................   restart_wdt(); 
08E7:  CLRWDT
.................... } // }}} 
08E8:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
057E:  MOVLB  02
057F:  MOVF   3E,W
0580:  MOVWF  04
0581:  MOVF   3F,W
0582:  MOVWF  05
0583:  MOVF   00,W
0584:  MOVWF  41
....................   if ( tmp > 127 ) { 
0585:  MOVF   41,W
0586:  SUBLW  7F
0587:  BTFSS  03.0
....................     tmp++; 
0588:  INCF   41,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
0589:  BCF    03.0
058A:  RLF    41,W
058B:  XORLW  09
058C:  ADDWF  40,W
058D:  MOVWF  41
....................   *cksum=tmp; 
058E:  MOVF   3E,W
058F:  MOVWF  04
0590:  MOVF   3F,W
0591:  MOVWF  05
0592:  MOVF   41,W
0593:  MOVWF  00
.................... } // }}} 
0594:  MOVLB  00
0595:  RETURN
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
0596:  MOVLW  01
0597:  MOVLB  02
0598:  MOVWF  38
....................   eeprom_index=0; 
0599:  CLRF   39
....................   retVal = 1; 
059A:  MOVWF  3B
....................   if ( source == USE_EEPROM_VARS ) { 
059B:  DECFSZ 34,W
059C:  GOTO   5A6
....................     printf("\n\rInitializing RAM variables from EEPROM"); 
059D:  MOVLW  98
059E:  MOVLB  03
059F:  MOVWF  11
05A0:  MOVLW  04
05A1:  MOVWF  12
05A2:  MOVLB  00
05A3:  CALL   529
....................   } else { 
05A4:  GOTO   5AD
05A5:  MOVLB  02
....................     printf("\n\rInitializing RAM variables with firmware default values"); 
05A6:  MOVLW  AD
05A7:  MOVLB  03
05A8:  MOVWF  11
05A9:  MOVLW  04
05AA:  MOVWF  12
05AB:  MOVLB  00
05AC:  CALL   529
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
05AD:  MOVLB  02
05AE:  CLRF   35
05AF:  MOVF   35,W
05B0:  SUBLW  37
05B1:  BTFSS  03.0
05B2:  GOTO   60C
....................     regPtr=RegMap[x].reg_ptr; 
05B3:  RLF    35,W
05B4:  MOVWF  77
05B5:  RLF    77,F
05B6:  MOVLW  FC
05B7:  ANDWF  77,F
05B8:  MOVF   77,W
05B9:  MOVWF  3D
05BA:  INCF   3D,W
05BB:  MOVLB  00
05BC:  CALL   043
05BD:  MOVWF  7A
05BE:  MOVLB  02
05BF:  MOVF   3D,W
05C0:  MOVLB  00
05C1:  CALL   043
05C2:  MOVLB  02
05C3:  MOVWF  36
05C4:  MOVF   7A,W
05C5:  MOVWF  37
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
05C6:  DECFSZ 34,W
05C7:  GOTO   5F8
05C8:  RLF    35,W
05C9:  MOVWF  77
05CA:  RLF    77,F
05CB:  MOVLW  FC
05CC:  ANDWF  77,F
05CD:  MOVF   77,W
05CE:  ADDLW  03
05CF:  MOVLB  00
05D0:  CALL   043
05D1:  MOVWF  78
05D2:  BTFSC  78.0
05D3:  GOTO   5D6
05D4:  MOVLB  02
05D5:  GOTO   5F8
....................     eeprom_val=read_eeprom(eeprom_index); 
05D6:  MOVLB  02
05D7:  MOVF   39,W
05D8:  MOVLB  03
05D9:  MOVWF  11
05DA:  BCF    15.7
05DB:  BSF    15.0
05DC:  MOVF   13,W
05DD:  MOVLB  02
05DE:  MOVWF  3C
....................     *regPtr=eeprom_val; 
05DF:  MOVF   36,W
05E0:  MOVWF  04
05E1:  MOVF   37,W
05E2:  MOVWF  05
05E3:  MOVF   3C,W
05E4:  MOVWF  00
....................     update_checksum(&cksum,*regPtr);     
05E5:  MOVF   37,W
05E6:  MOVWF  7A
05E7:  MOVF   36,W
05E8:  MOVWF  04
05E9:  MOVF   37,W
05EA:  MOVWF  05
05EB:  MOVF   00,W
05EC:  MOVWF  3D
05ED:  MOVLW  20
05EE:  MOVWF  3F
05EF:  MOVLW  B8
05F0:  MOVWF  3E
05F1:  MOVF   3D,W
05F2:  MOVWF  40
05F3:  MOVLB  00
05F4:  CALL   57E
....................       eeprom_index++; 
05F5:  MOVLB  02
05F6:  INCF   39,F
....................     } else { 
05F7:  GOTO   60A
....................       default_value=(int8)RegMap[x].default_value; 
05F8:  RLF    35,W
05F9:  MOVWF  77
05FA:  RLF    77,F
05FB:  MOVLW  FC
05FC:  ANDWF  77,F
05FD:  MOVF   77,W
05FE:  ADDLW  02
05FF:  MOVLB  00
0600:  CALL   043
0601:  MOVWF  78
0602:  MOVLB  02
0603:  MOVWF  3A
....................       *regPtr=default_value; 
0604:  MOVF   36,W
0605:  MOVWF  04
0606:  MOVF   37,W
0607:  MOVWF  05
0608:  MOVF   3A,W
0609:  MOVWF  00
....................     } 
....................   } 
060A:  INCF   35,F
060B:  GOTO   5AF
....................   if ( source == USE_EEPROM_VARS ) { 
060C:  DECFSZ 34,W
060D:  GOTO   618
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
060E:  MOVF   39,W
060F:  MOVLB  03
0610:  MOVWF  11
0611:  BCF    15.7
0612:  BSF    15.0
0613:  MOVF   13,W
0614:  MOVLB  02
0615:  SUBWF  38,W
0616:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
0617:  CLRF   3B
....................     } 
....................   } 
....................   return (retVal); 
0618:  MOVF   3B,W
0619:  MOVWF  78
.................... } // }}} 
061A:  MOVLB  00
061B:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
061C:  MOVLW  01
061D:  MOVLB  02
061E:  MOVWF  38
....................  
....................   eeprom_index=0; 
061F:  CLRF   35
....................   for(x=0;x<RegMapNum;x++) { 
0620:  CLRF   34
0621:  MOVF   34,W
0622:  SUBLW  37
0623:  BTFSS  03.0
0624:  GOTO   67A
....................     regPtr=RegMap[x].reg_ptr; 
0625:  RLF    34,W
0626:  MOVWF  77
0627:  RLF    77,F
0628:  MOVLW  FC
0629:  ANDWF  77,F
062A:  MOVF   77,W
062B:  MOVWF  3A
062C:  INCF   3A,W
062D:  MOVLB  00
062E:  CALL   043
062F:  MOVWF  7A
0630:  MOVLB  02
0631:  MOVF   3A,W
0632:  MOVLB  00
0633:  CALL   043
0634:  MOVLB  02
0635:  MOVWF  36
0636:  MOVF   7A,W
0637:  MOVWF  37
....................     if ( RegMap[x].non_volatile ) { 
0638:  RLF    34,W
0639:  MOVWF  77
063A:  RLF    77,F
063B:  MOVLW  FC
063C:  ANDWF  77,F
063D:  MOVF   77,W
063E:  ADDLW  03
063F:  MOVLB  00
0640:  CALL   043
0641:  MOVWF  78
0642:  BTFSS  78.0
0643:  GOTO   677
....................      value=*regPtr; 
0644:  MOVLB  02
0645:  MOVF   36,W
0646:  MOVWF  04
0647:  MOVF   37,W
0648:  MOVWF  05
0649:  MOVF   00,W
064A:  MOVWF  39
....................      if ( read_eeprom(eeprom_index) != value ) { 
064B:  MOVF   35,W
064C:  MOVLB  03
064D:  MOVWF  11
064E:  BCF    15.7
064F:  BSF    15.0
0650:  MOVF   13,W
0651:  MOVLB  02
0652:  SUBWF  39,W
0653:  BTFSC  03.2
0654:  GOTO   66C
....................        write_eeprom(eeprom_index,value); 
0655:  MOVF   0B,W
0656:  MOVWF  77
0657:  BCF    0B.7
0658:  MOVF   35,W
0659:  MOVLB  03
065A:  MOVWF  11
065B:  MOVLB  02
065C:  MOVF   39,W
065D:  MOVLB  03
065E:  MOVWF  13
065F:  BCF    15.7
0660:  BSF    15.2
0661:  MOVLW  55
0662:  MOVWF  16
0663:  MOVLW  AA
0664:  MOVWF  16
0665:  BSF    15.1
0666:  BTFSC  15.1
0667:  GOTO   666
0668:  BCF    15.2
0669:  MOVF   77,W
066A:  IORWF  0B,F
066B:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
066C:  MOVLW  20
066D:  MOVWF  3F
066E:  MOVLW  B8
066F:  MOVWF  3E
0670:  MOVF   39,W
0671:  MOVWF  40
0672:  MOVLB  00
0673:  CALL   57E
....................      eeprom_index++; 
0674:  MOVLB  02
0675:  INCF   35,F
0676:  MOVLB  00
....................     } 
....................   } 
0677:  MOVLB  02
0678:  INCF   34,F
0679:  GOTO   621
....................   write_eeprom(eeprom_index,cksum); 
067A:  MOVF   0B,W
067B:  MOVWF  77
067C:  BCF    0B.7
067D:  MOVF   35,W
067E:  MOVLB  03
067F:  MOVWF  11
0680:  MOVLB  02
0681:  MOVF   38,W
0682:  MOVLB  03
0683:  MOVWF  13
0684:  BCF    15.7
0685:  BSF    15.2
0686:  MOVLW  55
0687:  MOVWF  16
0688:  MOVLW  AA
0689:  MOVWF  16
068A:  BSF    15.1
068B:  BTFSC  15.1
068C:  GOTO   68B
068D:  BCF    15.2
068E:  MOVF   77,W
068F:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
0690:  MOVLW  CA
0691:  MOVWF  11
0692:  MOVLW  04
0693:  MOVWF  12
0694:  MOVLB  00
0695:  CALL   529
.................... } // }}} 
0696:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
0697:  MOVLB  02
0698:  MOVF   33,W
0699:  MOVWF  34
069A:  MOVLB  00
069B:  CALL   596
069C:  MOVF   78,F
069D:  BTFSS  03.2
069E:  GOTO   6AB
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
069F:  MOVLW  DD
06A0:  MOVLB  03
06A1:  MOVWF  11
06A2:  MOVLW  04
06A3:  MOVWF  12
06A4:  MOVLB  00
06A5:  CALL   529
....................         _init_variables(USE_DEFAULT_VARS); 
06A6:  MOVLB  02
06A7:  CLRF   34
06A8:  MOVLB  00
06A9:  CALL   596
....................     store_variables(); 
06AA:  CALL   61C
....................     } 
.................... } // }}} 
06AB:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0DA2:  MOVLB  02
0DA3:  CLRF   45
0DA4:  CLRF   46
0DA5:  MOVLB  00
0DA6:  CALL   000
....................   set_trimpot(1,0); 
0DA7:  MOVLW  01
0DA8:  MOVLB  02
0DA9:  MOVWF  45
0DAA:  CLRF   46
0DAB:  MOVLB  00
0DAC:  CALL   000
....................   set_trimpot(2,0); 
0DAD:  MOVLW  02
0DAE:  MOVLB  02
0DAF:  MOVWF  45
0DB0:  CLRF   46
0DB1:  MOVLB  00
0DB2:  CALL   000
....................   set_trimpot(3,0); 
0DB3:  MOVLW  03
0DB4:  MOVLB  02
0DB5:  MOVWF  45
0DB6:  CLRF   46
0DB7:  MOVLB  00
0DB8:  CALL   000
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0D2A:  MOVLP  00
0D2B:  CALL   50F
0D2C:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0D2D:  MOVLB  02
0D2E:  CLRF   12
0D2F:  CLRF   11
0D30:  CLRF   14
0D31:  CLRF   13
....................   setup_wdt(WDT_2S); 
0D32:  MOVLW  17
0D33:  MOVLB  01
0D34:  MOVWF  17
....................   COR_IN=0; 
0D35:  MOVLB  00
0D36:  CLRF   5F
....................   COR_DROP_FLAG=0; 
0D37:  BCF    72.7
....................   LastRegisterIndexValid=0; 
0D38:  CLRF   7D
....................   LastRegisterIndex=0; 
0D39:  CLRF   7C
....................   CurrentCorMask=0; 
0D3A:  CLRF   6A
....................   CurrentCorPriority=0; 
0D3B:  CLRF   6C
....................   CurrentCorIndex=0; 
0D3C:  CLRF   6B
....................   CurrentTrimPot=0; 
0D3D:  CLRF   74
....................   set_tris_b(0xFF); 
0D3E:  MOVLW  FF
0D3F:  TRIS   6
....................   set_tris_d(0x00); 
0D40:  MOVLW  00
0D41:  MOVLB  01
0D42:  MOVWF  0F
....................   // 0b11111000 
....................   set_tris_e(0xF8); 
0D43:  BCF    10.0
0D44:  BCF    10.1
0D45:  BCF    10.2
0D46:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0D47:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0D48:  BSF    0B.3
0D49:  MOVLW  CF
0D4A:  MOVLB  07
0D4B:  IORWF  14,F
0D4C:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0D4D:  BSF    0B.3
0D4E:  BSF    15.4
0D4F:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0D50:  MOVLW  C0
0D51:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0D52:  MOVLB  02
0D53:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0D54:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0D55:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0D56:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0D57:  MOVLW  01
0D58:  MOVWF  33
0D59:  MOVLP  00
0D5A:  MOVLB  00
0D5B:  CALL   697
0D5C:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D8E:  MOVLB  01
0D8F:  BSF    5B.4
....................   Enable_Mask = 0x0F; 
0D90:  MOVLW  0F
0D91:  MOVLB  00
0D92:  MOVWF  61
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D93:  MOVF   62,W
0D94:  ANDLW  0F
0D95:  IORLW  C0
0D96:  MOVLB  04
0D97:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D98:  MOVLB  01
0D99:  BCF    15.7
....................   // }}} 
....................   header(); 
0D9A:  MOVLP  00
0D9B:  MOVLB  00
0D9C:  CALL   003
0D9D:  MOVLP  08
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D9E:  MOVLW  9D
0D9F:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0DA0:  MOVLW  80
0DA1:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0DB9:  MOVLB  01
0DBA:  CLRF   2F
0DBB:  MOVLW  1E
0DBC:  MOVWF  2E
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0DBD:  MOVF   15,W
0DBE:  ANDLW  C0
0DBF:  IORLW  07
0DC0:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0DC1:  BSF    0B.5
....................   update_ptt(0); 
0DC2:  MOVLB  02
0DC3:  CLRF   34
0DC4:  MOVLB  00
0DC5:  CALL   3C1
....................   MinuteCounter=MIN_COUNTER; 
0DC6:  MOVLW  1D
0DC7:  MOVLB  01
0DC8:  MOVWF  5D
....................   SecondCounter=SEC_COUNTER; 
0DC9:  MOVLW  3B
0DCA:  MOVWF  5C
....................   THIRTY_MIN_FLAG=0; 
0DCB:  BCF    72.6
....................   MINUTE_FLAG=0; 
0DCC:  BCF    72.5
....................   PROMPT_FLAG=1; 
0DCD:  BSF    5B.5
....................   TailChar=Tail; 
0DCE:  MOVLB  00
0DCF:  MOVF   65,W
0DD0:  MOVWF  68
....................   ConfirmChar=0; 
0DD1:  CLRF   69
....................   AuxOut[0] = PO_AUX_OUT0; 
0DD2:  MOVLW  01
0DD3:  MOVWF  42
....................   AuxOut[1] = PO_AUX_OUT1; 
0DD4:  MOVWF  43
....................   AuxOut[2] = PO_AUX_OUT2; 
0DD5:  MOVWF  44
....................   AuxInSW[0] = 0; 
0DD6:  CLRF   3F
....................   AuxInSW[1] = 0; 
0DD7:  CLRF   40
....................   AuxInSW[2] = 0; 
0DD8:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0DD9:  MOVLB  01
0DDA:  BCF    5B.0
....................   COR_IN_EFFECTIVE=0; 
0DDB:  MOVLB  00
0DDC:  CLRF   6D
....................   set_admin_mode(0); 
0DDD:  MOVLB  02
0DDE:  CLRF   46
0DDF:  MOVLB  00
0DE0:  CALL   513
....................   rs232_mode=0; 
0DE1:  MOVLB  01
0DE2:  BCF    5B.7
....................   button_state=0; 
0DE3:  CLRF   5A
.................... //  setup_adc_ports(ADJ_POT); 
.................... //  set_adc_channel(13); 
.................... //  printf("\n\rInitialization complete"); 
.................... } // }}} 
0DE4:  MOVLP  18
0DE5:  MOVLB  00
0DE6:  GOTO   5FA (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180D:  MOVLB  02
180E:  BCF    2E.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
180F:  CLRF   45
1810:  CLRF   46
1811:  MOVLW  20
1812:  MOVWF  05
1813:  MOVLW  B1
1814:  MOVWF  04
1815:  MOVF   45,W
1816:  ADDWF  04,F
1817:  MOVLW  00
1818:  ADDWFC 05,F
1819:  MOVF   46,W
181A:  MOVLP  00
181B:  MOVLB  00
181C:  CALL   135
181D:  MOVLP  18
181E:  MOVWF  00
181F:  IORLW  00
1820:  BTFSC  03.2
1821:  GOTO   027
1822:  MOVLB  02
1823:  INCF   46,F
1824:  INCF   45,F
1825:  GOTO   011
1826:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1827:  MOVLW  20
1828:  MOVLB  02
1829:  MOVWF  46
182A:  MOVLW  4E
182B:  MOVWF  45
182C:  MOVLW  20
182D:  MOVWF  48
182E:  MOVLW  B1
182F:  MOVWF  47
1830:  MOVLP  08
1831:  MOVLB  00
1832:  CALL   611
1833:  MOVLP  18
1834:  MOVF   79,W
1835:  MOVLB  02
1836:  MOVWF  30
1837:  MOVF   78,W
1838:  MOVWF  2F
....................   if (sptr!=0) {; 
1839:  MOVF   2F,F
183A:  BTFSS  03.2
183B:  GOTO   03F
183C:  MOVF   30,F
183D:  BTFSC  03.2
183E:  GOTO   059
....................     strcpy(verb,sptr); 
183F:  MOVF   30,W
1840:  MOVWF  48
1841:  MOVF   2F,W
1842:  MOVWF  47
1843:  MOVLW  20
1844:  MOVWF  46
1845:  MOVLW  A6
1846:  MOVWF  45
1847:  MOVF   48,W
1848:  MOVWF  05
1849:  MOVF   47,W
184A:  MOVWF  04
184B:  MOVF   00,W
184C:  MOVWF  49
184D:  MOVF   46,W
184E:  MOVWF  05
184F:  MOVF   45,W
1850:  MOVWF  04
1851:  MOVF   49,W
1852:  MOVWF  00
1853:  MOVF   00,F
1854:  BTFSC  03.2
1855:  GOTO   059
1856:  INCF   45,F
1857:  INCF   47,F
1858:  GOTO   047
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
1859:  CLRF   46
185A:  CLRF   45
185B:  MOVLW  20
185C:  MOVWF  48
185D:  MOVLW  B1
185E:  MOVWF  47
185F:  MOVLP  08
1860:  MOVLB  00
1861:  CALL   611
1862:  MOVLP  18
1863:  MOVF   79,W
1864:  MOVLB  02
1865:  MOVWF  30
1866:  MOVF   78,W
1867:  MOVWF  2F
....................   if (sptr!=0) {; 
1868:  MOVF   2F,F
1869:  BTFSS  03.2
186A:  GOTO   06E
186B:  MOVF   30,F
186C:  BTFSC  03.2
186D:  GOTO   088
....................     strcpy(argument_name,sptr); 
186E:  MOVF   30,W
186F:  MOVWF  48
1870:  MOVF   2F,W
1871:  MOVWF  47
1872:  MOVLW  20
1873:  MOVWF  46
1874:  MOVLW  6E
1875:  MOVWF  45
1876:  MOVF   48,W
1877:  MOVWF  05
1878:  MOVF   47,W
1879:  MOVWF  04
187A:  MOVF   00,W
187B:  MOVWF  49
187C:  MOVF   46,W
187D:  MOVWF  05
187E:  MOVF   45,W
187F:  MOVWF  04
1880:  MOVF   49,W
1881:  MOVWF  00
1882:  MOVF   00,F
1883:  BTFSC  03.2
1884:  GOTO   088
1885:  INCF   45,F
1886:  INCF   47,F
1887:  GOTO   076
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1888:  CLRF   46
1889:  CLRF   45
188A:  MOVLW  20
188B:  MOVWF  48
188C:  MOVLW  B1
188D:  MOVWF  47
188E:  MOVLP  08
188F:  MOVLB  00
1890:  CALL   611
1891:  MOVLP  18
1892:  MOVF   79,W
1893:  MOVLB  02
1894:  MOVWF  30
1895:  MOVF   78,W
1896:  MOVWF  2F
....................   if (sptr!=0) {; 
1897:  MOVF   2F,F
1898:  BTFSS  03.2
1899:  GOTO   09D
189A:  MOVF   30,F
189B:  BTFSC  03.2
189C:  GOTO   0C3
....................     strcpy(match_val,sptr); 
189D:  MOVF   30,W
189E:  MOVWF  48
189F:  MOVF   2F,W
18A0:  MOVWF  47
18A1:  MOVLW  20
18A2:  MOVWF  46
18A3:  MOVLW  B9
18A4:  MOVWF  45
18A5:  MOVF   48,W
18A6:  MOVWF  05
18A7:  MOVF   47,W
18A8:  MOVWF  04
18A9:  MOVF   00,W
18AA:  MOVWF  49
18AB:  MOVF   46,W
18AC:  MOVWF  05
18AD:  MOVF   45,W
18AE:  MOVWF  04
18AF:  MOVF   49,W
18B0:  MOVWF  00
18B1:  MOVF   00,F
18B2:  BTFSC  03.2
18B3:  GOTO   0B7
18B4:  INCF   45,F
18B5:  INCF   47,F
18B6:  GOTO   0A5
....................     value = str_to_decimal(match_val); 
18B7:  MOVLW  20
18B8:  MOVWF  46
18B9:  MOVLW  B9
18BA:  MOVWF  45
18BB:  MOVLP  08
18BC:  MOVLB  00
18BD:  CALL   717
18BE:  MOVLP  18
18BF:  MOVF   78,W
18C0:  MOVWF  76
....................   } else { 
18C1:  GOTO   0C6
18C2:  MOVLB  02
....................     value = 0; 
18C3:  CLRF   76
....................     do_get_var = 1; 
18C4:  BSF    2E.0
18C5:  MOVLB  00
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18C6:  MOVLB  02
18C7:  CLRF   45
18C8:  CLRF   46
18C9:  MOVLW  20
18CA:  MOVWF  05
18CB:  MOVLW  BD
18CC:  MOVWF  04
18CD:  MOVF   45,W
18CE:  ADDWF  04,F
18CF:  MOVLW  00
18D0:  ADDWFC 05,F
18D1:  MOVF   46,W
18D2:  MOVLP  00
18D3:  MOVLB  00
18D4:  CALL   13B
18D5:  MOVLP  18
18D6:  MOVWF  00
18D7:  IORLW  00
18D8:  BTFSC  03.2
18D9:  GOTO   0DF
18DA:  MOVLB  02
18DB:  INCF   46,F
18DC:  INCF   45,F
18DD:  GOTO   0C9
18DE:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
18DF:  MOVLW  20
18E0:  MOVLB  02
18E1:  MOVWF  46
18E2:  MOVLW  BD
18E3:  MOVWF  45
18E4:  MOVLW  20
18E5:  MOVWF  48
18E6:  MOVLW  A6
18E7:  MOVWF  47
18E8:  MOVLP  08
18E9:  MOVLB  00
18EA:  CALL   750
18EB:  MOVLP  18
18EC:  MOVF   78,F
18ED:  BTFSS  03.2
18EE:  GOTO   0F8
....................     if ( do_get_var ) { 
18EF:  MOVLB  02
18F0:  BTFSS  2E.0
18F1:  GOTO   0F5
....................       command=GET_REG; 
18F2:  MOVLW  03
18F3:  MOVWF  70
....................     } else { 
18F4:  GOTO   0F7
....................       command=SET_REG; 
18F5:  MOVLW  02
18F6:  MOVWF  70
18F7:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18F8:  MOVLB  02
18F9:  CLRF   45
18FA:  CLRF   46
18FB:  MOVLW  20
18FC:  MOVWF  05
18FD:  MOVLW  BD
18FE:  MOVWF  04
18FF:  MOVF   45,W
1900:  ADDWF  04,F
1901:  MOVLW  00
1902:  ADDWFC 05,F
1903:  MOVF   46,W
1904:  MOVLP  00
1905:  MOVLB  00
1906:  CALL   140
1907:  MOVLP  18
1908:  MOVWF  00
1909:  IORLW  00
190A:  BTFSC  03.2
190B:  GOTO   111
190C:  MOVLB  02
190D:  INCF   46,F
190E:  INCF   45,F
190F:  GOTO   0FB
1910:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1911:  MOVLW  20
1912:  MOVLB  02
1913:  MOVWF  46
1914:  MOVLW  BD
1915:  MOVWF  45
1916:  MOVLW  20
1917:  MOVWF  48
1918:  MOVLW  A6
1919:  MOVWF  47
191A:  MOVLP  08
191B:  MOVLB  00
191C:  CALL   750
191D:  MOVLP  18
191E:  MOVF   78,F
191F:  BTFSS  03.2
1920:  GOTO   123
....................       command=SAVE_SETTINGS; 
1921:  MOVLW  04
1922:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1923:  MOVLB  02
1924:  CLRF   45
1925:  CLRF   46
1926:  MOVLW  20
1927:  MOVWF  05
1928:  MOVLW  BD
1929:  MOVWF  04
192A:  MOVF   45,W
192B:  ADDWF  04,F
192C:  MOVLW  00
192D:  ADDWFC 05,F
192E:  MOVF   46,W
192F:  MOVLP  00
1930:  MOVLB  00
1931:  CALL   146
1932:  MOVLP  18
1933:  MOVWF  00
1934:  IORLW  00
1935:  BTFSC  03.2
1936:  GOTO   13C
1937:  MOVLB  02
1938:  INCF   46,F
1939:  INCF   45,F
193A:  GOTO   126
193B:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
193C:  MOVLW  20
193D:  MOVLB  02
193E:  MOVWF  46
193F:  MOVLW  BD
1940:  MOVWF  45
1941:  MOVLW  20
1942:  MOVWF  48
1943:  MOVLW  A6
1944:  MOVWF  47
1945:  MOVLP  08
1946:  MOVLB  00
1947:  CALL   750
1948:  MOVLP  18
1949:  MOVF   78,F
194A:  BTFSS  03.2
194B:  GOTO   14E
....................       command=RESTORE_SETTINGS; 
194C:  MOVLW  05
194D:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
194E:  MOVLB  02
194F:  CLRF   45
1950:  CLRF   46
1951:  MOVLW  20
1952:  MOVWF  05
1953:  MOVLW  BD
1954:  MOVWF  04
1955:  MOVF   45,W
1956:  ADDWF  04,F
1957:  MOVLW  00
1958:  ADDWFC 05,F
1959:  MOVF   46,W
195A:  MOVLP  00
195B:  MOVLB  00
195C:  CALL   14F
195D:  MOVLP  18
195E:  MOVWF  00
195F:  IORLW  00
1960:  BTFSC  03.2
1961:  GOTO   167
1962:  MOVLB  02
1963:  INCF   46,F
1964:  INCF   45,F
1965:  GOTO   151
1966:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1967:  MOVLW  20
1968:  MOVLB  02
1969:  MOVWF  46
196A:  MOVLW  BD
196B:  MOVWF  45
196C:  MOVLW  20
196D:  MOVWF  48
196E:  MOVLW  A6
196F:  MOVWF  47
1970:  MOVLP  08
1971:  MOVLB  00
1972:  CALL   750
1973:  MOVLP  18
1974:  MOVF   78,F
1975:  BTFSS  03.2
1976:  GOTO   179
....................     command=STATUS; 
1977:  MOVLW  08
1978:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
1979:  MOVLB  02
197A:  CLRF   45
197B:  CLRF   46
197C:  MOVLW  20
197D:  MOVWF  05
197E:  MOVLW  BD
197F:  MOVWF  04
1980:  MOVF   45,W
1981:  ADDWF  04,F
1982:  MOVLW  00
1983:  ADDWFC 05,F
1984:  MOVF   46,W
1985:  MOVLP  00
1986:  MOVLB  00
1987:  CALL   157
1988:  MOVLP  18
1989:  MOVWF  00
198A:  IORLW  00
198B:  BTFSC  03.2
198C:  GOTO   192
198D:  MOVLB  02
198E:  INCF   46,F
198F:  INCF   45,F
1990:  GOTO   17C
1991:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1992:  MOVLW  20
1993:  MOVLB  02
1994:  MOVWF  46
1995:  MOVLW  BD
1996:  MOVWF  45
1997:  MOVLW  20
1998:  MOVWF  48
1999:  MOVLW  A6
199A:  MOVWF  47
199B:  MOVLP  08
199C:  MOVLB  00
199D:  CALL   750
199E:  MOVLP  18
199F:  MOVF   78,F
19A0:  BTFSS  03.2
19A1:  GOTO   1A6
....................     command=ADMIN; 
19A2:  MOVLW  09
19A3:  MOVWF  70
....................     argument=REBOOT; 
19A4:  MOVLW  02
19A5:  MOVWF  75
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19A6:  MOVLB  02
19A7:  CLRF   45
19A8:  CLRF   46
19A9:  MOVLW  20
19AA:  MOVWF  05
19AB:  MOVLW  BD
19AC:  MOVWF  04
19AD:  MOVF   45,W
19AE:  ADDWF  04,F
19AF:  MOVLW  00
19B0:  ADDWFC 05,F
19B1:  MOVF   46,W
19B2:  MOVLP  00
19B3:  MOVLB  00
19B4:  CALL   15F
19B5:  MOVLP  18
19B6:  MOVWF  00
19B7:  IORLW  00
19B8:  BTFSC  03.2
19B9:  GOTO   1BF
19BA:  MOVLB  02
19BB:  INCF   46,F
19BC:  INCF   45,F
19BD:  GOTO   1A9
19BE:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
19BF:  MOVLW  20
19C0:  MOVLB  02
19C1:  MOVWF  46
19C2:  MOVLW  BD
19C3:  MOVWF  45
19C4:  MOVLW  20
19C5:  MOVWF  48
19C6:  MOVLW  A6
19C7:  MOVWF  47
19C8:  MOVLP  08
19C9:  MOVLB  00
19CA:  CALL   750
19CB:  MOVLP  18
19CC:  MOVF   78,F
19CD:  BTFSS  03.2
19CE:  GOTO   220
....................     //command=DTMF_SEND; 
....................     command=0; 
19CF:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D0:  MOVLW  20
19D1:  MOVLB  02
19D2:  MOVWF  46
19D3:  MOVLW  6E
19D4:  MOVWF  45
19D5:  MOVLP  08
19D6:  MOVLB  00
19D7:  CALL   717
19D8:  MOVLP  18
19D9:  MOVF   78,W
19DA:  MOVWF  76
....................     if ( value == d0 ) { 
19DB:  MOVF   76,W
19DC:  SUBLW  0A
19DD:  BTFSS  03.2
19DE:  GOTO   1E1
....................       value = dd; 
19DF:  CLRF   76
....................     } else if (value == dd) { 
19E0:  GOTO   1E6
19E1:  MOVF   76,F
19E2:  BTFSS  03.2
19E3:  GOTO   1E6
....................       value = d0; 
19E4:  MOVLW  0A
19E5:  MOVWF  76
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19E6:  MOVF   76,W
19E7:  ANDLW  0F
19E8:  MOVLB  02
19E9:  MOVWF  45
19EA:  MOVF   45,W
19EB:  MOVWF  46
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A20:  MOVLB  02
1A21:  CLRF   45
1A22:  CLRF   46
1A23:  MOVLW  20
1A24:  MOVWF  05
1A25:  MOVLW  BD
1A26:  MOVWF  04
1A27:  MOVF   45,W
1A28:  ADDWF  04,F
1A29:  MOVLW  00
1A2A:  ADDWFC 05,F
1A2B:  MOVF   46,W
1A2C:  MOVLP  00
1A2D:  MOVLB  00
1A2E:  CALL   162
1A2F:  MOVLP  18
1A30:  MOVWF  00
1A31:  IORLW  00
1A32:  BTFSC  03.2
1A33:  GOTO   239
1A34:  MOVLB  02
1A35:  INCF   46,F
1A36:  INCF   45,F
1A37:  GOTO   223
1A38:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1A39:  MOVLW  20
1A3A:  MOVLB  02
1A3B:  MOVWF  46
1A3C:  MOVLW  BD
1A3D:  MOVWF  45
1A3E:  MOVLW  20
1A3F:  MOVWF  48
1A40:  MOVLW  A6
1A41:  MOVWF  47
1A42:  MOVLP  08
1A43:  MOVLB  00
1A44:  CALL   750
1A45:  MOVLP  18
1A46:  MOVF   78,F
1A47:  BTFSS  03.2
1A48:  GOTO   24B
....................     command=I2C_SEND; 
1A49:  MOVLW  0C
1A4A:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A4B:  MOVLB  02
1A4C:  CLRF   45
1A4D:  CLRF   46
1A4E:  MOVLW  20
1A4F:  MOVWF  05
1A50:  MOVLW  BD
1A51:  MOVWF  04
1A52:  MOVF   45,W
1A53:  ADDWF  04,F
1A54:  MOVLW  00
1A55:  ADDWFC 05,F
1A56:  MOVF   46,W
1A57:  MOVLP  00
1A58:  MOVLB  00
1A59:  CALL   167
1A5A:  MOVLP  18
1A5B:  MOVWF  00
1A5C:  IORLW  00
1A5D:  BTFSC  03.2
1A5E:  GOTO   264
1A5F:  MOVLB  02
1A60:  INCF   46,F
1A61:  INCF   45,F
1A62:  GOTO   24E
1A63:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1A64:  MOVLW  20
1A65:  MOVLB  02
1A66:  MOVWF  46
1A67:  MOVLW  BD
1A68:  MOVWF  45
1A69:  MOVLW  20
1A6A:  MOVWF  48
1A6B:  MOVLW  A6
1A6C:  MOVWF  47
1A6D:  MOVLP  08
1A6E:  MOVLB  00
1A6F:  CALL   750
1A70:  MOVLP  18
1A71:  MOVF   78,F
1A72:  BTFSS  03.2
1A73:  GOTO   28B
....................     value = str_to_decimal(argument_name); 
1A74:  MOVLW  20
1A75:  MOVLB  02
1A76:  MOVWF  46
1A77:  MOVLW  6E
1A78:  MOVWF  45
1A79:  MOVLP  08
1A7A:  MOVLB  00
1A7B:  CALL   717
1A7C:  MOVLP  18
1A7D:  MOVF   78,W
1A7E:  MOVWF  76
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A7F:  MOVF   76,W
1A80:  SUBLW  24
1A81:  BTFSS  03.0
1A82:  GOTO   287
....................       argument = 0; 
1A83:  CLRF   75
....................       command  = MORSE_SEND; 
1A84:  MOVLW  0B
1A85:  MOVWF  70
....................     } else { 
1A86:  GOTO   28B
....................       command  = ADMIN; 
1A87:  MOVLW  09
1A88:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A89:  MOVLW  03
1A8A:  MOVWF  75
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A8B:  MOVLB  02
1A8C:  CLRF   45
1A8D:  CLRF   46
1A8E:  MOVLW  20
1A8F:  MOVWF  05
1A90:  MOVLW  BD
1A91:  MOVWF  04
1A92:  MOVF   45,W
1A93:  ADDWF  04,F
1A94:  MOVLW  00
1A95:  ADDWFC 05,F
1A96:  MOVF   46,W
1A97:  MOVLP  00
1A98:  MOVLB  00
1A99:  CALL   16E
1A9A:  MOVLP  18
1A9B:  MOVWF  00
1A9C:  IORLW  00
1A9D:  BTFSC  03.2
1A9E:  GOTO   2A4
1A9F:  MOVLB  02
1AA0:  INCF   46,F
1AA1:  INCF   45,F
1AA2:  GOTO   28E
1AA3:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1AA4:  MOVLW  20
1AA5:  MOVLB  02
1AA6:  MOVWF  46
1AA7:  MOVLW  BD
1AA8:  MOVWF  45
1AA9:  MOVLW  20
1AAA:  MOVWF  48
1AAB:  MOVLW  A6
1AAC:  MOVWF  47
1AAD:  MOVLP  08
1AAE:  MOVLB  00
1AAF:  CALL   750
1AB0:  MOVLP  18
1AB1:  MOVF   78,F
1AB2:  BTFSS  03.2
1AB3:  GOTO   2B6
....................     command=INCREMENT_REG; 
1AB4:  MOVLW  06
1AB5:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1AB6:  MOVLB  02
1AB7:  CLRF   45
1AB8:  CLRF   46
1AB9:  MOVLW  20
1ABA:  MOVWF  05
1ABB:  MOVLW  BD
1ABC:  MOVWF  04
1ABD:  MOVF   45,W
1ABE:  ADDWF  04,F
1ABF:  MOVLW  00
1AC0:  ADDWFC 05,F
1AC1:  MOVF   46,W
1AC2:  MOVLP  00
1AC3:  MOVLB  00
1AC4:  CALL   171
1AC5:  MOVLP  18
1AC6:  MOVWF  00
1AC7:  IORLW  00
1AC8:  BTFSC  03.2
1AC9:  GOTO   2CF
1ACA:  MOVLB  02
1ACB:  INCF   46,F
1ACC:  INCF   45,F
1ACD:  GOTO   2B9
1ACE:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1ACF:  MOVLW  20
1AD0:  MOVLB  02
1AD1:  MOVWF  46
1AD2:  MOVLW  BD
1AD3:  MOVWF  45
1AD4:  MOVLW  20
1AD5:  MOVWF  48
1AD6:  MOVLW  A6
1AD7:  MOVWF  47
1AD8:  MOVLP  08
1AD9:  MOVLB  00
1ADA:  CALL   750
1ADB:  MOVLP  18
1ADC:  MOVF   78,F
1ADD:  BTFSS  03.2
1ADE:  GOTO   2E1
....................     command=DECREMENT_REG; 
1ADF:  MOVLW  07
1AE0:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AE1:  MOVLB  02
1AE2:  CLRF   45
1AE3:  CLRF   46
1AE4:  MOVLW  20
1AE5:  MOVWF  05
1AE6:  MOVLW  BD
1AE7:  MOVWF  04
1AE8:  MOVF   45,W
1AE9:  ADDWF  04,F
1AEA:  MOVLW  00
1AEB:  ADDWFC 05,F
1AEC:  MOVF   46,W
1AED:  MOVLP  00
1AEE:  MOVLB  00
1AEF:  CALL   174
1AF0:  MOVLP  18
1AF1:  MOVWF  00
1AF2:  IORLW  00
1AF3:  BTFSC  03.2
1AF4:  GOTO   2FA
1AF5:  MOVLB  02
1AF6:  INCF   46,F
1AF7:  INCF   45,F
1AF8:  GOTO   2E4
1AF9:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1AFA:  MOVLW  20
1AFB:  MOVLB  02
1AFC:  MOVWF  46
1AFD:  MOVLW  BD
1AFE:  MOVWF  45
1AFF:  MOVLW  20
1B00:  MOVWF  48
1B01:  MOVLW  A6
1B02:  MOVWF  47
1B03:  MOVLP  08
1B04:  MOVLB  00
1B05:  CALL   750
1B06:  MOVLP  18
1B07:  MOVF   78,F
1B08:  BTFSS  03.2
1B09:  GOTO   329
....................     command=SET_REG; 
1B0A:  MOVLW  02
1B0B:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B0C:  MOVLW  01
1B0D:  ADDWF  74,W
1B0E:  ANDLW  03
1B0F:  MOVWF  76
....................     strcpy(argument_name,"CPOT"); 
1B10:  MOVLB  02
1B11:  CLRF   45
1B12:  CLRF   46
1B13:  MOVLW  20
1B14:  MOVWF  05
1B15:  MOVLW  6E
1B16:  MOVWF  04
1B17:  MOVF   45,W
1B18:  ADDWF  04,F
1B19:  MOVLW  00
1B1A:  ADDWFC 05,F
1B1B:  MOVF   46,W
1B1C:  MOVLP  00
1B1D:  MOVLB  00
1B1E:  CALL   177
1B1F:  MOVLP  18
1B20:  MOVWF  00
1B21:  IORLW  00
1B22:  BTFSC  03.2
1B23:  GOTO   329
1B24:  MOVLB  02
1B25:  INCF   46,F
1B26:  INCF   45,F
1B27:  GOTO   313
1B28:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B29:  MOVLB  02
1B2A:  CLRF   45
1B2B:  CLRF   46
1B2C:  MOVLW  20
1B2D:  MOVWF  05
1B2E:  MOVLW  BD
1B2F:  MOVWF  04
1B30:  MOVF   45,W
1B31:  ADDWF  04,F
1B32:  MOVLW  00
1B33:  ADDWFC 05,F
1B34:  MOVF   46,W
1B35:  MOVLP  00
1B36:  MOVLB  00
1B37:  CALL   17D
1B38:  MOVLP  18
1B39:  MOVWF  00
1B3A:  IORLW  00
1B3B:  BTFSC  03.2
1B3C:  GOTO   342
1B3D:  MOVLB  02
1B3E:  INCF   46,F
1B3F:  INCF   45,F
1B40:  GOTO   32C
1B41:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1B42:  MOVLW  20
1B43:  MOVLB  02
1B44:  MOVWF  46
1B45:  MOVLW  BD
1B46:  MOVWF  45
1B47:  MOVLW  20
1B48:  MOVWF  48
1B49:  MOVLW  A6
1B4A:  MOVWF  47
1B4B:  MOVLP  08
1B4C:  MOVLB  00
1B4D:  CALL   750
1B4E:  MOVLP  18
1B4F:  MOVF   78,F
1B50:  BTFSS  03.2
1B51:  GOTO   362
....................     AdminMode = ~AdminMode; 
1B52:  MOVLW  40
1B53:  MOVLB  01
1B54:  XORWF  5B,F
....................     set_admin_mode(AdminMode); 
1B55:  MOVLW  00
1B56:  BTFSC  5B.6
1B57:  MOVLW  01
1B58:  MOVLB  02
1B59:  MOVWF  45
1B5A:  MOVWF  46
1B5B:  MOVLP  08
1B5C:  MOVLB  00
1B5D:  CALL   513
1B5E:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B5F:  MOVLB  01
1B60:  BSF    5B.5
1B61:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
1187:  MOVF   76,W
1188:  SUBLW  FF
1189:  BTFSS  03.2
118A:  GOTO   1B1
....................     printf ("\n\r%s %u",argument,value); 
118B:  MOVLW  0A
118C:  CLRWDT
118D:  BTFSS  11.4
118E:  GOTO   18C
118F:  MOVLB  03
1190:  MOVWF  1A
1191:  MOVLW  0D
1192:  CLRWDT
1193:  MOVLB  00
1194:  BTFSC  11.4
1195:  GOTO   198
1196:  MOVLB  03
1197:  GOTO   192
1198:  MOVLB  03
1199:  MOVWF  1A
119A:  CLRF   05
119B:  MOVF   75,W
119C:  MOVWF  04
119D:  MOVLP  08
119E:  MOVLB  00
119F:  CALL   2A5
11A0:  MOVLP  10
11A1:  MOVLW  20
11A2:  CLRWDT
11A3:  BTFSS  11.4
11A4:  GOTO   1A2
11A5:  MOVLB  03
11A6:  MOVWF  1A
11A7:  MOVF   76,W
11A8:  MOVLB  02
11A9:  MOVWF  56
11AA:  MOVLW  1B
11AB:  MOVWF  57
11AC:  MOVLP  00
11AD:  MOVLB  00
11AE:  CALL   775
11AF:  MOVLP  10
....................   } else { 
11B0:  GOTO   23E
....................     pObj=RegMap[argument].reg_ptr; 
11B1:  RLF    75,W
11B2:  MOVWF  77
11B3:  RLF    77,F
11B4:  MOVLW  FC
11B5:  ANDWF  77,F
11B6:  MOVF   77,W
11B7:  MOVLB  02
11B8:  MOVWF  35
11B9:  INCF   35,W
11BA:  MOVLP  00
11BB:  MOVLB  00
11BC:  CALL   043
11BD:  MOVLP  10
11BE:  MOVWF  7A
11BF:  MOVLB  02
11C0:  MOVF   35,W
11C1:  MOVLP  00
11C2:  MOVLB  00
11C3:  CALL   043
11C4:  MOVLP  10
11C5:  MOVLB  02
11C6:  MOVWF  32
11C7:  MOVF   7A,W
11C8:  MOVWF  33
....................     if ( in_admin_mode() ) { 
11C9:  MOVLB  00
11CA:  CALL   027
11CB:  MOVF   78,F
11CC:  BTFSC  03.2
11CD:  GOTO   1D6
....................       *pObj=value; 
11CE:  MOVLB  02
11CF:  MOVF   32,W
11D0:  MOVWF  04
11D1:  MOVF   33,W
11D2:  MOVWF  05
11D3:  MOVF   76,W
11D4:  MOVWF  00
11D5:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
11D6:  MOVLB  02
11D7:  MOVF   32,W
11D8:  MOVWF  04
11D9:  MOVF   33,W
11DA:  MOVWF  05
11DB:  MOVF   00,W
11DC:  MOVWF  34
....................     LastRegisterIndex = argument; 
11DD:  MOVF   75,W
11DE:  MOVWF  7C
....................     LastRegisterIndexValid=1; 
11DF:  MOVLW  01
11E0:  MOVWF  7D
....................     printf ("\n\rSetting %s(%u) to %u",argument_name,argument,lVar); 
11E1:  MOVLW  F6
11E2:  MOVLB  03
11E3:  MOVWF  11
11E4:  MOVLW  04
11E5:  MOVWF  12
11E6:  BCF    03.0
11E7:  MOVLW  0A
11E8:  MOVLB  02
11E9:  MOVWF  56
11EA:  MOVLP  00
11EB:  MOVLB  00
11EC:  CALL   701
11ED:  MOVLP  10
11EE:  MOVLW  20
11EF:  MOVWF  05
11F0:  MOVLW  6E
11F1:  MOVWF  04
11F2:  MOVLP  08
11F3:  CALL   2A5
11F4:  MOVLP  10
11F5:  MOVLW  28
11F6:  CLRWDT
11F7:  BTFSS  11.4
11F8:  GOTO   1F6
11F9:  MOVLB  03
11FA:  MOVWF  1A
11FB:  MOVF   75,W
11FC:  MOVLB  02
11FD:  MOVWF  56
11FE:  MOVLW  1B
11FF:  MOVWF  57
1200:  MOVLP  00
1201:  MOVLB  00
1202:  CALL   775
1203:  MOVLP  10
1204:  MOVLW  FD
1205:  MOVLB  03
1206:  MOVWF  11
1207:  MOVLW  04
1208:  MOVWF  12
1209:  BSF    03.0
120A:  MOVLW  05
120B:  MOVLB  02
120C:  MOVWF  56
120D:  MOVLP  00
120E:  MOVLB  00
120F:  CALL   701
1210:  MOVLP  10
1211:  MOVLB  02
1212:  MOVF   34,W
1213:  MOVWF  56
1214:  MOVLW  1B
1215:  MOVWF  57
1216:  MOVLP  00
1217:  MOVLB  00
1218:  CALL   775
1219:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
121A:  MOVLB  02
121B:  MOVF   33,W
121C:  SUBLW  1F
121D:  BTFSC  03.0
121E:  GOTO   230
121F:  XORLW  FF
1220:  BTFSS  03.2
1221:  GOTO   226
1222:  MOVF   32,W
1223:  SUBLW  0B
1224:  BTFSC  03.0
1225:  GOTO   230
1226:  MOVF   33,W
1227:  SUBLW  20
1228:  BTFSS  03.0
1229:  GOTO   230
122A:  BTFSS  03.2
122B:  GOTO   237
122C:  MOVF   32,W
122D:  SUBLW  1B
122E:  BTFSC  03.0
122F:  GOTO   237
1230:  MOVF   32,W
1231:  SUBLW  74
1232:  BTFSS  03.2
1233:  GOTO   23B
1234:  MOVF   33,F
1235:  BTFSS  03.2
1236:  GOTO   23B
....................       increment(0); // Increment is done in this function. Only update trim pot. 
1237:  CLRF   35
1238:  MOVLB  00
1239:  CALL   036
123A:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
123B:  MOVLB  01
123C:  BSF    5B.5
123D:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
1036:  MOVF   74,W
1037:  ANDLW  03
1038:  MOVLB  02
1039:  MOVWF  39
....................   if ( CurrentCorIndex ) { 
103A:  MOVLB  00
103B:  MOVF   6B,F
103C:  BTFSC  03.2
103D:  GOTO   075
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
103E:  MOVLW  01
103F:  SUBWF  6B,W
1040:  MOVWF  77
1041:  RLF    77,F
1042:  RLF    77,F
1043:  MOVLW  FC
1044:  ANDWF  77,F
1045:  MOVF   77,W
1046:  MOVLB  02
1047:  ADDWF  39,W
1048:  ADDLW  0C
1049:  MOVWF  78
104A:  MOVLW  20
104B:  MOVWF  7A
104C:  BTFSC  03.0
104D:  INCF   7A,F
104E:  MOVF   78,W
104F:  MOVWF  36
1050:  MOVF   7A,W
1051:  MOVWF  37
....................     value = *pot_ptr; 
1052:  MOVF   36,W
1053:  MOVWF  04
1054:  MOVF   37,W
1055:  MOVWF  05
1056:  MOVF   00,W
1057:  MOVWF  38
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
1058:  MOVF   36,W
1059:  MOVWF  04
105A:  MOVF   37,W
105B:  MOVWF  05
105C:  MOVF   35,W
105D:  ADDWF  38,W
105E:  MOVWF  00
....................     if ( in_admin_mode() ) { 
105F:  MOVLB  00
1060:  CALL   027
1061:  MOVF   78,F
1062:  BTFSC  03.2
1063:  GOTO   075
....................       set_trimpot(CPotPtr,*pot_ptr); 
1064:  MOVLB  02
1065:  MOVF   37,W
1066:  MOVWF  7A
1067:  MOVF   36,W
1068:  MOVWF  04
1069:  MOVF   37,W
106A:  MOVWF  05
106B:  MOVF   00,W
106C:  MOVWF  3A
106D:  MOVF   39,W
106E:  MOVWF  45
106F:  MOVF   3A,W
1070:  MOVWF  46
1071:  MOVLP  08
1072:  MOVLB  00
1073:  CALL   000
1074:  MOVLP  10
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
1075:  MOVLP  08
1076:  CALL   2BF
1077:  MOVLP  10
.................... } // }}} 
1078:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
1000:  MOVLB  02
1001:  CLRF   45
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
1002:  MOVF   45,W
1003:  SUBLW  05
1004:  BTFSS  03.0
1005:  GOTO   025
....................     dest[c]=src[c]; 
1006:  MOVF   45,W
1007:  ADDWF  41,W
1008:  MOVWF  46
1009:  MOVLW  00
100A:  ADDWFC 42,W
100B:  MOVWF  47
100C:  MOVF   45,W
100D:  ADDWF  43,W
100E:  MOVWF  78
100F:  MOVLW  00
1010:  ADDWFC 44,W
1011:  MOVWF  7A
1012:  MOVF   78,W
1013:  MOVLB  03
1014:  MOVWF  11
1015:  MOVF   7A,W
1016:  MOVWF  12
1017:  MOVLB  02
1018:  MOVF   47,W
1019:  MOVWF  05
101A:  MOVF   46,W
101B:  MOVWF  04
101C:  MOVLW  01
101D:  MOVWF  4B
101E:  MOVLP  00
101F:  MOVLB  00
1020:  CALL   7DD
1021:  MOVLP  10
....................   c++; 
1022:  MOVLB  02
1023:  INCF   45,F
....................   } 
1024:  GOTO   002
.................... } // }}} 
1025:  MOVLB  00
1026:  RETURN
.................... void ExecAuxOutOp(int op,int arg,int ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
16DA:  MOVF   30,W
16DB:  ANDLW  0F
16DC:  MOVWF  32
....................   uarg = (arg & 0xF0) >> 4; 
16DD:  MOVF   30,W
16DE:  ANDLW  F0
16DF:  MOVWF  77
16E0:  SWAPF  77,W
16E1:  MOVWF  33
16E2:  MOVLW  0F
16E3:  ANDWF  33,F
....................   switch(op) { 
16E4:  MOVF   2F,W
16E5:  XORLW  01
16E6:  MOVLB  00
16E7:  BTFSC  03.2
16E8:  GOTO   6ED
16E9:  XORLW  03
16EA:  BTFSC  03.2
16EB:  GOTO   702
16EC:  GOTO   71B
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       AuxOut[ID] = ((COR_IN_EFFECTIVE ^ uarg) & larg) != 0; 
16ED:  MOVLW  22
16EE:  MOVLB  02
16EF:  ADDWF  31,W
16F0:  MOVWF  04
16F1:  MOVLW  20
16F2:  MOVWF  05
16F3:  BTFSC  03.0
16F4:  INCF   05,F
16F5:  MOVLB  00
16F6:  MOVF   6D,W
16F7:  MOVLB  02
16F8:  XORWF  33,W
16F9:  ANDWF  32,W
16FA:  BTFSS  03.2
16FB:  GOTO   6FE
16FC:  MOVLW  00
16FD:  GOTO   6FF
16FE:  MOVLW  01
16FF:  MOVWF  00
....................     break; 
1700:  MOVLB  00
1701:  GOTO   71B
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
1702:  MOVLW  22
1703:  MOVLB  02
1704:  ADDWF  31,W
1705:  MOVWF  04
1706:  MOVLW  20
1707:  MOVWF  05
1708:  BTFSC  03.0
1709:  INCF   05,F
170A:  MOVF   32,W
170B:  ANDLW  1F
170C:  MOVWF  36
170D:  MOVF   7A,W
170E:  MOVWF  37
170F:  MOVF   33,W
1710:  XORWF  36,F
1711:  BTFSS  03.2
1712:  GOTO   718
1713:  MOVF   37,F
1714:  BTFSS  03.2
1715:  GOTO   718
1716:  MOVLW  00
1717:  GOTO   719
1718:  MOVLW  01
1719:  MOVWF  00
....................     break; 
171A:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0F17:  MOVLB  02
0F18:  CLRF   47
0F19:  CLRF   48
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0F1A:  MOVF   47,W
0F1B:  ADDWF  45,W
0F1C:  MOVWF  04
0F1D:  MOVLW  00
0F1E:  ADDWFC 46,W
0F1F:  MOVWF  05
0F20:  MOVF   00,F
0F21:  BTFSC  03.2
0F22:  GOTO   74C
0F23:  MOVF   47,W
0F24:  ADDWF  45,W
0F25:  MOVWF  04
0F26:  MOVLW  00
0F27:  ADDWFC 46,W
0F28:  MOVWF  05
0F29:  MOVF   00,W
0F2A:  SUBLW  2F
0F2B:  BTFSC  03.0
0F2C:  GOTO   74C
0F2D:  MOVF   47,W
0F2E:  ADDWF  45,W
0F2F:  MOVWF  04
0F30:  MOVLW  00
0F31:  ADDWFC 46,W
0F32:  MOVWF  05
0F33:  MOVF   00,W
0F34:  SUBLW  39
0F35:  BTFSS  03.0
0F36:  GOTO   74C
....................     value = (value * 10) + (str[x]-'0'); 
0F37:  MOVF   48,W
0F38:  MOVWF  49
0F39:  MOVLW  0A
0F3A:  MOVWF  4A
0F3B:  MOVLB  00
0F3C:  CALL   6F0
0F3D:  MOVF   78,W
0F3E:  MOVLB  02
0F3F:  MOVWF  49
0F40:  MOVF   47,W
0F41:  ADDWF  45,W
0F42:  MOVWF  04
0F43:  MOVLW  00
0F44:  ADDWFC 46,W
0F45:  MOVWF  05
0F46:  MOVLW  30
0F47:  SUBWF  00,W
0F48:  ADDWF  49,W
0F49:  MOVWF  48
....................     x++; 
0F4A:  INCF   47,F
....................   } 
0F4B:  GOTO   71A
....................   return(value); 
0F4C:  MOVF   48,W
0F4D:  MOVWF  78
.................... } // }}} 
0F4E:  MOVLB  00
0F4F:  RETURN
.................... void ExecAuxInOp(int op,int arg,int ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
15FA:  MOVLB  02
15FB:  BCF    32.0
15FC:  MOVLW  1F
15FD:  ADDWF  31,W
15FE:  MOVWF  04
15FF:  MOVLW  20
1600:  MOVWF  05
1601:  BTFSC  03.0
1602:  INCF   05,F
1603:  MOVF   00,F
1604:  BTFSS  03.2
1605:  BSF    32.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
1606:  MOVF   30,W
1607:  ANDLW  0F
1608:  MOVWF  33
....................   uarg = (arg & 0xF0) >> 4; 
1609:  MOVF   30,W
160A:  ANDLW  F0
160B:  MOVWF  77
160C:  SWAPF  77,W
160D:  MOVWF  34
160E:  MOVLW  0F
160F:  ANDWF  34,F
....................   switch(op) { 
1610:  MOVLW  01
1611:  SUBWF  2F,W
1612:  ADDLW  FC
1613:  BTFSC  03.0
1614:  GOTO   65B
1615:  ADDLW  04
1616:  MOVLB  00
1617:  GOTO   65E
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
1618:  MOVLB  02
1619:  BTFSS  32.0
161A:  GOTO   620
....................         Enable_Mask &= arg; 
161B:  MOVF   30,W
161C:  MOVLB  00
161D:  ANDWF  61,F
....................       } else { // AuxIn is not enabled 
161E:  GOTO   625
161F:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
1620:  MOVF   30,W
1621:  XORLW  FF
1622:  ANDLW  0F
1623:  MOVLB  00
1624:  IORWF  61,F
....................       } 
....................       break; 
1625:  MOVLB  02
1626:  GOTO   65B
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
1627:  MOVLB  02
1628:  BTFSS  32.0
1629:  GOTO   630
....................         COR_DROP_FLAG=1; 
162A:  BSF    72.7
....................         TailChar=arg; 
162B:  MOVF   30,W
162C:  MOVLB  00
162D:  MOVWF  68
....................       } else { 
162E:  GOTO   632
162F:  MOVLB  02
....................         TailChar=0; 
1630:  MOVLB  00
1631:  CLRF   68
....................       } 
....................     break; 
1632:  MOVLB  02
1633:  GOTO   65B
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
1634:  MOVLB  02
1635:  BTFSC  32.0
1636:  GOTO   63D
....................         COR_DROP_FLAG=1; 
1637:  BSF    72.7
....................         TailChar=arg; 
1638:  MOVF   30,W
1639:  MOVLB  00
163A:  MOVWF  68
....................       } else { 
163B:  GOTO   63F
163C:  MOVLB  02
....................         TailChar=0; 
163D:  MOVLB  00
163E:  CLRF   68
....................       } 
....................     break; 
163F:  MOVLB  02
1640:  GOTO   65B
....................     case AUXI_EMULATE_COR: 
....................       if ( (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0 ) { 
1641:  MOVLB  02
1642:  MOVF   30,W
1643:  ANDLW  10
1644:  BTFSC  03.2
1645:  GOTO   64A
....................         tmp_bit = ~in_bit; 
1646:  BCF    32.1
1647:  BTFSS  32.0
1648:  BSF    32.1
....................       } else { 
1649:  GOTO   64D
....................         tmp_bit = in_bit; 
164A:  BCF    32.1
164B:  BTFSC  32.0
164C:  BSF    32.1
....................       } 
....................       if ( tmp_bit ) { 
164D:  BTFSS  32.1
164E:  GOTO   654
....................         COR_EMUL |= larg; 
164F:  MOVF   33,W
1650:  MOVLB  00
1651:  IORWF  67,F
....................       } else { 
1652:  GOTO   658
1653:  MOVLB  02
....................         COR_EMUL &= ~larg; 
1654:  MOVF   33,W
1655:  XORLW  FF
1656:  MOVLB  00
1657:  ANDWF  67,F
....................       } 
....................     break; 
1658:  MOVLB  02
1659:  GOTO   65B
165A:  MOVLB  02
....................   } 
.................... } // }}} 
165B:  MOVLP  10
165C:  MOVLB  00
165D:  GOTO   78C (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
15AD:  MOVLB  01
15AE:  CLRF   6C
15AF:  MOVF   6C,W
15B0:  SUBLW  02
15B1:  BTFSS  03.0
15B2:  GOTO   5F7
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = (input(AUX_IN_PIN[x])!=0) || (AuxIn[x]!=0); 
15B3:  MOVLW  1F
15B4:  ADDWF  6C,W
15B5:  MOVWF  78
15B6:  MOVLW  20
15B7:  MOVWF  7A
15B8:  BTFSC  03.0
15B9:  INCF   7A,F
15BA:  MOVF   78,W
15BB:  MOVLB  02
15BC:  MOVWF  20
15BD:  MOVF   7A,W
15BE:  MOVWF  21
15BF:  MOVLB  01
15C0:  MOVF   6C,W
15C1:  MOVLP  00
15C2:  MOVLB  00
15C3:  CALL   03F
15C4:  MOVLP  10
15C5:  MOVLB  02
15C6:  MOVWF  22
15C7:  MOVWF  46
15C8:  MOVLW  01
15C9:  MOVWF  47
15CA:  CLRF   49
15CB:  MOVLW  80
15CC:  MOVWF  48
15CD:  MOVLP  08
15CE:  MOVLB  00
15CF:  CALL   142
15D0:  MOVLP  10
15D1:  MOVLB  02
15D2:  MOVF   22,W
15D3:  MOVWF  23
15D4:  CLRF   25
15D5:  CLRF   24
15D6:  MOVLB  00
15D7:  GOTO   593
15D8:  BTFSC  78.0
15D9:  GOTO   5EA
15DA:  MOVLW  1C
15DB:  MOVLB  01
15DC:  ADDWF  6C,W
15DD:  MOVWF  04
15DE:  MOVLW  20
15DF:  MOVWF  05
15E0:  BTFSC  03.0
15E1:  INCF   05,F
15E2:  MOVF   00,F
15E3:  BTFSC  03.2
15E4:  GOTO   5E7
15E5:  MOVLB  00
15E6:  GOTO   5EA
15E7:  MOVLW  00
15E8:  GOTO   5EC
15E9:  MOVLB  00
15EA:  MOVLW  01
15EB:  MOVLB  01
15EC:  MOVLB  02
15ED:  MOVWF  23
15EE:  MOVF   21,W
15EF:  MOVWF  05
15F0:  MOVF   20,W
15F1:  MOVWF  04
15F2:  MOVF   23,W
15F3:  MOVWF  00
....................   } 
15F4:  MOVLB  01
15F5:  INCF   6C,F
15F6:  GOTO   5AF
.................... } // }}} 
15F7:  MOVLP  18
15F8:  MOVLB  00
15F9:  GOTO   6B0 (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
169F:  MOVLW  30
16A0:  MOVLB  01
16A1:  MOVWF  6F
16A2:  MOVLB  02
16A3:  MOVWF  20
16A4:  MOVWF  21
16A5:  CLRF   22
....................   char AuxOut_s[4]={'0','0','0',0}; 
16A6:  MOVWF  23
16A7:  MOVWF  24
16A8:  MOVWF  25
16A9:  CLRF   26
....................   char ADM[]=" ADMIN"; 
16AA:  MOVLW  20
16AB:  MOVWF  27
16AC:  MOVLW  41
16AD:  MOVWF  28
16AE:  MOVLW  44
16AF:  MOVWF  29
16B0:  MOVLW  4D
16B1:  MOVWF  2A
16B2:  MOVLW  49
16B3:  MOVWF  2B
16B4:  MOVLW  4E
16B5:  MOVWF  2C
16B6:  CLRF   2D
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
16B7:  MOVLB  01
16B8:  CLRF   6C
16B9:  MOVF   6C,W
16BA:  SUBLW  02
16BB:  BTFSS  03.0
16BC:  GOTO   78F
....................     AuxOp = AuxOutOp[x]; 
16BD:  MOVLW  33
16BE:  ADDWF  6C,W
16BF:  MOVWF  04
16C0:  MOVLW  20
16C1:  MOVWF  05
16C2:  BTFSC  03.0
16C3:  INCF   05,F
16C4:  MOVF   00,W
16C5:  MOVWF  6D
....................     AuxArg = AuxOutArg[x]; 
16C6:  MOVLW  36
16C7:  ADDWF  6C,W
16C8:  MOVWF  04
16C9:  MOVLW  20
16CA:  MOVWF  05
16CB:  BTFSC  03.0
16CC:  INCF   05,F
16CD:  MOVF   00,W
16CE:  MOVWF  6E
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
16CF:  MOVF   6D,W
16D0:  MOVLB  02
16D1:  MOVWF  2F
16D2:  MOVLB  01
16D3:  MOVF   6E,W
16D4:  MOVLB  02
16D5:  MOVWF  30
16D6:  MOVLB  01
16D7:  MOVF   6C,W
16D8:  MOVLB  02
16D9:  MOVWF  31
....................     out_bit = (AuxOut[x])==0; 
*
171B:  MOVLB  02
171C:  BCF    2E.0
171D:  MOVLW  22
171E:  MOVLB  01
171F:  ADDWF  6C,W
1720:  MOVWF  04
1721:  MOVLW  20
1722:  MOVWF  05
1723:  BTFSC  03.0
1724:  INCF   05,F
1725:  MOVF   00,F
1726:  BTFSS  03.2
1727:  GOTO   72B
1728:  MOVLB  02
1729:  BSF    2E.0
172A:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
172B:  MOVF   6C,W
172C:  MOVLP  00
172D:  MOVLB  00
172E:  CALL   03B
172F:  MOVLP  10
1730:  MOVLB  02
1731:  MOVWF  2F
1732:  MOVLW  00
1733:  BTFSC  2E.0
1734:  MOVLW  01
1735:  MOVWF  77
1736:  MOVF   2F,W
1737:  MOVWF  46
1738:  MOVF   77,W
1739:  MOVWF  47
173A:  MOVLW  01
173B:  MOVWF  49
173C:  CLRF   48
173D:  MOVLP  08
173E:  MOVLB  00
173F:  CALL   142
1740:  MOVLP  10
1741:  MOVLB  02
1742:  MOVF   2F,W
1743:  MOVWF  46
1744:  CLRF   47
1745:  CLRF   49
1746:  MOVLW  80
1747:  MOVWF  48
1748:  MOVLP  08
1749:  MOVLB  00
174A:  CALL   142
174B:  MOVLP  10
....................     if(out_bit==0) { 
174C:  MOVLB  02
174D:  BTFSC  2E.0
174E:  GOTO   75A
....................       AuxOut_s[x]='1'; 
174F:  MOVLW  A3
1750:  MOVLB  01
1751:  ADDWF  6C,W
1752:  MOVWF  04
1753:  MOVLW  20
1754:  MOVWF  05
1755:  BTFSC  03.0
1756:  INCF   05,F
1757:  MOVLW  31
1758:  MOVWF  00
1759:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
175A:  MOVLW  39
175B:  MOVLB  01
175C:  ADDWF  6C,W
175D:  MOVWF  04
175E:  MOVLW  20
175F:  MOVWF  05
1760:  BTFSC  03.0
1761:  INCF   05,F
1762:  MOVF   00,W
1763:  MOVWF  6D
....................     AuxArg = AuxInArg[x]; 
1764:  MOVLW  3C
1765:  ADDWF  6C,W
1766:  MOVWF  04
1767:  MOVLW  20
1768:  MOVWF  05
1769:  BTFSC  03.0
176A:  INCF   05,F
176B:  MOVF   00,W
176C:  MOVWF  6E
....................     if(AuxInSW[x]==1) { 
176D:  MOVLW  1F
176E:  ADDWF  6C,W
176F:  MOVWF  04
1770:  MOVLW  20
1771:  MOVWF  05
1772:  BTFSC  03.0
1773:  INCF   05,F
1774:  DECFSZ 00,W
1775:  GOTO   77F
....................       AuxIn_s[x]='1'; 
1776:  MOVLW  9F
1777:  ADDWF  6C,W
1778:  MOVWF  04
1779:  MOVLW  20
177A:  MOVWF  05
177B:  BTFSC  03.0
177C:  INCF   05,F
177D:  MOVLW  31
177E:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
177F:  MOVF   6D,W
1780:  MOVLB  02
1781:  MOVWF  2F
1782:  MOVLB  01
1783:  MOVF   6E,W
1784:  MOVLB  02
1785:  MOVWF  30
1786:  MOVLB  01
1787:  MOVF   6C,W
1788:  MOVLB  02
1789:  MOVWF  31
178A:  MOVLB  00
178B:  GOTO   5FA
....................     // }}} 
....................   } 
178C:  MOVLB  01
178D:  INCF   6C,F
178E:  GOTO   6B9
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
178F:  MOVLW  20
1790:  MOVWF  62
1791:  MOVLW  74
1792:  MOVWF  61
1793:  MOVLW  49
1794:  MOVLB  02
1795:  MOVWF  56
1796:  MOVLP  00
1797:  MOVLB  00
1798:  CALL   7F0
1799:  MOVLP  10
179A:  MOVLW  3A
179B:  MOVLB  02
179C:  MOVWF  56
179D:  MOVLP  00
179E:  MOVLB  00
179F:  CALL   7F0
17A0:  MOVLP  10
17A1:  MOVLW  20
17A2:  MOVWF  05
17A3:  MOVLW  9F
17A4:  MOVWF  04
17A5:  MOVLP  08
17A6:  CALL   1BB
17A7:  MOVLP  10
17A8:  MOVLW  20
17A9:  MOVLB  02
17AA:  MOVWF  56
17AB:  MOVLP  00
17AC:  MOVLB  00
17AD:  CALL   7F0
17AE:  MOVLP  10
17AF:  MOVLW  4F
17B0:  MOVLB  02
17B1:  MOVWF  56
17B2:  MOVLP  00
17B3:  MOVLB  00
17B4:  CALL   7F0
17B5:  MOVLP  10
17B6:  MOVLW  3A
17B7:  MOVLB  02
17B8:  MOVWF  56
17B9:  MOVLP  00
17BA:  MOVLB  00
17BB:  CALL   7F0
17BC:  MOVLP  10
17BD:  MOVLW  20
17BE:  MOVWF  05
17BF:  MOVLW  A3
17C0:  MOVWF  04
17C1:  MOVLP  08
17C2:  CALL   1BB
17C3:  MOVLP  10
....................   if ( AdminMode ) { 
17C4:  MOVLB  01
17C5:  BTFSS  5B.6
17C6:  GOTO   7D3
....................     strcat(LCD_str,ADM); 
17C7:  MOVLW  20
17C8:  MOVLB  02
17C9:  MOVWF  30
17CA:  MOVLW  74
17CB:  MOVWF  2F
17CC:  MOVLW  20
17CD:  MOVWF  32
17CE:  MOVLW  A7
17CF:  MOVWF  31
17D0:  MOVLB  00
17D1:  CALL   666
17D2:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
17D3:  MOVLW  03
17D4:  MOVLB  02
17D5:  MOVWF  50
17D6:  MOVLW  20
17D7:  MOVWF  52
17D8:  MOVLW  74
17D9:  MOVWF  51
17DA:  MOVLP  08
17DB:  MOVLB  00
17DC:  CALL   1D2
17DD:  MOVLP  10
.................... } // }}} 
17DE:  RETURN
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
10DA:  MOVLW  01
10DB:  MOVLB  02
10DC:  MOVWF  34
10DD:  MOVLP  08
10DE:  MOVLB  00
10DF:  CALL   3C1
10E0:  MOVLP  10
....................   delay_ms(1000); 
10E1:  MOVLW  04
10E2:  MOVLB  02
10E3:  MOVWF  34
10E4:  MOVLW  FA
10E5:  MOVWF  50
10E6:  MOVLP  00
10E7:  MOVLB  00
10E8:  CALL   7C4
10E9:  MOVLP  10
10EA:  MOVLB  02
10EB:  DECFSZ 34,F
10EC:  GOTO   0E4
....................   for(x=0;x<6;x++) { 
10ED:  CLRF   32
10EE:  MOVF   32,W
10EF:  SUBLW  05
10F0:  BTFSS  03.0
10F1:  GOTO   10E
....................     mchar=Morse[x]; 
10F2:  MOVLW  2D
10F3:  ADDWF  32,W
10F4:  MOVWF  04
10F5:  MOVLW  20
10F6:  MOVWF  05
10F7:  BTFSC  03.0
10F8:  INCF   05,F
10F9:  MOVF   00,W
10FA:  MOVWF  33
....................     morse(mchar); 
10FB:  MOVF   33,W
10FC:  MOVWF  45
10FD:  MOVLP  08
10FE:  MOVLB  00
10FF:  CALL   0E9
1100:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
1101:  MOVLB  01
1102:  CLRF   31
1103:  MOVLW  06
1104:  MOVWF  30
....................     while(aux_timer) { 
1105:  MOVF   30,W
1106:  IORWF  31,W
1107:  BTFSC  03.2
1108:  GOTO   10B
....................       delay_cycles(1); 
1109:  NOP
....................     } 
110A:  GOTO   105
....................   } 
110B:  MOVLB  02
110C:  INCF   32,F
110D:  GOTO   0EE
....................   delay_ms(1000); 
110E:  MOVLW  04
110F:  MOVWF  34
1110:  MOVLW  FA
1111:  MOVWF  50
1112:  MOVLP  00
1113:  MOVLB  00
1114:  CALL   7C4
1115:  MOVLP  10
1116:  MOVLB  02
1117:  DECFSZ 34,F
1118:  GOTO   110
....................   COR_FLAG=1; 
1119:  BSF    72.3
.................... } // }}} 
111A:  MOVLB  00
111B:  RETURN
.................... void main (void) { // {{{ 
*
1DC7:  CLRF   05
1DC8:  CLRF   04
1DC9:  MOVLW  1F
1DCA:  ANDWF  03,F
1DCB:  MOVLW  72
1DCC:  MOVLB  01
1DCD:  MOVWF  19
1DCE:  BSF    0E.3
1DCF:  BSF    0E.4
1DD0:  MOVLB  04
1DD1:  BCF    17.0
1DD2:  BCF    17.1
1DD3:  BCF    17.3
1DD4:  MOVLW  13
1DD5:  MOVWF  12
1DD6:  MOVLW  28
1DD7:  MOVWF  15
1DD8:  BSF    14.7
1DD9:  BCF    14.6
1DDA:  MOVLW  0C
1DDB:  MOVLB  03
1DDC:  MOVWF  1B
1DDD:  MOVLW  A2
1DDE:  MOVWF  1E
1DDF:  MOVLW  90
1DE0:  MOVWF  1D
1DE1:  MOVLB  01
1DE2:  BSF    60.0
1DE3:  CLRF   62
1DE4:  CLRF   61
1DE5:  MOVLB  0F
1DE6:  CLRF   11
1DE7:  CLRF   12
1DE8:  CLRF   18
1DE9:  CLRF   19
1DEA:  CLRF   1A
1DEB:  MOVLB  03
1DEC:  CLRF   0C
1DED:  CLRF   0D
1DEE:  CLRF   0F
1DEF:  CLRF   10
1DF0:  MOVLB  02
1DF1:  CLRF   12
1DF2:  CLRF   11
1DF3:  CLRF   14
1DF4:  CLRF   13
....................   int x,dtmf; 
....................   char tmp[5]; 
....................   initialize(); 
*
1DF8:  MOVLP  08
1DF9:  GOTO   52A
1DFA:  MOVLP  18
....................   char enter_b,select_b; 
....................  
....................   setup_adc(ADC_CLOCK_INTERNAL); 
1DFB:  MOVLB  01
1DFC:  BSF    1E.4
1DFD:  BSF    1E.5
1DFE:  BCF    1E.6
1DFF:  BCF    1E.7
1E00:  BSF    1D.0
....................   setup_adc_ports(ADJ_POT|VSS_VDD); 
1E01:  BCF    1E.0
1E02:  BCF    1E.1
1E03:  BCF    1E.2
1E04:  MOVLW  00
1E05:  MOVLB  03
1E06:  MOVWF  0C
1E07:  MOVWF  10
1E08:  MOVLW  20
1E09:  MOVWF  0D
1E0A:  MOVLW  00
1E0B:  MOVWF  0F
....................   set_adc_channel(13); 
1E0C:  MOVLW  34
1E0D:  MOVWF  78
1E0E:  MOVLB  01
1E0F:  MOVF   1D,W
1E10:  ANDLW  83
1E11:  IORWF  78,W
1E12:  MOVWF  1D
....................  
....................   while(1) { // {{{ 
....................     restart_wdt(); 
1E13:  CLRWDT
.................... #ifdef BUTTON_STATES 
....................   // Process Enter / select buttons {{{ 
....................   if ( input(ENTER_BUTTON)==0 ) { 
1E14:  BSF    0C.7
1E15:  MOVLB  00
1E16:  BTFSC  0C.7
1E17:  GOTO   624
....................     ENTER_PRESSED = (enter_b == DEBOUNCE_COUNT); 
1E18:  BCF    72.1
1E19:  MOVLB  01
1E1A:  MOVF   6A,W
1E1B:  SUBLW  08
1E1C:  BTFSC  03.2
1E1D:  BSF    72.1
....................     if ( enter_b < DEBOUNCE_COUNT+ 1 ) { 
1E1E:  MOVF   6A,W
1E1F:  SUBLW  08
1E20:  BTFSC  03.0
....................       enter_b++;  
1E21:  INCF   6A,F
....................     } 
....................   } else { 
1E22:  GOTO   627
1E23:  MOVLB  00
....................     enter_b = 0; 
1E24:  MOVLB  01
1E25:  CLRF   6A
....................     ENTER_PRESSED = 0; 
1E26:  BCF    72.1
....................   } 
....................   if ( input(SELECT_BUTTON)==0 ) { 
1E27:  MOVLB  00
1E28:  BTFSC  10.3
1E29:  GOTO   636
....................     SELECT_PRESSED = (select_b == DEBOUNCE_COUNT); 
1E2A:  BCF    72.2
1E2B:  MOVLB  01
1E2C:  MOVF   6B,W
1E2D:  SUBLW  08
1E2E:  BTFSC  03.2
1E2F:  BSF    72.2
....................     if ( select_b < DEBOUNCE_COUNT + 1 ) { 
1E30:  MOVF   6B,W
1E31:  SUBLW  08
1E32:  BTFSC  03.0
....................       select_b++; 
1E33:  INCF   6B,F
....................     } 
....................   } else { 
1E34:  GOTO   639
1E35:  MOVLB  00
....................     select_b = 0; 
1E36:  MOVLB  01
1E37:  CLRF   6B
....................     SELECT_PRESSED = 0; 
1E38:  BCF    72.2
....................   } 
....................   // Define Button States 
....................   // IDLE + ENTER --> TRIM 
....................   // TRIM + ENTER --> Exit 
....................   // TRIM + SELECT --> NextPot 
....................   #define IDLE 0 
....................   #define CALIB 16 
....................   #define TRIM 15  
....................   switch (button_state) { 
1E39:  MOVF   5A,W
1E3A:  XORLW  00
1E3B:  MOVLB  00
1E3C:  BTFSC  03.2
1E3D:  GOTO   645
1E3E:  XORLW  10
1E3F:  BTFSC  03.2
1E40:  GOTO   64C
1E41:  XORLW  1F
1E42:  BTFSC  03.2
1E43:  GOTO   65E
1E44:  GOTO   69E
....................     case IDLE:   
....................       if ( ENTER_PRESSED == 1 ) { 
1E45:  BTFSS  72.1
1E46:  GOTO   64B
....................         button_state=CALIB; 
1E47:  MOVLW  10
1E48:  MOVLB  01
1E49:  MOVWF  5A
1E4A:  MOVLB  00
....................       } 
....................     break; 
1E4B:  GOTO   6A1
....................     case CALIB: 
....................       adj_value_a = read_adc() >> 2; 
1E4C:  MOVLB  01
1E4D:  BSF    1D.1
1E4E:  BTFSC  1D.1
1E4F:  GOTO   64E
1E50:  RRF    1C,W
1E51:  MOVWF  7E
1E52:  RRF    7E,F
1E53:  MOVLW  3F
1E54:  ANDWF  7E,F
....................       adj_value_b = adj_value_a; 
1E55:  MOVF   7E,W
1E56:  MOVWF  59
....................       button_state=TRIM; 
1E57:  MOVLW  0F
1E58:  MOVWF  5A
....................       pot_values_to_lcd(); 
1E59:  MOVLP  08
1E5A:  MOVLB  00
1E5B:  CALL   2BF
1E5C:  MOVLP  18
....................       break; 
1E5D:  GOTO   6A1
....................     case TRIM: 
....................        if ( ((COR_IN|COR_EMUL)&0x0F) != 0 ) { 
1E5E:  MOVF   5F,W
1E5F:  IORWF  67,W
1E60:  ANDLW  0F
1E61:  BTFSC  03.2
1E62:  GOTO   687
....................          adj_value_a = read_adc() >> 2; 
1E63:  MOVLB  01
1E64:  BSF    1D.1
1E65:  BTFSC  1D.1
1E66:  GOTO   665
1E67:  RRF    1C,W
1E68:  MOVWF  7E
1E69:  RRF    7E,F
1E6A:  MOVLW  3F
1E6B:  ANDWF  7E,F
....................          if ( adj_value_a != adj_value_b ) { 
1E6C:  MOVF   59,W
1E6D:  SUBWF  7E,W
1E6E:  BTFSC  03.2
1E6F:  GOTO   684
....................            rs232_mode = 1; 
1E70:  BSF    5B.7
....................            set_trimpot(CurrentTrimPot, 63-adj_value_a); 
1E71:  MOVF   7E,W
1E72:  SUBLW  3F
1E73:  MOVWF  6C
1E74:  MOVF   74,W
1E75:  MOVLB  02
1E76:  MOVWF  45
1E77:  MOVLB  01
1E78:  MOVF   6C,W
1E79:  MOVLB  02
1E7A:  MOVWF  46
1E7B:  MOVLP  08
1E7C:  MOVLB  00
1E7D:  CALL   000
1E7E:  MOVLP  18
....................            pot_values_to_lcd(); 
1E7F:  MOVLP  08
1E80:  CALL   2BF
1E81:  MOVLP  18
....................            rs232_mode = 0; 
1E82:  MOVLB  01
1E83:  BCF    5B.7
....................          } 
....................          adj_value_b = adj_value_a; 
1E84:  MOVF   7E,W
1E85:  MOVWF  59
1E86:  MOVLB  00
.................... 	     } 
....................        if ( SELECT_PRESSED == 1 ) { 
1E87:  BTFSS  72.2
1E88:  GOTO   690
....................          CurrentTrimPot = (CurrentTrimPot + 1 ) & 0x03; 
1E89:  MOVLW  01
1E8A:  ADDWF  74,W
1E8B:  ANDLW  03
1E8C:  MOVWF  74
....................          pot_values_to_lcd(); 
1E8D:  MOVLP  08
1E8E:  CALL   2BF
1E8F:  MOVLP  18
....................        } 
....................        if ( ENTER_PRESSED == 1 ) { 
1E90:  BTFSS  72.1
1E91:  GOTO   69A
....................          // Hold SELECT and press ENTER to store settings in EEPROM 
....................          if ( input(SELECT_BUTTON)==0 ) { 
1E92:  BTFSC  10.3
1E93:  GOTO   697
....................            store_variables(); 
1E94:  MOVLP  00
1E95:  CALL   61C
1E96:  MOVLP  18
....................          } 
....................          button_state = IDLE; 
1E97:  MOVLB  01
1E98:  CLRF   5A
1E99:  MOVLB  00
.................... 	     }  
....................        status_led(); 
1E9A:  MOVLP  08
1E9B:  GOTO   5E7
1E9C:  MOVLP  18
....................     break; 
1E9D:  GOTO   6A1
....................     default: 
....................   		button_state = IDLE; 
1E9E:  MOVLB  01
1E9F:  CLRF   5A
....................     break; 
1EA0:  MOVLB  00
....................   } 
....................   restart_wdt(); 
1EA1:  CLRWDT
....................   // }}} 
.................... #endif 
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "#" or a "\r" is received. 
....................     if ( sBufferFlag ) { 
1EA2:  BTFSS  72.0
1EA3:  GOTO   6A9
....................       process_sBuffer(); 
1EA4:  GOTO   000
....................       clear_sBuffer(); 
1EA5:  MOVLP  00
1EA6:  CALL   50F
1EA7:  MOVLP  18
....................       sBufferFlag=0; 
1EA8:  BCF    72.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1EA9:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1EAA:  MOVLB  01
1EAB:  BTFSS  5B.0
1EAC:  GOTO   6B3
....................       update_aux_in(); 
1EAD:  MOVLP  10
1EAE:  MOVLB  00
1EAF:  GOTO   5AD
1EB0:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1EB1:  MOVLB  01
1EB2:  BCF    5B.0
....................     } 
....................     if ( SECOND_FLAG ) { 
1EB3:  BTFSS  72.4
1EB4:  GOTO   6FE
....................       update_aux_out(); 
1EB5:  MOVLP  10
1EB6:  MOVLB  00
1EB7:  CALL   69F
1EB8:  MOVLP  18
....................       // Time Out PTT {{{ 
....................       if ( TOT_SecondCounter || TOT_Min == 0) { 
1EB9:  MOVLB  01
1EBA:  MOVF   5E,W
1EBB:  IORWF  5F,W
1EBC:  BTFSS  03.2
1EBD:  GOTO   6C3
1EBE:  MOVLB  00
1EBF:  MOVF   66,F
1EC0:  BTFSS  03.2
1EC1:  GOTO   6C9
1EC2:  MOVLB  01
....................         TOT_SecondCounter--; 
1EC3:  MOVF   5E,W
1EC4:  BTFSC  03.2
1EC5:  DECF   5F,F
1EC6:  DECF   5E,F
....................       } else if ( COR_IN != 0x00 ) { 
1EC7:  GOTO   6DD
1EC8:  MOVLB  00
1EC9:  MOVF   5F,F
1ECA:  BTFSC  03.2
1ECB:  GOTO   6DE
....................         update_ptt(0); 
1ECC:  MOVLB  02
1ECD:  CLRF   34
1ECE:  MOVLP  08
1ECF:  MOVLB  00
1ED0:  CALL   3C1
1ED1:  MOVLP  18
....................         printf("\n\r# PTT Timeout!\n"); 
1ED2:  MOVLW  02
1ED3:  MOVLB  03
1ED4:  MOVWF  11
1ED5:  MOVLW  05
1ED6:  MOVWF  12
1ED7:  MOVLP  00
1ED8:  MOVLB  00
1ED9:  CALL   529
1EDA:  MOVLP  18
....................         PROMPT_FLAG=1; 
1EDB:  MOVLB  01
1EDC:  BSF    5B.5
1EDD:  MOVLB  00
....................       } 
....................       // }}} 
....................       // Admin mode timeout {{{ 
....................       if ( admin_timer ) { 
1EDE:  MOVF   73,F
1EDF:  BTFSC  03.2
1EE0:  GOTO   6E3
....................         admin_timer--; 
1EE1:  DECF   73,F
....................       } else { 
1EE2:  GOTO   6EC
....................         // Exit admin mode. 
....................         if ( AdminMode ) { 
1EE3:  MOVLB  01
1EE4:  BTFSS  5B.6
1EE5:  GOTO   6ED
....................           set_admin_mode(0); 
1EE6:  MOVLB  02
1EE7:  CLRF   46
1EE8:  MOVLP  08
1EE9:  MOVLB  00
1EEA:  CALL   513
1EEB:  MOVLP  18
1EEC:  MOVLB  01
....................         } 
....................       } 
....................       // }}} 
....................       restart_wdt(); 
1EED:  CLRWDT
....................       if ( SecondCounter ) { 
1EEE:  MOVF   5C,F
1EEF:  BTFSC  03.2
1EF0:  GOTO   6F3
....................         SecondCounter--; 
1EF1:  DECF   5C,F
....................       } else { 
1EF2:  GOTO   6FD
....................         SecondCounter=SEC_COUNTER; 
1EF3:  MOVLW  3B
1EF4:  MOVWF  5C
....................         if ( MinuteCounter ) { 
1EF5:  MOVF   5D,F
1EF6:  BTFSC  03.2
1EF7:  GOTO   6FA
....................           MinuteCounter--; 
1EF8:  DECF   5D,F
....................         } else { 
1EF9:  GOTO   6FD
....................           THIRTY_MIN_FLAG=1; 
1EFA:  BSF    72.6
....................           MinuteCounter = MIN_COUNTER; 
1EFB:  MOVLW  1D
1EFC:  MOVWF  5D
....................         } 
....................       } 
....................       SECOND_FLAG=0; 
1EFD:  BCF    72.4
....................     } 
....................     if ( THIRTY_MIN_FLAG ) { 
1EFE:  BTFSS  72.6
1EFF:  GOTO   71C
....................       if ( (TXSiteID&0x03) !=0 ) { 
1F00:  MOVLB  00
1F01:  MOVF   64,W
1F02:  ANDLW  03
1F03:  BTFSC  03.2
1F04:  GOTO   719
....................         // Transmit Site ID every 30 mins when: 
....................         // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................         // E = Transmit every 30 mins 
....................         // M = Transmit only if EnableMask is off 
....................         if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
1F05:  MOVF   64,W
1F06:  ANDLW  01
1F07:  BTFSS  03.2
1F08:  GOTO   716
1F09:  MOVF   64,W
1F0A:  ANDLW  02
1F0B:  BTFSC  03.2
1F0C:  GOTO   719
1F0D:  SWAPF  64,W
1F0E:  MOVWF  77
1F0F:  MOVLW  0F
1F10:  ANDWF  77,F
1F11:  MOVF   77,W
1F12:  ANDLW  0F
1F13:  ANDWF  60,W
1F14:  BTFSS  03.2
1F15:  GOTO   719
....................           send_morse_id(); 
1F16:  MOVLP  10
1F17:  CALL   0DA
1F18:  MOVLP  18
....................         } 
....................       } 
....................       THIRTY_MIN_FLAG=0; 
1F19:  BCF    72.6
....................       restart_wdt(); 
1F1A:  CLRWDT
1F1B:  MOVLB  01
....................     } 
....................     if ( COR_FLAG ) { 
1F1C:  BTFSS  72.3
1F1D:  GOTO   726
....................       process_cor(); 
1F1E:  MOVLB  00
1F1F:  GOTO   430
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       update_aux_out();  
1F20:  MOVLP  10
1F21:  CALL   69F
1F22:  MOVLP  18
....................       COR_FLAG=0; 
1F23:  BCF    72.3
....................       restart_wdt(); 
1F24:  CLRWDT
1F25:  MOVLB  01
....................      } 
....................     if ( DTMF_IN_FLAG ) { 
1F26:  BTFSS  5B.3
1F27:  GOTO   7B9
....................       strcpy(LCD_str,"DTMF:"); 
1F28:  CLRF   6C
1F29:  CLRF   6D
1F2A:  MOVLW  20
1F2B:  MOVWF  05
1F2C:  MOVLW  74
1F2D:  MOVWF  04
1F2E:  MOVF   6C,W
1F2F:  ADDWF  04,F
1F30:  MOVLW  00
1F31:  ADDWFC 05,F
1F32:  MOVF   6D,W
1F33:  MOVLP  00
1F34:  MOVLB  00
1F35:  CALL   184
1F36:  MOVLP  18
1F37:  MOVWF  00
1F38:  IORLW  00
1F39:  BTFSC  03.2
1F3A:  GOTO   740
1F3B:  MOVLB  01
1F3C:  INCF   6D,F
1F3D:  INCF   6C,F
1F3E:  GOTO   72A
1F3F:  MOVLB  00
....................       printf("\n\rDTMF="); 
1F40:  MOVLW  0B
1F41:  MOVLB  03
1F42:  MOVWF  11
1F43:  MOVLW  05
1F44:  MOVWF  12
1F45:  MOVLP  00
1F46:  MOVLB  00
1F47:  CALL   529
1F48:  MOVLP  18
....................       for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1F49:  MOVLB  01
1F4A:  CLRF   63
1F4B:  MOVF   63,W
1F4C:  SUBLW  09
1F4D:  BTFSS  03.0
1F4E:  GOTO   797
....................         if(DTMF_ARRAY[x].Strobe) { 
1F4F:  MOVLW  62
1F50:  ADDWF  63,W
1F51:  MOVWF  04
1F52:  MOVLW  20
1F53:  MOVWF  05
1F54:  BTFSC  03.0
1F55:  INCF   05,F
1F56:  BTFSS  00.4
1F57:  GOTO   794
....................           dtmf=(int)DTMF_ARRAY[x].Key; 
1F58:  MOVLW  62
1F59:  ADDWF  63,W
1F5A:  MOVWF  04
1F5B:  MOVLW  20
1F5C:  MOVWF  05
1F5D:  BTFSC  03.0
1F5E:  INCF   05,F
1F5F:  MOVF   00,W
1F60:  ANDLW  0F
1F61:  MOVWF  64
....................           sprintf(tmp,"%d ",dtmf); 
1F62:  MOVLW  20
1F63:  MOVWF  62
1F64:  MOVLW  95
1F65:  MOVWF  61
1F66:  MOVF   64,W
1F67:  MOVLB  02
1F68:  MOVWF  50
1F69:  MOVLW  18
1F6A:  MOVWF  51
1F6B:  MOVLP  08
1F6C:  MOVLB  00
1F6D:  CALL   236
1F6E:  MOVLP  18
1F6F:  MOVLW  20
1F70:  MOVLB  02
1F71:  MOVWF  56
1F72:  MOVLP  00
1F73:  MOVLB  00
1F74:  CALL   7F0
1F75:  MOVLP  18
....................           strcat(LCD_str,tmp); 
1F76:  MOVLW  20
1F77:  MOVLB  02
1F78:  MOVWF  30
1F79:  MOVLW  74
1F7A:  MOVWF  2F
1F7B:  MOVLW  20
1F7C:  MOVWF  32
1F7D:  MOVLW  95
1F7E:  MOVWF  31
1F7F:  MOVLP  10
1F80:  MOVLB  00
1F81:  CALL   666
1F82:  MOVLP  18
....................           printf(" %u",dtmf); 
1F83:  MOVLW  20
1F84:  CLRWDT
1F85:  BTFSS  11.4
1F86:  GOTO   784
1F87:  MOVLB  03
1F88:  MOVWF  1A
1F89:  MOVLB  01
1F8A:  MOVF   64,W
1F8B:  MOVLB  02
1F8C:  MOVWF  56
1F8D:  MOVLW  1B
1F8E:  MOVWF  57
1F8F:  MOVLP  00
1F90:  MOVLB  00
1F91:  CALL   775
1F92:  MOVLP  18
1F93:  MOVLB  01
....................         } 
....................       restart_wdt(); 
1F94:  CLRWDT
....................       } 
1F95:  INCF   63,F
1F96:  GOTO   74B
....................       printf("\n\r"); 
1F97:  MOVLW  0A
1F98:  CLRWDT
1F99:  MOVLB  00
1F9A:  BTFSC  11.4
1F9B:  GOTO   79E
1F9C:  MOVLB  01
1F9D:  GOTO   798
1F9E:  MOVLB  03
1F9F:  MOVWF  1A
1FA0:  MOVLW  0D
1FA1:  CLRWDT
1FA2:  MOVLB  00
1FA3:  BTFSC  11.4
1FA4:  GOTO   7A7
1FA5:  MOVLB  03
1FA6:  GOTO   7A1
1FA7:  MOVLB  03
1FA8:  MOVWF  1A
....................       DTMF_IN_FLAG=0; 
1FA9:  MOVLB  01
1FAA:  BCF    5B.3
....................       PROMPT_FLAG=1; 
1FAB:  BSF    5B.5
....................       lcd_send(2,LCD_str); // Send DTMF on line 3 
1FAC:  MOVLW  02
1FAD:  MOVLB  02
1FAE:  MOVWF  50
1FAF:  MOVLW  20
1FB0:  MOVWF  52
1FB1:  MOVLW  74
1FB2:  MOVWF  51
1FB3:  MOVLP  08
1FB4:  MOVLB  00
1FB5:  CALL   1D2
1FB6:  MOVLP  18
....................     restart_wdt(); 
1FB7:  CLRWDT
1FB8:  MOVLB  01
....................     } 
....................     if ( DTMF_FLAG ) { 
1FB9:  BTFSS  5B.2
1FBA:  GOTO   7C0
....................       process_dtmf(); 
1FBB:  MOVLB  00
1FBC:  GOTO   4F7
....................       DTMF_FLAG=0; 
1FBD:  MOVLB  01
1FBE:  BCF    5B.2
....................     restart_wdt(); 
1FBF:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1FC0:  BTFSS  5B.4
1FC1:  GOTO   7C8
....................       clear_dtmf_array(); 
1FC2:  MOVLP  10
1FC3:  MOVLB  00
1FC4:  GOTO   7DF
1FC5:  MOVLP  18
....................       CLEAR_DTMF_FLAG=0; 
1FC6:  MOVLB  01
1FC7:  BCF    5B.4
....................     } 
....................     if ( PROMPT_FLAG ) { 
1FC8:  BTFSS  5B.5
1FC9:  GOTO   7D1
....................       prompt(); 
1FCA:  MOVLP  10
1FCB:  MOVLB  00
1FCC:  CALL   0C2
1FCD:  MOVLP  18
....................       PROMPT_FLAG=0; 
1FCE:  MOVLB  01
1FCF:  BCF    5B.5
....................     restart_wdt(); 
1FD0:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1FD1:  GOTO   613
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0BF0:  CLRWDT
*
1FD2:  SLEEP
....................   delay_ms(1000); 
*
0BF1:  MOVLW  04
0BF2:  MOVLB  02
0BF3:  MOVWF  45
0BF4:  MOVLW  FA
0BF5:  MOVWF  50
0BF6:  MOVLP  00
0BF7:  MOVLB  00
0BF8:  CALL   7C4
0BF9:  MOVLP  08
0BFA:  MOVLB  02
0BFB:  DECFSZ 45,F
0BFC:  GOTO   3F4
....................   if ( ConfirmChar!=0 ) { 
0BFD:  MOVLB  00
0BFE:  MOVF   69,F
0BFF:  BTFSC  03.2
0C00:  GOTO   415
....................     morse(ConfirmChar); 
0C01:  MOVF   69,W
0C02:  MOVLB  02
0C03:  MOVWF  45
0C04:  MOVLB  00
0C05:  CALL   0E9
....................     ConfirmChar=0; 
0C06:  CLRF   69
....................     restart_wdt(); 
0C07:  CLRWDT
....................     delay_ms(500); 
0C08:  MOVLW  02
0C09:  MOVLB  02
0C0A:  MOVWF  45
0C0B:  MOVLW  FA
0C0C:  MOVWF  50
0C0D:  MOVLP  00
0C0E:  MOVLB  00
0C0F:  CALL   7C4
0C10:  MOVLP  08
0C11:  MOVLB  02
0C12:  DECFSZ 45,F
0C13:  GOTO   40B
0C14:  MOVLB  00
....................   } 
....................   if (TailChar != 0) { 
0C15:  MOVF   68,F
0C16:  BTFSC  03.2
0C17:  GOTO   42C
....................     morse(TailChar); 
0C18:  MOVF   68,W
0C19:  MOVLB  02
0C1A:  MOVWF  45
0C1B:  MOVLB  00
0C1C:  CALL   0E9
....................     TailChar=0; 
0C1D:  CLRF   68
....................     restart_wdt(); 
0C1E:  CLRWDT
....................     delay_ms(500); 
0C1F:  MOVLW  02
0C20:  MOVLB  02
0C21:  MOVWF  45
0C22:  MOVLW  FA
0C23:  MOVWF  50
0C24:  MOVLP  00
0C25:  MOVLB  00
0C26:  CALL   7C4
0C27:  MOVLP  08
0C28:  MOVLB  02
0C29:  DECFSZ 45,F
0C2A:  GOTO   422
0C2B:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0C2C:  CLRWDT
0C2D:  MOVLB  02
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
1027:  MOVLB  01
1028:  BTFSS  5B.6
1029:  GOTO   02C
....................     admin_timer = ADMIN_TIMEOUT; 
102A:  MOVLW  FF
102B:  MOVWF  73
....................   } 
....................   return(AdminMode||rs232_mode); 
102C:  BTFSC  5B.6
102D:  GOTO   032
102E:  BTFSC  5B.7
102F:  GOTO   032
1030:  MOVLW  00
1031:  GOTO   033
1032:  MOVLW  01
1033:  MOVWF  78
.................... } // }}} 
1034:  MOVLB  00
1035:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0D13:  MOVLB  01
0D14:  BCF    5B.6
0D15:  MOVLB  02
0D16:  MOVF   46,F
0D17:  BTFSC  03.2
0D18:  GOTO   51C
0D19:  MOVLB  01
0D1A:  BSF    5B.6
0D1B:  MOVLB  02
....................   if (AdminMode) { 
0D1C:  MOVLB  01
0D1D:  BTFSS  5B.6
0D1E:  GOTO   526
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0D1F:  MOVLW  0A
0D20:  MOVLB  00
0D21:  MOVWF  69
....................     admin_timer = ADMIN_TIMEOUT; 
0D22:  MOVLW  FF
0D23:  MOVWF  73
....................   } else { 
0D24:  GOTO   529
0D25:  MOVLB  01
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0D26:  MOVLW  18
0D27:  MOVLB  00
0D28:  MOVWF  69
....................   }  
.................... } // }}} 
0D29:  RETURN
....................  

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
