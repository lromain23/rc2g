CCS PCM C Compiler, Version 4.140, 64991               10-Jan-24 14:46

               Filename:   C:\Users\m3n2bn\Projects\MBPAB IDE\RC2Ga\52_Buckingham\Firmware.lst

               ROM used:   8014 words (98%)
                           Largest free fragment is 142
               RAM used:   162 (32%) at main() level
                           228 (45%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   6CE
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   348
002D:  MOVLP  00
002E:  GOTO   37A
002F:  MOVLP  00
0030:  GOTO   2EB
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
16AC:  MOVLB  02
16AD:  MOVF   26,W
16AE:  MOVWF  2A
16AF:  MOVF   25,W
16B0:  MOVWF  29
16B1:  MOVF   2A,W
16B2:  MOVWF  7A
16B3:  MOVF   29,W
16B4:  MOVWF  04
16B5:  MOVF   7A,W
16B6:  MOVWF  05
16B7:  MOVF   00,F
16B8:  BTFSC  03.2
16B9:  GOTO   6BE
16BA:  INCF   29,F
16BB:  BTFSC  03.2
16BC:  INCF   2A,F
16BD:  GOTO   6B1
....................    while(*s2 != '\0') 
....................    { 
16BE:  MOVF   28,W
16BF:  MOVWF  7A
16C0:  MOVF   27,W
16C1:  MOVWF  04
16C2:  MOVF   7A,W
16C3:  MOVWF  05
16C4:  MOVF   00,F
16C5:  BTFSC  03.2
16C6:  GOTO   6DA
....................       *s = *s2; 
16C7:  MOVF   27,W
16C8:  MOVWF  04
16C9:  MOVF   28,W
16CA:  MOVWF  05
16CB:  MOVF   00,W
16CC:  MOVWF  2D
16CD:  MOVF   2A,W
16CE:  MOVWF  05
16CF:  MOVF   29,W
16D0:  MOVWF  04
16D1:  MOVF   2D,W
16D2:  MOVWF  00
....................       ++s; 
16D3:  INCF   29,F
16D4:  BTFSC  03.2
16D5:  INCF   2A,F
....................       ++s2; 
16D6:  INCF   27,F
16D7:  BTFSC  03.2
16D8:  INCF   28,F
....................    } 
16D9:  GOTO   6BE
....................  
....................    *s = '\0'; 
16DA:  MOVF   29,W
16DB:  MOVWF  04
16DC:  MOVF   2A,W
16DD:  MOVWF  05
16DE:  CLRF   00
....................    return(s1); 
16DF:  MOVF   25,W
16E0:  MOVWF  78
16E1:  MOVF   26,W
16E2:  MOVWF  79
.................... } 
16E3:  MOVLB  00
16E4:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0DF4:  MOVF   44,W
0DF5:  MOVWF  48
0DF6:  MOVF   43,W
0DF7:  MOVWF  47
0DF8:  MOVF   48,W
0DF9:  MOVWF  7A
0DFA:  MOVF   47,W
0DFB:  MOVWF  04
0DFC:  MOVF   7A,W
0DFD:  MOVWF  05
0DFE:  MOVF   00,F
0DFF:  BTFSC  03.2
0E00:  GOTO   62D
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0E01:  MOVF   46,W
0E02:  MOVWF  4A
0E03:  MOVF   45,W
0E04:  MOVWF  49
0E05:  MOVF   4A,W
0E06:  MOVWF  7A
0E07:  MOVF   49,W
0E08:  MOVWF  04
0E09:  MOVF   7A,W
0E0A:  MOVWF  05
0E0B:  MOVF   00,F
0E0C:  BTFSC  03.2
0E0D:  GOTO   629
....................          if (*sc1 == *sc2) 
0E0E:  MOVF   48,W
0E0F:  MOVWF  7A
0E10:  MOVF   47,W
0E11:  MOVWF  04
0E12:  MOVF   7A,W
0E13:  MOVWF  05
0E14:  MOVF   00,W
0E15:  MOVWF  4B
0E16:  MOVF   4A,W
0E17:  MOVWF  7A
0E18:  MOVF   49,W
0E19:  MOVWF  04
0E1A:  MOVF   7A,W
0E1B:  MOVWF  05
0E1C:  MOVF   00,W
0E1D:  SUBWF  4B,W
0E1E:  BTFSS  03.2
0E1F:  GOTO   625
....................             return(sc1); 
0E20:  MOVF   47,W
0E21:  MOVWF  78
0E22:  MOVF   48,W
0E23:  MOVWF  79
0E24:  GOTO   630
0E25:  INCF   49,F
0E26:  BTFSC  03.2
0E27:  INCF   4A,F
0E28:  GOTO   605
0E29:  INCF   47,F
0E2A:  BTFSC  03.2
0E2B:  INCF   48,F
0E2C:  GOTO   5F8
....................    return(0); 
0E2D:  MOVLW  00
0E2E:  MOVWF  78
0E2F:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0D8D:  MOVF   44,W
0D8E:  MOVWF  48
0D8F:  MOVF   43,W
0D90:  MOVWF  47
0D91:  MOVF   48,W
0D92:  MOVWF  7A
0D93:  MOVF   47,W
0D94:  MOVWF  04
0D95:  MOVF   7A,W
0D96:  MOVWF  05
0D97:  MOVF   00,F
0D98:  BTFSC  03.2
0D99:  GOTO   5CB
....................       for (sc2 = s2; ; sc2++) 
0D9A:  MOVF   46,W
0D9B:  MOVWF  4A
0D9C:  MOVF   45,W
0D9D:  MOVWF  49
....................     if (*sc2 == '\0') 
0D9E:  MOVF   4A,W
0D9F:  MOVWF  7A
0DA0:  MOVF   49,W
0DA1:  MOVWF  04
0DA2:  MOVF   7A,W
0DA3:  MOVWF  05
0DA4:  MOVF   00,F
0DA5:  BTFSS  03.2
0DA6:  GOTO   5B1
....................        return(sc1 - s1); 
0DA7:  MOVF   43,W
0DA8:  SUBWF  47,W
0DA9:  MOVWF  77
0DAA:  MOVF   44,W
0DAB:  SUBWFC 48,W
0DAC:  MOVWF  7A
0DAD:  MOVF   77,W
0DAE:  MOVWF  78
0DAF:  GOTO   5D3
....................          else if (*sc1 == *sc2) 
0DB0:  GOTO   5C3
0DB1:  MOVF   48,W
0DB2:  MOVWF  7A
0DB3:  MOVF   47,W
0DB4:  MOVWF  04
0DB5:  MOVF   7A,W
0DB6:  MOVWF  05
0DB7:  MOVF   00,W
0DB8:  MOVWF  4B
0DB9:  MOVF   4A,W
0DBA:  MOVWF  7A
0DBB:  MOVF   49,W
0DBC:  MOVWF  04
0DBD:  MOVF   7A,W
0DBE:  MOVWF  05
0DBF:  MOVF   00,W
0DC0:  SUBWF  4B,W
0DC1:  BTFSC  03.2
....................             break; 
0DC2:  GOTO   5C7
0DC3:  INCF   49,F
0DC4:  BTFSC  03.2
0DC5:  INCF   4A,F
0DC6:  GOTO   59E
0DC7:  INCF   47,F
0DC8:  BTFSC  03.2
0DC9:  INCF   48,F
0DCA:  GOTO   591
....................    return(sc1 - s1); 
0DCB:  MOVF   43,W
0DCC:  SUBWF  47,W
0DCD:  MOVWF  77
0DCE:  MOVF   44,W
0DCF:  SUBWFC 48,W
0DD0:  MOVWF  7A
0DD1:  MOVF   77,W
0DD2:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1EFC:  MOVLB  00
1EFD:  CLRF   26
1EFE:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0D74:  MOVLB  02
0D75:  MOVF   3B,W
0D76:  IORWF  3C,W
0D77:  BTFSC  03.2
0D78:  GOTO   57D
0D79:  MOVF   3C,W
0D7A:  MOVWF  7A
0D7B:  MOVF   3B,W
0D7C:  GOTO   582
0D7D:  MOVLB  00
0D7E:  MOVF   27,W
0D7F:  MOVWF  7A
0D80:  MOVF   26,W
0D81:  MOVLB  02
0D82:  MOVWF  3F
0D83:  MOVF   7A,W
0D84:  MOVWF  40
....................    beg += strspn(beg, s2); 
0D85:  MOVF   40,W
0D86:  MOVWF  44
0D87:  MOVF   3F,W
0D88:  MOVWF  43
0D89:  MOVF   3E,W
0D8A:  MOVWF  46
0D8B:  MOVF   3D,W
0D8C:  MOVWF  45
*
0DD3:  MOVF   78,W
0DD4:  ADDWF  3F,F
0DD5:  MOVLW  00
0DD6:  ADDWFC 40,F
....................    if (*beg == '\0') 
0DD7:  MOVF   40,W
0DD8:  MOVWF  7A
0DD9:  MOVF   3F,W
0DDA:  MOVWF  04
0DDB:  MOVF   7A,W
0DDC:  MOVWF  05
0DDD:  MOVF   00,F
0DDE:  BTFSS  03.2
0DDF:  GOTO   5EC
....................    { 
....................       *save = ' '; 
0DE0:  MOVLB  00
0DE1:  MOVF   26,W
0DE2:  MOVWF  04
0DE3:  MOVF   27,W
0DE4:  MOVWF  05
0DE5:  MOVLW  20
0DE6:  MOVWF  00
....................       return(0); 
0DE7:  MOVLW  00
0DE8:  MOVWF  78
0DE9:  MOVWF  79
0DEA:  GOTO   651
0DEB:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0DEC:  MOVF   40,W
0DED:  MOVWF  44
0DEE:  MOVF   3F,W
0DEF:  MOVWF  43
0DF0:  MOVF   3E,W
0DF1:  MOVWF  46
0DF2:  MOVF   3D,W
0DF3:  MOVWF  45
*
0E30:  MOVF   79,W
0E31:  MOVWF  42
0E32:  MOVF   78,W
0E33:  MOVWF  41
....................    if (*end != '\0') 
0E34:  MOVF   42,W
0E35:  MOVWF  7A
0E36:  MOVF   41,W
0E37:  MOVWF  04
0E38:  MOVF   7A,W
0E39:  MOVWF  05
0E3A:  MOVF   00,F
0E3B:  BTFSC  03.2
0E3C:  GOTO   645
....................    { 
....................       *end = '\0'; 
0E3D:  MOVF   41,W
0E3E:  MOVWF  04
0E3F:  MOVF   42,W
0E40:  MOVWF  05
0E41:  CLRF   00
....................       end++; 
0E42:  INCF   41,F
0E43:  BTFSC  03.2
0E44:  INCF   42,F
....................    } 
....................    save = end; 
0E45:  MOVF   42,W
0E46:  MOVLB  00
0E47:  MOVWF  27
0E48:  MOVLB  02
0E49:  MOVF   41,W
0E4A:  MOVLB  00
0E4B:  MOVWF  26
....................    return(beg); 
0E4C:  MOVLB  02
0E4D:  MOVF   3F,W
0E4E:  MOVWF  78
0E4F:  MOVF   40,W
0E50:  MOVWF  79
0E51:  MOVLB  00
.................... } 
0E52:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
....................  
.................... #define POT_MAX 63 
....................  
.................... #define RS 0x01 
.................... #define LCD_READ 0x02   
.................... #define LCD_WRITE 0x00   
.................... #define E 0x04 
.................... #define BT 0x08 
.................... #define CHANGE_LINE 0x80 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
0800:  MOVLW  20
0801:  MOVWF  05
0802:  MOVLW  C6
0803:  MOVWF  04
0804:  MOVF   00,W
0805:  BTFSC  03.2
0806:  GOTO   018
0807:  MOVLW  02
0808:  MOVWF  78
0809:  MOVLW  BF
080A:  MOVWF  77
080B:  CLRWDT
080C:  DECFSZ 77,F
080D:  GOTO   00B
080E:  DECFSZ 78,F
080F:  GOTO   009
0810:  MOVLW  96
0811:  MOVWF  77
0812:  DECFSZ 77,F
0813:  GOTO   012
0814:  GOTO   015
0815:  CLRWDT
0816:  DECFSZ 00,F
0817:  GOTO   007
0818:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
06AF:  MOVLB  04
06B0:  BCF    15.7
06B1:  MOVLB  00
06B2:  BCF    11.3
06B3:  MOVLB  02
06B4:  MOVF   4C,W
06B5:  MOVLB  04
06B6:  MOVWF  11
06B7:  MOVLW  02
06B8:  BTFSC  15.7
06B9:  GOTO   6C1
06BA:  MOVLB  00
06BB:  BTFSS  11.3
06BC:  GOTO   6BB
06BD:  MOVLW  00
06BE:  MOVLB  04
06BF:  BTFSC  16.6
06C0:  MOVLW  01
06C1:  MOVWF  78
06C2:  MOVLB  00
06C3:  RETURN
*
0AA0:  MOVLB  04
0AA1:  BCF    15.6
0AA2:  BSF    16.3
0AA3:  BTFSC  16.3
0AA4:  GOTO   2A3
0AA5:  BTFSC  77.0
0AA6:  BCF    16.5
0AA7:  BTFSS  77.0
0AA8:  BSF    16.5
0AA9:  BSF    16.4
0AAA:  BTFSC  16.4
0AAB:  GOTO   2AA
0AAC:  MOVF   11,W
0AAD:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02E4:  CLRWDT
02E5:  BTFSS  11.4
02E6:  GOTO   2E4
02E7:  MOVLB  03
02E8:  MOVWF  1A
02E9:  MOVLB  00
02EA:  RETURN
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void process_dtmf_interrupt(void); 
.................... void init_lcd(void); 
.................... void send_tail(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... #if __DEVICE__==1939 
.................... void set_bit(void); 
.................... void clear_bit(void); 
.................... #endif 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
.................... void print_dfmf_info(void); 
.................... void do_delay_counters(void); 
.................... int1 my_stricmp(char *, char *); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN; 
.................... unsigned int Enable; 
.................... unsigned int Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned int TOT_Min; 
.................... unsigned int TOT_FLAG_Mask; 
.................... unsigned long QSO_Duration; 
.................... unsigned int Link_TOT,LinkDurationTimer; 
.................... unsigned int COR_EMUL; 
.................... unsigned int COR_AUX; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... char COR_IN_EFFECTIVE; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... #define LINK_CMD 1 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
.................... #define SET_BIT 14 
.................... #define CLEAR_BIT 15 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... #define QSO_DURATION_DELAY 5 
.................... // This command operates the same way as AUX_OUT_FOLLOW_COR but 
.................... // it extends the aux output by 1 minute. 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT_OUTPUT 0x10 
.................... #define AUX_OUT_FOLLOW_COR_OFF_DELAY     0x20 
.................... #define AUX_OUT_FOLLOW_COR_ON_DELAY      0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... #define AUXI_EMULATE_COR1 0x01 
.................... #define AUXI_EMULATE_COR2 0x02 
.................... #define AUXI_EMULATE_COR3 0x04 
.................... #define AUXI_EMULATE_COR4 0x08 
.................... #define AUXI_EMULATE_COR5 0x10 // COR from AUX only for DTMF control (No audio feed-thru) 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x20 
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... unsigned int AuxOutDelayCnt; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... unsigned int command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
....................   int  usage : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1       COR_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int1 	   AUX_OUT_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1       DTMF_INTERRUPT_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... // PROTECTED -- Must be in admin mode to set value 
.................... // PUBLIC    -- Register can be set in any mode 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
.................... #define PROTECTED 1 
.................... #define PUBLIC    0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 
.................... 	{"XI2"},	  // 19 
.................... 	{"XI3"},	  // 20 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"LTO"},  // 54 
....................     {"COR"},  // 55 
....................     {"CPOT"}  // 56 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
....................  
.................... #define SITE_ID_VAL  	52 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... #define ENABLE_DEFAULT 0xEF 
.................... #define TOT_MIN 5 
.................... #define LINK_TOT 0 
.................... #define DEFAULT_GAIN 32 
.................... //#define LCD_TYPE_PI 1 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('e') 
.................... #define MORSEID5	MCHAR('h') 
....................  
.................... #define AUXOUTOP0  AUX_OUT_FOLLOW_COR 
.................... #define AUXOUTARG0 AUX_OUT_FOLLOW_COR1 | AUX_OUT_FOLLOW_COR_INVERT_OUTPUT 
.................... // AuxOut2 connected to RPT Disable 
.................... #define AUXOUTOP1  0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2  AUX_OUT_FOLLOW_COR 
.................... #define AUXOUTARG2 AUX_OUT_FOLLOW_COR1 | AUX_OUT_FOLLOW_COR2 | AUX_OUT_FOLLOW_COR3 | AUX_OUT_FOLLOW_COR4 | AUX_OUT_FOLLOW_COR_INVERT_OUTPUT | AUX_OUT_FOLLOW_COR_OFF_DELAY | AUX_OUT_FOLLOW_COR_ON_DELAY 
....................  
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  AUXI_EMULATE_COR 
.................... #define AUXINARG0 AUXI_EMULATE_COR1 | AUXI_EMULATE_COR_ACTIVE_LO 
.................... #define AUXINOP1  AUXI_TAIL_WHEN_LO 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
.................... #define RX1_PTT 0x0E 
.................... #define RX2_PTT 0x0D 
.................... #define RX3_PTT 0x0B 
.................... #define RX4_PTT 0x07 
....................  
.................... // Define default variables {{{ 
.................... #ifdef LCD_TYPE_PI 
....................   #define LCD_I2C_ADD 0x27 
.................... #else 
....................   #define LCD_I2C_ADD 0x60 
.................... #endif 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... #ifndef RX1_PTT 
....................   #define RX1_PTT 0x0E 
.................... #endif 
.................... #ifndef RX2_PTT 
....................   #define RX2_PTT 0x0D 
.................... #endif 
.................... #ifndef RX3_PTT 
....................   #define RX3_PTT 0x0B  
.................... #endif 
.................... #ifndef RX4_PTT 
....................   #define RX4_PTT 0x07 
.................... #endif 
.................... #ifndef DEFAULT_GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  , EEPROM,PUBLIC}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL, EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&AuxIn[0]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[1]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[2]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[0]     ,PO_AUX_OUT0     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[1]     ,PO_AUX_OUT1     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[2]     ,PO_AUX_OUT2     , EEPROM,PUBLIC}, 
.................... 	{&RXPriority[0] ,4               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[1] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[2] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[3] ,2               , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[0]     ,RX1_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[1]     ,RX2_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[2]     ,RX3_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[3]     ,RX4_PTT         , EEPROM,PROTECTED}, 
.................... 	{&SiteID        ,SITE_ID_VAL     , EEPROM,PROTECTED}, 
.................... 	{&TXSiteID      ,0x12            , EEPROM,PROTECTED}, 
....................   {&Morse[0]      ,MORSEID0        , EEPROM,PROTECTED}, 
....................   {&Morse[1]      ,MORSEID1        , EEPROM,PROTECTED}, 
....................   {&Morse[2]      ,MORSEID2        , EEPROM,PROTECTED}, 
....................   {&Morse[3]      ,MORSEID3        , EEPROM,PROTECTED}, 
....................   {&Morse[4]      ,MORSEID4        , EEPROM,PROTECTED}, 
....................   {&Morse[5]      ,MORSEID5        , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2      , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2        , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2       , EEPROM,PROTECTED}, 
....................   {&Tail          ,TAIL_CHAR       , EEPROM,PROTECTED}, 
....................   {&TOT_Min       ,TOT_MIN         , EEPROM,PROTECTED}, 
....................   {&Link_TOT      ,LINK_TOT        , EEPROM,PROTECTED}, 
.................... 	{&COR_EMUL      ,0x00            , RAM   ,PUBLIC}, 
.................... 	{&CurrentTrimPot,0x00            , RAM   ,PROTECTED}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02EB:  BTFSS  11.5
02EC:  GOTO   342
....................     c = getc(); 
02ED:  CLRWDT
02EE:  BTFSS  11.5
02EF:  GOTO   2ED
02F0:  MOVLB  03
02F1:  MOVF   19,W
02F2:  MOVLB  02
02F3:  MOVWF  51
....................     if ( c == '\b' ) { 
02F4:  MOVF   51,W
02F5:  SUBLW  08
02F6:  BTFSS  03.2
02F7:  GOTO   320
....................       if ( sBufferIndex > 0 ) { 
02F8:  MOVF   75,F
02F9:  BTFSC  03.2
02FA:  GOTO   31A
....................         sBufferIndex--; 
02FB:  DECF   75,F
....................         sBuffer[sBufferIndex]='\0'; 
02FC:  MOVLW  50
02FD:  ADDWF  75,W
02FE:  MOVWF  04
02FF:  MOVLW  20
0300:  MOVWF  05
0301:  BTFSC  03.0
0302:  INCF   05,F
0303:  CLRF   00
....................         putc('\b'); 
0304:  MOVLW  08
0305:  MOVLB  00
0306:  CALL   2E4
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
0307:  MOVLW  1B
0308:  CALL   2E4
....................   printf("[K"); 
0309:  MOVLW  5B
030A:  CLRWDT
030B:  BTFSS  11.4
030C:  GOTO   30A
030D:  MOVLB  03
030E:  MOVWF  1A
030F:  MOVLW  4B
0310:  CLRWDT
0311:  MOVLB  00
0312:  BTFSC  11.4
0313:  GOTO   316
0314:  MOVLB  03
0315:  GOTO   310
0316:  MOVLB  03
0317:  MOVWF  1A
....................       } else { 
0318:  GOTO   31E
0319:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
031A:  MOVLW  07
031B:  MOVLB  00
031C:  CALL   2E4
031D:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
031E:  GOTO   344
031F:  MOVLB  02
0320:  MOVF   75,W
0321:  SUBLW  0F
0322:  BTFSS  03.0
0323:  GOTO   33F
....................       putc(c); // echo the character 
0324:  MOVF   51,W
0325:  MOVLB  00
0326:  CALL   2E4
....................       sBuffer[sBufferIndex++] = c; 
0327:  MOVF   75,W
0328:  INCF   75,F
0329:  ADDLW  50
032A:  MOVWF  04
032B:  MOVLW  20
032C:  MOVWF  05
032D:  BTFSC  03.0
032E:  INCF   05,F
032F:  MOVLB  02
0330:  MOVF   51,W
0331:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0332:  MOVF   51,W
0333:  SUBLW  0D
0334:  BTFSC  03.2
0335:  GOTO   33D
0336:  MOVF   51,W
0337:  SUBLW  2B
0338:  BTFSC  03.2
0339:  GOTO   33D
033A:  MOVF   51,W
033B:  SUBLW  2D
033C:  BTFSC  03.2
....................         sBufferFlag=1; 
033D:  BSF    76.0
....................       } 
....................     } else { 
033E:  GOTO   343
....................       putc('\a'); // Send alert. Avoid buffer overflow 
033F:  MOVLW  07
0340:  MOVLB  00
0341:  CALL   2E4
0342:  MOVLB  02
0343:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
0344:  MOVLB  00
0345:  BCF    11.5
0346:  MOVLP  00
0347:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   int LAST_COR_IN; 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if(IOCBF&0x0F) { // Check for interrupts on RB[3:0] only 
0348:  MOVLB  07
0349:  MOVF   16,W
034A:  ANDLW  0F
034B:  BTFSC  03.2
034C:  GOTO   36B
....................     LAST_COR_IN=COR_IN; 
034D:  MOVLB  00
034E:  MOVF   5F,W
034F:  MOVLB  02
0350:  MOVWF  51
....................     COR_IN= ((input_b() ^ Polarity)&0x0F) | (COR_EMUL & 0x1F) | (COR_AUX&0x0F); 
0351:  MOVLB  00
0352:  MOVF   0D,W
0353:  XORWF  62,W
0354:  ANDLW  0F
0355:  MOVLB  02
0356:  MOVWF  52
0357:  MOVLB  00
0358:  MOVF   6C,W
0359:  ANDLW  1F
035A:  MOVLB  02
035B:  IORWF  52,F
035C:  MOVLB  00
035D:  MOVF   6D,W
035E:  ANDLW  0F
035F:  MOVLB  02
0360:  IORWF  52,W
0361:  MOVLB  00
0362:  MOVWF  5F
....................     if ( LAST_COR_IN != COR_IN ) { 
0363:  MOVF   5F,W
0364:  MOVLB  02
0365:  SUBWF  51,W
0366:  BTFSS  03.2
....................       COR_FLAG = 1; 
0367:  BSF    76.1
....................     } 
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
0368:  MOVLW  F0
0369:  MOVLB  07
036A:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
036B:  BTFSS  0B.0
036C:  GOTO   371
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     DTMF_INTERRUPT_FLAG = 1; 
036D:  MOVLB  01
036E:  BSF    5F.2
....................     clear_interrupt(INT_RB4_H2L); 
036F:  MOVLB  07
0370:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
0371:  BTFSS  0B.0
0372:  GOTO   376
....................     AUX_IN_FLAG=1; 
0373:  BSF    76.6
....................     clear_interrupt(INT_RB6|INT_RB7); 
0374:  MOVLW  3F
0375:  ANDWF  16,F
....................   } 
.................... } // }}} 
0376:  BCF    0B.0
0377:  MOVLP  00
0378:  MOVLB  00
0379:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
037A:  MOVLB  01
037B:  MOVF   30,W
037C:  IORWF  31,W
037D:  BTFSC  03.2
037E:  GOTO   384
....................     rtcc_cnt--; 
037F:  MOVF   30,W
0380:  BTFSC  03.2
0381:  DECF   31,F
0382:  DECF   30,F
....................   } else { 
0383:  GOTO   39D
....................     COR_IN= ((input_b() ^ Polarity)&0x0F) | (COR_EMUL & 0x1F) | (COR_AUX&0x0F); 
0384:  MOVLB  00
0385:  MOVF   0D,W
0386:  XORWF  62,W
0387:  ANDLW  0F
0388:  MOVLB  02
0389:  MOVWF  51
038A:  MOVLB  00
038B:  MOVF   6C,W
038C:  ANDLW  1F
038D:  MOVLB  02
038E:  IORWF  51,F
038F:  MOVLB  00
0390:  MOVF   6D,W
0391:  ANDLW  0F
0392:  MOVLB  02
0393:  IORWF  51,W
0394:  MOVLB  00
0395:  MOVWF  5F
....................     COR_FLAG=1; 
0396:  BSF    76.1
....................     SECOND_FLAG=1; 
0397:  BSF    76.2
....................     AUX_IN_FLAG=1; 
0398:  BSF    76.6
....................     rtcc_cnt=30; 
0399:  MOVLB  01
039A:  CLRF   31
039B:  MOVLW  1E
039C:  MOVWF  30
....................   } 
....................   if (aux_timer ) { 
039D:  MOVF   32,W
039E:  IORWF  33,W
039F:  BTFSC  03.2
03A0:  GOTO   3A5
....................     aux_timer--; 
03A1:  MOVF   32,W
03A2:  BTFSC  03.2
03A3:  DECF   33,F
03A4:  DECF   32,F
....................   } 
.................... } // }}} 
03A5:  BCF    0B.2
03A6:  MOVLP  00
03A7:  MOVLB  00
03A8:  GOTO   020
.................... int1 warn_no_lcd = 1; 
....................  
.................... void lcd_strobe(char data) { // {{{ 
....................   i2c_write(data | E); 
....................   i2c_write(data & ~E); 
.................... } // }}} 
....................  
.................... void lcd_write(char rs, char data) { // {{{ 
....................   char lcd_word_a,lcd_word_b; 
....................   lcd_word_a = LCD_WRITE | BT | (data&0xF0); 
....................   lcd_word_b = LCD_WRITE | BT | ((data<<4)&0xF0); 
....................   if ( rs ) { 
....................     lcd_word_a |= RS; 
....................     lcd_word_b |= RS; 
....................   }  
....................   lcd_strobe(lcd_word_a); 
....................   lcd_strobe(lcd_word_b); 
.................... } // }}} 
....................  
.................... void lcd_send(char line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   i2c_start(); 
*
098C:  MOVLB  04
098D:  BSF    16.0
098E:  BTFSC  16.0
098F:  GOTO   18E
....................   #ifdef LCD_TYPE_PI 
....................   ack=i2c_write(LCD_I2C_ADD << 1); 
.................... //  ack=i2c_write(line&0x03); 
.................... // Change line 
....................   switch(line&0x03) { 
....................     case 0x00: lcd_write(0,CHANGE_LINE);break; 
....................     case 0x01: lcd_write(0,CHANGE_LINE+0x40);break; 
....................     case 0x02: lcd_write(0,CHANGE_LINE+0x14);break; 
....................     case 0x03: lcd_write(0,CHANGE_LINE+0x54);break; 
....................   } 
....................   restart_wdt(); 
....................   #else 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
0990:  BCF    03.0
0991:  MOVLB  02
0992:  RLF    46,W
0993:  ANDLW  0E
0994:  IORLW  60
0995:  MOVWF  49
....................   ack=i2c_write(lcd_cmd); 
0996:  MOVF   49,W
0997:  MOVWF  4C
0998:  MOVLP  00
0999:  MOVLB  00
099A:  CALL   6AF
099B:  MOVLP  08
099C:  MOVF   78,W
099D:  MOVLB  02
099E:  BCF    4A.0
099F:  BTFSC  78.0
09A0:  BSF    4A.0
....................   #endif 
....................   if ( ack!=0 ) { 
09A1:  BTFSS  4A.0
09A2:  GOTO   1C5
....................     if ( warn_no_lcd ) { 
09A3:  MOVLB  01
09A4:  BTFSS  5F.7
09A5:  GOTO   1C3
....................       printf("\n\rI2C : No ACK from LCD : %u",ack); 
09A6:  MOVLW  00
09A7:  MOVLB  02
09A8:  BTFSC  4A.0
09A9:  MOVLW  01
09AA:  MOVWF  4B
09AB:  MOVLW  A9
09AC:  MOVLB  03
09AD:  MOVWF  11
09AE:  MOVLW  03
09AF:  MOVWF  12
09B0:  BCF    03.0
09B1:  MOVLW  1A
09B2:  MOVLB  02
09B3:  MOVWF  4C
09B4:  MOVLP  00
09B5:  MOVLB  00
09B6:  CALL   6C4
09B7:  MOVLP  08
09B8:  MOVLB  02
09B9:  MOVF   4B,W
09BA:  MOVWF  4C
09BB:  MOVLW  1B
09BC:  MOVWF  4D
09BD:  MOVLP  00
09BE:  MOVLB  00
09BF:  CALL   738
09C0:  MOVLP  08
....................       warn_no_lcd = 0; 
09C1:  MOVLB  01
09C2:  BCF    5F.7
....................     } 
....................   } else { 
09C3:  GOTO   1C7
09C4:  MOVLB  02
....................     warn_no_lcd = 1; 
09C5:  MOVLB  01
09C6:  BSF    5F.7
....................   } 
....................   while(*s) { 
09C7:  MOVLB  02
09C8:  MOVF   48,W
09C9:  MOVWF  7A
09CA:  MOVF   47,W
09CB:  MOVWF  04
09CC:  MOVF   7A,W
09CD:  MOVWF  05
09CE:  MOVF   00,F
09CF:  BTFSC  03.2
09D0:  GOTO   1E4
.................... #ifdef LCD_TYPE_PI 
....................     if ( *s != '\r' && *s != '\n') { 
....................       lcd_write(1,*s); 
....................     } 
....................     s++; 
.................... #else 
....................    i2c_write(*s++); 
09D1:  MOVF   48,W
09D2:  MOVWF  7A
09D3:  MOVF   47,W
09D4:  INCF   47,F
09D5:  BTFSC  03.2
09D6:  INCF   48,F
09D7:  MOVWF  04
09D8:  MOVF   7A,W
09D9:  MOVWF  05
09DA:  MOVF   00,W
09DB:  MOVWF  4B
09DC:  MOVWF  4C
09DD:  MOVLP  00
09DE:  MOVLB  00
09DF:  CALL   6AF
09E0:  MOVLP  08
.................... #endif 
....................   } 
09E1:  MOVLB  01
09E2:  GOTO   1C7
09E3:  MOVLB  02
.................... #ifndef LCD_TYPE_PI 
....................   i2c_write(0); // EOL 
09E4:  CLRF   4C
09E5:  MOVLP  00
09E6:  MOVLB  00
09E7:  CALL   6AF
09E8:  MOVLP  08
.................... #endif 
....................   i2c_stop(); 
09E9:  MOVLB  04
09EA:  BSF    16.2
09EB:  BTFSC  16.2
09EC:  GOTO   1EB
.................... #endif 
.................... } // }}} 
09ED:  MOVLB  00
09EE:  RETURN
....................  
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
1000:  MOVF   70,F
1001:  BTFSC  03.2
1002:  GOTO   066
....................     printf("\n\rProcessing Command:"); 
1003:  MOVLW  B8
1004:  MOVLB  03
1005:  MOVWF  11
1006:  MOVLW  03
1007:  MOVWF  12
1008:  MOVLP  00
1009:  MOVLB  00
100A:  CALL   4D3
100B:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
100C:  MOVLW  C3
100D:  MOVLB  03
100E:  MOVWF  11
100F:  MOVLW  03
1010:  MOVWF  12
1011:  BCF    03.0
1012:  MOVLW  0E
1013:  MOVLB  02
1014:  MOVWF  4C
1015:  MOVLP  00
1016:  MOVLB  00
1017:  CALL   6C4
1018:  MOVLP  10
1019:  MOVF   63,W
101A:  MOVLB  02
101B:  MOVWF  4C
101C:  MOVLW  1B
101D:  MOVWF  4D
101E:  MOVLP  00
101F:  MOVLB  00
1020:  CALL   738
1021:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
1022:  MOVLW  CC
1023:  MOVLB  03
1024:  MOVWF  11
1025:  MOVLW  03
1026:  MOVWF  12
1027:  BCF    03.0
1028:  MOVLW  0E
1029:  MOVLB  02
102A:  MOVWF  4C
102B:  MOVLP  00
102C:  MOVLB  00
102D:  CALL   6C4
102E:  MOVLP  10
102F:  MOVF   70,W
1030:  MOVLB  02
1031:  MOVWF  4C
1032:  MOVLW  1B
1033:  MOVWF  4D
1034:  MOVLP  00
1035:  MOVLB  00
1036:  CALL   738
1037:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
1038:  MOVLW  D5
1039:  MOVLB  03
103A:  MOVWF  11
103B:  MOVLW  03
103C:  MOVWF  12
103D:  BCF    03.0
103E:  MOVLW  0E
103F:  MOVLB  02
1040:  MOVWF  4C
1041:  MOVLP  00
1042:  MOVLB  00
1043:  CALL   6C4
1044:  MOVLP  10
1045:  MOVLB  01
1046:  MOVF   40,W
1047:  MOVLB  02
1048:  MOVWF  4C
1049:  MOVLW  1B
104A:  MOVWF  4D
104B:  MOVLP  00
104C:  MOVLB  00
104D:  CALL   738
104E:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
104F:  MOVLW  DE
1050:  MOVLB  03
1051:  MOVWF  11
1052:  MOVLW  03
1053:  MOVWF  12
1054:  BCF    03.0
1055:  MOVLW  0E
1056:  MOVLB  02
1057:  MOVWF  4C
1058:  MOVLP  00
1059:  MOVLB  00
105A:  CALL   6C4
105B:  MOVLP  10
105C:  MOVLB  01
105D:  MOVF   41,W
105E:  MOVLB  02
105F:  MOVWF  4C
1060:  MOVLW  1B
1061:  MOVWF  4D
1062:  MOVLP  00
1063:  MOVLB  00
1064:  CALL   738
1065:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
1066:  MOVLW  02
1067:  SUBWF  70,W
1068:  ADDLW  F5
1069:  BTFSC  03.0
106A:  GOTO   4B6
106B:  ADDLW  0B
106C:  GOTO   4B7
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
1142:  GOTO   4B6
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
1143:  MOVLB  01
1144:  RLF    40,W
1145:  MOVWF  77
1146:  RLF    77,F
1147:  MOVLW  FC
1148:  ANDWF  77,F
1149:  MOVF   77,W
114A:  MOVLB  02
114B:  MOVWF  28
114C:  INCF   28,W
114D:  MOVLP  00
114E:  MOVLB  00
114F:  CALL   043
1150:  MOVLP  10
1151:  MOVWF  7A
1152:  MOVLB  02
1153:  MOVF   28,W
1154:  MOVLP  00
1155:  MOVLB  00
1156:  CALL   043
1157:  MOVLP  10
1158:  MOVLB  01
1159:  MOVWF  6C
115A:  MOVF   7A,W
115B:  MOVWF  6D
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
115C:  MOVLW  01
115D:  MOVWF  7A
115E:  MOVLW  8F
115F:  MOVLB  02
1160:  MOVWF  28
1161:  MOVF   7A,W
1162:  MOVWF  29
1163:  CLRF   2B
1164:  MOVLB  01
1165:  MOVF   40,W
1166:  MOVLB  02
1167:  MOVWF  2A
1168:  MOVF   2B,W
1169:  MOVWF  3A
116A:  MOVF   2A,W
116B:  MOVWF  39
116C:  CLRF   3C
116D:  MOVLW  06
116E:  MOVWF  3B
116F:  MOVLP  08
1170:  MOVLB  00
1171:  CALL   6DB
1172:  MOVLP  10
1173:  MOVF   78,W
1174:  MOVLB  02
1175:  ADDWF  28,W
1176:  MOVWF  20
1177:  MOVF   79,W
1178:  ADDWFC 29,W
1179:  MOVWF  21
....................       romstrcpy(rname,cPtr); 
117A:  MOVLW  20
117B:  MOVWF  38
117C:  MOVLW  A2
117D:  MOVWF  37
117E:  MOVF   21,W
117F:  MOVWF  3A
1180:  MOVF   20,W
1181:  MOVWF  39
1182:  MOVLP  08
1183:  MOVLB  00
1184:  CALL   6F2
1185:  MOVLP  10
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
1186:  MOVLB  01
1187:  MOVF   6D,W
1188:  MOVWF  7A
1189:  MOVF   6C,W
118A:  MOVWF  04
118B:  MOVF   6D,W
118C:  MOVWF  05
118D:  MOVF   00,W
118E:  MOVLB  02
118F:  MOVWF  28
1190:  MOVLW  20
1191:  MOVLB  01
1192:  MOVWF  61
1193:  MOVLW  78
1194:  MOVWF  60
1195:  MOVLW  5B
1196:  MOVLB  02
1197:  MOVWF  4C
1198:  MOVLP  08
1199:  MOVLB  00
119A:  CALL   115
119B:  MOVLP  10
119C:  MOVLB  01
119D:  MOVF   40,W
119E:  MOVLB  02
119F:  MOVWF  29
11A0:  MOVLW  01
11A1:  MOVWF  2A
11A2:  MOVLP  08
11A3:  MOVLB  00
11A4:  CALL   76B
11A5:  MOVLP  10
11A6:  MOVLW  5D
11A7:  MOVLB  02
11A8:  MOVWF  4C
11A9:  MOVLP  08
11AA:  MOVLB  00
11AB:  CALL   115
11AC:  MOVLP  10
11AD:  MOVLW  20
11AE:  MOVLB  02
11AF:  MOVWF  4C
11B0:  MOVLP  08
11B1:  MOVLB  00
11B2:  CALL   115
11B3:  MOVLP  10
11B4:  MOVLW  20
11B5:  MOVWF  05
11B6:  MOVLW  A2
11B7:  MOVWF  04
11B8:  MOVLP  08
11B9:  CALL   177
11BA:  MOVLP  10
11BB:  MOVLW  20
11BC:  MOVLB  02
11BD:  MOVWF  4C
11BE:  MOVLP  08
11BF:  MOVLB  00
11C0:  CALL   115
11C1:  MOVLP  10
11C2:  MOVLB  02
11C3:  MOVF   28,W
11C4:  MOVWF  29
11C5:  MOVLW  1B
11C6:  MOVWF  2A
11C7:  MOVLP  08
11C8:  MOVLB  00
11C9:  CALL   76B
11CA:  MOVLP  10
11CB:  MOVLW  0A
11CC:  MOVLB  02
11CD:  MOVWF  4C
11CE:  MOVLP  08
11CF:  MOVLB  00
11D0:  CALL   115
11D1:  MOVLP  10
11D2:  MOVLW  0D
11D3:  MOVLB  02
11D4:  MOVWF  4C
11D5:  MOVLP  08
11D6:  MOVLB  00
11D7:  CALL   115
11D8:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
11D9:  MOVLW  0A
11DA:  CLRWDT
11DB:  BTFSS  11.4
11DC:  GOTO   1DA
11DD:  MOVLB  03
11DE:  MOVWF  1A
11DF:  MOVLW  0D
11E0:  CLRWDT
11E1:  MOVLB  00
11E2:  BTFSC  11.4
11E3:  GOTO   1E6
11E4:  MOVLB  03
11E5:  GOTO   1E0
11E6:  MOVLB  03
11E7:  MOVWF  1A
11E8:  MOVLW  20
11E9:  MOVWF  05
11EA:  MOVLW  78
11EB:  MOVWF  04
11EC:  MOVLP  08
11ED:  MOVLB  00
11EE:  CALL   256
11EF:  MOVLP  10
....................       lcd_send(2,LCD_str); 
11F0:  MOVLW  02
11F1:  MOVLB  02
11F2:  MOVWF  46
11F3:  MOVLW  20
11F4:  MOVWF  48
11F5:  MOVLW  78
11F6:  MOVWF  47
11F7:  MOVLP  08
11F8:  MOVLB  00
11F9:  CALL   18C
11FA:  MOVLP  10
....................       prompt(); 
11FB:  MOVLP  08
11FC:  CALL   7AE
11FD:  MOVLP  10
....................       break; 
11FE:  GOTO   4B6
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
11FF:  MOVLP  08
1200:  CALL   71B
1201:  MOVLP  10
1202:  MOVF   78,F
1203:  BTFSC  03.2
1204:  GOTO   208
....................         store_variables(); 
1205:  MOVLP  00
1206:  CALL   5C6
1207:  MOVLP  10
....................       } 
....................       break; 
1208:  GOTO   4B6
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
1209:  MOVLB  01
120A:  DECFSZ 41,W
120B:  GOTO   20E
....................         init_src=USE_EEPROM_VARS; 
120C:  BSF    6E.0
....................       } else { 
120D:  GOTO   20F
....................         init_src=USE_DEFAULT_VARS; 
120E:  BCF    6E.0
....................       } 
....................       if ( in_admin_mode() ) { 
120F:  MOVLP  08
1210:  MOVLB  00
1211:  CALL   71B
1212:  MOVLP  10
1213:  MOVF   78,F
1214:  BTFSC  03.2
1215:  GOTO   221
....................         init_variables(init_src); 
1216:  MOVLW  00
1217:  MOVLB  01
1218:  BTFSC  6E.0
1219:  MOVLW  01
121A:  MOVLB  02
121B:  MOVWF  28
121C:  MOVWF  29
121D:  MOVLP  00
121E:  MOVLB  00
121F:  CALL   641
1220:  MOVLP  10
....................       } 
....................       break; 
1221:  GOTO   4B6
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1222:  MOVLB  01
1223:  MOVF   40,W
1224:  ANDLW  03
1225:  MOVWF  7D
....................       increment(value); 
1226:  MOVF   41,W
1227:  MOVLB  02
1228:  MOVWF  2B
1229:  MOVLP  08
122A:  MOVLB  00
122B:  CALL   72A
122C:  MOVLP  10
....................       PROMPT_FLAG=1; 
122D:  MOVLB  01
122E:  BSF    5F.4
....................       break; 
122F:  MOVLB  00
1230:  GOTO   4B6
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1231:  MOVLB  01
1232:  MOVF   40,W
1233:  ANDLW  03
1234:  MOVWF  7D
....................       increment(-1*value); 
1235:  MOVLW  FF
1236:  MOVLB  02
1237:  MOVWF  3F
1238:  MOVLB  01
1239:  MOVF   41,W
123A:  MOVLB  02
123B:  MOVWF  40
123C:  MOVLP  08
123D:  MOVLB  00
123E:  CALL   653
123F:  MOVLP  10
1240:  MOVF   78,W
1241:  MOVLB  02
1242:  MOVWF  28
1243:  MOVWF  2B
1244:  MOVLP  08
1245:  MOVLB  00
1246:  CALL   72A
1247:  MOVLP  10
....................       PROMPT_FLAG=1; 
1248:  MOVLB  01
1249:  BSF    5F.4
....................       break; 
124A:  MOVLB  00
124B:  GOTO   4B6
....................     case STATUS: 
....................       status(); 
....................       break; 
*
142B:  MOVLB  00
142C:  GOTO   4B6
....................     case ADMIN: 
....................       switch(argument) { 
142D:  MOVLB  01
142E:  MOVF   40,W
142F:  XORLW  02
1430:  MOVLB  00
1431:  BTFSC  03.2
1432:  GOTO   43A
1433:  XORLW  03
1434:  BTFSC  03.2
1435:  GOTO   441
1436:  XORLW  02
1437:  BTFSC  03.2
1438:  GOTO   449
1439:  GOTO   44D
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
143A:  MOVLP  08
143B:  CALL   71B
143C:  MOVLP  10
143D:  MOVF   78,F
143E:  BTFSS  03.2
....................             reset_cpu(); 
143F:  RESET
....................           } 
....................           break; 
1440:  GOTO   453
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
1441:  MOVLW  01
1442:  MOVLB  02
1443:  MOVWF  3C
1444:  MOVLP  08
1445:  MOVLB  00
1446:  CALL   49E
1447:  MOVLP  10
....................           break; 
1448:  GOTO   453
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
1449:  MOVLP  08
144A:  CALL   7C6
144B:  MOVLP  10
....................         break; 
144C:  GOTO   453
....................         default: 
....................           set_admin_mode(0); 
144D:  MOVLB  02
144E:  CLRF   3C
144F:  MOVLP  08
1450:  MOVLB  00
1451:  CALL   49E
1452:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
1453:  GOTO   4B6
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
.................... #ifdef LCD_TYPE_PI 
....................       switch(value) { 
....................         case 0 : init_lcd();break;   
....................         case 1 : lcd_write(0,0x01); 
....................       } 
.................... #else 
....................       lcd_cmd=4+(value&0x03); 
1454:  MOVLB  01
1455:  MOVF   41,W
1456:  ANDLW  03
1457:  ADDLW  04
1458:  MOVWF  6F
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
1459:  MOVLW  20
145A:  MOVWF  61
145B:  MOVLW  78
145C:  MOVWF  60
145D:  MOVLW  E7
145E:  MOVLB  03
145F:  MOVWF  11
1460:  MOVLW  03
1461:  MOVWF  12
1462:  BCF    03.0
1463:  MOVLW  04
1464:  MOVLB  02
1465:  MOVWF  46
1466:  MOVLP  08
1467:  MOVLB  00
1468:  CALL   124
1469:  MOVLP  10
146A:  MOVLW  60
146B:  MOVLB  02
146C:  MOVWF  46
146D:  MOVLW  18
146E:  MOVWF  47
146F:  MOVLP  08
1470:  MOVLB  00
1471:  CALL   1EF
1472:  MOVLP  10
1473:  MOVLW  EA
1474:  MOVLB  03
1475:  MOVWF  11
1476:  MOVLW  03
1477:  MOVWF  12
1478:  BCF    03.0
1479:  MOVLW  08
147A:  MOVLB  02
147B:  MOVWF  46
147C:  MOVLP  08
147D:  MOVLB  00
147E:  CALL   124
147F:  MOVLP  10
1480:  MOVLB  01
1481:  MOVF   6F,W
1482:  MOVLB  02
1483:  MOVWF  46
1484:  MOVLW  18
1485:  MOVWF  47
1486:  MOVLP  08
1487:  MOVLB  00
1488:  CALL   1EF
1489:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
148A:  MOVLW  0A
148B:  CLRWDT
148C:  BTFSS  11.4
148D:  GOTO   48B
148E:  MOVLB  03
148F:  MOVWF  1A
1490:  MOVLW  0D
1491:  CLRWDT
1492:  MOVLB  00
1493:  BTFSC  11.4
1494:  GOTO   497
1495:  MOVLB  03
1496:  GOTO   491
1497:  MOVLB  03
1498:  MOVWF  1A
1499:  MOVLW  20
149A:  MOVWF  05
149B:  MOVLW  78
149C:  MOVWF  04
149D:  MOVLP  08
149E:  MOVLB  00
149F:  CALL   256
14A0:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
14A1:  MOVLB  01
14A2:  MOVF   6F,W
14A3:  MOVLB  02
14A4:  MOVWF  46
14A5:  MOVLW  20
14A6:  MOVWF  48
14A7:  MOVLW  78
14A8:  MOVWF  47
14A9:  MOVLP  08
14AA:  MOVLB  00
14AB:  CALL   18C
14AC:  MOVLP  10
.................... #endif 
....................       break; 
14AD:  GOTO   4B6
.................... #if __DEVICE__  == 1939 
....................     case SET_BIT: 
....................       set_bit(); 
....................       break; 
....................     case CLEAR_BIT: 
....................       clear_bit(); 
....................       break; 
.................... #endif 
....................     case MORSE_SEND: 
....................       morse(value); 
14AE:  MOVLB  01
14AF:  MOVF   41,W
14B0:  MOVLB  02
14B1:  MOVWF  3B
14B2:  MOVLP  08
14B3:  MOVLB  00
14B4:  CALL   09C
14B5:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
14B6:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  46
1803:  MOVLW  20
1804:  MOVWF  48
1805:  MOVLW  50
1806:  MOVWF  47
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   18C
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVLB  01
180D:  MOVWF  40
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B6C:  MOVLB  01
1B6D:  CLRF   63
1B6E:  CLRF   62
1B6F:  MOVF   63,F
1B70:  BTFSS  03.2
1B71:  GOTO   3BB
1B72:  MOVF   62,W
1B73:  SUBLW  38
1B74:  BTFSS  03.0
1B75:  GOTO   3BB
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B76:  MOVLW  01
1B77:  MOVWF  7A
1B78:  MOVLW  8F
1B79:  MOVWF  6C
1B7A:  MOVF   7A,W
1B7B:  MOVWF  6D
1B7C:  MOVF   63,W
1B7D:  MOVLB  02
1B7E:  MOVWF  3A
1B7F:  MOVLB  01
1B80:  MOVF   62,W
1B81:  MOVLB  02
1B82:  MOVWF  39
1B83:  CLRF   3C
1B84:  MOVLW  06
1B85:  MOVWF  3B
1B86:  MOVLP  08
1B87:  MOVLB  00
1B88:  CALL   6DB
1B89:  MOVLP  18
1B8A:  MOVF   78,W
1B8B:  MOVLB  01
1B8C:  ADDWF  6C,W
1B8D:  MOVWF  64
1B8E:  MOVF   79,W
1B8F:  ADDWFC 6D,W
1B90:  MOVWF  65
....................     romstrcpy(rname,cPtr); 
1B91:  MOVLW  20
1B92:  MOVLB  02
1B93:  MOVWF  38
1B94:  MOVLW  96
1B95:  MOVWF  37
1B96:  MOVLB  01
1B97:  MOVF   65,W
1B98:  MOVLB  02
1B99:  MOVWF  3A
1B9A:  MOVLB  01
1B9B:  MOVF   64,W
1B9C:  MOVLB  02
1B9D:  MOVWF  39
1B9E:  MOVLP  08
1B9F:  MOVLB  00
1BA0:  CALL   6F2
1BA1:  MOVLP  18
....................     if(my_stricmp(argument_name,rname)==0) { 
1BA2:  MOVLW  20
1BA3:  MOVLB  02
1BA4:  MOVWF  3C
1BA5:  MOVLW  72
1BA6:  MOVWF  3B
1BA7:  MOVLW  20
1BA8:  MOVWF  3E
1BA9:  MOVLW  96
1BAA:  MOVWF  3D
1BAB:  MOVLP  08
1BAC:  MOVLB  00
1BAD:  CALL   6B3
1BAE:  MOVLP  18
1BAF:  MOVF   78,F
1BB0:  BTFSS  03.2
1BB1:  GOTO   3B6
....................       argument=x; 
1BB2:  MOVLB  01
1BB3:  MOVF   62,W
1BB4:  MOVWF  40
1BB5:  MOVLB  00
....................     } 
....................   } 
1BB6:  MOVLB  01
1BB7:  INCF   62,F
1BB8:  BTFSC  03.2
1BB9:  INCF   63,F
1BBA:  GOTO   36F
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BBB:  MOVF   40,W
1BBC:  SUBLW  FF
1BBD:  BTFSS  03.2
1BBE:  GOTO   422
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BBF:  MOVLW  20
1BC0:  MOVLB  02
1BC1:  MOVWF  3C
1BC2:  MOVLW  72
1BC3:  MOVWF  3B
1BC4:  MOVLP  08
1BC5:  MOVLB  00
1BC6:  CALL   67A
1BC7:  MOVLP  18
1BC8:  MOVF   78,W
1BC9:  MOVLB  01
1BCA:  MOVWF  41
....................     strcpy(rname,"eeprom"); 
1BCB:  CLRF   6C
1BCC:  CLRF   6D
1BCD:  MOVLW  20
1BCE:  MOVWF  05
1BCF:  MOVLW  96
1BD0:  MOVWF  04
1BD1:  MOVF   6C,W
1BD2:  ADDWF  04,F
1BD3:  MOVLW  00
1BD4:  ADDWFC 05,F
1BD5:  MOVF   6D,W
1BD6:  MOVLP  00
1BD7:  MOVLB  00
1BD8:  CALL   128
1BD9:  MOVLP  18
1BDA:  MOVWF  00
1BDB:  IORLW  00
1BDC:  BTFSC  03.2
1BDD:  GOTO   3E3
1BDE:  MOVLB  01
1BDF:  INCF   6D,F
1BE0:  INCF   6C,F
1BE1:  GOTO   3CD
1BE2:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1BE3:  MOVLW  20
1BE4:  MOVLB  02
1BE5:  MOVWF  3C
1BE6:  MOVLW  72
1BE7:  MOVWF  3B
1BE8:  MOVLW  20
1BE9:  MOVWF  3E
1BEA:  MOVLW  96
1BEB:  MOVWF  3D
1BEC:  MOVLP  08
1BED:  MOVLB  00
1BEE:  CALL   6B3
1BEF:  MOVLP  18
1BF0:  MOVF   78,F
1BF1:  BTFSS  03.2
1BF2:  GOTO   3F7
....................       value=USE_EEPROM_VARS; 
1BF3:  MOVLW  01
1BF4:  MOVLB  01
1BF5:  MOVWF  41
1BF6:  MOVLB  00
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BF7:  MOVLB  01
1BF8:  CLRF   6C
1BF9:  CLRF   6D
1BFA:  MOVLW  20
1BFB:  MOVWF  05
1BFC:  MOVLW  96
1BFD:  MOVWF  04
1BFE:  MOVF   6C,W
1BFF:  ADDWF  04,F
1C00:  MOVLW  00
1C01:  ADDWFC 05,F
1C02:  MOVF   6D,W
1C03:  MOVLP  00
1C04:  MOVLB  00
1C05:  CALL   130
1C06:  MOVLP  18
1C07:  MOVWF  00
1C08:  IORLW  00
1C09:  BTFSC  03.2
1C0A:  GOTO   410
1C0B:  MOVLB  01
1C0C:  INCF   6D,F
1C0D:  INCF   6C,F
1C0E:  GOTO   3FA
1C0F:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C10:  MOVLW  20
1C11:  MOVLB  02
1C12:  MOVWF  3C
1C13:  MOVLW  72
1C14:  MOVWF  3B
1C15:  MOVLW  20
1C16:  MOVWF  3E
1C17:  MOVLW  96
1C18:  MOVWF  3D
1C19:  MOVLP  08
1C1A:  MOVLB  00
1C1B:  CALL   6B3
1C1C:  MOVLP  18
1C1D:  MOVF   78,F
1C1E:  BTFSS  03.2
1C1F:  GOTO   423
....................       value=USE_DEFAULT_VARS; 
1C20:  MOVLB  01
1C21:  CLRF   41
1C22:  MOVLB  00
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C23:  MOVF   70,W
1C24:  SUBLW  06
1C25:  BTFSC  03.2
1C26:  GOTO   42B
1C27:  MOVF   70,W
1C28:  SUBLW  07
1C29:  BTFSS  03.2
1C2A:  GOTO   431
....................     value = 1; 
1C2B:  MOVLW  01
1C2C:  MOVLB  01
1C2D:  MOVWF  41
....................     argument = CurrentTrimPot; 
1C2E:  MOVF   7D,W
1C2F:  MOVWF  40
1C30:  MOVLB  00
....................   } 
....................   rs232_mode = 1; 
1C31:  MOVLB  01
1C32:  BSF    5F.6
....................   execute_command(); 
1C33:  MOVLP  10
1C34:  MOVLB  00
1C35:  CALL   000
1C36:  MOVLP  18
....................   rs232_mode = 0; 
1C37:  MOVLB  01
1C38:  BCF    5F.6
.................... } // }}} 
1C39:  MOVLP  18
1C3A:  MOVLB  00
1C3B:  GOTO   706 (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
124C:  MOVLW  1B
124D:  MOVLP  00
124E:  CALL   2E4
124F:  MOVLP  10
....................   printf("[2J"); 
1250:  MOVLW  5B
1251:  CLRWDT
1252:  BTFSS  11.4
1253:  GOTO   251
1254:  MOVLB  03
1255:  MOVWF  1A
1256:  MOVLW  32
1257:  CLRWDT
1258:  MOVLB  00
1259:  BTFSC  11.4
125A:  GOTO   25D
125B:  MOVLB  03
125C:  GOTO   257
125D:  MOVLB  03
125E:  MOVWF  1A
125F:  MOVLW  4A
1260:  CLRWDT
1261:  MOVLB  00
1262:  BTFSC  11.4
1263:  GOTO   266
1264:  MOVLB  03
1265:  GOTO   260
1266:  MOVLB  03
1267:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
1268:  MOVLW  1B
1269:  MOVLP  00
126A:  MOVLB  00
126B:  CALL   2E4
126C:  MOVLP  10
....................   printf("[0;0H"); 
126D:  MOVLW  F0
126E:  MOVLB  03
126F:  MOVWF  11
1270:  MOVLW  03
1271:  MOVWF  12
1272:  MOVLP  00
1273:  MOVLB  00
1274:  CALL   4D3
1275:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
0787:  MOVLB  02
0788:  SWAPF  3B,W
0789:  MOVWF  3D
078A:  RLF    3D,F
078B:  RLF    3D,F
078C:  MOVLW  C0
078D:  ANDWF  3D,F
....................   tx_value=tx_value + (value & 0x3F); 
078E:  MOVF   3C,W
078F:  ANDLW  3F
0790:  ADDWF  3D,F
....................   i2c_start(); 
0791:  MOVLB  04
0792:  BSF    16.0
0793:  BTFSC  16.0
0794:  GOTO   793
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
0795:  MOVLW  50
0796:  MOVLB  02
0797:  MOVWF  4C
0798:  MOVLB  00
0799:  CALL   6AF
079A:  MOVF   78,W
079B:  MOVLB  02
079C:  BCF    3E.0
079D:  BTFSC  78.0
079E:  BSF    3E.0
....................   if ( ack != 0) { 
079F:  BTFSS  3E.0
07A0:  GOTO   7B8
....................     printf("\n\rI2C : No ACK : %u",ack); 
07A1:  MOVLW  00
07A2:  BTFSC  3E.0
07A3:  MOVLW  01
07A4:  MOVWF  3F
07A5:  MOVLW  F3
07A6:  MOVLB  03
07A7:  MOVWF  11
07A8:  MOVLW  03
07A9:  MOVWF  12
07AA:  BCF    03.0
07AB:  MOVLW  11
07AC:  MOVLB  02
07AD:  MOVWF  4C
07AE:  MOVLB  00
07AF:  CALL   6C4
07B0:  MOVLB  02
07B1:  MOVF   3F,W
07B2:  MOVWF  4C
07B3:  MOVLW  1B
07B4:  MOVWF  4D
07B5:  MOVLB  00
07B6:  CALL   738
07B7:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
07B8:  MOVF   3D,W
07B9:  MOVWF  4C
07BA:  MOVLB  00
07BB:  CALL   6AF
....................   i2c_stop();   
07BC:  MOVLB  04
07BD:  BSF    16.2
07BE:  BTFSC  16.2
07BF:  GOTO   7BE
....................   printf("\n\rPot(%u)<=%u",pot,value); 
07C0:  MOVLW  FD
07C1:  MOVLB  03
07C2:  MOVWF  11
07C3:  MOVLW  03
07C4:  MOVWF  12
07C5:  BCF    03.0
07C6:  MOVLW  06
07C7:  MOVLB  02
07C8:  MOVWF  4C
07C9:  MOVLB  00
07CA:  CALL   6C4
07CB:  MOVLB  02
07CC:  MOVF   3B,W
07CD:  MOVWF  4C
07CE:  MOVLW  1B
07CF:  MOVWF  4D
07D0:  MOVLB  00
07D1:  CALL   738
07D2:  MOVLW  29
07D3:  CLRWDT
07D4:  BTFSS  11.4
07D5:  GOTO   7D3
07D6:  MOVLB  03
07D7:  MOVWF  1A
07D8:  MOVLW  3C
07D9:  CLRWDT
07DA:  MOVLB  00
07DB:  BTFSC  11.4
07DC:  GOTO   7DF
07DD:  MOVLB  03
07DE:  GOTO   7D9
07DF:  MOVLB  03
07E0:  MOVWF  1A
07E1:  MOVLW  3D
07E2:  CLRWDT
07E3:  MOVLB  00
07E4:  BTFSC  11.4
07E5:  GOTO   7E8
07E6:  MOVLB  03
07E7:  GOTO   7E2
07E8:  MOVLB  03
07E9:  MOVWF  1A
07EA:  MOVLB  02
07EB:  MOVF   3C,W
07EC:  MOVWF  4C
07ED:  MOVLW  1B
07EE:  MOVWF  4D
07EF:  MOVLB  00
07F0:  CALL   738
....................  
.................... } // }}} 
07F1:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
089C:  MOVLW  DB
089D:  MOVLB  02
089E:  ADDWF  3B,W
089F:  MOVWF  3F
08A0:  MOVLW  1F
08A1:  MOVWF  40
08A2:  BTFSC  03.0
08A3:  INCF   40,F
08A4:  MOVF   40,W
08A5:  MOVLB  03
08A6:  MOVWF  12
08A7:  MOVLB  02
08A8:  MOVF   3F,W
08A9:  MOVLB  03
08AA:  MOVWF  11
08AB:  MOVLW  20
08AC:  MOVWF  05
08AD:  MOVLW  BC
08AE:  MOVWF  04
08AF:  MOVLW  01
08B0:  MOVLB  02
08B1:  MOVWF  41
08B2:  MOVLB  00
08B3:  CALL   019
....................    
....................   PROMPT_FLAG=1; 
08B4:  MOVLB  01
08B5:  BSF    5F.4
....................   for(x=0;x<4;x++) { 
08B6:  MOVLB  02
08B7:  CLRF   3D
08B8:  MOVF   3D,W
08B9:  SUBLW  03
08BA:  BTFSS  03.0
08BB:  GOTO   0E2
....................     do_delay=1; 
08BC:  BSF    3E.0
....................     switch(mc & 0xc0) { // Check two MSB's 
08BD:  MOVF   3C,W
08BE:  ANDLW  C0
08BF:  XORLW  40
08C0:  MOVLB  00
08C1:  BTFSC  03.2
08C2:  GOTO   0C7
08C3:  XORLW  C0
08C4:  BTFSC  03.2
08C5:  GOTO   0C9
08C6:  GOTO   0CB
....................       case(0x40): 
....................         dit(); 
08C7:  CALL   02C
....................         break; 
08C8:  GOTO   0CE
....................       case(0x80): 
....................         dah(); 
08C9:  CALL   064
....................         break; 
08CA:  GOTO   0CE
....................       default: 
....................         do_delay=0; 
08CB:  MOVLB  02
08CC:  BCF    3E.0
....................         break; 
08CD:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
08CE:  MOVLB  02
08CF:  RLF    3C,F
08D0:  RLF    3C,F
08D1:  MOVLW  FC
08D2:  ANDWF  3C,F
....................     if ( do_delay ) { 
08D3:  BTFSS  3E.0
08D4:  GOTO   0E0
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
08D5:  MOVLB  01
08D6:  CLRF   33
08D7:  MOVLW  02
08D8:  MOVWF  32
....................       while(aux_timer) { 
08D9:  MOVF   32,W
08DA:  IORWF  33,W
08DB:  BTFSC  03.2
08DC:  GOTO   0DF
....................         delay_cycles(1); 
08DD:  NOP
....................       } 
08DE:  GOTO   0D9
08DF:  MOVLB  02
....................     } 
....................   } 
08E0:  INCF   3D,F
08E1:  GOTO   0B8
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
08E2:  MOVF   3B,W
08E3:  SUBLW  09
08E4:  BTFSS  03.0
08E5:  GOTO   0F1
....................     if ( c < 5 ) { 
08E6:  MOVF   3B,W
08E7:  SUBLW  04
08E8:  BTFSS  03.0
08E9:  GOTO   0EE
....................       dah(); 
08EA:  MOVLB  00
08EB:  CALL   064
....................     } 
....................     else { 
08EC:  GOTO   0F0
08ED:  MOVLB  02
....................       dit(); 
08EE:  MOVLB  00
08EF:  CALL   02C
08F0:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
08F1:  MOVLB  00
08F2:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0B60:  MOVLW  30
0B61:  MOVLB  02
0B62:  MOVWF  30
0B63:  MOVWF  31
0B64:  MOVWF  32
0B65:  MOVWF  33
0B66:  CLRF   34
....................   char PTT_s[5]={'0','0','0','0',0}; 
0B67:  MOVWF  35
0B68:  MOVWF  36
0B69:  MOVWF  37
0B6A:  MOVWF  38
0B6B:  CLRF   39
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0B6C:  MOVF   2A,W
0B6D:  MOVWF  72
....................  
....................   if ( cor ) { 
0B6E:  MOVF   2A,F
0B6F:  BTFSC  03.2
0B70:  GOTO   382
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0B71:  MOVLW  01
0B72:  SUBWF  2A,W
0B73:  ADDLW  29
0B74:  MOVWF  04
0B75:  MOVLW  20
0B76:  MOVWF  05
0B77:  BTFSC  03.0
0B78:  INCF   05,F
0B79:  MOVF   00,W
0B7A:  MOVWF  3B
0B7B:  MOVLB  00
0B7C:  MOVF   60,W
0B7D:  ANDWF  61,W
0B7E:  MOVLB  02
0B7F:  ANDWF  3B,W
0B80:  MOVWF  2F
....................   } else { 
0B81:  GOTO   3C5
....................     ptt=0; 
0B82:  CLRF   2F
....................     //COR_EMUL=0; 
....................     if ( COR_DROP_FLAG ) { 
0B83:  BTFSS  76.5
0B84:  GOTO   3C5
....................       COR_DROP_FLAG=0; 
0B85:  BCF    76.5
....................       if ( ConfirmChar || TailChar ) { 
0B86:  MOVLB  00
0B87:  MOVF   6F,F
0B88:  BTFSS  03.2
0B89:  GOTO   38D
0B8A:  MOVF   6E,F
0B8B:  BTFSC  03.2
0B8C:  GOTO   3C4
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0BC5:  MOVLW  01
0BC6:  MOVWF  2E
....................   for(x=0;x<4;x++) { 
0BC7:  CLRF   2B
0BC8:  MOVF   2B,W
0BC9:  SUBLW  03
0BCA:  BTFSS  03.0
0BCB:  GOTO   42C
....................     if ( !cor ) { 
0BCC:  MOVF   2A,F
0BCD:  BTFSS  03.2
0BCE:  GOTO   3D2
....................       rx_bit=0; 
0BCF:  BCF    3A.0
....................       ptt_bit=0; 
0BD0:  BCF    3A.1
....................     } else { 
0BD1:  GOTO   3E1
....................       if ( cor == (x+1) ) { 
0BD2:  MOVLW  01
0BD3:  ADDWF  2B,W
0BD4:  SUBWF  2A,W
0BD5:  BTFSS  03.2
0BD6:  GOTO   3DB
....................         rx_bit=1; 
0BD7:  BSF    3A.0
....................         CurrentCorMask=mask; 
0BD8:  MOVF   2E,W
0BD9:  MOVWF  71
....................       } else { 
0BDA:  GOTO   3DC
....................         rx_bit=0; 
0BDB:  BCF    3A.0
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0BDC:  BCF    3A.1
0BDD:  MOVF   2F,W
0BDE:  ANDWF  2E,W
0BDF:  BTFSS  03.2
0BE0:  BSF    3A.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0BE1:  MOVF   2B,W
0BE2:  MOVLP  00
0BE3:  MOVLB  00
0BE4:  CALL   031
0BE5:  MOVLP  08
0BE6:  MOVLB  02
0BE7:  MOVWF  3B
0BE8:  MOVLW  00
0BE9:  BTFSC  3A.0
0BEA:  MOVLW  01
0BEB:  MOVWF  77
0BEC:  MOVF   3B,W
0BED:  MOVWF  3C
0BEE:  MOVF   77,W
0BEF:  MOVWF  3D
0BF0:  MOVLW  01
0BF1:  MOVWF  3F
0BF2:  CLRF   3E
0BF3:  MOVLB  00
0BF4:  CALL   0F3
0BF5:  MOVLB  02
0BF6:  MOVF   3B,W
0BF7:  MOVWF  3C
0BF8:  CLRF   3D
0BF9:  CLRF   3F
0BFA:  MOVLW  80
0BFB:  MOVWF  3E
0BFC:  MOVLB  00
0BFD:  CALL   0F3
....................     output_bit(PTT_PIN[x],ptt_bit); 
0BFE:  MOVLB  02
0BFF:  MOVF   2B,W
0C00:  MOVLP  00
0C01:  MOVLB  00
0C02:  CALL   036
0C03:  MOVLP  08
0C04:  MOVLB  02
0C05:  MOVWF  3B
0C06:  MOVLW  00
0C07:  BTFSC  3A.1
0C08:  MOVLW  01
0C09:  MOVWF  77
0C0A:  MOVF   3B,W
0C0B:  MOVWF  3C
0C0C:  MOVF   77,W
0C0D:  MOVWF  3D
0C0E:  MOVLW  01
0C0F:  MOVWF  3F
0C10:  CLRF   3E
0C11:  MOVLB  00
0C12:  CALL   0F3
0C13:  MOVLB  02
0C14:  MOVF   3B,W
0C15:  MOVWF  3C
0C16:  CLRF   3D
0C17:  CLRF   3F
0C18:  MOVLW  80
0C19:  MOVWF  3E
0C1A:  MOVLB  00
0C1B:  CALL   0F3
....................     if(ptt_bit) { 
0C1C:  MOVLB  02
0C1D:  BTFSS  3A.1
0C1E:  GOTO   428
....................       PTT_s[x]='1'; 
0C1F:  MOVLW  B5
0C20:  ADDWF  2B,W
0C21:  MOVWF  04
0C22:  MOVLW  20
0C23:  MOVWF  05
0C24:  BTFSC  03.0
0C25:  INCF   05,F
0C26:  MOVLW  31
0C27:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C28:  BCF    03.0
0C29:  RLF    2E,F
....................   }  
0C2A:  INCF   2B,F
0C2B:  GOTO   3C8
....................   if(!cor) { 
0C2C:  MOVF   2A,F
0C2D:  BTFSS  03.2
0C2E:  GOTO   431
....................     CurrentCorPriority=0; 
0C2F:  CLRF   73
....................   } else { 
0C30:  GOTO   45F
....................     CurrentCorPriority=RXPriority[cor-1]; 
0C31:  MOVLW  01
0C32:  SUBWF  2A,W
0C33:  ADDLW  25
0C34:  MOVWF  04
0C35:  MOVLW  20
0C36:  MOVWF  05
0C37:  BTFSC  03.0
0C38:  INCF   05,F
0C39:  MOVF   00,W
0C3A:  MOVWF  73
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0C3B:  CLRF   2C
0C3C:  MOVF   2C,W
0C3D:  SUBLW  03
0C3E:  BTFSS  03.0
0C3F:  GOTO   45C
....................       pot_val=RX_GAIN[cor-1][pot]; 
0C40:  MOVLW  01
0C41:  SUBWF  2A,W
0C42:  MOVWF  77
0C43:  RLF    77,F
0C44:  RLF    77,F
0C45:  MOVLW  FC
0C46:  ANDWF  77,F
0C47:  MOVF   77,W
0C48:  ADDWF  2C,W
0C49:  ADDLW  0C
0C4A:  MOVWF  04
0C4B:  MOVLW  20
0C4C:  MOVWF  05
0C4D:  BTFSC  03.0
0C4E:  INCF   05,F
0C4F:  MOVF   00,W
0C50:  MOVWF  2D
....................       set_trimpot(pot,pot_val); 
0C51:  MOVF   2C,W
0C52:  MOVWF  3B
0C53:  MOVF   2D,W
0C54:  MOVWF  3C
0C55:  MOVLP  00
0C56:  MOVLB  00
0C57:  CALL   787
0C58:  MOVLP  08
....................     } 
0C59:  MOVLB  02
0C5A:  INCF   2C,F
0C5B:  GOTO   43C
....................     PROMPT_FLAG=1; 
0C5C:  MOVLB  01
0C5D:  BSF    5F.4
0C5E:  MOVLB  02
....................   } 
....................   COR_s[cor-1]='1'; 
0C5F:  MOVLW  01
0C60:  SUBWF  2A,W
0C61:  ADDLW  B0
0C62:  MOVWF  04
0C63:  MOVLW  20
0C64:  MOVWF  05
0C65:  BTFSC  03.0
0C66:  INCF   05,F
0C67:  MOVLW  31
0C68:  MOVWF  00
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0C69:  MOVLW  20
0C6A:  MOVLB  01
0C6B:  MOVWF  61
0C6C:  MOVLW  78
0C6D:  MOVWF  60
0C6E:  MOVLW  04
0C6F:  MOVLB  03
0C70:  MOVWF  11
0C71:  MOVLW  04
0C72:  MOVWF  12
0C73:  BCF    03.0
0C74:  MOVLW  04
0C75:  MOVLB  02
0C76:  MOVWF  46
0C77:  MOVLB  00
0C78:  CALL   124
0C79:  MOVLW  20
0C7A:  MOVWF  05
0C7B:  MOVLW  B0
0C7C:  MOVWF  04
0C7D:  CALL   177
0C7E:  MOVLW  07
0C7F:  MOVLB  03
0C80:  MOVWF  11
0C81:  MOVLW  04
0C82:  MOVWF  12
0C83:  BCF    03.0
0C84:  MOVLW  05
0C85:  MOVLB  02
0C86:  MOVWF  46
0C87:  MOVLB  00
0C88:  CALL   124
0C89:  MOVLW  20
0C8A:  MOVWF  05
0C8B:  MOVLW  B5
0C8C:  MOVWF  04
0C8D:  CALL   177
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0C8E:  MOVLW  01
0C8F:  MOVLB  02
0C90:  MOVWF  46
0C91:  MOVLW  20
0C92:  MOVWF  48
0C93:  MOVLW  78
0C94:  MOVWF  47
0C95:  MOVLB  00
0C96:  CALL   18C
....................   delay_ms(50); 
0C97:  MOVLW  32
0C98:  MOVLB  02
0C99:  MOVWF  46
0C9A:  MOVLB  00
0C9B:  CALL   000
....................   pot_values_to_lcd(); 
0C9C:  CALL   270
.................... }// }}} 
0C9D:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1E0E:  MOVF   64,W
1E0F:  SUBLW  0A
1E10:  BTFSS  03.0
1E11:  GOTO   62C
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1E12:  MOVLW  64
1E13:  ADDWF  64,W
1E14:  MOVWF  04
1E15:  MOVLW  20
1E16:  MOVWF  05
1E17:  BTFSC  03.0
1E18:  INCF   05,F
1E19:  BTFSS  00.4
1E1A:  GOTO   62A
1E1B:  MOVLW  64
1E1C:  ADDWF  64,W
1E1D:  MOVWF  04
1E1E:  MOVLW  20
1E1F:  MOVWF  05
1E20:  BTFSC  03.0
1E21:  INCF   05,F
1E22:  MOVF   00,W
1E23:  ANDLW  0F
1E24:  SUBLW  0C
1E25:  BTFSC  03.2
1E26:  GOTO   62A
....................       strobe=1; 
1E27:  MOVLW  01
1E28:  MOVWF  65
....................      } else { 
1E29:  GOTO   62B
....................       strobe = 0; 
1E2A:  CLRF   65
....................     }  
....................   } else { 
1E2B:  GOTO   62D
....................     strobe=0; 
1E2C:  CLRF   65
....................   } 
....................   return(strobe); 
1E2D:  MOVF   65,W
1E2E:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
17B9:  MOVLB  01
17BA:  MOVF   64,W
17BB:  SUBWF  65,W
17BC:  BTFSS  03.0
17BD:  GOTO   7E3
17BE:  MOVF   64,W
17BF:  SUBLW  09
17C0:  BTFSS  03.0
17C1:  GOTO   7E3
....................     valid=1; 
17C2:  BSF    68.0
....................     for(x=a;x<=b;x++) { 
17C3:  MOVF   64,W
17C4:  MOVWF  67
17C5:  MOVF   67,W
17C6:  SUBWF  65,W
17C7:  BTFSS  03.0
17C8:  GOTO   7E2
....................       key=(int)DTMF_ARRAY[x].Key; 
17C9:  MOVLW  64
17CA:  ADDWF  67,W
17CB:  MOVWF  04
17CC:  MOVLW  20
17CD:  MOVWF  05
17CE:  BTFSC  03.0
17CF:  INCF   05,F
17D0:  MOVF   00,W
17D1:  ANDLW  0F
17D2:  MOVWF  66
....................       if(! DTMF_ARRAY[x].Strobe ) { 
17D3:  MOVLW  64
17D4:  ADDWF  67,W
17D5:  MOVWF  04
17D6:  MOVLW  20
17D7:  MOVWF  05
17D8:  BTFSC  03.0
17D9:  INCF   05,F
17DA:  BTFSS  00.4
....................         valid=0; 
17DB:  BCF    68.0
....................       } 
....................      if(key==dp) { 
17DC:  MOVF   66,W
17DD:  SUBLW  0C
17DE:  BTFSC  03.2
....................         valid=0; 
17DF:  BCF    68.0
....................       } 
....................     } 
17E0:  INCF   67,F
17E1:  GOTO   7C5
....................   } else { 
17E2:  GOTO   7E4
....................     valid=0; 
17E3:  BCF    68.0
....................   } 
....................   return(valid); 
17E4:  MOVLW  00
17E5:  BTFSC  68.0
17E6:  MOVLW  01
17E7:  MOVWF  78
.................... } // }}} 
17E8:  MOVLB  00
17E9:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   unsigned site_id; 
....................   unsigned digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 01 : Link commands 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : Disable Link Radio 
....................   // 11 : Enable Link Radio 
....................   // 12 : Send to I2C 
....................   // 14 : SetBit   (*52 14 <reg> <bit>) 
....................   // 15 : ClearBit (*52 15 <reg> <bit>) 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Save Settings	    : 52 04 00 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   // -- User Functions -- 
....................   // Disable AuxOut0        : 51 02 21 0 #  
....................   // Disable AuxOut0 (!Arg) : 51 02 21 #  
....................   // Enable  AuxOut1        : 51 02 22 1 # 
....................   command=0; 
*
1DBA:  CLRF   70
....................   value=0; 
1DBB:  MOVLB  01
1DBC:  CLRF   41
....................   if ( ValidKeyRange(0,3)) { 
1DBD:  CLRF   64
1DBE:  MOVLW  03
1DBF:  MOVWF  65
1DC0:  MOVLP  10
1DC1:  MOVLB  00
1DC2:  CALL   7B9
1DC3:  MOVLP  18
1DC4:  MOVF   78,F
1DC5:  BTFSC  03.2
1DC6:  GOTO   67B
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1DC7:  MOVLB  01
1DC8:  MOVF   34,W
1DC9:  ANDLW  0F
1DCA:  MOVWF  65
1DCB:  MOVLB  02
1DCC:  MOVWF  3F
1DCD:  MOVLW  0A
1DCE:  MOVWF  40
1DCF:  MOVLP  08
1DD0:  MOVLB  00
1DD1:  CALL   653
1DD2:  MOVLP  18
1DD3:  MOVF   78,W
1DD4:  MOVLB  01
1DD5:  MOVWF  64
1DD6:  MOVF   35,W
1DD7:  ANDLW  0F
1DD8:  ADDWF  64,W
1DD9:  MOVWF  62
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1DDA:  MOVF   36,W
1DDB:  ANDLW  0F
1DDC:  MOVWF  65
1DDD:  MOVLB  02
1DDE:  MOVWF  3F
1DDF:  MOVLW  0A
1DE0:  MOVWF  40
1DE1:  MOVLP  08
1DE2:  MOVLB  00
1DE3:  CALL   653
1DE4:  MOVLP  18
1DE5:  MOVF   78,W
1DE6:  MOVLB  01
1DE7:  MOVWF  64
1DE8:  MOVF   37,W
1DE9:  ANDLW  0F
1DEA:  ADDWF  64,W
1DEB:  MOVWF  70
....................     if ( ValidKeyRange(4,5) ) { 
1DEC:  MOVLW  04
1DED:  MOVWF  64
1DEE:  MOVLW  05
1DEF:  MOVWF  65
1DF0:  MOVLP  10
1DF1:  MOVLB  00
1DF2:  CALL   7B9
1DF3:  MOVLP  18
1DF4:  MOVF   78,F
1DF5:  BTFSC  03.2
1DF6:  GOTO   64D
....................       // Admin mode {{{ 
....................       argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1DF7:  MOVLB  01
1DF8:  MOVF   38,W
1DF9:  ANDLW  0F
1DFA:  MOVWF  65
1DFB:  MOVLB  02
1DFC:  MOVWF  3F
1DFD:  MOVLW  0A
1DFE:  MOVWF  40
1DFF:  MOVLP  08
1E00:  MOVLB  00
1E01:  CALL   653
1E02:  MOVLP  18
1E03:  MOVF   78,W
1E04:  MOVLB  01
1E05:  MOVWF  64
1E06:  MOVF   39,W
1E07:  ANDLW  0F
1E08:  ADDWF  64,W
1E09:  MOVWF  40
....................       digit=6; 
1E0A:  MOVLW  06
1E0B:  MOVWF  63
....................       while(ValidKey(digit)) { 
1E0C:  MOVF   63,W
1E0D:  MOVWF  64
*
1E2F:  MOVF   78,F
1E30:  BTFSC  03.2
1E31:  GOTO   64B
....................        value = value * 10 + DTMF_ARRAY[digit].Key; 
1E32:  MOVF   41,W
1E33:  MOVLB  02
1E34:  MOVWF  3F
1E35:  MOVLW  0A
1E36:  MOVWF  40
1E37:  MOVLP  08
1E38:  MOVLB  00
1E39:  CALL   653
1E3A:  MOVLP  18
1E3B:  MOVF   78,W
1E3C:  MOVLB  01
1E3D:  MOVWF  64
1E3E:  MOVLW  64
1E3F:  ADDWF  63,W
1E40:  MOVWF  04
1E41:  MOVLW  20
1E42:  MOVWF  05
1E43:  BTFSC  03.0
1E44:  INCF   05,F
1E45:  MOVF   00,W
1E46:  ANDLW  0F
1E47:  ADDWF  64,W
1E48:  MOVWF  41
....................        digit++; 
1E49:  INCF   63,F
....................       } 
1E4A:  GOTO   60C
....................       // Admin mode }}} 
....................     } else { 
1E4B:  GOTO   666
1E4C:  MOVLB  00
....................       // User function {{{ 
....................       // Only 4 digits were entered.  
....................       // Use 'command' value as user function. 
....................       switch(command) { 
1E4D:  MOVF   70,W
1E4E:  XORLW  0A
1E4F:  BTFSC  03.2
1E50:  GOTO   655
1E51:  XORLW  01
1E52:  BTFSC  03.2
1E53:  GOTO   65C
1E54:  GOTO   664
....................         // Commands 10 (disable link) and 11 (enable link) 
....................         case(10): 
....................           argument = 0; 
1E55:  MOVLB  01
1E56:  CLRF   40
....................           value = 0x0E; 
1E57:  MOVLW  0E
1E58:  MOVWF  41
.................... 	  command=SET_REG; 
1E59:  MOVLW  02
1E5A:  MOVWF  70
....................   	      break; 
1E5B:  GOTO   666
....................         case(11): 
....................           argument = 0; 
1E5C:  MOVLB  01
1E5D:  CLRF   40
....................           value = 0x0F; 
1E5E:  MOVLW  0F
1E5F:  MOVWF  41
.................... 	  command=SET_REG; 
1E60:  MOVLW  02
1E61:  MOVWF  70
....................    		    break; 
1E62:  GOTO   666
1E63:  MOVLB  00
.................... 	default: 
.................... 	  command=0; 
1E64:  CLRF   70
1E65:  MOVLB  01
....................       } 
....................       // User function }}} 
....................     } 
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1E66:  MOVF   70,W
1E67:  XORLW  04
1E68:  MOVLB  00
1E69:  BTFSC  03.2
1E6A:  GOTO   66E
1E6B:  XORLW  01
1E6C:  BTFSS  03.2
1E6D:  GOTO   672
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1E6E:  MOVLB  01
1E6F:  MOVF   40,W
1E70:  MOVWF  41
....................         break; 
1E71:  MOVLB  00
....................     } 
....................     if ( site_id == SiteID ) { 
1E72:  MOVF   63,W
1E73:  MOVLB  01
1E74:  SUBWF  62,W
1E75:  BTFSS  03.2
1E76:  GOTO   67C
....................       execute_command(); 
1E77:  MOVLP  10
1E78:  MOVLB  00
1E79:  CALL   000
1E7A:  MOVLP  18
1E7B:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1E7C:  MOVF   34,W
1E7D:  ANDLW  0F
1E7E:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1E7F:  BTFSS  5F.5
1E80:  GOTO   6B3
1E81:  CLRF   64
1E82:  CLRF   65
1E83:  MOVLP  10
1E84:  MOVLB  00
1E85:  CALL   7B9
1E86:  MOVLP  18
1E87:  MOVF   78,F
1E88:  BTFSS  03.2
1E89:  GOTO   68C
1E8A:  MOVLB  01
1E8B:  GOTO   6B3
....................     restart_wdt(); 
1E8C:  CLRWDT
....................     switch(command) { 
1E8D:  MOVF   70,W
1E8E:  XORLW  0E
1E8F:  BTFSC  03.2
1E90:  GOTO   698
1E91:  XORLW  01
1E92:  BTFSC  03.2
1E93:  GOTO   6A0
1E94:  XORLW  05
1E95:  BTFSC  03.2
1E96:  GOTO   6A8
1E97:  GOTO   6AF
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1E98:  MOVLW  01
1E99:  ADDWF  7D,W
1E9A:  ANDLW  03
1E9B:  MOVWF  7D
....................         pot_values_to_lcd(); 
1E9C:  MOVLP  08
1E9D:  CALL   270
1E9E:  MOVLP  18
....................         break; 
1E9F:  GOTO   6AF
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1EA0:  MOVLW  FF
1EA1:  MOVLB  02
1EA2:  MOVWF  2B
1EA3:  MOVLP  08
1EA4:  MOVLB  00
1EA5:  CALL   72A
1EA6:  MOVLP  18
....................         break; 
1EA7:  GOTO   6AF
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1EA8:  MOVLW  01
1EA9:  MOVLB  02
1EAA:  MOVWF  2B
1EAB:  MOVLP  08
1EAC:  MOVLB  00
1EAD:  CALL   72A
1EAE:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1EAF:  MOVLP  08
1EB0:  CALL   71B
1EB1:  MOVLP  18
1EB2:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1EB3:  BSF    5F.3
.................... } // }}} 
1EB4:  MOVLP  18
1EB5:  MOVLB  00
1EB6:  GOTO   738 (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int cor_index; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
15BD:  MOVLW  01
15BE:  MOVLB  01
15BF:  MOVWF  62
....................   do_update_ptt=0; 
15C0:  CLRF   65
....................   // Allow emulated COR[4] for DTMF control (No audio feed-thru) 
....................   cor_in = COR_IN ; 
15C1:  MOVLB  00
15C2:  MOVF   5F,W
15C3:  MOVLB  01
15C4:  MOVWF  64
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in & CurrentCorMask) ) { 
15C5:  MOVF   73,F
15C6:  BTFSC  03.2
15C7:  GOTO   5DD
15C8:  MOVF   64,W
15C9:  ANDWF  71,W
15CA:  BTFSS  03.2
15CB:  GOTO   5DD
....................     CurrentCorPriority=0; 
15CC:  CLRF   73
....................     CurrentCorMask=0; 
15CD:  CLRF   71
....................     do_update_ptt=1; 
15CE:  MOVLW  01
15CF:  MOVWF  65
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
15D0:  MOVF   64,W
15D1:  MOVLB  00
15D2:  ANDWF  60,W
15D3:  ANDWF  61,W
15D4:  BTFSS  03.2
15D5:  GOTO   5DC
....................       COR_DROP_FLAG=1; 
15D6:  BSF    76.5
....................       if ( Tail ) { 
15D7:  MOVF   65,F
15D8:  BTFSC  03.2
15D9:  GOTO   5DC
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
15DA:  MOVF   65,W
15DB:  MOVWF  6E
15DC:  MOVLB  01
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
15DD:  CLRF   66
....................   for(x=0;x<4;x++) { 
15DE:  CLRF   67
15DF:  MOVF   67,W
15E0:  SUBLW  03
15E1:  BTFSS  03.0
15E2:  GOTO   617
....................     if ( cor_in & cor_mask & (~TOT_FLAG_Mask) ) { 
15E3:  MOVF   64,W
15E4:  ANDWF  62,W
15E5:  MOVWF  68
15E6:  MOVLB  00
15E7:  MOVF   67,W
15E8:  XORLW  FF
15E9:  MOVLB  01
15EA:  ANDWF  68,W
15EB:  BTFSC  03.2
15EC:  GOTO   613
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
15ED:  MOVLB  00
15EE:  MOVF   60,W
15EF:  ANDWF  61,W
15F0:  MOVLB  01
15F1:  ANDWF  62,W
15F2:  BTFSC  03.2
15F3:  GOTO   5FE
....................         rx_priority=RXPriority[x]; 
15F4:  MOVLW  25
15F5:  ADDWF  67,W
15F6:  MOVWF  04
15F7:  MOVLW  20
15F8:  MOVWF  05
15F9:  BTFSC  03.0
15FA:  INCF   05,F
15FB:  MOVF   00,W
15FC:  MOVWF  63
....................       } else { 
15FD:  GOTO   600
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
15FE:  MOVLW  01
15FF:  MOVWF  63
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1600:  MOVF   63,W
1601:  SUBWF  73,W
1602:  BTFSC  03.0
1603:  GOTO   613
....................         if ( ! CurrentCorPriority ) { 
1604:  MOVF   73,F
1605:  BTFSS  03.2
1606:  GOTO   609
....................           CurrentCorPriority = rx_priority; 
1607:  MOVF   63,W
1608:  MOVWF  73
....................         } 
....................         cor_index=x+1; 
1609:  MOVLW  01
160A:  ADDWF  67,W
160B:  MOVWF  66
....................         do_update_ptt=1; 
160C:  MOVLW  01
160D:  MOVWF  65
.................... 	TOT_FLAG_Mask=0; 
160E:  MOVLB  00
160F:  CLRF   67
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
1610:  MOVLB  01
1611:  MOVF   62,W
1612:  MOVWF  74
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
1613:  BCF    03.0
1614:  RLF    62,F
....................   } 
1615:  INCF   67,F
1616:  GOTO   5DF
....................   if ( do_update_ptt ) { 
1617:  MOVF   65,F
1618:  BTFSC  03.2
1619:  GOTO   623
....................     update_ptt(cor_index); 
161A:  MOVF   66,W
161B:  MOVLB  02
161C:  MOVWF  2A
161D:  MOVLP  08
161E:  MOVLB  00
161F:  CALL   360
1620:  MOVLP  10
....................     PROMPT_FLAG=1; 
1621:  MOVLB  01
1622:  BSF    5F.4
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
1623:  MOVF   64,F
1624:  BTFSS  03.2
1625:  GOTO   62B
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
1626:  BSF    5F.3
....................     COR_IN_EFFECTIVE=0; 
1627:  CLRF   74
....................     TOT_FLAG_Mask=0; 
1628:  MOVLB  00
1629:  CLRF   67
162A:  MOVLB  01
....................   } 
....................   // Refresh Link Time-out timer when COR is received. 
....................   // Any COR value refreshes the link TOT timer. 
....................   if ( Link_TOT != 0 && (cor_in)!=0 ) { 
162B:  MOVLB  00
162C:  MOVF   6A,F
162D:  BTFSC  03.2
162E:  GOTO   638
162F:  MOVLB  01
1630:  MOVF   64,F
1631:  BTFSS  03.2
1632:  GOTO   635
1633:  MOVLB  00
1634:  GOTO   638
....................     LinkDurationTimer = Link_TOT; 
1635:  MOVLB  00
1636:  MOVF   6A,W
1637:  MOVWF  6B
....................   } 
.................... } // }}} 
1638:  MOVLP  18
1639:  GOTO   71A (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
1EB7:  MOVLB  01
1EB8:  CLRF   62
1EB9:  MOVF   62,W
1EBA:  SUBLW  09
1EBB:  BTFSS  03.0
1EBC:  GOTO   6C7
....................     DTMF_ARRAY[x]=(sDTMF)0; 
1EBD:  MOVLW  64
1EBE:  ADDWF  62,W
1EBF:  MOVWF  04
1EC0:  MOVLW  20
1EC1:  MOVWF  05
1EC2:  BTFSC  03.0
1EC3:  INCF   05,F
1EC4:  CLRF   00
....................   } 
1EC5:  INCF   62,F
1EC6:  GOTO   6B9
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
1EC7:  MOVLW  20
1EC8:  MOVWF  3F
1EC9:  MOVLW  64
1ECA:  MOVWF  3E
.................... } // }}} 
1ECB:  MOVLP  18
1ECC:  MOVLB  00
1ECD:  GOTO   73F (RETURN)
.................... void header (void) { // {{{ 
.................... } // }}} 
*
0003:  RETURN
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   header(); 
*
1276:  MOVLP  00
1277:  CALL   003
1278:  MOVLP  10
....................   dtmf_in=dtmf_read(CONTROL_REG); 
1279:  MOVLW  01
127A:  MOVLB  02
127B:  MOVWF  37
127C:  MOVLP  00
127D:  MOVLB  00
127E:  CALL   696
127F:  MOVLP  10
1280:  MOVF   78,W
1281:  MOVLB  02
1282:  MOVWF  2F
....................   aux_in = 0; 
1283:  CLRF   30
....................   for(x=0;x<RegMapNum;x++) { 
1284:  CLRF   29
1285:  CLRF   28
1286:  MOVF   29,F
1287:  BTFSS  03.2
1288:  GOTO   38D
1289:  MOVF   28,W
128A:  SUBLW  38
128B:  BTFSS  03.0
128C:  GOTO   38D
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
128D:  MOVLW  01
128E:  MOVWF  7A
128F:  MOVLW  8F
1290:  MOVWF  37
1291:  MOVF   7A,W
1292:  MOVWF  38
1293:  MOVF   29,W
1294:  MOVWF  3A
1295:  MOVF   28,W
1296:  MOVWF  39
1297:  CLRF   3C
1298:  MOVLW  06
1299:  MOVWF  3B
129A:  MOVLP  08
129B:  MOVLB  00
129C:  CALL   6DB
129D:  MOVLP  10
129E:  MOVF   78,W
129F:  MOVLB  02
12A0:  ADDWF  37,W
12A1:  MOVWF  2B
12A2:  MOVF   79,W
12A3:  ADDWFC 38,W
12A4:  MOVWF  2C
....................     romstrcpy(rname,cPtr); 
12A5:  MOVLW  20
12A6:  MOVWF  38
12A7:  MOVLW  B1
12A8:  MOVWF  37
12A9:  MOVF   2C,W
12AA:  MOVWF  3A
12AB:  MOVF   2B,W
12AC:  MOVWF  39
12AD:  MOVLP  08
12AE:  MOVLB  00
12AF:  CALL   6F2
12B0:  MOVLP  10
....................   regPtr=RegMap[x].reg_ptr; 
12B1:  MOVLB  02
12B2:  RLF    28,W
12B3:  MOVWF  37
12B4:  RLF    29,W
12B5:  MOVWF  38
12B6:  RLF    37,F
12B7:  RLF    38,F
12B8:  MOVLW  FC
12B9:  ANDWF  37,F
12BA:  MOVF   38,W
12BB:  MOVWF  7A
12BC:  MOVF   37,W
12BD:  MOVWF  39
12BE:  INCF   37,W
12BF:  MOVLP  00
12C0:  MOVLB  00
12C1:  CALL   043
12C2:  MOVLP  10
12C3:  MOVWF  7A
12C4:  MOVLB  02
12C5:  MOVF   39,W
12C6:  MOVLP  00
12C7:  MOVLB  00
12C8:  CALL   043
12C9:  MOVLP  10
12CA:  MOVLB  02
12CB:  MOVWF  2D
12CC:  MOVF   7A,W
12CD:  MOVWF  2E
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
12CE:  MOVF   2E,W
12CF:  MOVWF  7A
12D0:  MOVF   2D,W
12D1:  MOVWF  04
12D2:  MOVF   7A,W
12D3:  MOVWF  05
12D4:  MOVF   00,W
12D5:  MOVWF  37
12D6:  MOVLW  5B
12D7:  CLRWDT
12D8:  MOVLB  00
12D9:  BTFSC  11.4
12DA:  GOTO   2DD
12DB:  MOVLB  02
12DC:  GOTO   2D7
12DD:  MOVLB  03
12DE:  MOVWF  1A
12DF:  MOVLW  0B
12E0:  MOVWF  04
12E1:  MOVLB  02
12E2:  MOVF   29,W
12E3:  MOVWF  39
12E4:  MOVF   28,W
12E5:  MOVWF  38
*
1343:  MOVLW  5D
1344:  CLRWDT
1345:  MOVLB  00
1346:  BTFSC  11.4
1347:  GOTO   34A
1348:  MOVLB  02
1349:  GOTO   344
134A:  MOVLB  03
134B:  MOVWF  1A
134C:  MOVLW  20
134D:  CLRWDT
134E:  MOVLB  00
134F:  BTFSC  11.4
1350:  GOTO   353
1351:  MOVLB  03
1352:  GOTO   34D
1353:  MOVLB  03
1354:  MOVWF  1A
1355:  MOVLW  20
1356:  MOVWF  05
1357:  MOVLW  B1
1358:  MOVWF  04
1359:  MOVLP  08
135A:  MOVLB  00
135B:  CALL   256
135C:  MOVLP  10
135D:  MOVLW  20
135E:  CLRWDT
135F:  BTFSS  11.4
1360:  GOTO   35E
1361:  MOVLB  03
1362:  MOVWF  1A
1363:  MOVLB  02
1364:  MOVF   37,W
1365:  MOVWF  4C
1366:  MOVLW  1B
1367:  MOVWF  4D
1368:  MOVLP  00
1369:  MOVLB  00
136A:  CALL   738
136B:  MOVLP  10
136C:  MOVLW  09
136D:  CLRWDT
136E:  BTFSS  11.4
136F:  GOTO   36D
1370:  MOVLB  03
1371:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
1372:  MOVLB  02
1373:  MOVF   28,W
1374:  ANDLW  03
1375:  MOVWF  37
1376:  CLRF   38
1377:  MOVF   37,W
1378:  SUBLW  03
1379:  BTFSS  03.2
137A:  GOTO   388
137B:  MOVF   38,F
137C:  BTFSS  03.2
137D:  GOTO   388
....................       putc('\n'); 
137E:  MOVLW  0A
137F:  MOVLP  00
1380:  MOVLB  00
1381:  CALL   2E4
1382:  MOVLP  10
....................       putc('\r'); 
1383:  MOVLW  0D
1384:  MOVLP  00
1385:  CALL   2E4
1386:  MOVLP  10
1387:  MOVLB  02
....................     } 
....................     restart_wdt(); 
1388:  CLRWDT
....................   } 
1389:  INCF   28,F
138A:  BTFSC  03.2
138B:  INCF   29,F
138C:  GOTO   286
....................   for(y=0;y<3;y++) { 
138D:  CLRF   2A
138E:  MOVF   2A,W
138F:  SUBLW  02
1390:  BTFSS  03.0
1391:  GOTO   3A8
....................     if(AuxInSW[y]==1) { 
1392:  MOVLW  1F
1393:  ADDWF  2A,W
1394:  MOVWF  04
1395:  MOVLW  20
1396:  MOVWF  05
1397:  BTFSC  03.0
1398:  INCF   05,F
1399:  DECFSZ 00,W
139A:  GOTO   3A6
....................       aux_in += (1<<y); 
139B:  MOVLW  01
139C:  MOVWF  77
139D:  MOVF   2A,W
139E:  MOVWF  78
139F:  BTFSC  03.2
13A0:  GOTO   3A4
13A1:  LSLF   77,F
13A2:  DECFSZ 78,F
13A3:  GOTO   3A1
13A4:  MOVF   77,W
13A5:  ADDWF  30,F
....................     } 
....................   } 
13A6:  INCF   2A,F
13A7:  GOTO   38E
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u TOT:%u",COR_IN,COR_EMUL,aux_in,TOT_FLAG_Mask); 
13A8:  MOVLW  0B
13A9:  MOVLB  03
13AA:  MOVWF  11
13AB:  MOVLW  04
13AC:  MOVWF  12
13AD:  BCF    03.0
13AE:  MOVLW  07
13AF:  MOVLB  02
13B0:  MOVWF  4C
13B1:  MOVLP  00
13B2:  MOVLB  00
13B3:  CALL   6C4
13B4:  MOVLP  10
13B5:  MOVF   5F,W
13B6:  MOVLB  02
13B7:  MOVWF  4C
13B8:  MOVLW  1B
13B9:  MOVWF  4D
13BA:  MOVLP  00
13BB:  MOVLB  00
13BC:  CALL   738
13BD:  MOVLP  10
13BE:  MOVLW  0F
13BF:  MOVLB  03
13C0:  MOVWF  11
13C1:  MOVLW  04
13C2:  MOVWF  12
13C3:  BSF    03.0
13C4:  MOVLW  07
13C5:  MOVLB  02
13C6:  MOVWF  4C
13C7:  MOVLP  00
13C8:  MOVLB  00
13C9:  CALL   6C4
13CA:  MOVLP  10
13CB:  MOVF   6C,W
13CC:  MOVLB  02
13CD:  MOVWF  4C
13CE:  MOVLW  1B
13CF:  MOVWF  4D
13D0:  MOVLP  00
13D1:  MOVLB  00
13D2:  CALL   738
13D3:  MOVLP  10
13D4:  MOVLW  14
13D5:  MOVLB  03
13D6:  MOVWF  11
13D7:  MOVLW  04
13D8:  MOVWF  12
13D9:  BCF    03.0
13DA:  MOVLW  09
13DB:  MOVLB  02
13DC:  MOVWF  4C
13DD:  MOVLP  00
13DE:  MOVLB  00
13DF:  CALL   6C4
13E0:  MOVLP  10
13E1:  MOVLB  02
13E2:  MOVF   30,W
13E3:  MOVWF  4C
13E4:  MOVLW  1B
13E5:  MOVWF  4D
13E6:  MOVLP  00
13E7:  MOVLB  00
13E8:  CALL   738
13E9:  MOVLP  10
13EA:  MOVLW  19
13EB:  MOVLB  03
13EC:  MOVWF  11
13ED:  MOVLW  04
13EE:  MOVWF  12
13EF:  BSF    03.0
13F0:  MOVLW  05
13F1:  MOVLB  02
13F2:  MOVWF  4C
13F3:  MOVLP  00
13F4:  MOVLB  00
13F5:  CALL   6C4
13F6:  MOVLP  10
13F7:  MOVF   67,W
13F8:  MOVLB  02
13F9:  MOVWF  4C
13FA:  MOVLW  1B
13FB:  MOVWF  4D
13FC:  MOVLP  00
13FD:  MOVLB  00
13FE:  CALL   738
13FF:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
1400:  MOVLW  1E
1401:  MOVLB  03
1402:  MOVWF  11
1403:  MOVLW  04
1404:  MOVWF  12
1405:  BCF    03.0
1406:  MOVLW  10
1407:  MOVLB  02
1408:  MOVWF  4C
1409:  MOVLP  00
140A:  MOVLB  00
140B:  CALL   6C4
140C:  MOVLP  10
140D:  MOVLB  02
140E:  MOVF   2F,W
140F:  MOVWF  4C
1410:  MOVLW  1B
1411:  MOVWF  4D
1412:  MOVLP  00
1413:  MOVLB  00
1414:  CALL   738
1415:  MOVLP  10
1416:  MOVLW  0A
1417:  CLRWDT
1418:  BTFSS  11.4
1419:  GOTO   417
141A:  MOVLB  03
141B:  MOVWF  1A
141C:  MOVLW  0D
141D:  CLRWDT
141E:  MOVLB  00
141F:  BTFSC  11.4
1420:  GOTO   423
1421:  MOVLB  03
1422:  GOTO   41D
1423:  MOVLB  03
1424:  MOVWF  1A
....................   pot_values_to_lcd(); 
1425:  MOVLP  08
1426:  MOVLB  00
1427:  CALL   270
1428:  MOVLP  10
....................   PROMPT_FLAG=1; 
1429:  MOVLB  01
142A:  BSF    5F.4
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0A70:  MOVLW  20
0A71:  MOVLB  02
0A72:  MOVWF  3E
0A73:  MOVWF  3F
0A74:  MOVWF  40
0A75:  MOVWF  41
....................   unsigned pval[4]={0,0,0,0}; 
0A76:  CLRF   42
0A77:  CLRF   43
0A78:  CLRF   44
0A79:  CLRF   45
....................   delay_ms(40); 
0A7A:  MOVLW  28
0A7B:  MOVWF  46
0A7C:  MOVLB  00
0A7D:  CALL   000
....................   i2c_start(); 
0A7E:  MOVLB  04
0A7F:  BSF    16.0
0A80:  BTFSC  16.0
0A81:  GOTO   280
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0A82:  MOVLW  51
0A83:  MOVLB  02
0A84:  MOVWF  4C
0A85:  MOVLP  00
0A86:  MOVLB  00
0A87:  CALL   6AF
0A88:  MOVLP  08
0A89:  MOVF   78,W
0A8A:  MOVLB  02
0A8B:  BCF    3D.1
0A8C:  BTFSC  78.0
0A8D:  BSF    3D.1
....................   for(x=0;x<4;x++) { 
0A8E:  CLRF   3B
0A8F:  MOVF   3B,W
0A90:  SUBLW  03
0A91:  BTFSS  03.0
0A92:  GOTO   2CC
....................     if(x==3) { 
0A93:  MOVF   3B,W
0A94:  SUBLW  03
0A95:  BTFSS  03.2
0A96:  GOTO   299
....................       ack=0; 
0A97:  BCF    3D.0
....................     } else { 
0A98:  GOTO   29A
....................       ack=1; 
0A99:  BSF    3D.0
....................     } 
....................     pot_val=i2c_read(ack); 
0A9A:  MOVLW  00
0A9B:  BTFSC  3D.0
0A9C:  MOVLW  01
0A9D:  MOVWF  46
0A9E:  MOVF   46,W
0A9F:  MOVWF  77
*
0AAE:  MOVF   78,W
0AAF:  MOVLB  02
0AB0:  MOVWF  3C
....................     pot_val=pot_val&0x3F; 
0AB1:  MOVLW  3F
0AB2:  ANDWF  3C,F
....................     pval[x]=pot_val; 
0AB3:  MOVLW  C2
0AB4:  ADDWF  3B,W
0AB5:  MOVWF  04
0AB6:  MOVLW  20
0AB7:  MOVWF  05
0AB8:  BTFSC  03.0
0AB9:  INCF   05,F
0ABA:  MOVF   3C,W
0ABB:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0ABC:  MOVF   7D,W
0ABD:  ANDLW  03
0ABE:  SUBWF  3B,W
0ABF:  BTFSS  03.2
0AC0:  GOTO   2CA
....................       c[x] = '*'; 
0AC1:  MOVLW  BE
0AC2:  ADDWF  3B,W
0AC3:  MOVWF  04
0AC4:  MOVLW  20
0AC5:  MOVWF  05
0AC6:  BTFSC  03.0
0AC7:  INCF   05,F
0AC8:  MOVLW  2A
0AC9:  MOVWF  00
....................     } 
....................   } 
0ACA:  INCF   3B,F
0ACB:  GOTO   28F
....................   i2c_stop(); 
0ACC:  MOVLB  04
0ACD:  BSF    16.2
0ACE:  BTFSC  16.2
0ACF:  GOTO   2CE
....................   delay_ms(50); 
0AD0:  MOVLW  32
0AD1:  MOVLB  02
0AD2:  MOVWF  46
0AD3:  MOVLB  00
0AD4:  CALL   000
....................   if ( ack_in!=0 ) { 
0AD5:  MOVLB  02
0AD6:  BTFSS  3D.1
0AD7:  GOTO   2F3
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0AD8:  MOVLW  00
0AD9:  BTFSC  3D.0
0ADA:  MOVLW  01
0ADB:  MOVWF  46
0ADC:  MOVLW  29
0ADD:  MOVLB  03
0ADE:  MOVWF  11
0ADF:  MOVLW  04
0AE0:  MOVWF  12
0AE1:  BCF    03.0
0AE2:  MOVLW  25
0AE3:  MOVLB  02
0AE4:  MOVWF  4C
0AE5:  MOVLP  00
0AE6:  MOVLB  00
0AE7:  CALL   6C4
0AE8:  MOVLP  08
0AE9:  MOVLB  02
0AEA:  MOVF   46,W
0AEB:  MOVWF  4C
0AEC:  MOVLW  1B
0AED:  MOVWF  4D
0AEE:  MOVLP  00
0AEF:  MOVLB  00
0AF0:  CALL   738
0AF1:  MOVLP  08
0AF2:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0AF3:  MOVLW  20
0AF4:  MOVLB  01
0AF5:  MOVWF  61
0AF6:  MOVLW  78
0AF7:  MOVWF  60
0AF8:  MOVLW  3D
0AF9:  MOVLB  03
0AFA:  MOVWF  11
0AFB:  MOVLW  04
0AFC:  MOVWF  12
0AFD:  BCF    03.0
0AFE:  MOVLW  04
0AFF:  MOVLB  02
0B00:  MOVWF  46
0B01:  MOVLB  00
0B02:  CALL   124
0B03:  MOVLB  02
0B04:  MOVF   3E,W
0B05:  MOVWF  4C
0B06:  MOVLB  00
0B07:  CALL   115
0B08:  MOVLB  02
0B09:  MOVF   42,W
0B0A:  MOVWF  46
0B0B:  MOVLW  18
0B0C:  MOVWF  47
0B0D:  MOVLB  00
0B0E:  CALL   1EF
0B0F:  MOVLW  20
0B10:  MOVLB  02
0B11:  MOVWF  4C
0B12:  MOVLB  00
0B13:  CALL   115
0B14:  MOVLB  02
0B15:  MOVF   3F,W
0B16:  MOVWF  4C
0B17:  MOVLB  00
0B18:  CALL   115
0B19:  MOVLB  02
0B1A:  MOVF   43,W
0B1B:  MOVWF  46
0B1C:  MOVLW  18
0B1D:  MOVWF  47
0B1E:  MOVLB  00
0B1F:  CALL   1EF
0B20:  MOVLW  20
0B21:  MOVLB  02
0B22:  MOVWF  4C
0B23:  MOVLB  00
0B24:  CALL   115
0B25:  MOVLB  02
0B26:  MOVF   40,W
0B27:  MOVWF  4C
0B28:  MOVLB  00
0B29:  CALL   115
0B2A:  MOVLB  02
0B2B:  MOVF   44,W
0B2C:  MOVWF  46
0B2D:  MOVLW  18
0B2E:  MOVWF  47
0B2F:  MOVLB  00
0B30:  CALL   1EF
0B31:  MOVLW  20
0B32:  MOVLB  02
0B33:  MOVWF  4C
0B34:  MOVLB  00
0B35:  CALL   115
0B36:  MOVLB  02
0B37:  MOVF   41,W
0B38:  MOVWF  4C
0B39:  MOVLB  00
0B3A:  CALL   115
0B3B:  MOVLB  02
0B3C:  MOVF   45,W
0B3D:  MOVWF  46
0B3E:  MOVLW  18
0B3F:  MOVWF  47
0B40:  MOVLB  00
0B41:  CALL   1EF
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0B42:  MOVLB  02
0B43:  CLRF   46
0B44:  MOVLW  20
0B45:  MOVWF  48
0B46:  MOVLW  78
0B47:  MOVWF  47
0B48:  MOVLB  00
0B49:  CALL   18C
....................   printf("\n\r%s",LCD_str); 
0B4A:  MOVLW  0A
0B4B:  CLRWDT
0B4C:  BTFSS  11.4
0B4D:  GOTO   34B
0B4E:  MOVLB  03
0B4F:  MOVWF  1A
0B50:  MOVLW  0D
0B51:  CLRWDT
0B52:  MOVLB  00
0B53:  BTFSC  11.4
0B54:  GOTO   357
0B55:  MOVLB  03
0B56:  GOTO   351
0B57:  MOVLB  03
0B58:  MOVWF  1A
0B59:  MOVLW  20
0B5A:  MOVWF  05
0B5B:  MOVLW  78
0B5C:  MOVWF  04
0B5D:  MOVLB  00
0B5E:  CALL   256
....................  
.................... } // }}} 
0B5F:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
0FAE:  MOVLB  01
0FAF:  BTFSS  5F.5
0FB0:  GOTO   7BC
....................     printf("\n\n\rADMIN> "); 
0FB1:  MOVLW  49
0FB2:  MOVLB  03
0FB3:  MOVWF  11
0FB4:  MOVLW  04
0FB5:  MOVWF  12
0FB6:  MOVLP  00
0FB7:  MOVLB  00
0FB8:  CALL   4D3
0FB9:  MOVLP  08
....................   } else { 
0FBA:  GOTO   7C5
0FBB:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
0FBC:  MOVLW  4F
0FBD:  MOVLB  03
0FBE:  MOVWF  11
0FBF:  MOVLW  04
0FC0:  MOVWF  12
0FC1:  MOVLP  00
0FC2:  MOVLB  00
0FC3:  CALL   4D3
0FC4:  MOVLP  08
....................   } 
.................... } // }}} 
0FC5:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
04B9:  MOVLW  10
04BA:  MOVLB  01
04BB:  MOVWF  63
....................   for (x=0;x<char_num;x++) { 
04BC:  CLRF   62
04BD:  MOVF   63,W
04BE:  SUBWF  62,W
04BF:  BTFSC  03.0
04C0:  GOTO   4CB
....................     sBuffer[x]='\0'; 
04C1:  MOVLW  50
04C2:  ADDWF  62,W
04C3:  MOVWF  04
04C4:  MOVLW  20
04C5:  MOVWF  05
04C6:  BTFSC  03.0
04C7:  INCF   05,F
04C8:  CLRF   00
....................   } 
04C9:  INCF   62,F
04CA:  GOTO   4BD
....................   sBufferIndex=0; 
04CB:  CLRF   75
....................   sBufferFlag=0;   
04CC:  BCF    76.0
....................   argument=-1; 
04CD:  MOVLW  FF
04CE:  MOVWF  40
....................   argument_name[0]='\0'; 
04CF:  CLRF   42
....................   command=0; 
04D0:  CLRF   70
.................... } // }}} 
04D1:  MOVLB  00
04D2:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
0656:  MOVLW  00
0657:  MOVLB  01
0658:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
0659:  MOVLB  02
065A:  BCF    41.0
065B:  MOVF   3F,W
065C:  ANDLW  0F
065D:  ANDLW  01
065E:  BTFSS  03.2
065F:  BSF    41.0
....................   output_bit(DTMF_D0,dbit); 
0660:  BTFSC  41.0
0661:  GOTO   664
0662:  BCF    0F.0
0663:  GOTO   665
0664:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
0665:  BCF    41.0
0666:  MOVF   3F,W
0667:  ANDLW  0F
0668:  ANDLW  02
0669:  BTFSS  03.2
066A:  BSF    41.0
....................   output_bit(DTMF_D1,dbit); 
066B:  BTFSC  41.0
066C:  GOTO   66F
066D:  BCF    0F.1
066E:  GOTO   670
066F:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
0670:  BCF    41.0
0671:  MOVF   3F,W
0672:  ANDLW  0F
0673:  ANDLW  04
0674:  BTFSS  03.2
0675:  BSF    41.0
....................   output_bit(DTMF_D2,dbit); 
0676:  BTFSC  41.0
0677:  GOTO   67A
0678:  BCF    0F.2
0679:  GOTO   67B
067A:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
067B:  BCF    41.0
067C:  MOVF   3F,W
067D:  ANDLW  0F
067E:  ANDLW  08
067F:  BTFSS  03.2
0680:  BSF    41.0
....................   output_bit(DTMF_D3,dbit); 
0681:  BTFSC  41.0
0682:  GOTO   685
0683:  BCF    0F.3
0684:  GOTO   686
0685:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
0686:  MOVF   40,F
0687:  BTFSS  03.2
0688:  GOTO   68B
0689:  BCF    0F.6
068A:  GOTO   68C
068B:  BSF    0F.6
....................   delay_cycles(2); 
068C:  GOTO   68D
....................   output_bit(DTMF_WEB,0); 
068D:  BCF    0F.5
....................   delay_cycles(2); 
068E:  GOTO   68F
....................   output_bit(DTMF_WEB,1);   
068F:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
0690:  GOTO   691
....................   set_tris_d(0x0F); 
0691:  MOVLW  0F
0692:  MOVLB  01
0693:  MOVWF  0F
.................... } // }}} 
0694:  MOVLB  00
0695:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
0696:  MOVLW  0F
0697:  MOVLB  01
0698:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
0699:  MOVLB  02
069A:  MOVF   37,F
069B:  BTFSS  03.2
069C:  GOTO   69F
069D:  BCF    0F.6
069E:  GOTO   6A0
069F:  BSF    0F.6
....................   delay_cycles(1); 
06A0:  NOP
....................   output_bit(DTMF_REB,0); 
06A1:  BCF    0F.4
....................   delay_cycles(1); 
06A2:  NOP
....................   value=input_d(); 
06A3:  MOVLB  00
06A4:  MOVF   0F,W
06A5:  MOVLB  02
06A6:  MOVWF  38
....................   value&=0x0F; 
06A7:  MOVLW  0F
06A8:  ANDWF  38,F
....................   output_bit(DTMF_REB,1); 
06A9:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
06AA:  NOP
....................   return(value); 
06AB:  MOVF   38,W
06AC:  MOVWF  78
.................... } // }}} 
06AD:  MOVLB  00
06AE:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0CEF:  MOVLB  02
0CF0:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0CF1:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0CF2:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0CF3:  CLRF   3F
0CF4:  MOVLW  01
0CF5:  MOVWF  40
0CF6:  MOVLP  00
0CF7:  MOVLB  00
0CF8:  CALL   656
0CF9:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0CFA:  MOVLB  02
0CFB:  CLRF   3F
0CFC:  MOVLW  01
0CFD:  MOVWF  40
0CFE:  MOVLP  00
0CFF:  MOVLB  00
0D00:  CALL   656
0D01:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0D02:  MOVLW  0C
0D03:  MOVLB  02
0D04:  MOVWF  3F
0D05:  MOVLW  01
0D06:  MOVWF  40
0D07:  MOVLP  00
0D08:  MOVLB  00
0D09:  CALL   656
0D0A:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0D0B:  MOVLW  01
0D0C:  MOVLB  02
0D0D:  MOVWF  3F
0D0E:  MOVWF  40
0D0F:  MOVLP  00
0D10:  MOVLB  00
0D11:  CALL   656
0D12:  MOVLP  08
....................     dtmf_read(CONTROL_REG); 
0D13:  MOVLW  01
0D14:  MOVLB  02
0D15:  MOVWF  37
0D16:  MOVLP  00
0D17:  MOVLB  00
0D18:  CALL   696
0D19:  MOVLP  08
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19F3:  MOVF   3C,W
19F4:  MOVWF  3F
19F5:  CLRF   40
19F6:  MOVLP  00
19F7:  MOVLB  00
19F8:  CALL   656
19F9:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19FA:  MOVLW  0C
19FB:  MOVLB  02
19FC:  MOVWF  3F
19FD:  MOVLW  01
19FE:  MOVWF  40
19FF:  MOVLP  00
1A00:  MOVLB  00
1A01:  CALL   656
1A02:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
1A03:  MOVLW  01
1A04:  MOVLB  02
1A05:  MOVWF  3F
1A06:  MOVWF  40
1A07:  MOVLP  00
1A08:  MOVLB  00
1A09:  CALL   656
1A0A:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A0B:  MOVLW  05
1A0C:  MOVLB  02
1A0D:  MOVWF  3F
1A0E:  MOVLW  01
1A0F:  MOVWF  40
1A10:  MOVLP  00
1A11:  MOVLB  00
1A12:  CALL   656
1A13:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A14:  MOVLB  01
1A15:  CLRF   33
1A16:  MOVLW  10
1A17:  MOVWF  32
....................   while(aux_timer) { 
1A18:  MOVF   32,W
1A19:  IORWF  33,W
1A1A:  BTFSC  03.2
1A1B:  GOTO   21E
....................     delay_cycles(1); 
1A1C:  NOP
....................   } 
1A1D:  GOTO   218
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A1E:  MOVLW  04
1A1F:  MOVLB  02
1A20:  MOVWF  3F
1A21:  MOVLW  01
1A22:  MOVWF  40
1A23:  MOVLP  00
1A24:  MOVLB  00
1A25:  CALL   656
1A26:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
082C:  MOVLW  01
082D:  MOVLB  02
082E:  MOVWF  3F
082F:  CLRF   40
0830:  MOVLP  00
0831:  MOVLB  00
0832:  CALL   656
0833:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0834:  MOVLW  0C
0835:  MOVLB  02
0836:  MOVWF  3F
0837:  MOVLW  01
0838:  MOVWF  40
0839:  MOVLP  00
083A:  MOVLB  00
083B:  CALL   656
083C:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
083D:  MOVLW  05
083E:  MOVLB  02
083F:  MOVWF  3F
0840:  MOVLW  01
0841:  MOVWF  40
0842:  MOVLP  00
0843:  MOVLB  00
0844:  CALL   656
0845:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0846:  MOVLW  05
0847:  MOVLB  02
0848:  MOVWF  3F
0849:  MOVLW  01
084A:  MOVWF  40
084B:  MOVLP  00
084C:  MOVLB  00
084D:  CALL   656
084E:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
084F:  MOVLB  01
0850:  CLRF   33
0851:  MOVLW  02
0852:  MOVWF  32
....................   while(aux_timer) { 
0853:  MOVF   32,W
0854:  IORWF  33,W
0855:  BTFSC  03.2
0856:  GOTO   059
....................     delay_cycles(1); 
0857:  NOP
....................   } 
0858:  GOTO   053
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0859:  MOVLW  04
085A:  MOVLB  02
085B:  MOVWF  3F
085C:  MOVLW  01
085D:  MOVWF  40
085E:  MOVLP  00
085F:  MOVLB  00
0860:  CALL   656
0861:  MOVLP  08
....................   restart_wdt(); 
0862:  CLRWDT
.................... } // }}} 
0863:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
0864:  MOVLW  01
0865:  MOVLB  02
0866:  MOVWF  3F
0867:  CLRF   40
0868:  MOVLP  00
0869:  MOVLB  00
086A:  CALL   656
086B:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
086C:  MOVLW  0C
086D:  MOVLB  02
086E:  MOVWF  3F
086F:  MOVLW  01
0870:  MOVWF  40
0871:  MOVLP  00
0872:  MOVLB  00
0873:  CALL   656
0874:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0875:  MOVLW  05
0876:  MOVLB  02
0877:  MOVWF  3F
0878:  MOVLW  01
0879:  MOVWF  40
087A:  MOVLP  00
087B:  MOVLB  00
087C:  CALL   656
087D:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
087E:  MOVLW  05
087F:  MOVLB  02
0880:  MOVWF  3F
0881:  MOVLW  01
0882:  MOVWF  40
0883:  MOVLP  00
0884:  MOVLB  00
0885:  CALL   656
0886:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
0887:  MOVLB  01
0888:  CLRF   33
0889:  MOVLW  06
088A:  MOVWF  32
....................   while(aux_timer) { 
088B:  MOVF   32,W
088C:  IORWF  33,W
088D:  BTFSC  03.2
088E:  GOTO   091
....................     delay_cycles(1); 
088F:  NOP
....................   } 
0890:  GOTO   08B
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0891:  MOVLW  04
0892:  MOVLB  02
0893:  MOVWF  3F
0894:  MOVLW  01
0895:  MOVWF  40
0896:  MOVLP  00
0897:  MOVLB  00
0898:  CALL   656
0899:  MOVLP  08
....................   restart_wdt(); 
089A:  CLRWDT
.................... } // }}} 
089B:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
0528:  MOVLB  02
0529:  MOVF   34,W
052A:  MOVWF  04
052B:  MOVF   35,W
052C:  MOVWF  05
052D:  MOVF   00,W
052E:  MOVWF  37
....................   if ( tmp > 127 ) { 
052F:  MOVF   37,W
0530:  SUBLW  7F
0531:  BTFSS  03.0
....................     tmp++; 
0532:  INCF   37,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
0533:  BCF    03.0
0534:  RLF    37,W
0535:  XORLW  09
0536:  ADDWF  36,W
0537:  MOVWF  37
....................   *cksum=tmp; 
0538:  MOVF   34,W
0539:  MOVWF  04
053A:  MOVF   35,W
053B:  MOVWF  05
053C:  MOVF   37,W
053D:  MOVWF  00
.................... } // }}} 
053E:  MOVLB  00
053F:  RETURN
.................... void print_dtmf_info(void) { // {{{ 
....................   unsigned int x; 
....................   char dtmf; 
....................   char tmp[5]; 
....................   strcpy(LCD_str,"DTMF:"); 
*
1737:  MOVLB  01
1738:  CLRF   69
1739:  CLRF   6A
173A:  MOVLW  20
173B:  MOVWF  05
173C:  MOVLW  78
173D:  MOVWF  04
173E:  MOVF   69,W
173F:  ADDWF  04,F
1740:  MOVLW  00
1741:  ADDWFC 05,F
1742:  MOVF   6A,W
1743:  MOVLP  00
1744:  MOVLB  00
1745:  CALL   139
1746:  MOVLP  10
1747:  MOVWF  00
1748:  IORLW  00
1749:  BTFSC  03.2
174A:  GOTO   750
174B:  MOVLB  01
174C:  INCF   6A,F
174D:  INCF   69,F
174E:  GOTO   73A
174F:  MOVLB  00
....................   printf("\n\rDTMF="); 
1750:  MOVLW  56
1751:  MOVLB  03
1752:  MOVWF  11
1753:  MOVLW  04
1754:  MOVWF  12
1755:  MOVLP  00
1756:  MOVLB  00
1757:  CALL   4D3
1758:  MOVLP  10
....................   for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1759:  MOVLB  01
175A:  CLRF   62
175B:  MOVF   62,W
175C:  SUBLW  09
175D:  BTFSS  03.0
175E:  GOTO   798
....................     if(DTMF_ARRAY[x].Strobe) { 
175F:  MOVLW  64
1760:  ADDWF  62,W
1761:  MOVWF  04
1762:  MOVLW  20
1763:  MOVWF  05
1764:  BTFSC  03.0
1765:  INCF   05,F
1766:  BTFSS  00.4
1767:  GOTO   795
....................       dtmf=(int)DTMF_ARRAY[x].Key; 
1768:  MOVLW  64
1769:  ADDWF  62,W
176A:  MOVWF  04
176B:  MOVLW  20
176C:  MOVWF  05
176D:  BTFSC  03.0
176E:  INCF   05,F
176F:  MOVF   00,W
1770:  ANDLW  0F
1771:  MOVWF  63
....................       sprintf(tmp,"%d",dtmf); 
1772:  MOVLW  20
1773:  MOVWF  61
1774:  MOVLW  94
1775:  MOVWF  60
1776:  MOVF   63,W
1777:  MOVLB  02
1778:  MOVWF  46
1779:  MOVLW  18
177A:  MOVWF  47
177B:  MOVLP  08
177C:  MOVLB  00
177D:  CALL   1EF
177E:  MOVLP  10
....................       strcat(LCD_str,tmp); 
177F:  MOVLW  20
1780:  MOVLB  02
1781:  MOVWF  26
1782:  MOVLW  78
1783:  MOVWF  25
1784:  MOVLW  20
1785:  MOVWF  28
1786:  MOVLW  94
1787:  MOVWF  27
1788:  MOVLB  00
1789:  CALL   6AC
....................       printf("%u",dtmf); 
178A:  MOVLB  01
178B:  MOVF   63,W
178C:  MOVLB  02
178D:  MOVWF  4C
178E:  MOVLW  1B
178F:  MOVWF  4D
1790:  MOVLP  00
1791:  MOVLB  00
1792:  CALL   738
1793:  MOVLP  10
1794:  MOVLB  01
....................     } 
....................   restart_wdt(); 
1795:  CLRWDT
....................   } 
1796:  INCF   62,F
1797:  GOTO   75B
....................   printf("\n\r"); 
1798:  MOVLW  0A
1799:  CLRWDT
179A:  MOVLB  00
179B:  BTFSC  11.4
179C:  GOTO   79F
179D:  MOVLB  01
179E:  GOTO   799
179F:  MOVLB  03
17A0:  MOVWF  1A
17A1:  MOVLW  0D
17A2:  CLRWDT
17A3:  MOVLB  00
17A4:  BTFSC  11.4
17A5:  GOTO   7A8
17A6:  MOVLB  03
17A7:  GOTO   7A2
17A8:  MOVLB  03
17A9:  MOVWF  1A
....................   PROMPT_FLAG=1; 
17AA:  MOVLB  01
17AB:  BSF    5F.4
....................   lcd_send(2,LCD_str); // Send DTMF on line 3 
17AC:  MOVLW  02
17AD:  MOVLB  02
17AE:  MOVWF  46
17AF:  MOVLW  20
17B0:  MOVWF  48
17B1:  MOVLW  78
17B2:  MOVWF  47
17B3:  MOVLP  08
17B4:  MOVLB  00
17B5:  CALL   18C
17B6:  MOVLP  10
.................... } // }}} 
17B7:  MOVLP  18
17B8:  GOTO   730 (RETURN)
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
*
0540:  MOVLW  01
0541:  MOVLB  02
0542:  MOVWF  2E
....................   eeprom_index=0; 
0543:  CLRF   2F
....................   retVal = 1; 
0544:  MOVWF  31
....................   if ( source == USE_EEPROM_VARS ) { 
0545:  DECFSZ 2A,W
0546:  GOTO   550
....................     printf("\n\rInit RAM <= EEPROM"); 
0547:  MOVLW  5A
0548:  MOVLB  03
0549:  MOVWF  11
054A:  MOVLW  04
054B:  MOVWF  12
054C:  MOVLB  00
054D:  CALL   4D3
....................   } else { 
054E:  GOTO   557
054F:  MOVLB  02
....................     printf("\n\rInit RAM <= HW Defaults"); 
0550:  MOVLW  65
0551:  MOVLB  03
0552:  MOVWF  11
0553:  MOVLW  04
0554:  MOVWF  12
0555:  MOVLB  00
0556:  CALL   4D3
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
0557:  MOVLB  02
0558:  CLRF   2B
0559:  MOVF   2B,W
055A:  SUBLW  38
055B:  BTFSS  03.0
055C:  GOTO   5B6
....................     regPtr=RegMap[x].reg_ptr; 
055D:  RLF    2B,W
055E:  MOVWF  77
055F:  RLF    77,F
0560:  MOVLW  FC
0561:  ANDWF  77,F
0562:  MOVF   77,W
0563:  MOVWF  33
0564:  INCF   33,W
0565:  MOVLB  00
0566:  CALL   043
0567:  MOVWF  7A
0568:  MOVLB  02
0569:  MOVF   33,W
056A:  MOVLB  00
056B:  CALL   043
056C:  MOVLB  02
056D:  MOVWF  2C
056E:  MOVF   7A,W
056F:  MOVWF  2D
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
0570:  DECFSZ 2A,W
0571:  GOTO   5A2
0572:  RLF    2B,W
0573:  MOVWF  77
0574:  RLF    77,F
0575:  MOVLW  FC
0576:  ANDWF  77,F
0577:  MOVF   77,W
0578:  ADDLW  03
0579:  MOVLB  00
057A:  CALL   043
057B:  MOVWF  78
057C:  BTFSC  78.0
057D:  GOTO   580
057E:  MOVLB  02
057F:  GOTO   5A2
....................       eeprom_val=read_eeprom(eeprom_index); 
0580:  MOVLB  02
0581:  MOVF   2F,W
0582:  MOVLB  03
0583:  MOVWF  11
0584:  BCF    15.7
0585:  BSF    15.0
0586:  MOVF   13,W
0587:  MOVLB  02
0588:  MOVWF  32
....................       *regPtr=eeprom_val; 
0589:  MOVF   2C,W
058A:  MOVWF  04
058B:  MOVF   2D,W
058C:  MOVWF  05
058D:  MOVF   32,W
058E:  MOVWF  00
....................       update_checksum(&cksum,*regPtr);     
058F:  MOVF   2D,W
0590:  MOVWF  7A
0591:  MOVF   2C,W
0592:  MOVWF  04
0593:  MOVF   2D,W
0594:  MOVWF  05
0595:  MOVF   00,W
0596:  MOVWF  33
0597:  MOVLW  20
0598:  MOVWF  35
0599:  MOVLW  AE
059A:  MOVWF  34
059B:  MOVF   33,W
059C:  MOVWF  36
059D:  MOVLB  00
059E:  CALL   528
....................       eeprom_index++; 
059F:  MOVLB  02
05A0:  INCF   2F,F
....................     } else { 
05A1:  GOTO   5B4
....................       default_value=(int8)RegMap[x].default_value; 
05A2:  RLF    2B,W
05A3:  MOVWF  77
05A4:  RLF    77,F
05A5:  MOVLW  FC
05A6:  ANDWF  77,F
05A7:  MOVF   77,W
05A8:  ADDLW  02
05A9:  MOVLB  00
05AA:  CALL   043
05AB:  MOVWF  78
05AC:  MOVLB  02
05AD:  MOVWF  30
....................       *regPtr=default_value; 
05AE:  MOVF   2C,W
05AF:  MOVWF  04
05B0:  MOVF   2D,W
05B1:  MOVWF  05
05B2:  MOVF   30,W
05B3:  MOVWF  00
....................     } 
....................   } 
05B4:  INCF   2B,F
05B5:  GOTO   559
....................   if ( source == USE_EEPROM_VARS ) { 
05B6:  DECFSZ 2A,W
05B7:  GOTO   5C2
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
05B8:  MOVF   2F,W
05B9:  MOVLB  03
05BA:  MOVWF  11
05BB:  BCF    15.7
05BC:  BSF    15.0
05BD:  MOVF   13,W
05BE:  MOVLB  02
05BF:  SUBWF  2E,W
05C0:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
05C1:  CLRF   31
....................     } 
....................   } 
....................   return (retVal); 
05C2:  MOVF   31,W
05C3:  MOVWF  78
.................... } // }}} 
05C4:  MOVLB  00
05C5:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
05C6:  MOVLW  01
05C7:  MOVLB  02
05C8:  MOVWF  2E
....................  
....................   eeprom_index=0; 
05C9:  CLRF   2B
....................   for(x=0;x<RegMapNum;x++) { 
05CA:  CLRF   2A
05CB:  MOVF   2A,W
05CC:  SUBLW  38
05CD:  BTFSS  03.0
05CE:  GOTO   624
....................     regPtr=RegMap[x].reg_ptr; 
05CF:  RLF    2A,W
05D0:  MOVWF  77
05D1:  RLF    77,F
05D2:  MOVLW  FC
05D3:  ANDWF  77,F
05D4:  MOVF   77,W
05D5:  MOVWF  30
05D6:  INCF   30,W
05D7:  MOVLB  00
05D8:  CALL   043
05D9:  MOVWF  7A
05DA:  MOVLB  02
05DB:  MOVF   30,W
05DC:  MOVLB  00
05DD:  CALL   043
05DE:  MOVLB  02
05DF:  MOVWF  2C
05E0:  MOVF   7A,W
05E1:  MOVWF  2D
....................     if ( RegMap[x].non_volatile ) { 
05E2:  RLF    2A,W
05E3:  MOVWF  77
05E4:  RLF    77,F
05E5:  MOVLW  FC
05E6:  ANDWF  77,F
05E7:  MOVF   77,W
05E8:  ADDLW  03
05E9:  MOVLB  00
05EA:  CALL   043
05EB:  MOVWF  78
05EC:  BTFSS  78.0
05ED:  GOTO   621
....................      value=*regPtr; 
05EE:  MOVLB  02
05EF:  MOVF   2C,W
05F0:  MOVWF  04
05F1:  MOVF   2D,W
05F2:  MOVWF  05
05F3:  MOVF   00,W
05F4:  MOVWF  2F
....................      if ( read_eeprom(eeprom_index) != value ) { 
05F5:  MOVF   2B,W
05F6:  MOVLB  03
05F7:  MOVWF  11
05F8:  BCF    15.7
05F9:  BSF    15.0
05FA:  MOVF   13,W
05FB:  MOVLB  02
05FC:  SUBWF  2F,W
05FD:  BTFSC  03.2
05FE:  GOTO   616
....................        write_eeprom(eeprom_index,value); 
05FF:  MOVF   0B,W
0600:  MOVWF  77
0601:  BCF    0B.7
0602:  MOVF   2B,W
0603:  MOVLB  03
0604:  MOVWF  11
0605:  MOVLB  02
0606:  MOVF   2F,W
0607:  MOVLB  03
0608:  MOVWF  13
0609:  BCF    15.7
060A:  BSF    15.2
060B:  MOVLW  55
060C:  MOVWF  16
060D:  MOVLW  AA
060E:  MOVWF  16
060F:  BSF    15.1
0610:  BTFSC  15.1
0611:  GOTO   610
0612:  BCF    15.2
0613:  MOVF   77,W
0614:  IORWF  0B,F
0615:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
0616:  MOVLW  20
0617:  MOVWF  35
0618:  MOVLW  AE
0619:  MOVWF  34
061A:  MOVF   2F,W
061B:  MOVWF  36
061C:  MOVLB  00
061D:  CALL   528
....................      eeprom_index++; 
061E:  MOVLB  02
061F:  INCF   2B,F
0620:  MOVLB  00
....................     } 
....................   } 
0621:  MOVLB  02
0622:  INCF   2A,F
0623:  GOTO   5CB
....................   write_eeprom(eeprom_index,cksum); 
0624:  MOVF   0B,W
0625:  MOVWF  77
0626:  BCF    0B.7
0627:  MOVF   2B,W
0628:  MOVLB  03
0629:  MOVWF  11
062A:  MOVLB  02
062B:  MOVF   2E,W
062C:  MOVLB  03
062D:  MOVWF  13
062E:  BCF    15.7
062F:  BSF    15.2
0630:  MOVLW  55
0631:  MOVWF  16
0632:  MOVLW  AA
0633:  MOVWF  16
0634:  BSF    15.1
0635:  BTFSC  15.1
0636:  GOTO   635
0637:  BCF    15.2
0638:  MOVF   77,W
0639:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
063A:  MOVLW  72
063B:  MOVWF  11
063C:  MOVLW  04
063D:  MOVWF  12
063E:  MOVLB  00
063F:  CALL   4D3
.................... } // }}} 
0640:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
0641:  MOVLB  02
0642:  MOVF   29,W
0643:  MOVWF  2A
0644:  MOVLB  00
0645:  CALL   540
0646:  MOVF   78,F
0647:  BTFSS  03.2
0648:  GOTO   655
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
0649:  MOVLW  85
064A:  MOVLB  03
064B:  MOVWF  11
064C:  MOVLW  04
064D:  MOVWF  12
064E:  MOVLB  00
064F:  CALL   4D3
....................         _init_variables(USE_DEFAULT_VARS); 
0650:  MOVLB  02
0651:  CLRF   2A
0652:  MOVLB  00
0653:  CALL   540
....................     store_variables(); 
0654:  CALL   5C6
....................     } 
.................... } // }}} 
0655:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0D2E:  MOVLB  02
0D2F:  CLRF   3B
0D30:  CLRF   3C
0D31:  MOVLP  00
0D32:  MOVLB  00
0D33:  CALL   787
0D34:  MOVLP  08
....................   set_trimpot(1,0); 
0D35:  MOVLW  01
0D36:  MOVLB  02
0D37:  MOVWF  3B
0D38:  CLRF   3C
0D39:  MOVLP  00
0D3A:  MOVLB  00
0D3B:  CALL   787
0D3C:  MOVLP  08
....................   set_trimpot(2,0); 
0D3D:  MOVLW  02
0D3E:  MOVLB  02
0D3F:  MOVWF  3B
0D40:  CLRF   3C
0D41:  MOVLP  00
0D42:  MOVLB  00
0D43:  CALL   787
0D44:  MOVLP  08
....................   set_trimpot(3,0); 
0D45:  MOVLW  03
0D46:  MOVLB  02
0D47:  MOVWF  3B
0D48:  CLRF   3C
0D49:  MOVLP  00
0D4A:  MOVLB  00
0D4B:  CALL   787
0D4C:  MOVLP  08
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0CB5:  MOVLP  00
0CB6:  CALL   4B9
0CB7:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0CB8:  MOVLB  02
0CB9:  CLRF   12
0CBA:  CLRF   11
0CBB:  CLRF   14
0CBC:  CLRF   13
....................   setup_wdt(WDT_2S); 
0CBD:  MOVLW  17
0CBE:  MOVLB  01
0CBF:  MOVWF  17
....................   COR_IN=0; 
0CC0:  MOVLB  00
0CC1:  CLRF   5F
....................   COR_EMUL=0; 
0CC2:  CLRF   6C
....................   COR_AUX=0; 
0CC3:  CLRF   6D
....................   COR_DROP_FLAG=0; 
0CC4:  BCF    76.5
....................   DTMF_IN_FLAG=0; 
0CC5:  MOVLB  01
0CC6:  BCF    5F.1
....................   DTMF_INTERRUPT_FLAG=0; 
0CC7:  BCF    5F.2
....................   TOT_FLAG_Mask=0; 
0CC8:  MOVLB  00
0CC9:  CLRF   67
....................   AuxOutDelayCnt=0; 
0CCA:  CLRF   7E
....................   CurrentCorMask=0; 
0CCB:  CLRF   71
....................   CurrentCorPriority=0; 
0CCC:  CLRF   73
....................   CurrentCorIndex=0; 
0CCD:  CLRF   72
....................   CurrentTrimPot=0; 
0CCE:  CLRF   7D
....................   setup_adc(NO_ANALOGS); 
0CCF:  MOVLB  01
0CD0:  BCF    1D.0
....................   set_tris_b(0xFF); 
0CD1:  MOVLW  FF
0CD2:  TRIS   6
....................   set_tris_d(0x00); 
0CD3:  MOVLW  00
0CD4:  MOVWF  0F
....................   set_tris_e(0xF8); 
0CD5:  BCF    10.0
0CD6:  BCF    10.1
0CD7:  BCF    10.2
0CD8:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0CD9:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0CDA:  BSF    0B.3
0CDB:  MOVLW  CF
0CDC:  MOVLB  07
0CDD:  IORWF  14,F
0CDE:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0CDF:  BSF    0B.3
0CE0:  BSF    15.4
0CE1:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0CE2:  MOVLW  C0
0CE3:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0CE4:  MOVLB  02
0CE5:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0CE6:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0CE7:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0CE8:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0CE9:  MOVLW  01
0CEA:  MOVWF  29
0CEB:  MOVLP  00
0CEC:  MOVLB  00
0CED:  CALL   641
0CEE:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D1A:  MOVLB  01
0D1B:  BSF    5F.3
....................   Enable_Mask = 0x0F; 
0D1C:  MOVLW  0F
0D1D:  MOVLB  00
0D1E:  MOVWF  61
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D1F:  MOVF   62,W
0D20:  ANDLW  0F
0D21:  IORLW  C0
0D22:  MOVLB  04
0D23:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D24:  MOVLB  01
0D25:  BCF    15.7
....................   // }}} 
....................   header(); 
0D26:  MOVLP  00
0D27:  MOVLB  00
0D28:  CALL   003
0D29:  MOVLP  08
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D2A:  MOVLW  9D
0D2B:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0D2C:  MOVLW  80
0D2D:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0D4D:  MOVLB  01
0D4E:  CLRF   31
0D4F:  MOVLW  1E
0D50:  MOVWF  30
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0D51:  MOVF   15,W
0D52:  ANDLW  C0
0D53:  IORLW  07
0D54:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0D55:  BSF    0B.5
....................   update_ptt(0); 
0D56:  MOVLB  02
0D57:  CLRF   2A
0D58:  MOVLB  00
0D59:  CALL   360
....................   MinuteCounter=MIN_COUNTER; 
0D5A:  MOVLW  1D
0D5B:  MOVLB  01
0D5C:  MOVWF  5E
....................   SecondCounter=SEC_COUNTER; 
0D5D:  MOVLW  3B
0D5E:  MOVWF  5D
....................   THIRTY_MIN_FLAG=0; 
0D5F:  BCF    76.4
....................   MINUTE_FLAG=0; 
0D60:  BCF    76.3
....................   PROMPT_FLAG=1; 
0D61:  BSF    5F.4
....................   TailChar=Tail; 
0D62:  MOVLB  00
0D63:  MOVF   65,W
0D64:  MOVWF  6E
....................   ConfirmChar=0; 
0D65:  CLRF   6F
....................   //AuxOut[0] = PO_AUX_OUT0; 
....................   //AuxOut[1] = PO_AUX_OUT1; 
....................   //AuxOut[2] = PO_AUX_OUT2; 
....................   AuxInSW[0] = 0; 
0D66:  CLRF   3F
....................   AuxInSW[1] = 0; 
0D67:  CLRF   40
....................   AuxInSW[2] = 0; 
0D68:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0D69:  BCF    76.6
....................   COR_IN_EFFECTIVE=0; 
0D6A:  CLRF   74
....................   set_admin_mode(0); 
0D6B:  MOVLB  02
0D6C:  CLRF   3C
0D6D:  MOVLB  00
0D6E:  CALL   49E
....................   rs232_mode=0; 
0D6F:  MOVLB  01
0D70:  BCF    5F.6
.................... #ifdef LCD_TYPE_PI 
....................   init_lcd(); 
.................... #endif 
.................... } // }}} 
0D71:  MOVLP  18
0D72:  MOVLB  00
0D73:  GOTO   701 (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180E:  MOVLB  02
180F:  BCF    24.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
1810:  CLRF   3B
1811:  CLRF   3C
1812:  MOVLW  20
1813:  MOVWF  05
1814:  MOVLW  A7
1815:  MOVWF  04
1816:  MOVF   3B,W
1817:  ADDWF  04,F
1818:  MOVLW  00
1819:  ADDWFC 05,F
181A:  MOVF   3C,W
181B:  MOVLP  00
181C:  MOVLB  00
181D:  CALL   140
181E:  MOVLP  18
181F:  MOVWF  00
1820:  IORLW  00
1821:  BTFSC  03.2
1822:  GOTO   028
1823:  MOVLB  02
1824:  INCF   3C,F
1825:  INCF   3B,F
1826:  GOTO   012
1827:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1828:  MOVLW  20
1829:  MOVLB  02
182A:  MOVWF  3C
182B:  MOVLW  50
182C:  MOVWF  3B
182D:  MOVLW  20
182E:  MOVWF  3E
182F:  MOVLW  A7
1830:  MOVWF  3D
1831:  MOVLP  08
1832:  MOVLB  00
1833:  CALL   574
1834:  MOVLP  18
1835:  MOVF   79,W
1836:  MOVLB  02
1837:  MOVWF  26
1838:  MOVF   78,W
1839:  MOVWF  25
....................   if (sptr!=0) {; 
183A:  MOVF   25,F
183B:  BTFSS  03.2
183C:  GOTO   040
183D:  MOVF   26,F
183E:  BTFSC  03.2
183F:  GOTO   05A
....................     strcpy(verb,sptr); 
1840:  MOVF   26,W
1841:  MOVWF  3E
1842:  MOVF   25,W
1843:  MOVWF  3D
1844:  MOVLW  20
1845:  MOVWF  3C
1846:  MOVLW  9C
1847:  MOVWF  3B
1848:  MOVF   3E,W
1849:  MOVWF  05
184A:  MOVF   3D,W
184B:  MOVWF  04
184C:  MOVF   00,W
184D:  MOVWF  3F
184E:  MOVF   3C,W
184F:  MOVWF  05
1850:  MOVF   3B,W
1851:  MOVWF  04
1852:  MOVF   3F,W
1853:  MOVWF  00
1854:  MOVF   00,F
1855:  BTFSC  03.2
1856:  GOTO   05A
1857:  INCF   3B,F
1858:  INCF   3D,F
1859:  GOTO   048
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
185A:  CLRF   3C
185B:  CLRF   3B
185C:  MOVLW  20
185D:  MOVWF  3E
185E:  MOVLW  A7
185F:  MOVWF  3D
1860:  MOVLP  08
1861:  MOVLB  00
1862:  CALL   574
1863:  MOVLP  18
1864:  MOVF   79,W
1865:  MOVLB  02
1866:  MOVWF  26
1867:  MOVF   78,W
1868:  MOVWF  25
....................   if (sptr!=0) {; 
1869:  MOVF   25,F
186A:  BTFSS  03.2
186B:  GOTO   06F
186C:  MOVF   26,F
186D:  BTFSC  03.2
186E:  GOTO   089
....................     strcpy(argument_name,sptr); 
186F:  MOVF   26,W
1870:  MOVWF  3E
1871:  MOVF   25,W
1872:  MOVWF  3D
1873:  MOVLW  20
1874:  MOVWF  3C
1875:  MOVLW  72
1876:  MOVWF  3B
1877:  MOVF   3E,W
1878:  MOVWF  05
1879:  MOVF   3D,W
187A:  MOVWF  04
187B:  MOVF   00,W
187C:  MOVWF  3F
187D:  MOVF   3C,W
187E:  MOVWF  05
187F:  MOVF   3B,W
1880:  MOVWF  04
1881:  MOVF   3F,W
1882:  MOVWF  00
1883:  MOVF   00,F
1884:  BTFSC  03.2
1885:  GOTO   089
1886:  INCF   3B,F
1887:  INCF   3D,F
1888:  GOTO   077
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1889:  CLRF   3C
188A:  CLRF   3B
188B:  MOVLW  20
188C:  MOVWF  3E
188D:  MOVLW  A7
188E:  MOVWF  3D
188F:  MOVLP  08
1890:  MOVLB  00
1891:  CALL   574
1892:  MOVLP  18
1893:  MOVF   79,W
1894:  MOVLB  02
1895:  MOVWF  26
1896:  MOVF   78,W
1897:  MOVWF  25
....................   if (sptr!=0) {; 
1898:  MOVF   25,F
1899:  BTFSS  03.2
189A:  GOTO   09E
189B:  MOVF   26,F
189C:  BTFSC  03.2
189D:  GOTO   0C5
....................     strcpy(match_val,sptr); 
189E:  MOVF   26,W
189F:  MOVWF  3E
18A0:  MOVF   25,W
18A1:  MOVWF  3D
18A2:  MOVLW  20
18A3:  MOVWF  3C
18A4:  MOVLW  AF
18A5:  MOVWF  3B
18A6:  MOVF   3E,W
18A7:  MOVWF  05
18A8:  MOVF   3D,W
18A9:  MOVWF  04
18AA:  MOVF   00,W
18AB:  MOVWF  3F
18AC:  MOVF   3C,W
18AD:  MOVWF  05
18AE:  MOVF   3B,W
18AF:  MOVWF  04
18B0:  MOVF   3F,W
18B1:  MOVWF  00
18B2:  MOVF   00,F
18B3:  BTFSC  03.2
18B4:  GOTO   0B8
18B5:  INCF   3B,F
18B6:  INCF   3D,F
18B7:  GOTO   0A6
....................     value = str_to_decimal(match_val); 
18B8:  MOVLW  20
18B9:  MOVWF  3C
18BA:  MOVLW  AF
18BB:  MOVWF  3B
18BC:  MOVLP  08
18BD:  MOVLB  00
18BE:  CALL   67A
18BF:  MOVLP  18
18C0:  MOVF   78,W
18C1:  MOVLB  01
18C2:  MOVWF  41
....................   } else { 
18C3:  GOTO   0CA
18C4:  MOVLB  02
....................     value = 0; 
18C5:  MOVLB  01
18C6:  CLRF   41
....................     do_get_var = 1; 
18C7:  MOVLB  02
18C8:  BSF    24.0
18C9:  MOVLB  01
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18CA:  MOVLB  02
18CB:  CLRF   3B
18CC:  CLRF   3C
18CD:  MOVLW  20
18CE:  MOVWF  05
18CF:  MOVLW  B3
18D0:  MOVWF  04
18D1:  MOVF   3B,W
18D2:  ADDWF  04,F
18D3:  MOVLW  00
18D4:  ADDWFC 05,F
18D5:  MOVF   3C,W
18D6:  MOVLP  00
18D7:  MOVLB  00
18D8:  CALL   146
18D9:  MOVLP  18
18DA:  MOVWF  00
18DB:  IORLW  00
18DC:  BTFSC  03.2
18DD:  GOTO   0E3
18DE:  MOVLB  02
18DF:  INCF   3C,F
18E0:  INCF   3B,F
18E1:  GOTO   0CD
18E2:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
18E3:  MOVLW  20
18E4:  MOVLB  02
18E5:  MOVWF  3C
18E6:  MOVLW  B3
18E7:  MOVWF  3B
18E8:  MOVLW  20
18E9:  MOVWF  3E
18EA:  MOVLW  9C
18EB:  MOVWF  3D
18EC:  MOVLP  08
18ED:  MOVLB  00
18EE:  CALL   6B3
18EF:  MOVLP  18
18F0:  MOVF   78,F
18F1:  BTFSS  03.2
18F2:  GOTO   0FC
....................     if ( do_get_var ) { 
18F3:  MOVLB  02
18F4:  BTFSS  24.0
18F5:  GOTO   0F9
....................       command=GET_REG; 
18F6:  MOVLW  03
18F7:  MOVWF  70
....................     } else { 
18F8:  GOTO   0FB
....................       command=SET_REG; 
18F9:  MOVLW  02
18FA:  MOVWF  70
18FB:  MOVLB  00
....................     } 
....................   } // }}} 
.................... #if __DEVICE__  == 1939 
....................   // Check for "setb" command {{{ 
....................   strcpy(smatch_reg,"setb");   
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
....................       command=SET_BIT; 
....................   } // }}} 
....................   // Check for "setb" command {{{ 
....................   strcpy(smatch_reg,"clrb");   
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
....................       command=CLEAR_BIT; 
....................   } // }}} 
.................... #endif 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18FC:  MOVLB  02
18FD:  CLRF   3B
18FE:  CLRF   3C
18FF:  MOVLW  20
1900:  MOVWF  05
1901:  MOVLW  B3
1902:  MOVWF  04
1903:  MOVF   3B,W
1904:  ADDWF  04,F
1905:  MOVLW  00
1906:  ADDWFC 05,F
1907:  MOVF   3C,W
1908:  MOVLP  00
1909:  MOVLB  00
190A:  CALL   14B
190B:  MOVLP  18
190C:  MOVWF  00
190D:  IORLW  00
190E:  BTFSC  03.2
190F:  GOTO   115
1910:  MOVLB  02
1911:  INCF   3C,F
1912:  INCF   3B,F
1913:  GOTO   0FF
1914:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1915:  MOVLW  20
1916:  MOVLB  02
1917:  MOVWF  3C
1918:  MOVLW  B3
1919:  MOVWF  3B
191A:  MOVLW  20
191B:  MOVWF  3E
191C:  MOVLW  9C
191D:  MOVWF  3D
191E:  MOVLP  08
191F:  MOVLB  00
1920:  CALL   6B3
1921:  MOVLP  18
1922:  MOVF   78,F
1923:  BTFSS  03.2
1924:  GOTO   127
....................       command=SAVE_SETTINGS; 
1925:  MOVLW  04
1926:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1927:  MOVLB  02
1928:  CLRF   3B
1929:  CLRF   3C
192A:  MOVLW  20
192B:  MOVWF  05
192C:  MOVLW  B3
192D:  MOVWF  04
192E:  MOVF   3B,W
192F:  ADDWF  04,F
1930:  MOVLW  00
1931:  ADDWFC 05,F
1932:  MOVF   3C,W
1933:  MOVLP  00
1934:  MOVLB  00
1935:  CALL   151
1936:  MOVLP  18
1937:  MOVWF  00
1938:  IORLW  00
1939:  BTFSC  03.2
193A:  GOTO   140
193B:  MOVLB  02
193C:  INCF   3C,F
193D:  INCF   3B,F
193E:  GOTO   12A
193F:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1940:  MOVLW  20
1941:  MOVLB  02
1942:  MOVWF  3C
1943:  MOVLW  B3
1944:  MOVWF  3B
1945:  MOVLW  20
1946:  MOVWF  3E
1947:  MOVLW  9C
1948:  MOVWF  3D
1949:  MOVLP  08
194A:  MOVLB  00
194B:  CALL   6B3
194C:  MOVLP  18
194D:  MOVF   78,F
194E:  BTFSS  03.2
194F:  GOTO   152
....................       command=RESTORE_SETTINGS; 
1950:  MOVLW  05
1951:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
1952:  MOVLB  02
1953:  CLRF   3B
1954:  CLRF   3C
1955:  MOVLW  20
1956:  MOVWF  05
1957:  MOVLW  B3
1958:  MOVWF  04
1959:  MOVF   3B,W
195A:  ADDWF  04,F
195B:  MOVLW  00
195C:  ADDWFC 05,F
195D:  MOVF   3C,W
195E:  MOVLP  00
195F:  MOVLB  00
1960:  CALL   15A
1961:  MOVLP  18
1962:  MOVWF  00
1963:  IORLW  00
1964:  BTFSC  03.2
1965:  GOTO   16B
1966:  MOVLB  02
1967:  INCF   3C,F
1968:  INCF   3B,F
1969:  GOTO   155
196A:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
196B:  MOVLW  20
196C:  MOVLB  02
196D:  MOVWF  3C
196E:  MOVLW  B3
196F:  MOVWF  3B
1970:  MOVLW  20
1971:  MOVWF  3E
1972:  MOVLW  9C
1973:  MOVWF  3D
1974:  MOVLP  08
1975:  MOVLB  00
1976:  CALL   6B3
1977:  MOVLP  18
1978:  MOVF   78,F
1979:  BTFSS  03.2
197A:  GOTO   17D
....................     command=STATUS; 
197B:  MOVLW  08
197C:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
197D:  MOVLB  02
197E:  CLRF   3B
197F:  CLRF   3C
1980:  MOVLW  20
1981:  MOVWF  05
1982:  MOVLW  B3
1983:  MOVWF  04
1984:  MOVF   3B,W
1985:  ADDWF  04,F
1986:  MOVLW  00
1987:  ADDWFC 05,F
1988:  MOVF   3C,W
1989:  MOVLP  00
198A:  MOVLB  00
198B:  CALL   162
198C:  MOVLP  18
198D:  MOVWF  00
198E:  IORLW  00
198F:  BTFSC  03.2
1990:  GOTO   196
1991:  MOVLB  02
1992:  INCF   3C,F
1993:  INCF   3B,F
1994:  GOTO   180
1995:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1996:  MOVLW  20
1997:  MOVLB  02
1998:  MOVWF  3C
1999:  MOVLW  B3
199A:  MOVWF  3B
199B:  MOVLW  20
199C:  MOVWF  3E
199D:  MOVLW  9C
199E:  MOVWF  3D
199F:  MOVLP  08
19A0:  MOVLB  00
19A1:  CALL   6B3
19A2:  MOVLP  18
19A3:  MOVF   78,F
19A4:  BTFSS  03.2
19A5:  GOTO   1AC
....................     command=ADMIN; 
19A6:  MOVLW  09
19A7:  MOVWF  70
....................     argument=REBOOT; 
19A8:  MOVLW  02
19A9:  MOVLB  01
19AA:  MOVWF  40
19AB:  MOVLB  00
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19AC:  MOVLB  02
19AD:  CLRF   3B
19AE:  CLRF   3C
19AF:  MOVLW  20
19B0:  MOVWF  05
19B1:  MOVLW  B3
19B2:  MOVWF  04
19B3:  MOVF   3B,W
19B4:  ADDWF  04,F
19B5:  MOVLW  00
19B6:  ADDWFC 05,F
19B7:  MOVF   3C,W
19B8:  MOVLP  00
19B9:  MOVLB  00
19BA:  CALL   16A
19BB:  MOVLP  18
19BC:  MOVWF  00
19BD:  IORLW  00
19BE:  BTFSC  03.2
19BF:  GOTO   1C5
19C0:  MOVLB  02
19C1:  INCF   3C,F
19C2:  INCF   3B,F
19C3:  GOTO   1AF
19C4:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19C5:  MOVLW  20
19C6:  MOVLB  02
19C7:  MOVWF  3C
19C8:  MOVLW  B3
19C9:  MOVWF  3B
19CA:  MOVLW  20
19CB:  MOVWF  3E
19CC:  MOVLW  9C
19CD:  MOVWF  3D
19CE:  MOVLP  08
19CF:  MOVLB  00
19D0:  CALL   6B3
19D1:  MOVLP  18
19D2:  MOVF   78,F
19D3:  BTFSS  03.2
19D4:  GOTO   227
....................     //command=DTMF_SEND; 
....................     command=0; 
19D5:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D6:  MOVLW  20
19D7:  MOVLB  02
19D8:  MOVWF  3C
19D9:  MOVLW  72
19DA:  MOVWF  3B
19DB:  MOVLP  08
19DC:  MOVLB  00
19DD:  CALL   67A
19DE:  MOVLP  18
19DF:  MOVF   78,W
19E0:  MOVLB  01
19E1:  MOVWF  41
....................     if ( value == d0 ) { 
19E2:  MOVF   41,W
19E3:  SUBLW  0A
19E4:  BTFSS  03.2
19E5:  GOTO   1E8
....................       value = dd; 
19E6:  CLRF   41
....................     } else if (value == dd) { 
19E7:  GOTO   1ED
19E8:  MOVF   41,F
19E9:  BTFSS  03.2
19EA:  GOTO   1ED
....................       value = d0; 
19EB:  MOVLW  0A
19EC:  MOVWF  41
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19ED:  MOVF   41,W
19EE:  ANDLW  0F
19EF:  MOVLB  02
19F0:  MOVWF  3B
19F1:  MOVF   3B,W
19F2:  MOVWF  3C
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A27:  MOVLB  02
1A28:  CLRF   3B
1A29:  CLRF   3C
1A2A:  MOVLW  20
1A2B:  MOVWF  05
1A2C:  MOVLW  B3
1A2D:  MOVWF  04
1A2E:  MOVF   3B,W
1A2F:  ADDWF  04,F
1A30:  MOVLW  00
1A31:  ADDWFC 05,F
1A32:  MOVF   3C,W
1A33:  MOVLP  00
1A34:  MOVLB  00
1A35:  CALL   16D
1A36:  MOVLP  18
1A37:  MOVWF  00
1A38:  IORLW  00
1A39:  BTFSC  03.2
1A3A:  GOTO   240
1A3B:  MOVLB  02
1A3C:  INCF   3C,F
1A3D:  INCF   3B,F
1A3E:  GOTO   22A
1A3F:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A40:  MOVLW  20
1A41:  MOVLB  02
1A42:  MOVWF  3C
1A43:  MOVLW  B3
1A44:  MOVWF  3B
1A45:  MOVLW  20
1A46:  MOVWF  3E
1A47:  MOVLW  9C
1A48:  MOVWF  3D
1A49:  MOVLP  08
1A4A:  MOVLB  00
1A4B:  CALL   6B3
1A4C:  MOVLP  18
1A4D:  MOVF   78,F
1A4E:  BTFSS  03.2
1A4F:  GOTO   252
....................     command=I2C_SEND; 
1A50:  MOVLW  0C
1A51:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A52:  MOVLB  02
1A53:  CLRF   3B
1A54:  CLRF   3C
1A55:  MOVLW  20
1A56:  MOVWF  05
1A57:  MOVLW  B3
1A58:  MOVWF  04
1A59:  MOVF   3B,W
1A5A:  ADDWF  04,F
1A5B:  MOVLW  00
1A5C:  ADDWFC 05,F
1A5D:  MOVF   3C,W
1A5E:  MOVLP  00
1A5F:  MOVLB  00
1A60:  CALL   172
1A61:  MOVLP  18
1A62:  MOVWF  00
1A63:  IORLW  00
1A64:  BTFSC  03.2
1A65:  GOTO   26B
1A66:  MOVLB  02
1A67:  INCF   3C,F
1A68:  INCF   3B,F
1A69:  GOTO   255
1A6A:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A6B:  MOVLW  20
1A6C:  MOVLB  02
1A6D:  MOVWF  3C
1A6E:  MOVLW  B3
1A6F:  MOVWF  3B
1A70:  MOVLW  20
1A71:  MOVWF  3E
1A72:  MOVLW  9C
1A73:  MOVWF  3D
1A74:  MOVLP  08
1A75:  MOVLB  00
1A76:  CALL   6B3
1A77:  MOVLP  18
1A78:  MOVF   78,F
1A79:  BTFSS  03.2
1A7A:  GOTO   294
....................     value = str_to_decimal(argument_name); 
1A7B:  MOVLW  20
1A7C:  MOVLB  02
1A7D:  MOVWF  3C
1A7E:  MOVLW  72
1A7F:  MOVWF  3B
1A80:  MOVLP  08
1A81:  MOVLB  00
1A82:  CALL   67A
1A83:  MOVLP  18
1A84:  MOVF   78,W
1A85:  MOVLB  01
1A86:  MOVWF  41
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A87:  MOVF   41,W
1A88:  SUBLW  24
1A89:  BTFSS  03.0
1A8A:  GOTO   28F
....................       argument = 0; 
1A8B:  CLRF   40
....................       command  = MORSE_SEND; 
1A8C:  MOVLW  0B
1A8D:  MOVWF  70
....................     } else { 
1A8E:  GOTO   293
....................       command  = ADMIN; 
1A8F:  MOVLW  09
1A90:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A91:  MOVLW  03
1A92:  MOVWF  40
1A93:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A94:  MOVLB  02
1A95:  CLRF   3B
1A96:  CLRF   3C
1A97:  MOVLW  20
1A98:  MOVWF  05
1A99:  MOVLW  B3
1A9A:  MOVWF  04
1A9B:  MOVF   3B,W
1A9C:  ADDWF  04,F
1A9D:  MOVLW  00
1A9E:  ADDWFC 05,F
1A9F:  MOVF   3C,W
1AA0:  MOVLP  00
1AA1:  MOVLB  00
1AA2:  CALL   179
1AA3:  MOVLP  18
1AA4:  MOVWF  00
1AA5:  IORLW  00
1AA6:  BTFSC  03.2
1AA7:  GOTO   2AD
1AA8:  MOVLB  02
1AA9:  INCF   3C,F
1AAA:  INCF   3B,F
1AAB:  GOTO   297
1AAC:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AAD:  MOVLW  20
1AAE:  MOVLB  02
1AAF:  MOVWF  3C
1AB0:  MOVLW  B3
1AB1:  MOVWF  3B
1AB2:  MOVLW  20
1AB3:  MOVWF  3E
1AB4:  MOVLW  9C
1AB5:  MOVWF  3D
1AB6:  MOVLP  08
1AB7:  MOVLB  00
1AB8:  CALL   6B3
1AB9:  MOVLP  18
1ABA:  MOVF   78,F
1ABB:  BTFSS  03.2
1ABC:  GOTO   2BF
....................     command=INCREMENT_REG; 
1ABD:  MOVLW  06
1ABE:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1ABF:  MOVLB  02
1AC0:  CLRF   3B
1AC1:  CLRF   3C
1AC2:  MOVLW  20
1AC3:  MOVWF  05
1AC4:  MOVLW  B3
1AC5:  MOVWF  04
1AC6:  MOVF   3B,W
1AC7:  ADDWF  04,F
1AC8:  MOVLW  00
1AC9:  ADDWFC 05,F
1ACA:  MOVF   3C,W
1ACB:  MOVLP  00
1ACC:  MOVLB  00
1ACD:  CALL   17C
1ACE:  MOVLP  18
1ACF:  MOVWF  00
1AD0:  IORLW  00
1AD1:  BTFSC  03.2
1AD2:  GOTO   2D8
1AD3:  MOVLB  02
1AD4:  INCF   3C,F
1AD5:  INCF   3B,F
1AD6:  GOTO   2C2
1AD7:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AD8:  MOVLW  20
1AD9:  MOVLB  02
1ADA:  MOVWF  3C
1ADB:  MOVLW  B3
1ADC:  MOVWF  3B
1ADD:  MOVLW  20
1ADE:  MOVWF  3E
1ADF:  MOVLW  9C
1AE0:  MOVWF  3D
1AE1:  MOVLP  08
1AE2:  MOVLB  00
1AE3:  CALL   6B3
1AE4:  MOVLP  18
1AE5:  MOVF   78,F
1AE6:  BTFSS  03.2
1AE7:  GOTO   2EA
....................     command=DECREMENT_REG; 
1AE8:  MOVLW  07
1AE9:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AEA:  MOVLB  02
1AEB:  CLRF   3B
1AEC:  CLRF   3C
1AED:  MOVLW  20
1AEE:  MOVWF  05
1AEF:  MOVLW  B3
1AF0:  MOVWF  04
1AF1:  MOVF   3B,W
1AF2:  ADDWF  04,F
1AF3:  MOVLW  00
1AF4:  ADDWFC 05,F
1AF5:  MOVF   3C,W
1AF6:  MOVLP  00
1AF7:  MOVLB  00
1AF8:  CALL   17F
1AF9:  MOVLP  18
1AFA:  MOVWF  00
1AFB:  IORLW  00
1AFC:  BTFSC  03.2
1AFD:  GOTO   303
1AFE:  MOVLB  02
1AFF:  INCF   3C,F
1B00:  INCF   3B,F
1B01:  GOTO   2ED
1B02:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B03:  MOVLW  20
1B04:  MOVLB  02
1B05:  MOVWF  3C
1B06:  MOVLW  B3
1B07:  MOVWF  3B
1B08:  MOVLW  20
1B09:  MOVWF  3E
1B0A:  MOVLW  9C
1B0B:  MOVWF  3D
1B0C:  MOVLP  08
1B0D:  MOVLB  00
1B0E:  CALL   6B3
1B0F:  MOVLP  18
1B10:  MOVF   78,F
1B11:  BTFSS  03.2
1B12:  GOTO   333
....................     command=SET_REG; 
1B13:  MOVLW  02
1B14:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B15:  MOVLW  01
1B16:  ADDWF  7D,W
1B17:  ANDLW  03
1B18:  MOVLB  01
1B19:  MOVWF  41
....................     strcpy(argument_name,"CPOT"); 
1B1A:  MOVLB  02
1B1B:  CLRF   3B
1B1C:  CLRF   3C
1B1D:  MOVLW  20
1B1E:  MOVWF  05
1B1F:  MOVLW  72
1B20:  MOVWF  04
1B21:  MOVF   3B,W
1B22:  ADDWF  04,F
1B23:  MOVLW  00
1B24:  ADDWFC 05,F
1B25:  MOVF   3C,W
1B26:  MOVLP  00
1B27:  MOVLB  00
1B28:  CALL   182
1B29:  MOVLP  18
1B2A:  MOVWF  00
1B2B:  IORLW  00
1B2C:  BTFSC  03.2
1B2D:  GOTO   333
1B2E:  MOVLB  02
1B2F:  INCF   3C,F
1B30:  INCF   3B,F
1B31:  GOTO   31D
1B32:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B33:  MOVLB  02
1B34:  CLRF   3B
1B35:  CLRF   3C
1B36:  MOVLW  20
1B37:  MOVWF  05
1B38:  MOVLW  B3
1B39:  MOVWF  04
1B3A:  MOVF   3B,W
1B3B:  ADDWF  04,F
1B3C:  MOVLW  00
1B3D:  ADDWFC 05,F
1B3E:  MOVF   3C,W
1B3F:  MOVLP  00
1B40:  MOVLB  00
1B41:  CALL   188
1B42:  MOVLP  18
1B43:  MOVWF  00
1B44:  IORLW  00
1B45:  BTFSC  03.2
1B46:  GOTO   34C
1B47:  MOVLB  02
1B48:  INCF   3C,F
1B49:  INCF   3B,F
1B4A:  GOTO   336
1B4B:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B4C:  MOVLW  20
1B4D:  MOVLB  02
1B4E:  MOVWF  3C
1B4F:  MOVLW  B3
1B50:  MOVWF  3B
1B51:  MOVLW  20
1B52:  MOVWF  3E
1B53:  MOVLW  9C
1B54:  MOVWF  3D
1B55:  MOVLP  08
1B56:  MOVLB  00
1B57:  CALL   6B3
1B58:  MOVLP  18
1B59:  MOVF   78,F
1B5A:  BTFSS  03.2
1B5B:  GOTO   36C
....................     AdminMode = ~AdminMode; 
1B5C:  MOVLW  20
1B5D:  MOVLB  01
1B5E:  XORWF  5F,F
....................     set_admin_mode(AdminMode); 
1B5F:  MOVLW  00
1B60:  BTFSC  5F.5
1B61:  MOVLW  01
1B62:  MOVLB  02
1B63:  MOVWF  3B
1B64:  MOVWF  3C
1B65:  MOVLP  08
1B66:  MOVLB  00
1B67:  CALL   49E
1B68:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B69:  MOVLB  01
1B6A:  BSF    5F.4
1B6B:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... #if __DEVICE__  == 1939 
.................... void set_bit (void) { // {{{ 
....................   int *pObj; 
....................     pObj=RegMap[argument].reg_ptr; 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
....................       *pObj=bit_set(*pObj,(value&0x1F)); 
....................     } 
....................     PROMPT_FLAG; 
.................... } // }}} 
.................... void clear_bit (void) { // {{{ 
....................   int *pObj; 
....................     pObj=RegMap[argument].reg_ptr; 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
....................       *pObj=bit_clear(*pObj,(value&0x1F)); 
....................     } 
....................     PROMPT_FLAG=1; 
.................... } // }}} 
.................... #endif 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
106D:  MOVLB  01
106E:  MOVF   41,W
106F:  SUBLW  FF
1070:  BTFSS  03.2
1071:  GOTO   09E
....................     printf ("\n\r%s %u",argument,value); 
1072:  MOVLW  0A
1073:  CLRWDT
1074:  MOVLB  00
1075:  BTFSC  11.4
1076:  GOTO   079
1077:  MOVLB  01
1078:  GOTO   073
1079:  MOVLB  03
107A:  MOVWF  1A
107B:  MOVLW  0D
107C:  CLRWDT
107D:  MOVLB  00
107E:  BTFSC  11.4
107F:  GOTO   082
1080:  MOVLB  03
1081:  GOTO   07C
1082:  MOVLB  03
1083:  MOVWF  1A
1084:  CLRF   05
1085:  MOVLB  01
1086:  MOVF   40,W
1087:  MOVWF  04
1088:  MOVLP  08
1089:  MOVLB  00
108A:  CALL   256
108B:  MOVLP  10
108C:  MOVLW  20
108D:  CLRWDT
108E:  BTFSS  11.4
108F:  GOTO   08D
1090:  MOVLB  03
1091:  MOVWF  1A
1092:  MOVLB  01
1093:  MOVF   41,W
1094:  MOVLB  02
1095:  MOVWF  4C
1096:  MOVLW  1B
1097:  MOVWF  4D
1098:  MOVLP  00
1099:  MOVLB  00
109A:  CALL   738
109B:  MOVLP  10
....................   } else { 
109C:  GOTO   142
109D:  MOVLB  01
....................     pObj=RegMap[argument].reg_ptr; 
109E:  RLF    40,W
109F:  MOVWF  77
10A0:  RLF    77,F
10A1:  MOVLW  FC
10A2:  ANDWF  77,F
10A3:  MOVF   77,W
10A4:  MOVLB  02
10A5:  MOVWF  2B
10A6:  INCF   2B,W
10A7:  MOVLP  00
10A8:  MOVLB  00
10A9:  CALL   043
10AA:  MOVLP  10
10AB:  MOVWF  7A
10AC:  MOVLB  02
10AD:  MOVF   2B,W
10AE:  MOVLP  00
10AF:  MOVLB  00
10B0:  CALL   043
10B1:  MOVLP  10
10B2:  MOVLB  02
10B3:  MOVWF  28
10B4:  MOVF   7A,W
10B5:  MOVWF  29
....................     // Consider allowing some registers to be updated outside AdminMode. 
....................     // Example : AuxOut registers, Enable 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
10B6:  MOVLP  08
10B7:  MOVLB  00
10B8:  CALL   71B
10B9:  MOVLP  10
10BA:  MOVF   78,F
10BB:  BTFSS  03.2
10BC:  GOTO   0CC
10BD:  MOVLB  01
10BE:  RLF    40,W
10BF:  MOVWF  77
10C0:  RLF    77,F
10C1:  MOVLW  FC
10C2:  ANDWF  77,F
10C3:  MOVF   77,W
10C4:  ADDLW  03
10C5:  MOVLP  00
10C6:  MOVLB  00
10C7:  CALL   043
10C8:  MOVLP  10
10C9:  MOVWF  78
10CA:  BTFSC  78.1
10CB:  GOTO   0D5
....................       *pObj=value; 
10CC:  MOVLB  02
10CD:  MOVF   28,W
10CE:  MOVWF  04
10CF:  MOVF   29,W
10D0:  MOVWF  05
10D1:  MOVLB  01
10D2:  MOVF   41,W
10D3:  MOVWF  00
10D4:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
10D5:  MOVLB  02
10D6:  MOVF   28,W
10D7:  MOVWF  04
10D8:  MOVF   29,W
10D9:  MOVWF  05
10DA:  MOVF   00,W
10DB:  MOVWF  2A
....................     printf ("\n\r%s(%u) <= %u",argument_name,argument,lVar); 
10DC:  MOVLW  0A
10DD:  CLRWDT
10DE:  MOVLB  00
10DF:  BTFSC  11.4
10E0:  GOTO   0E3
10E1:  MOVLB  02
10E2:  GOTO   0DD
10E3:  MOVLB  03
10E4:  MOVWF  1A
10E5:  MOVLW  0D
10E6:  CLRWDT
10E7:  MOVLB  00
10E8:  BTFSC  11.4
10E9:  GOTO   0EC
10EA:  MOVLB  03
10EB:  GOTO   0E6
10EC:  MOVLB  03
10ED:  MOVWF  1A
10EE:  MOVLW  20
10EF:  MOVWF  05
10F0:  MOVLW  72
10F1:  MOVWF  04
10F2:  MOVLP  08
10F3:  MOVLB  00
10F4:  CALL   256
10F5:  MOVLP  10
10F6:  MOVLW  28
10F7:  CLRWDT
10F8:  BTFSS  11.4
10F9:  GOTO   0F7
10FA:  MOVLB  03
10FB:  MOVWF  1A
10FC:  MOVLB  01
10FD:  MOVF   40,W
10FE:  MOVLB  02
10FF:  MOVWF  4C
1100:  MOVLW  1B
1101:  MOVWF  4D
1102:  MOVLP  00
1103:  MOVLB  00
1104:  CALL   738
1105:  MOVLP  10
1106:  MOVLW  A1
1107:  MOVLB  03
1108:  MOVWF  11
1109:  MOVLW  04
110A:  MOVWF  12
110B:  BSF    03.0
110C:  MOVLW  05
110D:  MOVLB  02
110E:  MOVWF  4C
110F:  MOVLP  00
1110:  MOVLB  00
1111:  CALL   6C4
1112:  MOVLP  10
1113:  MOVLB  02
1114:  MOVF   2A,W
1115:  MOVWF  4C
1116:  MOVLW  1B
1117:  MOVWF  4D
1118:  MOVLP  00
1119:  MOVLB  00
111A:  CALL   738
111B:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
111C:  MOVLB  02
111D:  MOVF   29,W
111E:  SUBLW  1F
111F:  BTFSC  03.0
1120:  GOTO   132
1121:  XORLW  FF
1122:  BTFSS  03.2
1123:  GOTO   128
1124:  MOVF   28,W
1125:  SUBLW  0B
1126:  BTFSC  03.0
1127:  GOTO   132
1128:  MOVF   29,W
1129:  SUBLW  20
112A:  BTFSS  03.0
112B:  GOTO   132
112C:  BTFSS  03.2
112D:  GOTO   139
112E:  MOVF   28,W
112F:  SUBLW  1B
1130:  BTFSC  03.0
1131:  GOTO   139
1132:  MOVF   28,W
1133:  SUBLW  7D
1134:  BTFSS  03.2
1135:  GOTO   13F
1136:  MOVF   29,F
1137:  BTFSS  03.2
1138:  GOTO   13F
....................       increment(0); // Increment is done in this function. Only update trim pot. 
1139:  CLRF   2B
113A:  MOVLP  08
113B:  MOVLB  00
113C:  CALL   72A
113D:  MOVLP  10
113E:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
113F:  MOVLB  01
1140:  BSF    5F.4
1141:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
0F2A:  MOVF   7D,W
0F2B:  ANDLW  03
0F2C:  MOVLB  02
0F2D:  MOVWF  2F
....................   if ( CurrentCorIndex ) { 
0F2E:  MOVF   72,F
0F2F:  BTFSC  03.2
0F30:  GOTO   768
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
0F31:  MOVLW  01
0F32:  SUBWF  72,W
0F33:  MOVWF  77
0F34:  RLF    77,F
0F35:  RLF    77,F
0F36:  MOVLW  FC
0F37:  ANDWF  77,F
0F38:  MOVF   77,W
0F39:  ADDWF  2F,W
0F3A:  ADDLW  0C
0F3B:  MOVWF  78
0F3C:  MOVLW  20
0F3D:  MOVWF  7A
0F3E:  BTFSC  03.0
0F3F:  INCF   7A,F
0F40:  MOVF   78,W
0F41:  MOVWF  2C
0F42:  MOVF   7A,W
0F43:  MOVWF  2D
....................     value = *pot_ptr; 
0F44:  MOVF   2C,W
0F45:  MOVWF  04
0F46:  MOVF   2D,W
0F47:  MOVWF  05
0F48:  MOVF   00,W
0F49:  MOVWF  2E
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
0F4A:  MOVF   2C,W
0F4B:  MOVWF  04
0F4C:  MOVF   2D,W
0F4D:  MOVWF  05
0F4E:  MOVF   2B,W
0F4F:  ADDWF  2E,W
0F50:  MOVWF  00
....................     if ( in_admin_mode() ) { 
0F51:  MOVLB  00
0F52:  CALL   71B
0F53:  MOVF   78,F
0F54:  BTFSC  03.2
0F55:  GOTO   767
....................       set_trimpot(CPotPtr,*pot_ptr); 
0F56:  MOVLB  02
0F57:  MOVF   2D,W
0F58:  MOVWF  7A
0F59:  MOVF   2C,W
0F5A:  MOVWF  04
0F5B:  MOVF   2D,W
0F5C:  MOVWF  05
0F5D:  MOVF   00,W
0F5E:  MOVWF  30
0F5F:  MOVF   2F,W
0F60:  MOVWF  3B
0F61:  MOVF   30,W
0F62:  MOVWF  3C
0F63:  MOVLP  00
0F64:  MOVLB  00
0F65:  CALL   787
0F66:  MOVLP  08
0F67:  MOVLB  02
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
0F68:  MOVLB  00
0F69:  CALL   270
.................... } // }}} 
0F6A:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
0EF2:  MOVLB  02
0EF3:  CLRF   3B
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
0EF4:  MOVF   3B,W
0EF5:  SUBLW  05
0EF6:  BTFSS  03.0
0EF7:  GOTO   719
....................     dest[c]=src[c]; 
0EF8:  MOVF   3B,W
0EF9:  ADDWF  37,W
0EFA:  MOVWF  78
0EFB:  MOVLW  00
0EFC:  ADDWFC 38,W
0EFD:  MOVWF  7A
0EFE:  MOVF   78,W
0EFF:  MOVWF  3C
0F00:  MOVF   7A,W
0F01:  MOVWF  3D
0F02:  MOVF   3B,W
0F03:  ADDWF  39,W
0F04:  MOVWF  78
0F05:  MOVLW  00
0F06:  ADDWFC 3A,W
0F07:  MOVWF  7A
0F08:  MOVF   78,W
0F09:  MOVLB  03
0F0A:  MOVWF  11
0F0B:  MOVF   7A,W
0F0C:  MOVWF  12
0F0D:  MOVLB  02
0F0E:  MOVF   3D,W
0F0F:  MOVWF  05
0F10:  MOVF   3C,W
0F11:  MOVWF  04
0F12:  MOVLW  01
0F13:  MOVWF  41
0F14:  MOVLB  00
0F15:  CALL   019
....................   c++; 
0F16:  MOVLB  02
0F17:  INCF   3B,F
....................   } 
0F18:  GOTO   6F4
.................... } // }}} 
0F19:  MOVLB  00
0F1A:  RETURN
.................... void ExecAuxOutOp(char op,char arg,char ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
1C77:  MOVF   26,W
1C78:  ANDLW  0F
1C79:  MOVWF  28
....................   uarg = (arg & 0xF0) >> 4; 
1C7A:  MOVF   26,W
1C7B:  ANDLW  F0
1C7C:  MOVWF  77
1C7D:  SWAPF  77,W
1C7E:  MOVWF  29
1C7F:  MOVLW  0F
1C80:  ANDWF  29,F
....................   switch(op) { 
1C81:  MOVF   25,W
1C82:  XORLW  02
1C83:  MOVLB  00
1C84:  BTFSC  03.2
1C85:  GOTO   48A
1C86:  XORLW  03
1C87:  BTFSC  03.2
1C88:  GOTO   4A4
1C89:  GOTO   4F1
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
1C8A:  MOVLW  22
1C8B:  MOVLB  02
1C8C:  ADDWF  27,W
1C8D:  MOVWF  04
1C8E:  MOVLW  20
1C8F:  MOVWF  05
1C90:  BTFSC  03.0
1C91:  INCF   05,F
1C92:  MOVF   28,W
1C93:  ANDLW  1F
1C94:  MOVWF  2D
1C95:  MOVF   7A,W
1C96:  MOVWF  2E
1C97:  MOVF   29,W
1C98:  XORWF  2D,F
1C99:  BTFSS  03.2
1C9A:  GOTO   4A0
1C9B:  MOVF   2E,F
1C9C:  BTFSS  03.2
1C9D:  GOTO   4A0
1C9E:  MOVLW  00
1C9F:  GOTO   4A1
1CA0:  MOVLW  01
1CA1:  MOVWF  00
....................     break; 
1CA2:  MOVLB  00
1CA3:  GOTO   4F1
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       int1 invert_output = (arg & AUX_OUT_FOLLOW_COR_INVERT_OUTPUT)!=0; 
....................       int1 cor_active = ((COR_IN_EFFECTIVE & ~TOT_FLAG_Mask & larg) != 0); 
....................       int1 disable_delay_en = ((arg & AUX_OUT_FOLLOW_COR_OFF_DELAY) !=0); 
....................       int1 enable_delay = ((arg & AUX_OUT_FOLLOW_COR_ON_DELAY) !=0); 
....................       int1 disable_delay = (disable_delay_en && (AuxOutDelayCnt != 0)); 
....................       int1 pin_value; 
1CA4:  MOVLB  02
1CA5:  BCF    2A.0
1CA6:  MOVF   26,W
1CA7:  ANDLW  10
1CA8:  BTFSS  03.2
1CA9:  BSF    2A.0
1CAA:  BCF    2A.1
1CAB:  MOVLB  00
1CAC:  MOVF   67,W
1CAD:  XORLW  FF
1CAE:  ANDWF  74,W
1CAF:  MOVLB  02
1CB0:  ANDWF  28,W
1CB1:  BTFSS  03.2
1CB2:  BSF    2A.1
1CB3:  BCF    2A.2
1CB4:  MOVF   26,W
1CB5:  ANDLW  20
1CB6:  BTFSS  03.2
1CB7:  BSF    2A.2
1CB8:  BCF    2A.3
1CB9:  MOVF   26,W
1CBA:  ANDLW  40
1CBB:  BTFSS  03.2
1CBC:  BSF    2A.3
1CBD:  BCF    2A.4
1CBE:  BTFSS  2A.2
1CBF:  GOTO   4C3
1CC0:  MOVF   7E,F
1CC1:  BTFSS  03.2
1CC2:  BSF    2A.4
....................       if ( cor_active ) { 
1CC3:  BTFSS  2A.1
1CC4:  GOTO   4DD
....................         // Activate output after several seconds of active QSO 
....................         // or keep the pin active if servicing a disable delay. 
....................         if (enable_delay) { 
1CC5:  BTFSS  2A.3
1CC6:  GOTO   4DB
....................           pin_value = (QSO_Duration > QSO_DURATION_DELAY) || disable_delay; 
1CC7:  BCF    2A.5
1CC8:  MOVLB  00
1CC9:  MOVF   69,F
1CCA:  BTFSS  03.2
1CCB:  GOTO   4D4
1CCC:  MOVF   68,W
1CCD:  SUBLW  05
1CCE:  BTFSS  03.0
1CCF:  GOTO   4D4
1CD0:  MOVLB  02
1CD1:  BTFSS  2A.4
1CD2:  GOTO   4D6
1CD3:  MOVLB  00
1CD4:  MOVLB  02
1CD5:  BSF    2A.5
....................           if ( pin_value ) { 
1CD6:  BTFSS  2A.5
1CD7:  GOTO   4DA
....................             AuxOutDelayCnt = 60; 
1CD8:  MOVLW  3C
1CD9:  MOVWF  7E
....................           } 
....................         } else { 
1CDA:  GOTO   4DC
....................           pin_value = 1; 
1CDB:  BSF    2A.5
....................         } 
....................       } else { 
1CDC:  GOTO   4E0
....................         pin_value = disable_delay; 
1CDD:  BCF    2A.5
1CDE:  BTFSC  2A.4
1CDF:  BSF    2A.5
....................       } 
....................       AuxOut[ID] = pin_value ^ invert_output; 
1CE0:  MOVLW  22
1CE1:  ADDWF  27,W
1CE2:  MOVWF  04
1CE3:  MOVLW  20
1CE4:  MOVWF  05
1CE5:  BTFSC  03.0
1CE6:  INCF   05,F
1CE7:  MOVLW  00
1CE8:  BTFSC  2A.5
1CE9:  MOVLW  01
1CEA:  MOVWF  2E
1CEB:  MOVLW  00
1CEC:  BTFSC  2A.0
1CED:  MOVLW  01
1CEE:  XORWF  2E,W
1CEF:  MOVWF  00
....................     break; 
1CF0:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0E7A:  MOVLB  02
0E7B:  CLRF   3D
0E7C:  CLRF   3E
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0E7D:  MOVF   3D,W
0E7E:  ADDWF  3B,W
0E7F:  MOVWF  04
0E80:  MOVLW  00
0E81:  ADDWFC 3C,W
0E82:  MOVWF  05
0E83:  MOVF   00,F
0E84:  BTFSC  03.2
0E85:  GOTO   6AF
0E86:  MOVF   3D,W
0E87:  ADDWF  3B,W
0E88:  MOVWF  04
0E89:  MOVLW  00
0E8A:  ADDWFC 3C,W
0E8B:  MOVWF  05
0E8C:  MOVF   00,W
0E8D:  SUBLW  2F
0E8E:  BTFSC  03.0
0E8F:  GOTO   6AF
0E90:  MOVF   3D,W
0E91:  ADDWF  3B,W
0E92:  MOVWF  04
0E93:  MOVLW  00
0E94:  ADDWFC 3C,W
0E95:  MOVWF  05
0E96:  MOVF   00,W
0E97:  SUBLW  39
0E98:  BTFSS  03.0
0E99:  GOTO   6AF
....................     value = (value * 10) + (str[x]-'0'); 
0E9A:  MOVF   3E,W
0E9B:  MOVWF  3F
0E9C:  MOVLW  0A
0E9D:  MOVWF  40
0E9E:  MOVLB  00
0E9F:  CALL   653
0EA0:  MOVF   78,W
0EA1:  MOVLB  02
0EA2:  MOVWF  3F
0EA3:  MOVF   3D,W
0EA4:  ADDWF  3B,W
0EA5:  MOVWF  04
0EA6:  MOVLW  00
0EA7:  ADDWFC 3C,W
0EA8:  MOVWF  05
0EA9:  MOVLW  30
0EAA:  SUBWF  00,W
0EAB:  ADDWF  3F,W
0EAC:  MOVWF  3E
....................     x++; 
0EAD:  INCF   3D,F
....................   } 
0EAE:  GOTO   67D
....................   return(value); 
0EAF:  MOVF   3E,W
0EB0:  MOVWF  78
.................... } // }}} 
0EB1:  MOVLB  00
0EB2:  RETURN
.................... void ExecAuxInOp(char op,char arg,char ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
163A:  MOVLB  02
163B:  BCF    28.0
163C:  MOVLW  1F
163D:  ADDWF  27,W
163E:  MOVWF  04
163F:  MOVLW  20
1640:  MOVWF  05
1641:  BTFSC  03.0
1642:  INCF   05,F
1643:  MOVF   00,F
1644:  BTFSS  03.2
1645:  BSF    28.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   // Include arg[4] for COR4 emulation 
....................   larg = arg & 0x1F; 
1646:  MOVF   26,W
1647:  ANDLW  1F
1648:  MOVWF  29
....................   uarg = (arg & 0xF0) >> 4; 
1649:  MOVF   26,W
164A:  ANDLW  F0
164B:  MOVWF  77
164C:  SWAPF  77,W
164D:  MOVWF  2A
164E:  MOVLW  0F
164F:  ANDWF  2A,F
....................   switch(op) { 
1650:  MOVLW  01
1651:  SUBWF  25,W
1652:  ADDLW  FC
1653:  BTFSC  03.0
1654:  GOTO   6A1
1655:  ADDLW  04
1656:  MOVLB  00
1657:  GOTO   6A4
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
1658:  MOVLB  02
1659:  BTFSS  28.0
165A:  GOTO   660
....................         Enable_Mask &= arg; 
165B:  MOVF   26,W
165C:  MOVLB  00
165D:  ANDWF  61,F
....................       } else { // AuxIn is not enabled 
165E:  GOTO   665
165F:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
1660:  MOVF   26,W
1661:  XORLW  FF
1662:  ANDLW  0F
1663:  MOVLB  00
1664:  IORWF  61,F
....................       } 
....................       break; 
1665:  MOVLB  02
1666:  GOTO   6A1
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
1667:  MOVLB  02
1668:  BTFSS  28.0
1669:  GOTO   670
....................         COR_DROP_FLAG=1; 
166A:  BSF    76.5
....................         TailChar=arg; 
166B:  MOVF   26,W
166C:  MOVLB  00
166D:  MOVWF  6E
....................       } else { 
166E:  GOTO   672
166F:  MOVLB  02
....................         TailChar=0; 
1670:  MOVLB  00
1671:  CLRF   6E
....................       } 
....................     break; 
1672:  MOVLB  02
1673:  GOTO   6A1
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
1674:  MOVLB  02
1675:  BTFSC  28.0
1676:  GOTO   67D
....................         COR_DROP_FLAG=1; 
1677:  BSF    76.5
....................         TailChar=arg; 
1678:  MOVF   26,W
1679:  MOVLB  00
167A:  MOVWF  6E
....................       } else { 
167B:  GOTO   67F
167C:  MOVLB  02
....................         TailChar=0; 
167D:  MOVLB  00
167E:  CLRF   6E
....................       } 
....................     break; 
167F:  MOVLB  02
1680:  GOTO   6A1
....................     case AUXI_EMULATE_COR: 
....................       int1 active_low = (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0; 
1681:  MOVLB  02
1682:  BCF    28.2
1683:  MOVF   26,W
1684:  ANDLW  20
1685:  BTFSS  03.2
1686:  BSF    28.2
....................       tmp_bit = (active_low ^ in_bit); 
1687:  MOVLW  00
1688:  BTFSC  28.2
1689:  MOVLW  01
168A:  MOVWF  2C
168B:  MOVLW  00
168C:  BTFSC  28.0
168D:  MOVLW  01
168E:  XORWF  2C,W
168F:  MOVWF  78
1690:  BCF    28.1
1691:  BTFSC  78.0
1692:  BSF    28.1
....................       if ( tmp_bit ) { 
1693:  BTFSS  28.1
1694:  GOTO   69A
....................         COR_AUX |= larg; 
1695:  MOVF   29,W
1696:  MOVLB  00
1697:  IORWF  6D,F
....................       } else { 
1698:  GOTO   69E
1699:  MOVLB  02
....................         COR_AUX &= ~larg; 
169A:  MOVF   29,W
169B:  XORLW  FF
169C:  MOVLB  00
169D:  ANDWF  6D,F
....................       } 
....................     break; 
169E:  MOVLB  02
169F:  GOTO   6A1
16A0:  MOVLB  02
....................   } 
.................... } // }}} 
16A1:  MOVLP  18
16A2:  MOVLB  00
16A3:  GOTO   563 (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
14E0:  MOVLB  01
14E1:  CLRF   62
14E2:  MOVF   62,W
14E3:  SUBLW  02
14E4:  BTFSS  03.0
14E5:  GOTO   527
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = ((input(AUX_IN_PIN[x])!=0 )|| (AuxIn[x]!=0)); 
14E6:  MOVLW  1F
14E7:  ADDWF  62,W
14E8:  MOVWF  78
14E9:  MOVLW  20
14EA:  MOVWF  7A
14EB:  BTFSC  03.0
14EC:  INCF   7A,F
14ED:  MOVF   78,W
14EE:  MOVWF  63
14EF:  MOVF   7A,W
14F0:  MOVWF  64
14F1:  MOVF   62,W
14F2:  MOVLP  00
14F3:  MOVLB  00
14F4:  CALL   03F
14F5:  MOVLP  10
14F6:  MOVLB  01
14F7:  MOVWF  65
14F8:  MOVLB  02
14F9:  MOVWF  3C
14FA:  MOVLW  01
14FB:  MOVWF  3D
14FC:  CLRF   3F
14FD:  MOVLW  80
14FE:  MOVWF  3E
14FF:  MOVLP  08
1500:  MOVLB  00
1501:  CALL   0F3
1502:  MOVLP  10
1503:  MOVLB  01
1504:  MOVF   65,W
1505:  MOVWF  66
1506:  CLRF   68
1507:  CLRF   67
1508:  MOVLB  00
1509:  GOTO   4C6
150A:  BTFSC  78.0
150B:  GOTO   51C
150C:  MOVLW  1C
150D:  MOVLB  01
150E:  ADDWF  62,W
150F:  MOVWF  04
1510:  MOVLW  20
1511:  MOVWF  05
1512:  BTFSC  03.0
1513:  INCF   05,F
1514:  MOVF   00,F
1515:  BTFSC  03.2
1516:  GOTO   519
1517:  MOVLB  00
1518:  GOTO   51C
1519:  MOVLW  00
151A:  GOTO   51E
151B:  MOVLB  00
151C:  MOVLW  01
151D:  MOVLB  01
151E:  MOVWF  66
151F:  MOVF   64,W
1520:  MOVWF  05
1521:  MOVF   63,W
1522:  MOVWF  04
1523:  MOVF   66,W
1524:  MOVWF  00
....................   } 
1525:  INCF   62,F
1526:  GOTO   4E2
.................... } // }}} 
1527:  MOVLP  18
1528:  MOVLB  00
1529:  GOTO   70F (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
1C3C:  MOVLW  30
1C3D:  MOVLB  01
1C3E:  MOVWF  65
1C3F:  MOVWF  66
1C40:  MOVWF  67
1C41:  CLRF   68
....................   char AuxOut_s[4]={'0','0','0',0}; 
1C42:  MOVWF  69
1C43:  MOVWF  6A
1C44:  MOVWF  6B
1C45:  CLRF   6C
....................   char ADM[]=" ADMIN"; 
1C46:  MOVLW  20
1C47:  MOVWF  6D
1C48:  MOVLW  41
1C49:  MOVWF  6E
1C4A:  MOVLW  44
1C4B:  MOVWF  6F
1C4C:  MOVLW  4D
1C4D:  MOVLB  02
1C4E:  MOVWF  20
1C4F:  MOVLW  49
1C50:  MOVWF  21
1C51:  MOVLW  4E
1C52:  MOVWF  22
1C53:  CLRF   23
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
1C54:  MOVLB  01
1C55:  CLRF   62
1C56:  MOVF   62,W
1C57:  SUBLW  02
1C58:  BTFSS  03.0
1C59:  GOTO   567
....................     AuxOp = AuxOutOp[x]; 
1C5A:  MOVLW  33
1C5B:  ADDWF  62,W
1C5C:  MOVWF  04
1C5D:  MOVLW  20
1C5E:  MOVWF  05
1C5F:  BTFSC  03.0
1C60:  INCF   05,F
1C61:  MOVF   00,W
1C62:  MOVWF  63
....................     AuxArg = AuxOutArg[x]; 
1C63:  MOVLW  36
1C64:  ADDWF  62,W
1C65:  MOVWF  04
1C66:  MOVLW  20
1C67:  MOVWF  05
1C68:  BTFSC  03.0
1C69:  INCF   05,F
1C6A:  MOVF   00,W
1C6B:  MOVWF  64
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
1C6C:  MOVF   63,W
1C6D:  MOVLB  02
1C6E:  MOVWF  25
1C6F:  MOVLB  01
1C70:  MOVF   64,W
1C71:  MOVLB  02
1C72:  MOVWF  26
1C73:  MOVLB  01
1C74:  MOVF   62,W
1C75:  MOVLB  02
1C76:  MOVWF  27
....................     out_bit = (AuxOut[x])==0; 
*
1CF1:  MOVLB  02
1CF2:  BCF    24.0
1CF3:  MOVLW  22
1CF4:  MOVLB  01
1CF5:  ADDWF  62,W
1CF6:  MOVWF  04
1CF7:  MOVLW  20
1CF8:  MOVWF  05
1CF9:  BTFSC  03.0
1CFA:  INCF   05,F
1CFB:  MOVF   00,F
1CFC:  BTFSS  03.2
1CFD:  GOTO   501
1CFE:  MOVLB  02
1CFF:  BSF    24.0
1D00:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
1D01:  MOVF   62,W
1D02:  MOVLP  00
1D03:  MOVLB  00
1D04:  CALL   03B
1D05:  MOVLP  18
1D06:  MOVLB  02
1D07:  MOVWF  25
1D08:  MOVLW  00
1D09:  BTFSC  24.0
1D0A:  MOVLW  01
1D0B:  MOVWF  77
1D0C:  MOVF   25,W
1D0D:  MOVWF  3C
1D0E:  MOVF   77,W
1D0F:  MOVWF  3D
1D10:  MOVLW  01
1D11:  MOVWF  3F
1D12:  CLRF   3E
1D13:  MOVLP  08
1D14:  MOVLB  00
1D15:  CALL   0F3
1D16:  MOVLP  18
1D17:  MOVLB  02
1D18:  MOVF   25,W
1D19:  MOVWF  3C
1D1A:  CLRF   3D
1D1B:  CLRF   3F
1D1C:  MOVLW  80
1D1D:  MOVWF  3E
1D1E:  MOVLP  08
1D1F:  MOVLB  00
1D20:  CALL   0F3
1D21:  MOVLP  18
....................     if(out_bit==0) { 
1D22:  MOVLB  02
1D23:  BTFSC  24.0
1D24:  GOTO   530
....................       AuxOut_s[x]='1'; 
1D25:  MOVLW  99
1D26:  MOVLB  01
1D27:  ADDWF  62,W
1D28:  MOVWF  04
1D29:  MOVLW  20
1D2A:  MOVWF  05
1D2B:  BTFSC  03.0
1D2C:  INCF   05,F
1D2D:  MOVLW  31
1D2E:  MOVWF  00
1D2F:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
1D30:  MOVLW  39
1D31:  MOVLB  01
1D32:  ADDWF  62,W
1D33:  MOVWF  04
1D34:  MOVLW  20
1D35:  MOVWF  05
1D36:  BTFSC  03.0
1D37:  INCF   05,F
1D38:  MOVF   00,W
1D39:  MOVWF  63
....................     AuxArg = AuxInArg[x]; 
1D3A:  MOVLW  3C
1D3B:  ADDWF  62,W
1D3C:  MOVWF  04
1D3D:  MOVLW  20
1D3E:  MOVWF  05
1D3F:  BTFSC  03.0
1D40:  INCF   05,F
1D41:  MOVF   00,W
1D42:  MOVWF  64
....................     if(AuxInSW[x]==1) { 
1D43:  MOVLW  1F
1D44:  ADDWF  62,W
1D45:  MOVWF  04
1D46:  MOVLW  20
1D47:  MOVWF  05
1D48:  BTFSC  03.0
1D49:  INCF   05,F
1D4A:  DECFSZ 00,W
1D4B:  GOTO   555
....................       AuxIn_s[x]='1'; 
1D4C:  MOVLW  95
1D4D:  ADDWF  62,W
1D4E:  MOVWF  04
1D4F:  MOVLW  20
1D50:  MOVWF  05
1D51:  BTFSC  03.0
1D52:  INCF   05,F
1D53:  MOVLW  31
1D54:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
1D55:  MOVF   63,W
1D56:  MOVLB  02
1D57:  MOVWF  25
1D58:  MOVLB  01
1D59:  MOVF   64,W
1D5A:  MOVLB  02
1D5B:  MOVWF  26
1D5C:  MOVLB  01
1D5D:  MOVF   62,W
1D5E:  MOVLB  02
1D5F:  MOVWF  27
1D60:  MOVLP  10
1D61:  MOVLB  00
1D62:  GOTO   63A
1D63:  MOVLP  18
....................     // }}} 
....................   } 
1D64:  MOVLB  01
1D65:  INCF   62,F
1D66:  GOTO   456
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
1D67:  MOVLW  20
1D68:  MOVWF  61
1D69:  MOVLW  78
1D6A:  MOVWF  60
1D6B:  MOVLW  49
1D6C:  MOVLB  02
1D6D:  MOVWF  4C
1D6E:  MOVLP  08
1D6F:  MOVLB  00
1D70:  CALL   115
1D71:  MOVLP  18
1D72:  MOVLW  3A
1D73:  MOVLB  02
1D74:  MOVWF  4C
1D75:  MOVLP  08
1D76:  MOVLB  00
1D77:  CALL   115
1D78:  MOVLP  18
1D79:  MOVLW  20
1D7A:  MOVWF  05
1D7B:  MOVLW  95
1D7C:  MOVWF  04
1D7D:  MOVLP  08
1D7E:  CALL   177
1D7F:  MOVLP  18
1D80:  MOVLW  20
1D81:  MOVLB  02
1D82:  MOVWF  4C
1D83:  MOVLP  08
1D84:  MOVLB  00
1D85:  CALL   115
1D86:  MOVLP  18
1D87:  MOVLW  4F
1D88:  MOVLB  02
1D89:  MOVWF  4C
1D8A:  MOVLP  08
1D8B:  MOVLB  00
1D8C:  CALL   115
1D8D:  MOVLP  18
1D8E:  MOVLW  3A
1D8F:  MOVLB  02
1D90:  MOVWF  4C
1D91:  MOVLP  08
1D92:  MOVLB  00
1D93:  CALL   115
1D94:  MOVLP  18
1D95:  MOVLW  20
1D96:  MOVWF  05
1D97:  MOVLW  99
1D98:  MOVWF  04
1D99:  MOVLP  08
1D9A:  CALL   177
1D9B:  MOVLP  18
....................   if ( AdminMode ) { 
1D9C:  MOVLB  01
1D9D:  BTFSS  5F.5
1D9E:  GOTO   5AD
....................     strcat(LCD_str,ADM); 
1D9F:  MOVLW  20
1DA0:  MOVLB  02
1DA1:  MOVWF  26
1DA2:  MOVLW  78
1DA3:  MOVWF  25
1DA4:  MOVLW  20
1DA5:  MOVWF  28
1DA6:  MOVLW  9D
1DA7:  MOVWF  27
1DA8:  MOVLP  10
1DA9:  MOVLB  00
1DAA:  CALL   6AC
1DAB:  MOVLP  18
1DAC:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
1DAD:  MOVLW  03
1DAE:  MOVLB  02
1DAF:  MOVWF  46
1DB0:  MOVLW  20
1DB1:  MOVWF  48
1DB2:  MOVLW  78
1DB3:  MOVWF  47
1DB4:  MOVLP  08
1DB5:  MOVLB  00
1DB6:  CALL   18C
1DB7:  MOVLP  18
.................... } // }}} 
1DB8:  MOVLP  18
1DB9:  GOTO   721 (RETURN)
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
0FC6:  MOVLW  01
0FC7:  MOVLB  02
0FC8:  MOVWF  2A
0FC9:  MOVLB  00
0FCA:  CALL   360
....................   delay_ms(1000); 
0FCB:  MOVLW  04
0FCC:  MOVLB  02
0FCD:  MOVWF  2A
0FCE:  MOVLW  FA
0FCF:  MOVWF  46
0FD0:  MOVLB  00
0FD1:  CALL   000
0FD2:  MOVLB  02
0FD3:  DECFSZ 2A,F
0FD4:  GOTO   7CE
....................   for(x=0;x<6;x++) { 
0FD5:  CLRF   28
0FD6:  MOVF   28,W
0FD7:  SUBLW  05
0FD8:  BTFSS  03.0
0FD9:  GOTO   7F4
....................     mchar=Morse[x]; 
0FDA:  MOVLW  2D
0FDB:  ADDWF  28,W
0FDC:  MOVWF  04
0FDD:  MOVLW  20
0FDE:  MOVWF  05
0FDF:  BTFSC  03.0
0FE0:  INCF   05,F
0FE1:  MOVF   00,W
0FE2:  MOVWF  29
....................     morse(mchar); 
0FE3:  MOVF   29,W
0FE4:  MOVWF  3B
0FE5:  MOVLB  00
0FE6:  CALL   09C
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
0FE7:  MOVLB  01
0FE8:  CLRF   33
0FE9:  MOVLW  06
0FEA:  MOVWF  32
....................     while(aux_timer) { 
0FEB:  MOVF   32,W
0FEC:  IORWF  33,W
0FED:  BTFSC  03.2
0FEE:  GOTO   7F1
....................       delay_cycles(1); 
0FEF:  NOP
....................     } 
0FF0:  GOTO   7EB
....................   } 
0FF1:  MOVLB  02
0FF2:  INCF   28,F
0FF3:  GOTO   7D6
....................   delay_ms(1000); 
0FF4:  MOVLW  04
0FF5:  MOVWF  2A
0FF6:  MOVLW  FA
0FF7:  MOVWF  46
0FF8:  MOVLB  00
0FF9:  CALL   000
0FFA:  MOVLB  02
0FFB:  DECFSZ 2A,F
0FFC:  GOTO   7F6
....................   COR_FLAG=1; 
0FFD:  BSF    76.1
.................... } // }}} 
0FFE:  MOVLB  00
0FFF:  RETURN
.................... void main (void) { // {{{ 
*
1ECE:  CLRF   05
1ECF:  CLRF   04
1ED0:  MOVLW  1F
1ED1:  ANDWF  03,F
1ED2:  MOVLW  72
1ED3:  MOVLB  01
1ED4:  MOVWF  19
1ED5:  BSF    0E.3
1ED6:  BSF    0E.4
1ED7:  MOVLB  04
1ED8:  BCF    17.0
1ED9:  BCF    17.1
1EDA:  BCF    17.3
1EDB:  MOVLW  13
1EDC:  MOVWF  12
1EDD:  MOVLW  28
1EDE:  MOVWF  15
1EDF:  BSF    14.7
1EE0:  BCF    14.6
1EE1:  MOVLW  0C
1EE2:  MOVLB  03
1EE3:  MOVWF  1B
1EE4:  MOVLW  A2
1EE5:  MOVWF  1E
1EE6:  MOVLW  90
1EE7:  MOVWF  1D
1EE8:  MOVLB  01
1EE9:  BSF    5F.7
1EEA:  CLRF   61
1EEB:  CLRF   60
1EEC:  MOVLB  0F
1EED:  CLRF   11
1EEE:  CLRF   12
1EEF:  CLRF   18
1EF0:  CLRF   19
1EF1:  CLRF   1A
1EF2:  MOVLB  03
1EF3:  CLRF   0C
1EF4:  CLRF   0D
1EF5:  CLRF   0F
1EF6:  CLRF   10
1EF7:  MOVLB  02
1EF8:  CLRF   12
1EF9:  CLRF   11
1EFA:  CLRF   14
1EFB:  CLRF   13
....................   initialize(); 
*
1EFF:  MOVLP  08
1F00:  GOTO   4B5
1F01:  MOVLP  18
.................... #ignore_warnings 203 
....................   while(1) { // {{{ 
.................... #ignore_warnings none 
....................     restart_wdt(); 
1F02:  CLRWDT
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "\r" or "+" or "-" is received. 
....................     if ( sBufferFlag ) { 
1F03:  BTFSS  76.0
1F04:  GOTO   70A
....................       process_sBuffer(); 
1F05:  GOTO   000
....................       clear_sBuffer(); 
1F06:  MOVLP  00
1F07:  CALL   4B9
1F08:  MOVLP  18
....................       sBufferFlag=0; 
1F09:  BCF    76.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1F0A:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1F0B:  BTFSS  76.6
1F0C:  GOTO   712
....................       update_aux_in(); 
1F0D:  MOVLP  10
1F0E:  GOTO   4E0
1F0F:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1F10:  BCF    76.6
....................       AUX_OUT_FLAG=1; 
1F11:  BSF    76.7
....................     } 
....................     do_delay_counters(); 
1F12:  MOVLP  10
1F13:  GOTO   52A
1F14:  MOVLP  18
....................     restart_wdt(); 
1F15:  CLRWDT
....................     if ( COR_FLAG ) { 
1F16:  BTFSS  76.1
1F17:  GOTO   71E
....................       process_cor(); 
1F18:  MOVLP  10
1F19:  GOTO   5BD
1F1A:  MOVLP  18
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       AUX_OUT_FLAG=1; 
1F1B:  BSF    76.7
....................       COR_FLAG=0; 
1F1C:  BCF    76.1
....................       restart_wdt(); 
1F1D:  CLRWDT
....................     } 
....................     if ( AUX_OUT_FLAG ) { 
1F1E:  BTFSS  76.7
1F1F:  GOTO   722
....................       update_aux_out();  
1F20:  GOTO   43C
....................       AUX_OUT_FLAG=0; 
1F21:  BCF    76.7
....................     } 
....................     if ( DTMF_INTERRUPT_FLAG ) { 
1F22:  MOVLB  01
1F23:  BTFSS  5F.2
1F24:  GOTO   72B
....................       // Extract data from DTMF device 
....................       process_dtmf_interrupt(); 
1F25:  MOVLP  10
1F26:  MOVLB  00
1F27:  GOTO   6E5
1F28:  MOVLP  18
....................       DTMF_INTERRUPT_FLAG=0; 
1F29:  MOVLB  01
1F2A:  BCF    5F.2
....................     } 
....................     if ( DTMF_IN_FLAG ) { 
1F2B:  BTFSS  5F.1
1F2C:  GOTO   734
....................       print_dtmf_info(); 
1F2D:  MOVLP  10
1F2E:  MOVLB  00
1F2F:  GOTO   737
1F30:  MOVLP  18
....................       DTMF_IN_FLAG=0; 
1F31:  MOVLB  01
1F32:  BCF    5F.1
....................       restart_wdt(); 
1F33:  CLRWDT
....................     } 
....................     if ( DTMF_FLAG ) { 
1F34:  BTFSS  5F.0
1F35:  GOTO   73B
....................       process_dtmf(); 
1F36:  MOVLB  00
1F37:  GOTO   5BA
....................       DTMF_FLAG=0; 
1F38:  MOVLB  01
1F39:  BCF    5F.0
....................     restart_wdt(); 
1F3A:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1F3B:  BTFSS  5F.3
1F3C:  GOTO   741
....................       clear_dtmf_array(); 
1F3D:  MOVLB  00
1F3E:  GOTO   6B7
....................       CLEAR_DTMF_FLAG=0; 
1F3F:  MOVLB  01
1F40:  BCF    5F.3
....................     } 
....................     if ( PROMPT_FLAG ) { 
1F41:  BTFSS  5F.4
1F42:  GOTO   74A
....................       prompt(); 
1F43:  MOVLP  08
1F44:  MOVLB  00
1F45:  CALL   7AE
1F46:  MOVLP  18
....................       PROMPT_FLAG=0; 
1F47:  MOVLB  01
1F48:  BCF    5F.4
....................     restart_wdt(); 
1F49:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1F4A:  MOVLB  00
1F4B:  GOTO   702
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0B8D:  CLRWDT
*
1F4C:  SLEEP
....................   delay_ms(1000); 
*
0B8E:  MOVLW  04
0B8F:  MOVLB  02
0B90:  MOVWF  3B
0B91:  MOVLW  FA
0B92:  MOVWF  46
0B93:  MOVLB  00
0B94:  CALL   000
0B95:  MOVLB  02
0B96:  DECFSZ 3B,F
0B97:  GOTO   391
....................   if ( ConfirmChar!=0 ) { 
0B98:  MOVLB  00
0B99:  MOVF   6F,F
0B9A:  BTFSC  03.2
0B9B:  GOTO   3AE
....................     morse(ConfirmChar); 
0B9C:  MOVF   6F,W
0B9D:  MOVLB  02
0B9E:  MOVWF  3B
0B9F:  MOVLB  00
0BA0:  CALL   09C
....................     ConfirmChar=0; 
0BA1:  CLRF   6F
....................     restart_wdt(); 
0BA2:  CLRWDT
....................     delay_ms(500); 
0BA3:  MOVLW  02
0BA4:  MOVLB  02
0BA5:  MOVWF  3B
0BA6:  MOVLW  FA
0BA7:  MOVWF  46
0BA8:  MOVLB  00
0BA9:  CALL   000
0BAA:  MOVLB  02
0BAB:  DECFSZ 3B,F
0BAC:  GOTO   3A6
0BAD:  MOVLB  00
....................   } 
....................   if (TailChar != 0) { 
0BAE:  MOVF   6E,F
0BAF:  BTFSC  03.2
0BB0:  GOTO   3C3
....................     morse(TailChar); 
0BB1:  MOVF   6E,W
0BB2:  MOVLB  02
0BB3:  MOVWF  3B
0BB4:  MOVLB  00
0BB5:  CALL   09C
....................     TailChar=0; 
0BB6:  CLRF   6E
....................     restart_wdt(); 
0BB7:  CLRWDT
....................     delay_ms(500); 
0BB8:  MOVLW  02
0BB9:  MOVLB  02
0BBA:  MOVWF  3B
0BBB:  MOVLW  FA
0BBC:  MOVWF  46
0BBD:  MOVLB  00
0BBE:  CALL   000
0BBF:  MOVLB  02
0BC0:  DECFSZ 3B,F
0BC1:  GOTO   3BB
0BC2:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0BC3:  CLRWDT
0BC4:  MOVLB  02
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
0F1B:  MOVLB  01
0F1C:  BTFSS  5F.5
0F1D:  GOTO   720
....................     admin_timer = ADMIN_TIMEOUT; 
0F1E:  MOVLW  FF
0F1F:  MOVWF  7C
....................   } 
....................   return(AdminMode||rs232_mode); 
0F20:  BTFSC  5F.5
0F21:  GOTO   726
0F22:  BTFSC  5F.6
0F23:  GOTO   726
0F24:  MOVLW  00
0F25:  GOTO   727
0F26:  MOVLW  01
0F27:  MOVWF  78
.................... } // }}} 
0F28:  MOVLB  00
0F29:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0C9E:  MOVLB  01
0C9F:  BCF    5F.5
0CA0:  MOVLB  02
0CA1:  MOVF   3C,F
0CA2:  BTFSC  03.2
0CA3:  GOTO   4A7
0CA4:  MOVLB  01
0CA5:  BSF    5F.5
0CA6:  MOVLB  02
....................   if (AdminMode) { 
0CA7:  MOVLB  01
0CA8:  BTFSS  5F.5
0CA9:  GOTO   4B1
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0CAA:  MOVLW  0A
0CAB:  MOVLB  00
0CAC:  MOVWF  6F
....................     admin_timer = ADMIN_TIMEOUT; 
0CAD:  MOVLW  FF
0CAE:  MOVWF  7C
....................   } else { 
0CAF:  GOTO   4B4
0CB0:  MOVLB  01
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0CB1:  MOVLW  18
0CB2:  MOVLB  00
0CB3:  MOVWF  6F
....................   }  
.................... } // }}} 
0CB4:  RETURN
.................... // string matchnig function with case insensitive match. 
.................... int1 my_stricmp(char *s1,char *s2) { // {{{ 
*
0EB3:  MOVLB  02
0EB4:  CLRF   3F
....................   unsigned int x=0; 
....................   const char AMASK=0xDF; 
....................   while((AMASK&s1[x])==(AMASK&s2[x])) { 
0EB5:  MOVF   3F,W
0EB6:  ADDWF  3B,W
0EB7:  MOVWF  04
0EB8:  MOVLW  00
0EB9:  ADDWFC 3C,W
0EBA:  MOVWF  05
0EBB:  MOVF   00,W
0EBC:  ANDLW  DF
0EBD:  MOVWF  40
0EBE:  MOVF   3F,W
0EBF:  ADDWF  3D,W
0EC0:  MOVWF  04
0EC1:  MOVLW  00
0EC2:  ADDWFC 3E,W
0EC3:  MOVWF  05
0EC4:  MOVF   00,W
0EC5:  ANDLW  DF
0EC6:  SUBWF  40,W
0EC7:  BTFSS  03.2
0EC8:  GOTO   6D7
....................     if(s1[x]==0) { 
0EC9:  MOVF   3F,W
0ECA:  ADDWF  3B,W
0ECB:  MOVWF  04
0ECC:  MOVLW  00
0ECD:  ADDWFC 3C,W
0ECE:  MOVWF  05
0ECF:  MOVF   00,F
0ED0:  BTFSS  03.2
0ED1:  GOTO   6D5
....................       return 0; 
0ED2:  MOVLW  00
0ED3:  MOVWF  78
0ED4:  GOTO   6D9
....................     } 
....................     x++; 
0ED5:  INCF   3F,F
....................   } 
0ED6:  GOTO   6B5
....................   // Strings don't match. Return 1. 
....................   return 1; 
0ED7:  MOVLW  01
0ED8:  MOVWF  78
.................... } // }}} 
0ED9:  MOVLB  00
0EDA:  RETURN
.................... // Fetches data from MC8888 device upon interrupt 
.................... void process_dtmf_interrupt(void) { // {{{ 
....................   int value,dtmf_status; 
....................   dtmf_status = dtmf_read(CONTROL_REG); 
*
16E5:  MOVLW  01
16E6:  MOVLB  02
16E7:  MOVWF  37
16E8:  MOVLP  00
16E9:  MOVLB  00
16EA:  CALL   696
16EB:  MOVLP  10
16EC:  MOVF   78,W
16ED:  MOVLB  01
16EE:  MOVWF  63
....................   if ( dtmf_status & DTMF_BUFFER_FULL) { 
16EF:  BTFSS  63.2
16F0:  GOTO   734
....................     value=dtmf_read(DATA_REG); 
16F1:  MOVLB  02
16F2:  CLRF   37
16F3:  MOVLP  00
16F4:  MOVLB  00
16F5:  CALL   696
16F6:  MOVLP  10
16F7:  MOVF   78,W
16F8:  MOVLB  01
16F9:  MOVWF  62
....................     DTMF_IN_FLAG=1; 
16FA:  BSF    5F.1
....................     if ( value == dd ) { 
16FB:  MOVF   62,F
16FC:  BTFSS  03.2
16FD:  GOTO   701
....................       value=d0; 
16FE:  MOVLW  0A
16FF:  MOVWF  62
....................     } else if ( value == d0 ) { 
1700:  GOTO   705
1701:  MOVF   62,W
1702:  SUBLW  0A
1703:  BTFSC  03.2
....................       value=dd; 
1704:  CLRF   62
....................     } 
....................     if ( value == ds ) { 
1705:  MOVF   62,W
1706:  SUBLW  0B
1707:  BTFSC  03.2
....................       CLEAR_DTMF_FLAG=1; 
1708:  BSF    5F.3
....................     } 
....................     // Check for '#' 
....................     if ( value == dp ) { 
1709:  MOVF   62,W
170A:  SUBLW  0C
170B:  BTFSS  03.2
170C:  GOTO   715
....................       DTMF_FLAG = 1; 
170D:  BSF    5F.0
....................       DTMF_ptr->Last=1; 
170E:  MOVF   3E,W
170F:  MOVWF  04
1710:  MOVF   3F,W
1711:  MOVWF  05
1712:  ADDFSR 00,FSR0
1713:  BSF    00.5
....................     } else { 
1714:  GOTO   734
....................       if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
1715:  MOVF   3F,W
1716:  SUBLW  20
1717:  BTFSS  03.0
1718:  GOTO   734
1719:  BTFSS  03.2
171A:  GOTO   71F
171B:  MOVF   3E,W
171C:  SUBLW  6D
171D:  BTFSS  03.0
171E:  GOTO   734
....................         DTMF_ptr->Key=value; 
171F:  MOVF   3E,W
1720:  MOVWF  04
1721:  MOVF   3F,W
1722:  MOVWF  05
1723:  ADDFSR 00,FSR0
1724:  MOVF   62,W
1725:  ANDLW  0F
1726:  MOVWF  77
1727:  MOVLW  F0
1728:  ANDWF  00,W
1729:  IORWF  77,W
172A:  MOVWF  00
....................         DTMF_ptr->Strobe=1; 
172B:  MOVF   3E,W
172C:  MOVWF  04
172D:  MOVF   3F,W
172E:  MOVWF  05
172F:  ADDFSR 00,FSR0
1730:  BSF    00.4
....................         DTMF_ptr++; 
1731:  INCF   3E,F
1732:  BTFSC  03.2
1733:  INCF   3F,F
....................       } 
....................     } 
....................   } 
.................... } // }}} 
1734:  MOVLP  18
1735:  MOVLB  00
1736:  GOTO   728 (RETURN)
.................... void init_lcd(void) { // {{{ 
.................... #define INIT 0x18 
.................... #define MODE_SET 0x1C 
.................... #define ENABLE 0x04 
....................   i2c_start(); 
....................   i2c_write(LCD_I2C_ADD<<1); 
....................   // Function set 
....................   // Initialize in 8-bit mode first for 3 clock cycles 
....................   lcd_strobe(0x30);lcd_strobe(0x30);lcd_strobe(0x30); 
....................   // Init 4-bit interface mode 
....................   lcd_strobe(0x20); 
....................   lcd_write(0,0x2C); 
....................   // Display On/Off, Cursor off 
....................   lcd_write(0,0x0C); 
....................   // Display clear 
....................   lcd_write(0,0x01); 
....................   // Entry mode set 
....................   lcd_write(0,0x04); 
....................   i2c_stop(); 
.................... } // }}} 
.................... void do_delay_counters(void) { 
....................   // Second Flag {{{ 
....................   if ( SECOND_FLAG ) { 
*
152A:  BTFSS  76.2
152B:  GOTO   581
....................     if (COR_IN_EFFECTIVE != 0x00) { 
152C:  MOVF   74,F
152D:  BTFSC  03.2
152E:  GOTO   538
....................       if ( QSO_Duration != 0xFF ) { 
152F:  INCFSZ 68,W
1530:  GOTO   534
1531:  MOVF   69,F
1532:  BTFSC  03.2
1533:  GOTO   537
....................         QSO_Duration++; 
1534:  INCF   68,F
1535:  BTFSC  03.2
1536:  INCF   69,F
....................       } 
....................     } else { 
1537:  GOTO   53A
....................       QSO_Duration=0; 
1538:  CLRF   69
1539:  CLRF   68
....................     } 
....................     AUX_OUT_FLAG=1; 
153A:  BSF    76.7
....................     // Time Out PTT {{{ 
....................     if ( (TOT_Min > 0) && (QSO_Duration >= (TOT_Min*60))) { 
153B:  MOVF   66,F
153C:  BTFSC  03.2
153D:  GOTO   564
153E:  MOVF   66,W
153F:  MOVLB  02
1540:  MOVWF  3F
1541:  MOVLW  3C
1542:  MOVWF  40
1543:  MOVLP  08
1544:  MOVLB  00
1545:  CALL   653
1546:  MOVLP  10
1547:  MOVF   78,W
1548:  MOVF   69,F
1549:  BTFSS  03.2
154A:  GOTO   54E
154B:  SUBWF  68,W
154C:  BTFSS  03.0
154D:  GOTO   564
....................       if ( TOT_FLAG_Mask == 0 ) { 
154E:  MOVF   67,F
154F:  BTFSS  03.2
1550:  GOTO   562
....................         printf("\n\r# PTT Timeout!\n"); 
1551:  MOVLW  A6
1552:  MOVLB  03
1553:  MOVWF  11
1554:  MOVLW  04
1555:  MOVWF  12
1556:  MOVLP  00
1557:  MOVLB  00
1558:  CALL   4D3
1559:  MOVLP  10
....................         PROMPT_FLAG=1; 
155A:  MOVLB  01
155B:  BSF    5F.4
....................         update_ptt(0); 
155C:  MOVLB  02
155D:  CLRF   2A
155E:  MOVLP  08
155F:  MOVLB  00
1560:  CALL   360
1561:  MOVLP  10
....................       } 
....................       TOT_FLAG_Mask=COR_IN_EFFECTIVE; 
1562:  MOVF   74,W
1563:  MOVWF  67
....................     } 
....................     // }}} 
....................     // AuxOutDelayCnt {{{ 
....................     if ( AuxOutDelayCnt ) { 
1564:  MOVF   7E,F
1565:  BTFSS  03.2
....................       AuxOutDelayCnt--; 
1566:  DECF   7E,F
....................     } 
....................     // }}} 
....................     // Admin mode timeout {{{ 
....................     if ( admin_timer ) { 
1567:  MOVF   7C,F
1568:  BTFSC  03.2
1569:  GOTO   56C
....................       admin_timer--; 
156A:  DECF   7C,F
....................     } else { 
156B:  GOTO   575
....................       // Exit admin mode. 
....................       if ( AdminMode ) { 
156C:  MOVLB  01
156D:  BTFSS  5F.5
156E:  GOTO   576
....................         set_admin_mode(0); 
156F:  MOVLB  02
1570:  CLRF   3C
1571:  MOVLP  08
1572:  MOVLB  00
1573:  CALL   49E
1574:  MOVLP  10
1575:  MOVLB  01
....................       } 
....................     } 
....................     // }}} 
....................     restart_wdt(); 
1576:  CLRWDT
....................     if ( SecondCounter ) { 
1577:  MOVF   5D,F
1578:  BTFSC  03.2
1579:  GOTO   57C
....................       SecondCounter--; 
157A:  DECF   5D,F
....................     } else { 
157B:  GOTO   57F
....................       SecondCounter=SEC_COUNTER; 
157C:  MOVLW  3B
157D:  MOVWF  5D
....................       MINUTE_FLAG = 1; 
157E:  BSF    76.3
....................     } 
....................     SECOND_FLAG=0; 
157F:  BCF    76.2
1580:  MOVLB  00
....................   } 
....................   // Second Flag }}} 
....................   // Minute flag {{{ 
....................   if ( MINUTE_FLAG ) { 
1581:  BTFSS  76.3
1582:  GOTO   5A0
....................     if ( MinuteCounter ) { 
1583:  MOVLB  01
1584:  MOVF   5E,F
1585:  BTFSC  03.2
1586:  GOTO   589
....................       MinuteCounter--; 
1587:  DECF   5E,F
....................     } else { 
1588:  GOTO   58C
....................       THIRTY_MIN_FLAG=1; 
1589:  BSF    76.4
....................       MinuteCounter = MIN_COUNTER; 
158A:  MOVLW  1D
158B:  MOVWF  5E
....................     } 
....................     MINUTE_FLAG = 0; 
158C:  BCF    76.3
....................     // Link timeout timer {{{ 
....................     if ( Link_TOT != 0 ) { 
158D:  MOVLB  00
158E:  MOVF   6A,F
158F:  BTFSC  03.2
1590:  GOTO   5A0
....................       if ( LinkDurationTimer ) { 
1591:  MOVF   6B,F
1592:  BTFSC  03.2
1593:  GOTO   596
....................         LinkDurationTimer--; 
1594:  DECF   6B,F
....................       } else { 
1595:  GOTO   5A0
....................         // Disable Link 
....................         printf("\n\r# Link Timeout!\n"); 
1596:  MOVLW  AF
1597:  MOVLB  03
1598:  MOVWF  11
1599:  MOVLW  04
159A:  MOVWF  12
159B:  MOVLP  00
159C:  MOVLB  00
159D:  CALL   4D3
159E:  MOVLP  10
....................         Enable&=0xFE; 
159F:  BCF    60.0
....................       } 
....................     } 
....................     // Link timeout timer }}} 
....................   } 
....................   // Minute flag }}} 
....................   if ( THIRTY_MIN_FLAG ) { // {{{ 
15A0:  BTFSS  76.4
15A1:  GOTO   5BB
....................     if ( (TXSiteID&0x03) !=0 ) { 
15A2:  MOVF   64,W
15A3:  ANDLW  03
15A4:  BTFSC  03.2
15A5:  GOTO   5BA
....................       // Transmit Site ID every 30 mins when: 
....................       // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................       // E = Transmit every 30 mins 
....................       // M = Transmit only if EnableMask is off 
....................       if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
15A6:  MOVF   64,W
15A7:  ANDLW  01
15A8:  BTFSS  03.2
15A9:  GOTO   5B7
15AA:  MOVF   64,W
15AB:  ANDLW  02
15AC:  BTFSC  03.2
15AD:  GOTO   5BA
15AE:  SWAPF  64,W
15AF:  MOVWF  77
15B0:  MOVLW  0F
15B1:  ANDWF  77,F
15B2:  MOVF   77,W
15B3:  ANDLW  0F
15B4:  ANDWF  60,W
15B5:  BTFSS  03.2
15B6:  GOTO   5BA
....................         send_morse_id(); 
15B7:  MOVLP  08
15B8:  CALL   7C6
15B9:  MOVLP  10
....................       } 
....................     } 
....................     THIRTY_MIN_FLAG=0; 
15BA:  BCF    76.4
....................   } // }}} 
.................... } 
15BB:  MOVLP  18
15BC:  GOTO   714 (RETURN)
....................  

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
