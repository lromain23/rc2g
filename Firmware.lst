CCS PCM C Compiler, Version 4.140, 64991               13-Dec-24 16:48

               Filename:   C:\Users\m3n2bn\Projects\MBPAB IDE\RC2Gb\60_Master\Firmware.lst

               ROM used:   8105 words (99%)
                           Largest free fragment is 58
               RAM used:   168 (33%) at main() level
                           235 (46%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   70E
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   348
002D:  MOVLP  00
002E:  GOTO   361
002F:  MOVLP  00
0030:  GOTO   2EB
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #device ADC=8; 
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
16F5:  MOVLB  02
16F6:  MOVF   2C,W
16F7:  MOVWF  30
16F8:  MOVF   2B,W
16F9:  MOVWF  2F
16FA:  MOVF   30,W
16FB:  MOVWF  7A
16FC:  MOVF   2F,W
16FD:  MOVWF  04
16FE:  MOVF   7A,W
16FF:  MOVWF  05
1700:  MOVF   00,F
1701:  BTFSC  03.2
1702:  GOTO   707
1703:  INCF   2F,F
1704:  BTFSC  03.2
1705:  INCF   30,F
1706:  GOTO   6FA
....................    while(*s2 != '\0') 
....................    { 
1707:  MOVF   2E,W
1708:  MOVWF  7A
1709:  MOVF   2D,W
170A:  MOVWF  04
170B:  MOVF   7A,W
170C:  MOVWF  05
170D:  MOVF   00,F
170E:  BTFSC  03.2
170F:  GOTO   723
....................       *s = *s2; 
1710:  MOVF   2D,W
1711:  MOVWF  04
1712:  MOVF   2E,W
1713:  MOVWF  05
1714:  MOVF   00,W
1715:  MOVWF  33
1716:  MOVF   30,W
1717:  MOVWF  05
1718:  MOVF   2F,W
1719:  MOVWF  04
171A:  MOVF   33,W
171B:  MOVWF  00
....................       ++s; 
171C:  INCF   2F,F
171D:  BTFSC  03.2
171E:  INCF   30,F
....................       ++s2; 
171F:  INCF   2D,F
1720:  BTFSC  03.2
1721:  INCF   2E,F
....................    } 
1722:  GOTO   707
....................  
....................    *s = '\0'; 
1723:  MOVF   2F,W
1724:  MOVWF  04
1725:  MOVF   30,W
1726:  MOVWF  05
1727:  CLRF   00
....................    return(s1); 
1728:  MOVF   2B,W
1729:  MOVWF  78
172A:  MOVF   2C,W
172B:  MOVWF  79
.................... } 
172C:  MOVLB  00
172D:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E5F:  MOVF   4A,W
0E60:  MOVWF  4E
0E61:  MOVF   49,W
0E62:  MOVWF  4D
0E63:  MOVF   4E,W
0E64:  MOVWF  7A
0E65:  MOVF   4D,W
0E66:  MOVWF  04
0E67:  MOVF   7A,W
0E68:  MOVWF  05
0E69:  MOVF   00,F
0E6A:  BTFSC  03.2
0E6B:  GOTO   698
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0E6C:  MOVF   4C,W
0E6D:  MOVWF  50
0E6E:  MOVF   4B,W
0E6F:  MOVWF  4F
0E70:  MOVF   50,W
0E71:  MOVWF  7A
0E72:  MOVF   4F,W
0E73:  MOVWF  04
0E74:  MOVF   7A,W
0E75:  MOVWF  05
0E76:  MOVF   00,F
0E77:  BTFSC  03.2
0E78:  GOTO   694
....................          if (*sc1 == *sc2) 
0E79:  MOVF   4E,W
0E7A:  MOVWF  7A
0E7B:  MOVF   4D,W
0E7C:  MOVWF  04
0E7D:  MOVF   7A,W
0E7E:  MOVWF  05
0E7F:  MOVF   00,W
0E80:  MOVWF  51
0E81:  MOVF   50,W
0E82:  MOVWF  7A
0E83:  MOVF   4F,W
0E84:  MOVWF  04
0E85:  MOVF   7A,W
0E86:  MOVWF  05
0E87:  MOVF   00,W
0E88:  SUBWF  51,W
0E89:  BTFSS  03.2
0E8A:  GOTO   690
....................             return(sc1); 
0E8B:  MOVF   4D,W
0E8C:  MOVWF  78
0E8D:  MOVF   4E,W
0E8E:  MOVWF  79
0E8F:  GOTO   69B
0E90:  INCF   4F,F
0E91:  BTFSC  03.2
0E92:  INCF   50,F
0E93:  GOTO   670
0E94:  INCF   4D,F
0E95:  BTFSC  03.2
0E96:  INCF   4E,F
0E97:  GOTO   663
....................    return(0); 
0E98:  MOVLW  00
0E99:  MOVWF  78
0E9A:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0DF8:  MOVF   4A,W
0DF9:  MOVWF  4E
0DFA:  MOVF   49,W
0DFB:  MOVWF  4D
0DFC:  MOVF   4E,W
0DFD:  MOVWF  7A
0DFE:  MOVF   4D,W
0DFF:  MOVWF  04
0E00:  MOVF   7A,W
0E01:  MOVWF  05
0E02:  MOVF   00,F
0E03:  BTFSC  03.2
0E04:  GOTO   636
....................       for (sc2 = s2; ; sc2++) 
0E05:  MOVF   4C,W
0E06:  MOVWF  50
0E07:  MOVF   4B,W
0E08:  MOVWF  4F
....................     if (*sc2 == '\0') 
0E09:  MOVF   50,W
0E0A:  MOVWF  7A
0E0B:  MOVF   4F,W
0E0C:  MOVWF  04
0E0D:  MOVF   7A,W
0E0E:  MOVWF  05
0E0F:  MOVF   00,F
0E10:  BTFSS  03.2
0E11:  GOTO   61C
....................        return(sc1 - s1); 
0E12:  MOVF   49,W
0E13:  SUBWF  4D,W
0E14:  MOVWF  77
0E15:  MOVF   4A,W
0E16:  SUBWFC 4E,W
0E17:  MOVWF  7A
0E18:  MOVF   77,W
0E19:  MOVWF  78
0E1A:  GOTO   63E
....................          else if (*sc1 == *sc2) 
0E1B:  GOTO   62E
0E1C:  MOVF   4E,W
0E1D:  MOVWF  7A
0E1E:  MOVF   4D,W
0E1F:  MOVWF  04
0E20:  MOVF   7A,W
0E21:  MOVWF  05
0E22:  MOVF   00,W
0E23:  MOVWF  51
0E24:  MOVF   50,W
0E25:  MOVWF  7A
0E26:  MOVF   4F,W
0E27:  MOVWF  04
0E28:  MOVF   7A,W
0E29:  MOVWF  05
0E2A:  MOVF   00,W
0E2B:  SUBWF  51,W
0E2C:  BTFSC  03.2
....................             break; 
0E2D:  GOTO   632
0E2E:  INCF   4F,F
0E2F:  BTFSC  03.2
0E30:  INCF   50,F
0E31:  GOTO   609
0E32:  INCF   4D,F
0E33:  BTFSC  03.2
0E34:  INCF   4E,F
0E35:  GOTO   5FC
....................    return(sc1 - s1); 
0E36:  MOVF   49,W
0E37:  SUBWF  4D,W
0E38:  MOVWF  77
0E39:  MOVF   4A,W
0E3A:  SUBWFC 4E,W
0E3B:  MOVWF  7A
0E3C:  MOVF   77,W
0E3D:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1F3C:  MOVLB  00
1F3D:  CLRF   26
1F3E:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0DDF:  MOVLB  02
0DE0:  MOVF   41,W
0DE1:  IORWF  42,W
0DE2:  BTFSC  03.2
0DE3:  GOTO   5E8
0DE4:  MOVF   42,W
0DE5:  MOVWF  7A
0DE6:  MOVF   41,W
0DE7:  GOTO   5ED
0DE8:  MOVLB  00
0DE9:  MOVF   27,W
0DEA:  MOVWF  7A
0DEB:  MOVF   26,W
0DEC:  MOVLB  02
0DED:  MOVWF  45
0DEE:  MOVF   7A,W
0DEF:  MOVWF  46
....................    beg += strspn(beg, s2); 
0DF0:  MOVF   46,W
0DF1:  MOVWF  4A
0DF2:  MOVF   45,W
0DF3:  MOVWF  49
0DF4:  MOVF   44,W
0DF5:  MOVWF  4C
0DF6:  MOVF   43,W
0DF7:  MOVWF  4B
*
0E3E:  MOVF   78,W
0E3F:  ADDWF  45,F
0E40:  MOVLW  00
0E41:  ADDWFC 46,F
....................    if (*beg == '\0') 
0E42:  MOVF   46,W
0E43:  MOVWF  7A
0E44:  MOVF   45,W
0E45:  MOVWF  04
0E46:  MOVF   7A,W
0E47:  MOVWF  05
0E48:  MOVF   00,F
0E49:  BTFSS  03.2
0E4A:  GOTO   657
....................    { 
....................       *save = ' '; 
0E4B:  MOVLB  00
0E4C:  MOVF   26,W
0E4D:  MOVWF  04
0E4E:  MOVF   27,W
0E4F:  MOVWF  05
0E50:  MOVLW  20
0E51:  MOVWF  00
....................       return(0); 
0E52:  MOVLW  00
0E53:  MOVWF  78
0E54:  MOVWF  79
0E55:  GOTO   6BC
0E56:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0E57:  MOVF   46,W
0E58:  MOVWF  4A
0E59:  MOVF   45,W
0E5A:  MOVWF  49
0E5B:  MOVF   44,W
0E5C:  MOVWF  4C
0E5D:  MOVF   43,W
0E5E:  MOVWF  4B
*
0E9B:  MOVF   79,W
0E9C:  MOVWF  48
0E9D:  MOVF   78,W
0E9E:  MOVWF  47
....................    if (*end != '\0') 
0E9F:  MOVF   48,W
0EA0:  MOVWF  7A
0EA1:  MOVF   47,W
0EA2:  MOVWF  04
0EA3:  MOVF   7A,W
0EA4:  MOVWF  05
0EA5:  MOVF   00,F
0EA6:  BTFSC  03.2
0EA7:  GOTO   6B0
....................    { 
....................       *end = '\0'; 
0EA8:  MOVF   47,W
0EA9:  MOVWF  04
0EAA:  MOVF   48,W
0EAB:  MOVWF  05
0EAC:  CLRF   00
....................       end++; 
0EAD:  INCF   47,F
0EAE:  BTFSC  03.2
0EAF:  INCF   48,F
....................    } 
....................    save = end; 
0EB0:  MOVF   48,W
0EB1:  MOVLB  00
0EB2:  MOVWF  27
0EB3:  MOVLB  02
0EB4:  MOVF   47,W
0EB5:  MOVLB  00
0EB6:  MOVWF  26
....................    return(beg); 
0EB7:  MOVLB  02
0EB8:  MOVF   45,W
0EB9:  MOVWF  78
0EBA:  MOVF   46,W
0EBB:  MOVWF  79
0EBC:  MOVLB  00
.................... } 
0EBD:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
.................... #define BUTTON_STATES 
.................... #define POT_MAX 63 
....................  
.................... #define RS 0x01 
.................... #define LCD_READ 0x02   
.................... #define LCD_WRITE 0x00   
.................... #define E 0x04 
.................... #define BT 0x08 
.................... #define CHANGE_LINE 0x80 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
077E:  MOVLW  20
077F:  MOVWF  05
0780:  MOVLW  CC
0781:  MOVWF  04
0782:  MOVF   00,W
0783:  BTFSC  03.2
0784:  GOTO   796
0785:  MOVLW  02
0786:  MOVWF  78
0787:  MOVLW  BF
0788:  MOVWF  77
0789:  CLRWDT
078A:  DECFSZ 77,F
078B:  GOTO   789
078C:  DECFSZ 78,F
078D:  GOTO   787
078E:  MOVLW  96
078F:  MOVWF  77
0790:  DECFSZ 77,F
0791:  GOTO   790
0792:  GOTO   793
0793:  CLRWDT
0794:  DECFSZ 00,F
0795:  GOTO   785
0796:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
0646:  MOVLB  04
0647:  BCF    15.7
0648:  MOVLB  00
0649:  BCF    11.3
064A:  MOVLB  02
064B:  MOVF   52,W
064C:  MOVLB  04
064D:  MOVWF  11
064E:  MOVLW  02
064F:  BTFSC  15.7
0650:  GOTO   658
0651:  MOVLB  00
0652:  BTFSS  11.3
0653:  GOTO   652
0654:  MOVLW  00
0655:  MOVLB  04
0656:  BTFSC  16.6
0657:  MOVLW  01
0658:  MOVWF  78
0659:  MOVLB  00
065A:  RETURN
*
0A26:  MOVLB  04
0A27:  BCF    15.6
0A28:  BSF    16.3
0A29:  BTFSC  16.3
0A2A:  GOTO   229
0A2B:  BTFSC  77.0
0A2C:  BCF    16.5
0A2D:  BTFSS  77.0
0A2E:  BSF    16.5
0A2F:  BSF    16.4
0A30:  BTFSC  16.4
0A31:  GOTO   230
0A32:  MOVF   11,W
0A33:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02E4:  CLRWDT
02E5:  BTFSS  11.4
02E6:  GOTO   2E4
02E7:  MOVLB  03
02E8:  MOVWF  1A
02E9:  MOVLB  00
02EA:  RETURN
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void process_dtmf_interrupt(void); 
.................... void crlf (void); 
.................... void init_lcd(void); 
.................... int1 read_cor_in_ports(void); 
.................... void send_tail(void); 
.................... void status_led(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... #if __DEVICE__==1939 
.................... void set_bit(void); 
.................... void clear_bit(void); 
.................... #endif 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
.................... void print_dfmf_info(void); 
.................... void do_delay_counters(void); 
.................... void process_buttons(void); 
.................... int1 my_stricmp(char *, char *); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN_HW; 
.................... unsigned int COR_IN; 
.................... unsigned int COR_IN_EFFECTIVE; 
.................... unsigned int Enable; 
.................... unsigned int Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned long TOT_Min; 
.................... unsigned int TOT_FLAG_Mask; 
.................... unsigned long QSO_Duration; 
.................... unsigned int Link_TOT,LinkDurationTimer; 
.................... unsigned int COR_EMUL; 
.................... unsigned int COR_AUX; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... // 
.................... // Button calibration states 
.................... // 
.................... #define BUTTON_IDLE 0 
.................... #define CALIB 16 
.................... #define TRIM 15  
.................... // 
.................... // Command settings 
.................... // 
.................... #define LINK_CMD 1 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define DEBOUNCE_COUNT 8 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
.................... #define SET_BIT 14 
.................... #define CLEAR_BIT 15 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... #define QSO_DURATION_DELAY 5 
.................... // This command operates the same way as AUX_OUT_FOLLOW_COR but 
.................... // it extends the aux output by 1 minute. 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT_OUTPUT 0x10 
.................... #define AUX_OUT_FOLLOW_COR_OFF_DELAY     0x20 
.................... #define AUX_OUT_FOLLOW_COR_ON_DELAY      0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... // Arguments 
.................... #define AUXI_EMULATE_COR1 0x01 
.................... #define AUXI_EMULATE_COR2 0x02 
.................... #define AUXI_EMULATE_COR3 0x04 
.................... #define AUXI_EMULATE_COR4 0x08 
.................... #define AUXI_EMULATE_COR5 0x10 // COR from AUX only for DTMF control (No audio feed-thru) 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x20 
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... unsigned int AuxOutDelayCnt; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... unsigned int command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
....................   int  usage : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1 PROCESS_COR_FLAG; 
.................... int1 COR_IN_FLAG; 
.................... int1 ENTER_PRESSED; 
.................... int1 SELECT_PRESSED; 
.................... int  adj_value_a,adj_value_b; 
.................... char button_state; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int1 	   AUX_OUT_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... int1       STATUS_LED; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1       DTMF_INTERRUPT_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... // PROTECTED -- Must be in admin mode to set value 
.................... // PUBLIC    -- Register can be set in any mode 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
.................... #define PROTECTED 1 
.................... #define PUBLIC    0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 AuxIn[0] 
.................... 	{"XI2"},	  // 19 AuxIn[1] 
.................... 	{"XI3"},	  // 20 AuxIn[2] 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"LTO"},  // 54 
....................     {"COR"},  // 55 
....................     {"CPOT"}  // 56 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
.................... #define SITE_ID_VAL  	60 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... #define ENABLE_DEFAULT 15 
.................... #define TOT_MIN 5 
.................... #define LINK_TOT 0 
.................... #define DEFAULT_GAIN 32 
.................... //#define LCD_TYPE_PI 1 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('e') 
.................... #define MORSEID5	MCHAR('h') 
....................  
.................... #define AUXOUTOP0 0 
.................... #define AUXOUTARG0 0 
.................... #define AUXOUTOP1 0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2 0 
.................... #define AUXOUTARG2 0 
....................  
.................... //#define AUXINOP0 AUXI_ENABLE 
.................... //#define AUXINARG0 AUXI_ENABLE2|AUXI_ENABLE3|AUXI_ENABLE4 
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  0 
.................... #define AUXINARG0 0 
.................... #define AUXINOP1 AUXI_TAIL_WHEN_HI 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
.................... #define RX1_PTT 0x0E 
.................... #define RX2_PTT 0x0D 
.................... #define RX3_PTT 0x0B 
.................... #define RX4_PTT 0x07 
....................  
.................... // Define default variables {{{ 
.................... #ifdef LCD_TYPE_PI 
....................   #define LCD_I2C_ADD 0x27 
.................... #else 
....................   #define LCD_I2C_ADD 0x60 
.................... #endif 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... #ifndef RX1_PTT 
....................   #define RX1_PTT 0x0E 
.................... #endif 
.................... #ifndef RX2_PTT 
....................   #define RX2_PTT 0x0D 
.................... #endif 
.................... #ifndef RX3_PTT 
....................   #define RX3_PTT 0x0B  
.................... #endif 
.................... #ifndef RX4_PTT 
....................   #define RX4_PTT 0x07 
.................... #endif 
.................... #ifndef DEFAULT_GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... // }}} 
....................  
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  , EEPROM,PUBLIC}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL, EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&AuxIn[0]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[1]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[2]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[0]     ,PO_AUX_OUT0     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[1]     ,PO_AUX_OUT1     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[2]     ,PO_AUX_OUT2     , EEPROM,PUBLIC}, 
.................... 	{&RXPriority[0] ,4               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[1] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[2] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[3] ,2               , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[0]     ,RX1_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[1]     ,RX2_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[2]     ,RX3_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[3]     ,RX4_PTT         , EEPROM,PROTECTED}, 
.................... 	{&SiteID        ,SITE_ID_VAL     , EEPROM,PROTECTED}, 
.................... 	{&TXSiteID      ,0x12            , EEPROM,PROTECTED}, 
....................   {&Morse[0]      ,MORSEID0        , EEPROM,PROTECTED}, 
....................   {&Morse[1]      ,MORSEID1        , EEPROM,PROTECTED}, 
....................   {&Morse[2]      ,MORSEID2        , EEPROM,PROTECTED}, 
....................   {&Morse[3]      ,MORSEID3        , EEPROM,PROTECTED}, 
....................   {&Morse[4]      ,MORSEID4        , EEPROM,PROTECTED}, 
....................   {&Morse[5]      ,MORSEID5        , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2      , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2        , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2       , EEPROM,PROTECTED}, 
....................   {&Tail          ,TAIL_CHAR       , EEPROM,PROTECTED}, 
....................   {&TOT_Min       ,TOT_MIN         , EEPROM,PROTECTED}, 
....................   {&Link_TOT      ,LINK_TOT        , EEPROM,PROTECTED}, 
.................... 	{&COR_EMUL      ,0x00            , RAM   ,PUBLIC}, 
.................... 	{&CurrentTrimPot,0x00            , RAM   ,PROTECTED}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02EB:  BTFSS  11.5
02EC:  GOTO   342
....................     c = getc(); 
02ED:  CLRWDT
02EE:  BTFSS  11.5
02EF:  GOTO   2ED
02F0:  MOVLB  03
02F1:  MOVF   19,W
02F2:  MOVLB  02
02F3:  MOVWF  58
....................     if ( c == '\b' ) { 
02F4:  MOVF   58,W
02F5:  SUBLW  08
02F6:  BTFSS  03.2
02F7:  GOTO   320
....................       if ( sBufferIndex > 0 ) { 
02F8:  MOVF   7C,F
02F9:  BTFSC  03.2
02FA:  GOTO   31A
....................         sBufferIndex--; 
02FB:  DECF   7C,F
....................         sBuffer[sBufferIndex]='\0'; 
02FC:  MOVLW  50
02FD:  ADDWF  7C,W
02FE:  MOVWF  04
02FF:  MOVLW  20
0300:  MOVWF  05
0301:  BTFSC  03.0
0302:  INCF   05,F
0303:  CLRF   00
....................         putc('\b'); 
0304:  MOVLW  08
0305:  MOVLB  00
0306:  CALL   2E4
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
0307:  MOVLW  1B
0308:  CALL   2E4
....................   printf("[K"); 
0309:  MOVLW  5B
030A:  CLRWDT
030B:  BTFSS  11.4
030C:  GOTO   30A
030D:  MOVLB  03
030E:  MOVWF  1A
030F:  MOVLW  4B
0310:  CLRWDT
0311:  MOVLB  00
0312:  BTFSC  11.4
0313:  GOTO   316
0314:  MOVLB  03
0315:  GOTO   310
0316:  MOVLB  03
0317:  MOVWF  1A
....................       } else { 
0318:  GOTO   31E
0319:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
031A:  MOVLW  07
031B:  MOVLB  00
031C:  CALL   2E4
031D:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
031E:  GOTO   344
031F:  MOVLB  02
0320:  MOVF   7C,W
0321:  SUBLW  0F
0322:  BTFSS  03.0
0323:  GOTO   33F
....................       putc(c); // echo the character 
0324:  MOVF   58,W
0325:  MOVLB  00
0326:  CALL   2E4
....................       sBuffer[sBufferIndex++] = c; 
0327:  MOVF   7C,W
0328:  INCF   7C,F
0329:  ADDLW  50
032A:  MOVWF  04
032B:  MOVLW  20
032C:  MOVWF  05
032D:  BTFSC  03.0
032E:  INCF   05,F
032F:  MOVLB  02
0330:  MOVF   58,W
0331:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0332:  MOVF   58,W
0333:  SUBLW  0D
0334:  BTFSC  03.2
0335:  GOTO   33D
0336:  MOVF   58,W
0337:  SUBLW  2B
0338:  BTFSC  03.2
0339:  GOTO   33D
033A:  MOVF   58,W
033B:  SUBLW  2D
033C:  BTFSC  03.2
....................         sBufferFlag=1; 
033D:  BSF    7D.0
....................       } 
....................     } else { 
033E:  GOTO   343
....................       putc('\a'); // Send alert. Avoid buffer overflow 
033F:  MOVLW  07
0340:  MOVLB  00
0341:  CALL   2E4
0342:  MOVLB  02
0343:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
0344:  MOVLB  00
0345:  BCF    11.5
0346:  MOVLP  00
0347:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if( IOCBF & 0x0F ) { // Check for interrupts on RB[3:0] only 
0348:  MOVLB  07
0349:  MOVF   16,W
034A:  ANDLW  0F
034B:  BTFSC  03.2
034C:  GOTO   350
....................     // COR_IN_HW = actual COR_IN values from controller input ports. 
....................     COR_IN_FLAG=1; 
034D:  BSF    7D.2
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
034E:  MOVLW  F0
034F:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
0350:  BTFSS  0B.0
0351:  GOTO   356
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     DTMF_INTERRUPT_FLAG = 1; 
0352:  MOVLB  01
0353:  BSF    62.6
....................     clear_interrupt(INT_RB4_H2L); 
0354:  MOVLB  07
0355:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
0356:  BTFSS  0B.0
0357:  GOTO   35D
....................     AUX_IN_FLAG=1; 
0358:  MOVLB  01
0359:  BSF    62.1
....................     clear_interrupt(INT_RB6|INT_RB7); 
035A:  MOVLW  3F
035B:  MOVLB  07
035C:  ANDWF  16,F
....................   } 
.................... } // }}} 
035D:  BCF    0B.0
035E:  MOVLP  00
035F:  MOVLB  00
0360:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
0361:  MOVLB  01
0362:  MOVF   31,W
0363:  IORWF  32,W
0364:  BTFSC  03.2
0365:  GOTO   36B
....................     rtcc_cnt--; 
0366:  MOVF   31,W
0367:  BTFSC  03.2
0368:  DECF   32,F
0369:  DECF   31,F
....................   } else { 
036A:  GOTO   371
....................     COR_IN_FLAG = 1; 
036B:  BSF    7D.2
....................     SECOND_FLAG=1; 
036C:  BSF    7D.5
....................     AUX_IN_FLAG=1; 
036D:  BSF    62.1
....................     rtcc_cnt=30; 
036E:  CLRF   32
036F:  MOVLW  1E
0370:  MOVWF  31
....................   } 
....................   if (aux_timer ) { 
0371:  MOVF   33,W
0372:  IORWF  34,W
0373:  BTFSC  03.2
0374:  GOTO   379
....................     aux_timer--; 
0375:  MOVF   33,W
0376:  BTFSC  03.2
0377:  DECF   34,F
0378:  DECF   33,F
....................   } 
.................... } // }}} 
....................  
0379:  BCF    0B.2
037A:  MOVLP  00
037B:  MOVLB  00
037C:  GOTO   020
.................... int1 read_cor_in_ports (void) { // {{{ 
....................   // Updates COR_IN_HW and COR_IN variables 
....................   // Returns a 1 if a new COR is detected. 
....................   unsigned int LAST_COR_IN; 
....................   LAST_COR_IN = COR_IN; 
*
15E8:  MOVF   60,W
15E9:  MOVLB  01
15EA:  MOVWF  68
....................   COR_IN_HW   = ((input_b() ^ Polarity)&0x0F); 
15EB:  MOVLB  00
15EC:  MOVF   0D,W
15ED:  XORWF  64,W
15EE:  ANDLW  0F
15EF:  MOVWF  5F
....................   COR_IN      = COR_IN_HW | (COR_EMUL & 0x1F) | (COR_AUX&0x0F); 
15F0:  MOVF   6F,W
15F1:  ANDLW  1F
15F2:  IORWF  5F,W
15F3:  MOVLB  01
15F4:  MOVWF  69
15F5:  MOVF   71,W
15F6:  ANDLW  0F
15F7:  IORWF  69,W
15F8:  MOVLB  00
15F9:  MOVWF  60
....................   if ( LAST_COR_IN != COR_IN ) { 
15FA:  MOVF   60,W
15FB:  MOVLB  01
15FC:  SUBWF  68,W
15FD:  BTFSC  03.2
15FE:  GOTO   603
....................     return(1); 
15FF:  MOVLW  01
1600:  MOVWF  78
1601:  GOTO   605
....................   } else { 
1602:  GOTO   605
....................     return(0); 
1603:  MOVLW  00
1604:  MOVWF  78
....................   } 
.................... } // }}} 
1605:  MOVLP  18
1606:  MOVLB  00
1607:  GOTO   761 (RETURN)
.................... int1 warn_no_lcd = 1; 
....................  
.................... void lcd_strobe(char data) { // {{{ 
....................   i2c_write(data | E); 
....................   i2c_write(data & ~E); 
.................... } // }}} 
....................  
.................... void lcd_write(char rs, char data) { // {{{ 
....................   char lcd_word_a,lcd_word_b; 
....................   lcd_word_a = LCD_WRITE | BT | (data&0xF0); 
....................   lcd_word_b = LCD_WRITE | BT | ((data<<4)&0xF0); 
....................   if ( rs ) { 
....................     lcd_word_a |= RS; 
....................     lcd_word_b |= RS; 
....................   }  
....................   lcd_strobe(lcd_word_a); 
....................   lcd_strobe(lcd_word_b); 
.................... } // }}} 
....................  
.................... void lcd_send(char line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   i2c_start(); 
*
090C:  MOVLB  04
090D:  BSF    16.0
090E:  BTFSC  16.0
090F:  GOTO   10E
....................   #ifdef LCD_TYPE_PI 
....................   ack=i2c_write(LCD_I2C_ADD << 1); 
.................... //  ack=i2c_write(line&0x03); 
.................... // Change line 
....................   switch(line&0x03) { 
....................     case 0x00: lcd_write(0,CHANGE_LINE);break; 
....................     case 0x01: lcd_write(0,CHANGE_LINE+0x40);break; 
....................     case 0x02: lcd_write(0,CHANGE_LINE+0x14);break; 
....................     case 0x03: lcd_write(0,CHANGE_LINE+0x54);break; 
....................   } 
....................   restart_wdt(); 
....................   #else 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
0910:  BCF    03.0
0911:  MOVLB  02
0912:  RLF    4C,W
0913:  ANDLW  0E
0914:  IORLW  60
0915:  MOVWF  4F
....................   ack=i2c_write(lcd_cmd); 
0916:  MOVF   4F,W
0917:  MOVWF  52
0918:  MOVLP  00
0919:  MOVLB  00
091A:  CALL   646
091B:  MOVLP  08
091C:  MOVF   78,W
091D:  MOVLB  02
091E:  BCF    50.0
091F:  BTFSC  78.0
0920:  BSF    50.0
....................   #endif 
....................   if ( ack!=0 ) { 
0921:  BTFSS  50.0
0922:  GOTO   149
....................     if ( warn_no_lcd ) { 
0923:  MOVLB  01
0924:  BTFSS  65.3
0925:  GOTO   147
....................       crlf(); 
0926:  MOVLP  00
0927:  MOVLB  00
0928:  CALL   457
0929:  MOVLP  08
....................       printf("I2C : No ACK from LCD : %u",ack); 
092A:  MOVLW  00
092B:  MOVLB  02
092C:  BTFSC  50.0
092D:  MOVLW  01
092E:  MOVWF  51
092F:  MOVLW  7D
0930:  MOVLB  03
0931:  MOVWF  11
0932:  MOVLW  03
0933:  MOVWF  12
0934:  BCF    03.0
0935:  MOVLW  18
0936:  MOVLB  02
0937:  MOVWF  52
0938:  MOVLP  00
0939:  MOVLB  00
093A:  CALL   65B
093B:  MOVLP  08
093C:  MOVLB  02
093D:  MOVF   51,W
093E:  MOVWF  52
093F:  MOVLW  1B
0940:  MOVWF  53
0941:  MOVLP  00
0942:  MOVLB  00
0943:  CALL   6CF
0944:  MOVLP  08
....................       warn_no_lcd = 0; 
0945:  MOVLB  01
0946:  BCF    65.3
....................     } 
....................   } else { 
0947:  GOTO   14B
0948:  MOVLB  02
....................     warn_no_lcd = 1; 
0949:  MOVLB  01
094A:  BSF    65.3
....................   } 
....................   while(*s) { 
094B:  MOVLB  02
094C:  MOVF   4E,W
094D:  MOVWF  7A
094E:  MOVF   4D,W
094F:  MOVWF  04
0950:  MOVF   7A,W
0951:  MOVWF  05
0952:  MOVF   00,F
0953:  BTFSC  03.2
0954:  GOTO   168
.................... #ifdef LCD_TYPE_PI 
....................     if ( *s != '\r' && *s != '\n') { 
....................       lcd_write(1,*s); 
....................     } 
....................     s++; 
.................... #else 
....................    i2c_write(*s++); 
0955:  MOVF   4E,W
0956:  MOVWF  7A
0957:  MOVF   4D,W
0958:  INCF   4D,F
0959:  BTFSC  03.2
095A:  INCF   4E,F
095B:  MOVWF  04
095C:  MOVF   7A,W
095D:  MOVWF  05
095E:  MOVF   00,W
095F:  MOVWF  51
0960:  MOVWF  52
0961:  MOVLP  00
0962:  MOVLB  00
0963:  CALL   646
0964:  MOVLP  08
.................... #endif 
....................   } 
0965:  MOVLB  01
0966:  GOTO   14B
0967:  MOVLB  02
.................... #ifndef LCD_TYPE_PI 
....................   i2c_write(0); // EOL 
0968:  CLRF   52
0969:  MOVLP  00
096A:  MOVLB  00
096B:  CALL   646
096C:  MOVLP  08
.................... #endif 
....................   i2c_stop(); 
096D:  MOVLB  04
096E:  BSF    16.2
096F:  BTFSC  16.2
0970:  GOTO   16F
.................... #endif 
.................... } // }}} 
0971:  MOVLB  00
0972:  RETURN
.................... #ifdef BUTTON_STATES 
.................... void status_led(void) { // {{{ 
....................   char cnt_val; 
....................   STATUS_LED=0; 
*
0DB1:  BCF    62.3
....................   cnt_val = rtcc_cnt>>3; 
0DB2:  RRF    32,W
0DB3:  MOVWF  7A
0DB4:  RRF    31,W
0DB5:  MOVWF  79
0DB6:  RRF    7A,F
0DB7:  RRF    79,F
0DB8:  RRF    7A,F
0DB9:  RRF    79,F
0DBA:  MOVF   79,W
0DBB:  MOVWF  6D
....................   if ( button_state!=0 ) { 
0DBC:  MOVF   61,F
0DBD:  BTFSC  03.2
0DBE:  GOTO   5CD
....................     if ( (rtcc_cnt & 0x04) ) { 
0DBF:  MOVF   31,W
0DC0:  ANDLW  04
0DC1:  MOVWF  77
0DC2:  CLRF   7A
0DC3:  MOVF   77,W
0DC4:  IORWF  7A,W
0DC5:  BTFSC  03.2
0DC6:  GOTO   5CD
....................       STATUS_LED = (cnt_val < (CurrentTrimPot+1));  
0DC7:  BCF    62.3
0DC8:  MOVLW  01
0DC9:  ADDWF  30,W
0DCA:  SUBWF  6D,W
0DCB:  BTFSS  03.0
0DCC:  BSF    62.3
....................     } 
....................   }  
....................   output_bit(STATUS_LED_PIN,STATUS_LED); 
0DCD:  BTFSC  62.3
0DCE:  GOTO   5D3
0DCF:  MOVLB  02
0DD0:  BCF    0C.6
0DD1:  GOTO   5D5
0DD2:  MOVLB  01
0DD3:  MOVLB  02
0DD4:  BSF    0C.6
0DD5:  MOVLB  01
0DD6:  BCF    0C.6
.................... } // }}} 
.................... #endif 
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................   crlf(); 
*
10B3:  MOVLP  00
10B4:  CALL   457
10B5:  MOVLP  10
....................   if ( command ) { 
10B6:  MOVF   70,F
10B7:  BTFSC  03.2
10B8:  GOTO   12B
....................     crlf(); printf("Processing Command:"); 
10B9:  MOVLP  00
10BA:  CALL   457
10BB:  MOVLP  10
10BC:  MOVLW  8B
10BD:  MOVLB  03
10BE:  MOVWF  11
10BF:  MOVLW  03
10C0:  MOVWF  12
10C1:  MOVLP  00
10C2:  MOVLB  00
10C3:  CALL   45C
10C4:  MOVLP  10
....................     crlf(); printf("  SiteID   : %u",SiteID); 
10C5:  MOVLP  00
10C6:  CALL   457
10C7:  MOVLP  10
10C8:  MOVLW  95
10C9:  MOVLB  03
10CA:  MOVWF  11
10CB:  MOVLW  03
10CC:  MOVWF  12
10CD:  BCF    03.0
10CE:  MOVLW  0D
10CF:  MOVLB  02
10D0:  MOVWF  52
10D1:  MOVLP  00
10D2:  MOVLB  00
10D3:  CALL   65B
10D4:  MOVLP  10
10D5:  MOVF   65,W
10D6:  MOVLB  02
10D7:  MOVWF  52
10D8:  MOVLW  1B
10D9:  MOVWF  53
10DA:  MOVLP  00
10DB:  MOVLB  00
10DC:  CALL   6CF
10DD:  MOVLP  10
....................     crlf(); printf("  Command  : %02u",command); 
10DE:  MOVLP  00
10DF:  CALL   457
10E0:  MOVLP  10
10E1:  MOVLW  9D
10E2:  MOVLB  03
10E3:  MOVWF  11
10E4:  MOVLW  03
10E5:  MOVWF  12
10E6:  BCF    03.0
10E7:  MOVLW  0D
10E8:  MOVLB  02
10E9:  MOVWF  52
10EA:  MOVLP  00
10EB:  MOVLB  00
10EC:  CALL   65B
10ED:  MOVLP  10
10EE:  MOVF   70,W
10EF:  MOVLB  02
10F0:  MOVWF  52
10F1:  MOVLW  01
10F2:  MOVWF  53
10F3:  MOVLP  00
10F4:  MOVLB  00
10F5:  CALL   6CF
10F6:  MOVLP  10
....................     crlf(); printf("  Argument : %u",argument); 
10F7:  MOVLP  00
10F8:  CALL   457
10F9:  MOVLP  10
10FA:  MOVLW  A6
10FB:  MOVLB  03
10FC:  MOVWF  11
10FD:  MOVLW  03
10FE:  MOVWF  12
10FF:  BCF    03.0
1100:  MOVLW  0D
1101:  MOVLB  02
1102:  MOVWF  52
1103:  MOVLP  00
1104:  MOVLB  00
1105:  CALL   65B
1106:  MOVLP  10
1107:  MOVLB  01
1108:  MOVF   42,W
1109:  MOVLB  02
110A:  MOVWF  52
110B:  MOVLW  1B
110C:  MOVWF  53
110D:  MOVLP  00
110E:  MOVLB  00
110F:  CALL   6CF
1110:  MOVLP  10
....................     crlf(); printf("  Value    : %u",value); 
1111:  MOVLP  00
1112:  CALL   457
1113:  MOVLP  10
1114:  MOVLW  AE
1115:  MOVLB  03
1116:  MOVWF  11
1117:  MOVLW  03
1118:  MOVWF  12
1119:  BCF    03.0
111A:  MOVLW  0D
111B:  MOVLB  02
111C:  MOVWF  52
111D:  MOVLP  00
111E:  MOVLB  00
111F:  CALL   65B
1120:  MOVLP  10
1121:  MOVLB  01
1122:  MOVF   43,W
1123:  MOVLB  02
1124:  MOVWF  52
1125:  MOVLW  1B
1126:  MOVWF  53
1127:  MOVLP  00
1128:  MOVLB  00
1129:  CALL   6CF
112A:  MOVLP  10
....................   } 
....................   switch(command) { 
112B:  MOVLW  02
112C:  SUBWF  70,W
112D:  ADDLW  F5
112E:  BTFSC  03.0
112F:  GOTO   4EE
1130:  ADDLW  0B
1131:  GOTO   4EF
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
11EB:  GOTO   4EE
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
11EC:  MOVLB  01
11ED:  RLF    42,W
11EE:  MOVWF  77
11EF:  RLF    77,F
11F0:  MOVLW  FC
11F1:  ANDWF  77,F
11F2:  MOVF   77,W
11F3:  MOVLB  02
11F4:  MOVWF  2E
11F5:  INCF   2E,W
11F6:  MOVLP  00
11F7:  MOVLB  00
11F8:  CALL   043
11F9:  MOVLP  10
11FA:  MOVWF  7A
11FB:  MOVLB  02
11FC:  MOVF   2E,W
11FD:  MOVLP  00
11FE:  MOVLB  00
11FF:  CALL   043
1200:  MOVLP  10
1201:  MOVLB  02
1202:  MOVWF  22
1203:  MOVF   7A,W
1204:  MOVWF  23
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
1205:  MOVLW  01
1206:  MOVWF  7A
1207:  MOVLW  8F
1208:  MOVWF  2E
1209:  MOVF   7A,W
120A:  MOVWF  2F
120B:  CLRF   31
120C:  MOVLB  01
120D:  MOVF   42,W
120E:  MOVLB  02
120F:  MOVWF  30
1210:  MOVF   31,W
1211:  MOVWF  40
1212:  MOVF   30,W
1213:  MOVWF  3F
1214:  CLRF   42
1215:  MOVLW  06
1216:  MOVWF  41
1217:  MOVLP  08
1218:  MOVLB  00
1219:  CALL   746
121A:  MOVLP  10
121B:  MOVF   78,W
121C:  MOVLB  02
121D:  ADDWF  2E,W
121E:  MOVWF  26
121F:  MOVF   79,W
1220:  ADDWFC 2F,W
1221:  MOVWF  27
....................       romstrcpy(rname,cPtr); 
1222:  MOVLW  20
1223:  MOVWF  3E
1224:  MOVLW  A8
1225:  MOVWF  3D
1226:  MOVF   27,W
1227:  MOVWF  40
1228:  MOVF   26,W
1229:  MOVWF  3F
122A:  MOVLP  08
122B:  MOVLB  00
122C:  CALL   75D
122D:  MOVLP  10
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
122E:  MOVLB  02
122F:  MOVF   23,W
1230:  MOVWF  7A
1231:  MOVF   22,W
1232:  MOVWF  04
1233:  MOVF   23,W
1234:  MOVWF  05
1235:  MOVF   00,W
1236:  MOVWF  2E
1237:  MOVLW  20
1238:  MOVLB  01
1239:  MOVWF  67
123A:  MOVLW  7A
123B:  MOVWF  66
123C:  MOVLW  5B
123D:  MOVLB  02
123E:  MOVWF  52
123F:  MOVLP  08
1240:  MOVLB  00
1241:  CALL   095
1242:  MOVLP  10
1243:  MOVLB  01
1244:  MOVF   42,W
1245:  MOVLB  02
1246:  MOVWF  2F
1247:  MOVLW  01
1248:  MOVWF  30
1249:  MOVLB  00
124A:  CALL   000
124B:  MOVLW  5D
124C:  MOVLB  02
124D:  MOVWF  52
124E:  MOVLP  08
124F:  MOVLB  00
1250:  CALL   095
1251:  MOVLP  10
1252:  MOVLW  20
1253:  MOVLB  02
1254:  MOVWF  52
1255:  MOVLP  08
1256:  MOVLB  00
1257:  CALL   095
1258:  MOVLP  10
1259:  MOVLW  20
125A:  MOVWF  05
125B:  MOVLW  A8
125C:  MOVWF  04
125D:  MOVLP  08
125E:  CALL   0F7
125F:  MOVLP  10
1260:  MOVLW  20
1261:  MOVLB  02
1262:  MOVWF  52
1263:  MOVLP  08
1264:  MOVLB  00
1265:  CALL   095
1266:  MOVLP  10
1267:  MOVLB  02
1268:  MOVF   2E,W
1269:  MOVWF  2F
126A:  MOVLW  1B
126B:  MOVWF  30
126C:  MOVLB  00
126D:  CALL   000
126E:  MOVLW  0A
126F:  MOVLB  02
1270:  MOVWF  52
1271:  MOVLP  08
1272:  MOVLB  00
1273:  CALL   095
1274:  MOVLP  10
1275:  MOVLW  0D
1276:  MOVLB  02
1277:  MOVWF  52
1278:  MOVLP  08
1279:  MOVLB  00
127A:  CALL   095
127B:  MOVLP  10
....................       crlf(); 
127C:  MOVLP  00
127D:  CALL   457
127E:  MOVLP  10
....................       printf("%s",LCD_str); 
127F:  MOVLW  20
1280:  MOVWF  05
1281:  MOVLW  7A
1282:  MOVWF  04
1283:  MOVLP  08
1284:  CALL   1DA
1285:  MOVLP  10
....................       lcd_send(2,LCD_str); 
1286:  MOVLW  02
1287:  MOVLB  02
1288:  MOVWF  4C
1289:  MOVLW  20
128A:  MOVWF  4E
128B:  MOVLW  7A
128C:  MOVWF  4D
128D:  MOVLP  08
128E:  MOVLB  00
128F:  CALL   10C
1290:  MOVLP  10
....................       prompt(); 
1291:  CALL   049
....................       break; 
1292:  GOTO   4EE
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
1293:  MOVLP  08
1294:  CALL   788
1295:  MOVLP  10
1296:  MOVF   78,F
1297:  BTFSC  03.2
1298:  GOTO   29C
....................         store_variables(); 
1299:  MOVLP  00
129A:  CALL   559
129B:  MOVLP  10
....................       } 
....................       break; 
129C:  GOTO   4EE
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
129D:  MOVLB  01
129E:  DECFSZ 43,W
129F:  GOTO   2A4
....................         init_src=USE_EEPROM_VARS; 
12A0:  MOVLB  02
12A1:  BSF    24.0
....................       } else { 
12A2:  GOTO   2A6
12A3:  MOVLB  01
....................         init_src=USE_DEFAULT_VARS; 
12A4:  MOVLB  02
12A5:  BCF    24.0
....................       } 
....................       if ( in_admin_mode() ) { 
12A6:  MOVLP  08
12A7:  MOVLB  00
12A8:  CALL   788
12A9:  MOVLP  10
12AA:  MOVF   78,F
12AB:  BTFSC  03.2
12AC:  GOTO   2B7
....................         init_variables(init_src); 
12AD:  MOVLW  00
12AE:  MOVLB  02
12AF:  BTFSC  24.0
12B0:  MOVLW  01
12B1:  MOVWF  2E
12B2:  MOVWF  2F
12B3:  MOVLP  00
12B4:  MOVLB  00
12B5:  CALL   5D7
12B6:  MOVLP  10
....................       } 
....................       break; 
12B7:  GOTO   4EE
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
12B8:  MOVLB  01
12B9:  MOVF   42,W
12BA:  ANDLW  03
12BB:  MOVWF  30
....................       increment(value); 
12BC:  MOVF   43,W
12BD:  MOVLB  02
12BE:  MOVWF  31
12BF:  MOVLP  08
12C0:  MOVLB  00
12C1:  CALL   797
12C2:  MOVLP  10
....................       PROMPT_FLAG=1; 
12C3:  MOVLB  01
12C4:  BSF    65.0
....................       break; 
12C5:  MOVLB  00
12C6:  GOTO   4EE
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
12C7:  MOVLB  01
12C8:  MOVF   42,W
12C9:  ANDLW  03
12CA:  MOVWF  30
....................       increment(-1*value); 
12CB:  MOVLW  FF
12CC:  MOVLB  02
12CD:  MOVWF  45
12CE:  MOVLB  01
12CF:  MOVF   43,W
12D0:  MOVLB  02
12D1:  MOVWF  46
12D2:  MOVLP  08
12D3:  MOVLB  00
12D4:  CALL   6BE
12D5:  MOVLP  10
12D6:  MOVF   78,W
12D7:  MOVLB  02
12D8:  MOVWF  2E
12D9:  MOVWF  31
12DA:  MOVLP  08
12DB:  MOVLB  00
12DC:  CALL   797
12DD:  MOVLP  10
....................       PROMPT_FLAG=1; 
12DE:  MOVLB  01
12DF:  BSF    65.0
....................       break; 
12E0:  MOVLB  00
12E1:  GOTO   4EE
....................     case STATUS: 
....................       status(); 
....................       break; 
*
1488:  MOVLB  00
1489:  GOTO   4EE
....................     case ADMIN: 
....................       switch(argument) { 
148A:  MOVLB  01
148B:  MOVF   42,W
148C:  XORLW  02
148D:  MOVLB  00
148E:  BTFSC  03.2
148F:  GOTO   497
1490:  XORLW  03
1491:  BTFSC  03.2
1492:  GOTO   49E
1493:  XORLW  02
1494:  BTFSC  03.2
1495:  GOTO   4A6
1496:  GOTO   4A8
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
1497:  MOVLP  08
1498:  CALL   788
1499:  MOVLP  10
149A:  MOVF   78,F
149B:  BTFSS  03.2
....................             reset_cpu(); 
149C:  RESET
....................           } 
....................           break; 
149D:  GOTO   4AE
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
149E:  MOVLW  01
149F:  MOVLB  02
14A0:  MOVWF  42
14A1:  MOVLP  08
14A2:  MOVLB  00
14A3:  CALL   42C
14A4:  MOVLP  10
....................           break; 
14A5:  GOTO   4AE
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
14A6:  CALL   071
....................         break; 
14A7:  GOTO   4AE
....................         default: 
....................           set_admin_mode(0); 
14A8:  MOVLB  02
14A9:  CLRF   42
14AA:  MOVLP  08
14AB:  MOVLB  00
14AC:  CALL   42C
14AD:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
14AE:  GOTO   4EE
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
.................... #ifdef LCD_TYPE_PI 
....................       switch(value) { 
....................         case 0 : init_lcd();break;   
....................         case 1 : lcd_write(0,0x01); 
....................       } 
.................... #else 
....................       lcd_cmd=4+(value&0x03); 
14AF:  MOVLB  01
14B0:  MOVF   43,W
14B1:  ANDLW  03
14B2:  ADDLW  04
14B3:  MOVLB  02
14B4:  MOVWF  25
....................       sprintf(LCD_str,"I2C => %d",lcd_cmd); 
14B5:  MOVLW  20
14B6:  MOVLB  01
14B7:  MOVWF  67
14B8:  MOVLW  7A
14B9:  MOVWF  66
14BA:  MOVLW  B6
14BB:  MOVLB  03
14BC:  MOVWF  11
14BD:  MOVLW  03
14BE:  MOVWF  12
14BF:  BCF    03.0
14C0:  MOVLW  07
14C1:  MOVLB  02
14C2:  MOVWF  4C
14C3:  MOVLP  08
14C4:  MOVLB  00
14C5:  CALL   0A4
14C6:  MOVLP  10
14C7:  MOVLB  02
14C8:  MOVF   25,W
14C9:  MOVWF  4C
14CA:  MOVLW  18
14CB:  MOVWF  4D
14CC:  MOVLP  08
14CD:  MOVLB  00
14CE:  CALL   173
14CF:  MOVLP  10
....................       crlf(); 
14D0:  MOVLP  00
14D1:  CALL   457
14D2:  MOVLP  10
....................       printf("%s",LCD_str); 
14D3:  MOVLW  20
14D4:  MOVWF  05
14D5:  MOVLW  7A
14D6:  MOVWF  04
14D7:  MOVLP  08
14D8:  CALL   1DA
14D9:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
14DA:  MOVLB  02
14DB:  MOVF   25,W
14DC:  MOVWF  4C
14DD:  MOVLW  20
14DE:  MOVWF  4E
14DF:  MOVLW  7A
14E0:  MOVWF  4D
14E1:  MOVLP  08
14E2:  MOVLB  00
14E3:  CALL   10C
14E4:  MOVLP  10
.................... #endif 
....................       break; 
14E5:  GOTO   4EE
.................... #if __DEVICE__  == 1939 
....................     case SET_BIT: 
....................       set_bit(); 
....................       break; 
....................     case CLEAR_BIT: 
....................       clear_bit(); 
....................       break; 
.................... #endif 
....................     case MORSE_SEND: 
....................       morse(value); 
14E6:  MOVLB  01
14E7:  MOVF   43,W
14E8:  MOVLB  02
14E9:  MOVWF  41
14EA:  MOVLP  08
14EB:  MOVLB  00
14EC:  CALL   038
14ED:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
14EE:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  4C
1803:  MOVLW  20
1804:  MOVWF  4E
1805:  MOVLW  50
1806:  MOVWF  4D
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   10C
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVLB  01
180D:  MOVWF  42
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B6C:  MOVLB  01
1B6D:  CLRF   69
1B6E:  CLRF   68
1B6F:  MOVF   69,F
1B70:  BTFSS  03.2
1B71:  GOTO   3C0
1B72:  MOVF   68,W
1B73:  SUBLW  38
1B74:  BTFSS  03.0
1B75:  GOTO   3C0
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B76:  MOVLW  01
1B77:  MOVWF  7A
1B78:  MOVLW  8F
1B79:  MOVLB  02
1B7A:  MOVWF  22
1B7B:  MOVF   7A,W
1B7C:  MOVWF  23
1B7D:  MOVLB  01
1B7E:  MOVF   69,W
1B7F:  MOVLB  02
1B80:  MOVWF  40
1B81:  MOVLB  01
1B82:  MOVF   68,W
1B83:  MOVLB  02
1B84:  MOVWF  3F
1B85:  CLRF   42
1B86:  MOVLW  06
1B87:  MOVWF  41
1B88:  MOVLP  08
1B89:  MOVLB  00
1B8A:  CALL   746
1B8B:  MOVLP  18
1B8C:  MOVF   78,W
1B8D:  MOVLB  02
1B8E:  ADDWF  22,W
1B8F:  MOVLB  01
1B90:  MOVWF  6A
1B91:  MOVF   79,W
1B92:  MOVLB  02
1B93:  ADDWFC 23,W
1B94:  MOVLB  01
1B95:  MOVWF  6B
....................     romstrcpy(rname,cPtr); 
1B96:  MOVLW  20
1B97:  MOVLB  02
1B98:  MOVWF  3E
1B99:  MOVLW  9C
1B9A:  MOVWF  3D
1B9B:  MOVLB  01
1B9C:  MOVF   6B,W
1B9D:  MOVLB  02
1B9E:  MOVWF  40
1B9F:  MOVLB  01
1BA0:  MOVF   6A,W
1BA1:  MOVLB  02
1BA2:  MOVWF  3F
1BA3:  MOVLP  08
1BA4:  MOVLB  00
1BA5:  CALL   75D
1BA6:  MOVLP  18
....................     if(my_stricmp(argument_name,rname)==0) { 
1BA7:  MOVLW  20
1BA8:  MOVLB  02
1BA9:  MOVWF  42
1BAA:  MOVLW  74
1BAB:  MOVWF  41
1BAC:  MOVLW  20
1BAD:  MOVWF  44
1BAE:  MOVLW  9C
1BAF:  MOVWF  43
1BB0:  MOVLP  08
1BB1:  MOVLB  00
1BB2:  CALL   71E
1BB3:  MOVLP  18
1BB4:  MOVF   78,F
1BB5:  BTFSS  03.2
1BB6:  GOTO   3BB
....................       argument=x; 
1BB7:  MOVLB  01
1BB8:  MOVF   68,W
1BB9:  MOVWF  42
1BBA:  MOVLB  00
....................     } 
....................   } 
1BBB:  MOVLB  01
1BBC:  INCF   68,F
1BBD:  BTFSC  03.2
1BBE:  INCF   69,F
1BBF:  GOTO   36F
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BC0:  MOVF   42,W
1BC1:  SUBLW  FF
1BC2:  BTFSS  03.2
1BC3:  GOTO   428
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BC4:  MOVLW  20
1BC5:  MOVLB  02
1BC6:  MOVWF  42
1BC7:  MOVLW  74
1BC8:  MOVWF  41
1BC9:  MOVLP  08
1BCA:  MOVLB  00
1BCB:  CALL   6E5
1BCC:  MOVLP  18
1BCD:  MOVF   78,W
1BCE:  MOVLB  01
1BCF:  MOVWF  43
....................     strcpy(rname,"eeprom"); 
1BD0:  MOVLB  02
1BD1:  CLRF   22
1BD2:  CLRF   23
1BD3:  MOVLW  20
1BD4:  MOVWF  05
1BD5:  MOVLW  9C
1BD6:  MOVWF  04
1BD7:  MOVF   22,W
1BD8:  ADDWF  04,F
1BD9:  MOVLW  00
1BDA:  ADDWFC 05,F
1BDB:  MOVF   23,W
1BDC:  MOVLP  00
1BDD:  MOVLB  00
1BDE:  CALL   128
1BDF:  MOVLP  18
1BE0:  MOVWF  00
1BE1:  IORLW  00
1BE2:  BTFSC  03.2
1BE3:  GOTO   3E9
1BE4:  MOVLB  02
1BE5:  INCF   23,F
1BE6:  INCF   22,F
1BE7:  GOTO   3D3
1BE8:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1BE9:  MOVLW  20
1BEA:  MOVLB  02
1BEB:  MOVWF  42
1BEC:  MOVLW  74
1BED:  MOVWF  41
1BEE:  MOVLW  20
1BEF:  MOVWF  44
1BF0:  MOVLW  9C
1BF1:  MOVWF  43
1BF2:  MOVLP  08
1BF3:  MOVLB  00
1BF4:  CALL   71E
1BF5:  MOVLP  18
1BF6:  MOVF   78,F
1BF7:  BTFSS  03.2
1BF8:  GOTO   3FD
....................       value=USE_EEPROM_VARS; 
1BF9:  MOVLW  01
1BFA:  MOVLB  01
1BFB:  MOVWF  43
1BFC:  MOVLB  00
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BFD:  MOVLB  02
1BFE:  CLRF   22
1BFF:  CLRF   23
1C00:  MOVLW  20
1C01:  MOVWF  05
1C02:  MOVLW  9C
1C03:  MOVWF  04
1C04:  MOVF   22,W
1C05:  ADDWF  04,F
1C06:  MOVLW  00
1C07:  ADDWFC 05,F
1C08:  MOVF   23,W
1C09:  MOVLP  00
1C0A:  MOVLB  00
1C0B:  CALL   130
1C0C:  MOVLP  18
1C0D:  MOVWF  00
1C0E:  IORLW  00
1C0F:  BTFSC  03.2
1C10:  GOTO   416
1C11:  MOVLB  02
1C12:  INCF   23,F
1C13:  INCF   22,F
1C14:  GOTO   400
1C15:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C16:  MOVLW  20
1C17:  MOVLB  02
1C18:  MOVWF  42
1C19:  MOVLW  74
1C1A:  MOVWF  41
1C1B:  MOVLW  20
1C1C:  MOVWF  44
1C1D:  MOVLW  9C
1C1E:  MOVWF  43
1C1F:  MOVLP  08
1C20:  MOVLB  00
1C21:  CALL   71E
1C22:  MOVLP  18
1C23:  MOVF   78,F
1C24:  BTFSS  03.2
1C25:  GOTO   429
....................       value=USE_DEFAULT_VARS; 
1C26:  MOVLB  01
1C27:  CLRF   43
1C28:  MOVLB  00
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C29:  MOVF   70,W
1C2A:  SUBLW  06
1C2B:  BTFSC  03.2
1C2C:  GOTO   431
1C2D:  MOVF   70,W
1C2E:  SUBLW  07
1C2F:  BTFSS  03.2
1C30:  GOTO   437
....................     value = 1; 
1C31:  MOVLW  01
1C32:  MOVLB  01
1C33:  MOVWF  43
....................     argument = CurrentTrimPot; 
1C34:  MOVF   30,W
1C35:  MOVWF  42
1C36:  MOVLB  00
....................   } 
....................   rs232_mode = 1; 
1C37:  MOVLB  01
1C38:  BSF    65.2
....................   execute_command(); 
1C39:  MOVLP  10
1C3A:  MOVLB  00
1C3B:  CALL   0B3
1C3C:  MOVLP  18
....................   rs232_mode = 0; 
1C3D:  MOVLB  01
1C3E:  BCF    65.2
.................... } // }}} 
1C3F:  MOVLP  18
1C40:  MOVLB  00
1C41:  GOTO   749 (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
12E2:  MOVLW  1B
12E3:  MOVLP  00
12E4:  CALL   2E4
12E5:  MOVLP  10
....................   printf("[2J"); 
12E6:  MOVLW  5B
12E7:  CLRWDT
12E8:  BTFSS  11.4
12E9:  GOTO   2E7
12EA:  MOVLB  03
12EB:  MOVWF  1A
12EC:  MOVLW  32
12ED:  CLRWDT
12EE:  MOVLB  00
12EF:  BTFSC  11.4
12F0:  GOTO   2F3
12F1:  MOVLB  03
12F2:  GOTO   2ED
12F3:  MOVLB  03
12F4:  MOVWF  1A
12F5:  MOVLW  4A
12F6:  CLRWDT
12F7:  MOVLB  00
12F8:  BTFSC  11.4
12F9:  GOTO   2FC
12FA:  MOVLB  03
12FB:  GOTO   2F6
12FC:  MOVLB  03
12FD:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
12FE:  MOVLW  1B
12FF:  MOVLP  00
1300:  MOVLB  00
1301:  CALL   2E4
1302:  MOVLP  10
....................   printf("[0;0H"); 
1303:  MOVLW  BB
1304:  MOVLB  03
1305:  MOVWF  11
1306:  MOVLW  03
1307:  MOVWF  12
1308:  MOVLP  00
1309:  MOVLB  00
130A:  CALL   45C
130B:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
071E:  MOVLB  02
071F:  SWAPF  41,W
0720:  MOVWF  43
0721:  RLF    43,F
0722:  RLF    43,F
0723:  MOVLW  C0
0724:  ANDWF  43,F
....................   tx_value=tx_value + (value & 0x3F); 
0725:  MOVF   42,W
0726:  ANDLW  3F
0727:  ADDWF  43,F
....................   i2c_start(); 
0728:  MOVLB  04
0729:  BSF    16.0
072A:  BTFSC  16.0
072B:  GOTO   72A
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
072C:  MOVLW  50
072D:  MOVLB  02
072E:  MOVWF  52
072F:  MOVLB  00
0730:  CALL   646
0731:  MOVF   78,W
0732:  MOVLB  02
0733:  BCF    44.0
0734:  BTFSC  78.0
0735:  BSF    44.0
....................   if ( ack != 0) { 
0736:  BTFSS  44.0
0737:  GOTO   742
....................     crlf(); 
0738:  MOVLB  00
0739:  CALL   457
....................     printf("I2C : !ACK"); 
073A:  MOVLW  BE
073B:  MOVLB  03
073C:  MOVWF  11
073D:  MOVLW  03
073E:  MOVWF  12
073F:  MOVLB  00
0740:  CALL   45C
0741:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
0742:  MOVF   43,W
0743:  MOVWF  52
0744:  MOVLB  00
0745:  CALL   646
....................   i2c_stop();   
0746:  MOVLB  04
0747:  BSF    16.2
0748:  BTFSC  16.2
0749:  GOTO   748
....................   crlf(); 
074A:  MOVLB  00
074B:  CALL   457
....................   printf("Pot(%u)<=%u",pot,value); 
074C:  MOVLW  C4
074D:  MOVLB  03
074E:  MOVWF  11
074F:  MOVLW  03
0750:  MOVWF  12
0751:  BCF    03.0
0752:  MOVLW  04
0753:  MOVLB  02
0754:  MOVWF  52
0755:  MOVLB  00
0756:  CALL   65B
0757:  MOVLB  02
0758:  MOVF   41,W
0759:  MOVWF  52
075A:  MOVLW  1B
075B:  MOVWF  53
075C:  MOVLB  00
075D:  CALL   6CF
075E:  MOVLW  29
075F:  CLRWDT
0760:  BTFSS  11.4
0761:  GOTO   75F
0762:  MOVLB  03
0763:  MOVWF  1A
0764:  MOVLW  3C
0765:  CLRWDT
0766:  MOVLB  00
0767:  BTFSC  11.4
0768:  GOTO   76B
0769:  MOVLB  03
076A:  GOTO   765
076B:  MOVLB  03
076C:  MOVWF  1A
076D:  MOVLW  3D
076E:  CLRWDT
076F:  MOVLB  00
0770:  BTFSC  11.4
0771:  GOTO   774
0772:  MOVLB  03
0773:  GOTO   76E
0774:  MOVLB  03
0775:  MOVWF  1A
0776:  MOVLB  02
0777:  MOVF   42,W
0778:  MOVWF  52
0779:  MOVLW  1B
077A:  MOVWF  53
077B:  MOVLB  00
077C:  CALL   6CF
....................  
.................... } // }}} 
077D:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
0838:  MOVLW  DB
0839:  MOVLB  02
083A:  ADDWF  41,W
083B:  MOVWF  45
083C:  MOVLW  1F
083D:  MOVWF  46
083E:  BTFSC  03.0
083F:  INCF   46,F
0840:  MOVF   46,W
0841:  MOVLB  03
0842:  MOVWF  12
0843:  MOVLB  02
0844:  MOVF   45,W
0845:  MOVLB  03
0846:  MOVWF  11
0847:  MOVLW  20
0848:  MOVWF  05
0849:  MOVLW  C2
084A:  MOVWF  04
084B:  MOVLW  01
084C:  MOVLB  02
084D:  MOVWF  47
084E:  MOVLP  00
084F:  MOVLB  00
0850:  CALL   797
0851:  MOVLP  08
....................    
....................   PROMPT_FLAG=1; 
0852:  MOVLB  01
0853:  BSF    65.0
....................   for(x=0;x<4;x++) { 
0854:  MOVLB  02
0855:  CLRF   43
0856:  MOVF   43,W
0857:  SUBLW  03
0858:  BTFSS  03.0
0859:  GOTO   082
....................     do_delay=1; 
085A:  BSF    44.0
....................     switch(mc & 0xc0) { // Check two MSB's 
085B:  MOVF   42,W
085C:  ANDLW  C0
085D:  XORLW  40
085E:  MOVLB  00
085F:  BTFSC  03.2
0860:  GOTO   065
0861:  XORLW  C0
0862:  BTFSC  03.2
0863:  GOTO   069
0864:  GOTO   06B
....................       case(0x40): 
....................         dit(); 
0865:  MOVLP  00
0866:  CALL   7AA
0867:  MOVLP  08
....................         break; 
0868:  GOTO   06E
....................       case(0x80): 
....................         dah(); 
0869:  CALL   000
....................         break; 
086A:  GOTO   06E
....................       default: 
....................         do_delay=0; 
086B:  MOVLB  02
086C:  BCF    44.0
....................         break; 
086D:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
086E:  MOVLB  02
086F:  RLF    42,F
0870:  RLF    42,F
0871:  MOVLW  FC
0872:  ANDWF  42,F
....................     if ( do_delay ) { 
0873:  BTFSS  44.0
0874:  GOTO   080
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
0875:  MOVLB  01
0876:  CLRF   34
0877:  MOVLW  02
0878:  MOVWF  33
....................       while(aux_timer) { 
0879:  MOVF   33,W
087A:  IORWF  34,W
087B:  BTFSC  03.2
087C:  GOTO   07F
....................         delay_cycles(1); 
087D:  NOP
....................       } 
087E:  GOTO   079
087F:  MOVLB  02
....................     } 
....................   } 
0880:  INCF   43,F
0881:  GOTO   056
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
0882:  MOVF   41,W
0883:  SUBLW  09
0884:  BTFSS  03.0
0885:  GOTO   093
....................     if ( c < 5 ) { 
0886:  MOVF   41,W
0887:  SUBLW  04
0888:  BTFSS  03.0
0889:  GOTO   08E
....................       dah(); 
088A:  MOVLB  00
088B:  CALL   000
....................     } 
....................     else { 
088C:  GOTO   092
088D:  MOVLB  02
....................       dit(); 
088E:  MOVLP  00
088F:  MOVLB  00
0890:  CALL   7AA
0891:  MOVLP  08
0892:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
0893:  MOVLB  00
0894:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0AE2:  MOVLW  30
0AE3:  MOVLB  02
0AE4:  MOVWF  36
0AE5:  MOVWF  37
0AE6:  MOVWF  38
0AE7:  MOVWF  39
0AE8:  CLRF   3A
....................   char PTT_s[5]={'0','0','0','0',0}; 
0AE9:  MOVWF  3B
0AEA:  MOVWF  3C
0AEB:  MOVWF  3D
0AEC:  MOVWF  3E
0AED:  CLRF   3F
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0AEE:  MOVF   30,W
0AEF:  MOVWF  75
....................  
....................   if ( cor ) { 
0AF0:  MOVF   30,F
0AF1:  BTFSC  03.2
0AF2:  GOTO   304
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0AF3:  MOVLW  01
0AF4:  SUBWF  30,W
0AF5:  ADDLW  29
0AF6:  MOVWF  04
0AF7:  MOVLW  20
0AF8:  MOVWF  05
0AF9:  BTFSC  03.0
0AFA:  INCF   05,F
0AFB:  MOVF   00,W
0AFC:  MOVWF  41
0AFD:  MOVLB  00
0AFE:  MOVF   62,W
0AFF:  ANDWF  63,W
0B00:  MOVLB  02
0B01:  ANDWF  41,W
0B02:  MOVWF  35
....................   } else { 
0B03:  GOTO   347
....................     ptt=0; 
0B04:  CLRF   35
....................     if ( COR_DROP_FLAG ) { 
0B05:  MOVLB  01
0B06:  BTFSS  62.0
0B07:  GOTO   348
....................       COR_DROP_FLAG=0; 
0B08:  BCF    62.0
....................       if ( ConfirmChar || TailChar ) { 
0B09:  MOVF   73,F
0B0A:  BTFSS  03.2
0B0B:  GOTO   30F
0B0C:  MOVF   72,F
0B0D:  BTFSC  03.2
0B0E:  GOTO   348
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0B48:  MOVLW  01
0B49:  MOVLB  02
0B4A:  MOVWF  34
....................   for(x=0;x<4;x++) { 
0B4B:  CLRF   31
0B4C:  MOVF   31,W
0B4D:  SUBLW  03
0B4E:  BTFSS  03.0
0B4F:  GOTO   3B8
....................     if ( !cor ) { 
0B50:  MOVF   30,F
0B51:  BTFSS  03.2
0B52:  GOTO   356
....................       rx_bit=0; 
0B53:  BCF    40.0
....................       ptt_bit=0; 
0B54:  BCF    40.1
....................     } else { 
0B55:  GOTO   365
....................       if ( cor == (x+1) ) { 
0B56:  MOVLW  01
0B57:  ADDWF  31,W
0B58:  SUBWF  30,W
0B59:  BTFSS  03.2
0B5A:  GOTO   35F
....................         rx_bit=1; 
0B5B:  BSF    40.0
....................         CurrentCorMask=mask; 
0B5C:  MOVF   34,W
0B5D:  MOVWF  74
....................       } else { 
0B5E:  GOTO   360
....................         rx_bit=0; 
0B5F:  BCF    40.0
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0B60:  BCF    40.1
0B61:  MOVF   35,W
0B62:  ANDWF  34,W
0B63:  BTFSS  03.2
0B64:  BSF    40.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0B65:  MOVF   31,W
0B66:  MOVLP  00
0B67:  MOVLB  00
0B68:  CALL   031
0B69:  MOVLP  08
0B6A:  MOVLB  02
0B6B:  MOVWF  41
0B6C:  MOVLW  00
0B6D:  BTFSC  40.0
0B6E:  MOVLW  01
0B6F:  MOVWF  77
0B70:  MOVF   41,W
0B71:  MOVWF  42
0B72:  MOVF   77,W
0B73:  MOVWF  43
0B74:  MOVLW  01
0B75:  MOVWF  45
0B76:  CLRF   44
0B77:  MOVLP  00
0B78:  MOVLB  00
0B79:  CALL   7D8
0B7A:  MOVLP  08
0B7B:  MOVLB  02
0B7C:  MOVF   41,W
0B7D:  MOVWF  42
0B7E:  CLRF   43
0B7F:  CLRF   45
0B80:  MOVLW  80
0B81:  MOVWF  44
0B82:  MOVLP  00
0B83:  MOVLB  00
0B84:  CALL   7D8
0B85:  MOVLP  08
....................     output_bit(PTT_PIN[x],ptt_bit); 
0B86:  MOVLB  02
0B87:  MOVF   31,W
0B88:  MOVLP  00
0B89:  MOVLB  00
0B8A:  CALL   036
0B8B:  MOVLP  08
0B8C:  MOVLB  02
0B8D:  MOVWF  41
0B8E:  MOVLW  00
0B8F:  BTFSC  40.1
0B90:  MOVLW  01
0B91:  MOVWF  77
0B92:  MOVF   41,W
0B93:  MOVWF  42
0B94:  MOVF   77,W
0B95:  MOVWF  43
0B96:  MOVLW  01
0B97:  MOVWF  45
0B98:  CLRF   44
0B99:  MOVLP  00
0B9A:  MOVLB  00
0B9B:  CALL   7D8
0B9C:  MOVLP  08
0B9D:  MOVLB  02
0B9E:  MOVF   41,W
0B9F:  MOVWF  42
0BA0:  CLRF   43
0BA1:  CLRF   45
0BA2:  MOVLW  80
0BA3:  MOVWF  44
0BA4:  MOVLP  00
0BA5:  MOVLB  00
0BA6:  CALL   7D8
0BA7:  MOVLP  08
....................     if(ptt_bit) { 
0BA8:  MOVLB  02
0BA9:  BTFSS  40.1
0BAA:  GOTO   3B4
....................       PTT_s[x]='1'; 
0BAB:  MOVLW  BB
0BAC:  ADDWF  31,W
0BAD:  MOVWF  04
0BAE:  MOVLW  20
0BAF:  MOVWF  05
0BB0:  BTFSC  03.0
0BB1:  INCF   05,F
0BB2:  MOVLW  31
0BB3:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0BB4:  BCF    03.0
0BB5:  RLF    34,F
....................   }  
0BB6:  INCF   31,F
0BB7:  GOTO   34C
....................   if(!cor) { 
0BB8:  MOVF   30,F
0BB9:  BTFSS  03.2
0BBA:  GOTO   3BD
....................     CurrentCorPriority=0; 
0BBB:  CLRF   76
....................   } else { 
0BBC:  GOTO   3EB
....................     CurrentCorPriority=RXPriority[cor-1]; 
0BBD:  MOVLW  01
0BBE:  SUBWF  30,W
0BBF:  ADDLW  25
0BC0:  MOVWF  04
0BC1:  MOVLW  20
0BC2:  MOVWF  05
0BC3:  BTFSC  03.0
0BC4:  INCF   05,F
0BC5:  MOVF   00,W
0BC6:  MOVWF  76
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0BC7:  CLRF   32
0BC8:  MOVF   32,W
0BC9:  SUBLW  03
0BCA:  BTFSS  03.0
0BCB:  GOTO   3E8
....................       pot_val=RX_GAIN[cor-1][pot]; 
0BCC:  MOVLW  01
0BCD:  SUBWF  30,W
0BCE:  MOVWF  77
0BCF:  RLF    77,F
0BD0:  RLF    77,F
0BD1:  MOVLW  FC
0BD2:  ANDWF  77,F
0BD3:  MOVF   77,W
0BD4:  ADDWF  32,W
0BD5:  ADDLW  0C
0BD6:  MOVWF  04
0BD7:  MOVLW  20
0BD8:  MOVWF  05
0BD9:  BTFSC  03.0
0BDA:  INCF   05,F
0BDB:  MOVF   00,W
0BDC:  MOVWF  33
....................       set_trimpot(pot,pot_val); 
0BDD:  MOVF   32,W
0BDE:  MOVWF  41
0BDF:  MOVF   33,W
0BE0:  MOVWF  42
0BE1:  MOVLP  00
0BE2:  MOVLB  00
0BE3:  CALL   71E
0BE4:  MOVLP  08
....................     } 
0BE5:  MOVLB  02
0BE6:  INCF   32,F
0BE7:  GOTO   3C8
....................     PROMPT_FLAG=1; 
0BE8:  MOVLB  01
0BE9:  BSF    65.0
0BEA:  MOVLB  02
....................   } 
....................   COR_s[cor-1]='1'; 
0BEB:  MOVLW  01
0BEC:  SUBWF  30,W
0BED:  ADDLW  B6
0BEE:  MOVWF  04
0BEF:  MOVLW  20
0BF0:  MOVWF  05
0BF1:  BTFSC  03.0
0BF2:  INCF   05,F
0BF3:  MOVLW  31
0BF4:  MOVWF  00
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0BF5:  MOVLW  20
0BF6:  MOVLB  01
0BF7:  MOVWF  67
0BF8:  MOVLW  7A
0BF9:  MOVWF  66
0BFA:  MOVLW  CA
0BFB:  MOVLB  03
0BFC:  MOVWF  11
0BFD:  MOVLW  03
0BFE:  MOVWF  12
0BFF:  BCF    03.0
0C00:  MOVLW  04
0C01:  MOVLB  02
0C02:  MOVWF  4C
0C03:  MOVLB  00
0C04:  CALL   0A4
0C05:  MOVLW  20
0C06:  MOVWF  05
0C07:  MOVLW  B6
0C08:  MOVWF  04
0C09:  CALL   0F7
0C0A:  MOVLW  CD
0C0B:  MOVLB  03
0C0C:  MOVWF  11
0C0D:  MOVLW  03
0C0E:  MOVWF  12
0C0F:  BCF    03.0
0C10:  MOVLW  05
0C11:  MOVLB  02
0C12:  MOVWF  4C
0C13:  MOVLB  00
0C14:  CALL   0A4
0C15:  MOVLW  20
0C16:  MOVWF  05
0C17:  MOVLW  BB
0C18:  MOVWF  04
0C19:  CALL   0F7
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0C1A:  MOVLW  01
0C1B:  MOVLB  02
0C1C:  MOVWF  4C
0C1D:  MOVLW  20
0C1E:  MOVWF  4E
0C1F:  MOVLW  7A
0C20:  MOVWF  4D
0C21:  MOVLB  00
0C22:  CALL   10C
....................   delay_ms(50); 
0C23:  MOVLW  32
0C24:  MOVLB  02
0C25:  MOVWF  4C
0C26:  MOVLP  00
0C27:  MOVLB  00
0C28:  CALL   77E
0C29:  MOVLP  08
....................   pot_values_to_lcd(); 
0C2A:  CALL   1F4
.................... }// }}} 
0C2B:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1E4E:  MOVF   6A,W
1E4F:  SUBLW  0A
1E50:  BTFSS  03.0
1E51:  GOTO   66C
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1E52:  MOVLW  66
1E53:  ADDWF  6A,W
1E54:  MOVWF  04
1E55:  MOVLW  20
1E56:  MOVWF  05
1E57:  BTFSC  03.0
1E58:  INCF   05,F
1E59:  BTFSS  00.4
1E5A:  GOTO   66A
1E5B:  MOVLW  66
1E5C:  ADDWF  6A,W
1E5D:  MOVWF  04
1E5E:  MOVLW  20
1E5F:  MOVWF  05
1E60:  BTFSC  03.0
1E61:  INCF   05,F
1E62:  MOVF   00,W
1E63:  ANDLW  0F
1E64:  SUBLW  0C
1E65:  BTFSC  03.2
1E66:  GOTO   66A
....................       strobe=1; 
1E67:  MOVLW  01
1E68:  MOVWF  6B
....................      } else { 
1E69:  GOTO   66B
....................       strobe = 0; 
1E6A:  CLRF   6B
....................     }  
....................   } else { 
1E6B:  GOTO   66D
....................     strobe=0; 
1E6C:  CLRF   6B
....................   } 
....................   return(strobe); 
1E6D:  MOVF   6B,W
1E6E:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
1DCD:  MOVLB  01
1DCE:  MOVF   6A,W
1DCF:  SUBWF  6B,W
1DD0:  BTFSS  03.0
1DD1:  GOTO   5F7
1DD2:  MOVF   6A,W
1DD3:  SUBLW  09
1DD4:  BTFSS  03.0
1DD5:  GOTO   5F7
....................     valid=1; 
1DD6:  BSF    6E.0
....................     for(x=a;x<=b;x++) { 
1DD7:  MOVF   6A,W
1DD8:  MOVWF  6D
1DD9:  MOVF   6D,W
1DDA:  SUBWF  6B,W
1DDB:  BTFSS  03.0
1DDC:  GOTO   5F6
....................       key=(int)DTMF_ARRAY[x].Key; 
1DDD:  MOVLW  66
1DDE:  ADDWF  6D,W
1DDF:  MOVWF  04
1DE0:  MOVLW  20
1DE1:  MOVWF  05
1DE2:  BTFSC  03.0
1DE3:  INCF   05,F
1DE4:  MOVF   00,W
1DE5:  ANDLW  0F
1DE6:  MOVWF  6C
....................       if(! DTMF_ARRAY[x].Strobe ) { 
1DE7:  MOVLW  66
1DE8:  ADDWF  6D,W
1DE9:  MOVWF  04
1DEA:  MOVLW  20
1DEB:  MOVWF  05
1DEC:  BTFSC  03.0
1DED:  INCF   05,F
1DEE:  BTFSS  00.4
....................         valid=0; 
1DEF:  BCF    6E.0
....................       } 
....................      if(key==dp) { 
1DF0:  MOVF   6C,W
1DF1:  SUBLW  0C
1DF2:  BTFSC  03.2
....................         valid=0; 
1DF3:  BCF    6E.0
....................       } 
....................     } 
1DF4:  INCF   6D,F
1DF5:  GOTO   5D9
....................   } else { 
1DF6:  GOTO   5F8
....................     valid=0; 
1DF7:  BCF    6E.0
....................   } 
....................   return(valid); 
1DF8:  MOVLW  00
1DF9:  BTFSC  6E.0
1DFA:  MOVLW  01
1DFB:  MOVWF  78
.................... } // }}} 
1DFC:  MOVLB  00
1DFD:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   unsigned site_id; 
....................   unsigned digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 01 : Link commands 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : Disable Link Radio 
....................   // 11 : Enable Link Radio 
....................   // 12 : Send to I2C 
....................   // 14 : SetBit   (*52 14 <reg> <bit>) 
....................   // 15 : ClearBit (*52 15 <reg> <bit>) 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Save Settings	    : 52 04 00 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   // -- User Functions -- 
....................   // Disable AuxOut0        : 51 02 21 0 #  
....................   // Disable AuxOut0 (!Arg) : 51 02 21 #  
....................   // Enable  AuxOut1        : 51 02 22 1 # 
....................   command=0; 
1DFE:  CLRF   70
....................   value=0; 
1DFF:  MOVLB  01
1E00:  CLRF   43
....................   if ( ValidKeyRange(0,3)) { 
1E01:  CLRF   6A
1E02:  MOVLW  03
1E03:  MOVWF  6B
1E04:  MOVLB  00
1E05:  CALL   5CD
1E06:  MOVF   78,F
1E07:  BTFSC  03.2
1E08:  GOTO   6BB
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1E09:  MOVLB  01
1E0A:  MOVF   36,W
1E0B:  ANDLW  0F
1E0C:  MOVWF  6B
1E0D:  MOVLB  02
1E0E:  MOVWF  45
1E0F:  MOVLW  0A
1E10:  MOVWF  46
1E11:  MOVLP  08
1E12:  MOVLB  00
1E13:  CALL   6BE
1E14:  MOVLP  18
1E15:  MOVF   78,W
1E16:  MOVLB  01
1E17:  MOVWF  6A
1E18:  MOVF   37,W
1E19:  ANDLW  0F
1E1A:  ADDWF  6A,W
1E1B:  MOVWF  68
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1E1C:  MOVF   38,W
1E1D:  ANDLW  0F
1E1E:  MOVWF  6B
1E1F:  MOVLB  02
1E20:  MOVWF  45
1E21:  MOVLW  0A
1E22:  MOVWF  46
1E23:  MOVLP  08
1E24:  MOVLB  00
1E25:  CALL   6BE
1E26:  MOVLP  18
1E27:  MOVF   78,W
1E28:  MOVLB  01
1E29:  MOVWF  6A
1E2A:  MOVF   39,W
1E2B:  ANDLW  0F
1E2C:  ADDWF  6A,W
1E2D:  MOVWF  70
....................     if ( ValidKeyRange(4,5) ) { 
1E2E:  MOVLW  04
1E2F:  MOVWF  6A
1E30:  MOVLW  05
1E31:  MOVWF  6B
1E32:  MOVLB  00
1E33:  CALL   5CD
1E34:  MOVF   78,F
1E35:  BTFSC  03.2
1E36:  GOTO   68D
....................       // Admin mode {{{ 
....................       argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1E37:  MOVLB  01
1E38:  MOVF   3A,W
1E39:  ANDLW  0F
1E3A:  MOVWF  6B
1E3B:  MOVLB  02
1E3C:  MOVWF  45
1E3D:  MOVLW  0A
1E3E:  MOVWF  46
1E3F:  MOVLP  08
1E40:  MOVLB  00
1E41:  CALL   6BE
1E42:  MOVLP  18
1E43:  MOVF   78,W
1E44:  MOVLB  01
1E45:  MOVWF  6A
1E46:  MOVF   3B,W
1E47:  ANDLW  0F
1E48:  ADDWF  6A,W
1E49:  MOVWF  42
....................       digit=6; 
1E4A:  MOVLW  06
1E4B:  MOVWF  69
....................       while(ValidKey(digit)) { 
1E4C:  MOVF   69,W
1E4D:  MOVWF  6A
*
1E6F:  MOVF   78,F
1E70:  BTFSC  03.2
1E71:  GOTO   68B
....................        value = value * 10 + DTMF_ARRAY[digit].Key; 
1E72:  MOVF   43,W
1E73:  MOVLB  02
1E74:  MOVWF  45
1E75:  MOVLW  0A
1E76:  MOVWF  46
1E77:  MOVLP  08
1E78:  MOVLB  00
1E79:  CALL   6BE
1E7A:  MOVLP  18
1E7B:  MOVF   78,W
1E7C:  MOVLB  01
1E7D:  MOVWF  6A
1E7E:  MOVLW  66
1E7F:  ADDWF  69,W
1E80:  MOVWF  04
1E81:  MOVLW  20
1E82:  MOVWF  05
1E83:  BTFSC  03.0
1E84:  INCF   05,F
1E85:  MOVF   00,W
1E86:  ANDLW  0F
1E87:  ADDWF  6A,W
1E88:  MOVWF  43
....................        digit++; 
1E89:  INCF   69,F
....................       } 
1E8A:  GOTO   64C
....................       // Admin mode }}} 
....................     } else { 
1E8B:  GOTO   6A6
1E8C:  MOVLB  00
....................       // User function {{{ 
....................       // Only 4 digits were entered.  
....................       // Use 'command' value as user function. 
....................       switch(command) { 
1E8D:  MOVF   70,W
1E8E:  XORLW  0A
1E8F:  BTFSC  03.2
1E90:  GOTO   695
1E91:  XORLW  01
1E92:  BTFSC  03.2
1E93:  GOTO   69C
1E94:  GOTO   6A4
....................         // Commands 10 (disable link) and 11 (enable link) 
....................         case(10): 
....................           argument = 0; 
1E95:  MOVLB  01
1E96:  CLRF   42
....................           value = 0x0E; 
1E97:  MOVLW  0E
1E98:  MOVWF  43
.................... 	  command=SET_REG; 
1E99:  MOVLW  02
1E9A:  MOVWF  70
....................   	      break; 
1E9B:  GOTO   6A6
....................         case(11): 
....................           argument = 0; 
1E9C:  MOVLB  01
1E9D:  CLRF   42
....................           value = 0x0F; 
1E9E:  MOVLW  0F
1E9F:  MOVWF  43
.................... 	  command=SET_REG; 
1EA0:  MOVLW  02
1EA1:  MOVWF  70
....................    		    break; 
1EA2:  GOTO   6A6
1EA3:  MOVLB  00
.................... 	default: 
.................... 	  command=0; 
1EA4:  CLRF   70
1EA5:  MOVLB  01
....................       } 
....................       // User function }}} 
....................     } 
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1EA6:  MOVF   70,W
1EA7:  XORLW  04
1EA8:  MOVLB  00
1EA9:  BTFSC  03.2
1EAA:  GOTO   6AE
1EAB:  XORLW  01
1EAC:  BTFSS  03.2
1EAD:  GOTO   6B2
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1EAE:  MOVLB  01
1EAF:  MOVF   42,W
1EB0:  MOVWF  43
....................         break; 
1EB1:  MOVLB  00
....................     } 
....................     if ( site_id == SiteID ) { 
1EB2:  MOVF   65,W
1EB3:  MOVLB  01
1EB4:  SUBWF  68,W
1EB5:  BTFSS  03.2
1EB6:  GOTO   6BC
....................       execute_command(); 
1EB7:  MOVLP  10
1EB8:  MOVLB  00
1EB9:  CALL   0B3
1EBA:  MOVLP  18
1EBB:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1EBC:  MOVF   36,W
1EBD:  ANDLW  0F
1EBE:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1EBF:  BTFSS  65.1
1EC0:  GOTO   6F3
1EC1:  CLRF   6A
1EC2:  CLRF   6B
1EC3:  MOVLB  00
1EC4:  CALL   5CD
1EC5:  MOVF   78,F
1EC6:  BTFSS  03.2
1EC7:  GOTO   6CA
1EC8:  MOVLB  01
1EC9:  GOTO   6F3
....................     restart_wdt(); 
1ECA:  CLRWDT
....................     switch(command) { 
1ECB:  MOVF   70,W
1ECC:  XORLW  0E
1ECD:  BTFSC  03.2
1ECE:  GOTO   6D6
1ECF:  XORLW  01
1ED0:  BTFSC  03.2
1ED1:  GOTO   6E0
1ED2:  XORLW  05
1ED3:  BTFSC  03.2
1ED4:  GOTO   6E8
1ED5:  GOTO   6EF
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1ED6:  MOVLW  01
1ED7:  MOVLB  01
1ED8:  ADDWF  30,W
1ED9:  ANDLW  03
1EDA:  MOVWF  30
....................         pot_values_to_lcd(); 
1EDB:  MOVLP  08
1EDC:  MOVLB  00
1EDD:  CALL   1F4
1EDE:  MOVLP  18
....................         break; 
1EDF:  GOTO   6EF
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1EE0:  MOVLW  FF
1EE1:  MOVLB  02
1EE2:  MOVWF  31
1EE3:  MOVLP  08
1EE4:  MOVLB  00
1EE5:  CALL   797
1EE6:  MOVLP  18
....................         break; 
1EE7:  GOTO   6EF
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1EE8:  MOVLW  01
1EE9:  MOVLB  02
1EEA:  MOVWF  31
1EEB:  MOVLP  08
1EEC:  MOVLB  00
1EED:  CALL   797
1EEE:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1EEF:  MOVLP  08
1EF0:  CALL   788
1EF1:  MOVLP  18
1EF2:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1EF3:  BSF    62.7
.................... } // }}} 
1EF4:  MOVLP  18
1EF5:  MOVLB  00
1EF6:  GOTO   78C (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int cor_index; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
1608:  MOVLW  01
1609:  MOVLB  01
160A:  MOVWF  68
....................   do_update_ptt=0; 
160B:  CLRF   6B
....................   // Allow emulated COR[4] for DTMF control (No audio feed-thru) 
....................   cor_in = COR_IN ; 
160C:  MOVLB  00
160D:  MOVF   60,W
160E:  MOVLB  01
160F:  MOVWF  6A
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in & CurrentCorMask) ) { 
1610:  MOVF   76,F
1611:  BTFSC  03.2
1612:  GOTO   62A
1613:  MOVF   6A,W
1614:  ANDWF  74,W
1615:  BTFSS  03.2
1616:  GOTO   62A
....................     CurrentCorPriority=0; 
1617:  CLRF   76
....................     CurrentCorMask=0; 
1618:  CLRF   74
....................     do_update_ptt=1; 
1619:  MOVLW  01
161A:  MOVWF  6B
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
161B:  MOVF   6A,W
161C:  MOVLB  00
161D:  ANDWF  62,W
161E:  ANDWF  63,W
161F:  BTFSS  03.2
1620:  GOTO   629
....................       COR_DROP_FLAG=1; 
1621:  MOVLB  01
1622:  BSF    62.0
....................       if ( Tail ) { 
1623:  MOVLB  00
1624:  MOVF   67,F
1625:  BTFSC  03.2
1626:  GOTO   629
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
1627:  MOVF   67,W
1628:  MOVWF  72
1629:  MOVLB  01
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
162A:  CLRF   6C
....................   for(x=0;x<4;x++) { 
162B:  CLRF   6D
162C:  MOVF   6D,W
162D:  SUBLW  03
162E:  BTFSS  03.0
162F:  GOTO   668
....................     if ( cor_in & cor_mask & (~TOT_FLAG_Mask) ) { 
1630:  MOVF   6A,W
1631:  ANDWF  68,W
1632:  MOVWF  6E
1633:  MOVLB  00
1634:  MOVF   6A,W
1635:  XORLW  FF
1636:  MOVLB  01
1637:  ANDWF  6E,W
1638:  BTFSC  03.2
1639:  GOTO   664
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
163A:  MOVLB  00
163B:  MOVF   62,W
163C:  ANDWF  63,W
163D:  MOVLB  01
163E:  ANDWF  68,W
163F:  BTFSC  03.2
1640:  GOTO   64B
....................         rx_priority=RXPriority[x]; 
1641:  MOVLW  25
1642:  ADDWF  6D,W
1643:  MOVWF  04
1644:  MOVLW  20
1645:  MOVWF  05
1646:  BTFSC  03.0
1647:  INCF   05,F
1648:  MOVF   00,W
1649:  MOVWF  69
....................       } else { 
164A:  GOTO   64D
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
164B:  MOVLW  01
164C:  MOVWF  69
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
164D:  MOVF   69,W
164E:  SUBWF  76,W
164F:  BTFSC  03.0
1650:  GOTO   664
....................         if ( ! CurrentCorPriority ) { 
1651:  MOVF   76,F
1652:  BTFSS  03.2
1653:  GOTO   656
....................           CurrentCorPriority = rx_priority; 
1654:  MOVF   69,W
1655:  MOVWF  76
....................         } 
....................         cor_index=x+1; 
1656:  MOVLW  01
1657:  ADDWF  6D,W
1658:  MOVWF  6C
....................         do_update_ptt=1; 
1659:  MOVLW  01
165A:  MOVWF  6B
.................... 	TOT_FLAG_Mask=0; 
165B:  MOVLB  00
165C:  CLRF   6A
.................... 	QSO_Duration = 0; 
165D:  CLRF   6C
165E:  CLRF   6B
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
165F:  MOVLB  01
1660:  MOVF   68,W
1661:  MOVLB  00
1662:  MOVWF  61
1663:  MOVLB  01
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
1664:  BCF    03.0
1665:  RLF    68,F
....................   } 
1666:  INCF   6D,F
1667:  GOTO   62C
....................   if ( do_update_ptt ) { 
1668:  MOVF   6B,F
1669:  BTFSC  03.2
166A:  GOTO   674
....................     update_ptt(cor_index); 
166B:  MOVF   6C,W
166C:  MOVLB  02
166D:  MOVWF  30
166E:  MOVLP  08
166F:  MOVLB  00
1670:  CALL   2E2
1671:  MOVLP  10
....................     PROMPT_FLAG=1; 
1672:  MOVLB  01
1673:  BSF    65.0
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
1674:  MOVF   6A,F
1675:  BTFSS  03.2
1676:  GOTO   67C
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
1677:  BSF    62.7
....................     COR_IN_EFFECTIVE=0; 
1678:  MOVLB  00
1679:  CLRF   61
....................     TOT_FLAG_Mask=0; 
167A:  CLRF   6A
167B:  MOVLB  01
....................   } 
....................   // Refresh Link Time-out timer when COR is received. 
....................   // Any COR value refreshes the link TOT timer. 
....................   if ( Link_TOT != 0 && (cor_in)!=0 ) { 
167C:  MOVLB  00
167D:  MOVF   6D,F
167E:  BTFSC  03.2
167F:  GOTO   689
1680:  MOVLB  01
1681:  MOVF   6A,F
1682:  BTFSS  03.2
1683:  GOTO   686
1684:  MOVLB  00
1685:  GOTO   689
....................     LinkDurationTimer = Link_TOT; 
1686:  MOVLB  00
1687:  MOVF   6D,W
1688:  MOVWF  6E
....................   } 
.................... } // }}} 
1689:  MOVLP  18
168A:  GOTO   76A (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
1EF7:  MOVLB  01
1EF8:  CLRF   68
1EF9:  MOVF   68,W
1EFA:  SUBLW  09
1EFB:  BTFSS  03.0
1EFC:  GOTO   707
....................     DTMF_ARRAY[x]=(sDTMF)0; 
1EFD:  MOVLW  66
1EFE:  ADDWF  68,W
1EFF:  MOVWF  04
1F00:  MOVLW  20
1F01:  MOVWF  05
1F02:  BTFSC  03.0
1F03:  INCF   05,F
1F04:  CLRF   00
....................   } 
1F05:  INCF   68,F
1F06:  GOTO   6F9
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
1F07:  MOVLW  20
1F08:  MOVWF  41
1F09:  MOVLW  66
1F0A:  MOVWF  40
.................... } // }}} 
1F0B:  MOVLP  18
1F0C:  MOVLB  00
1F0D:  GOTO   793 (RETURN)
....................  
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   dtmf_in=dtmf_read(CONTROL_REG); 
*
130C:  MOVLW  01
130D:  MOVLB  02
130E:  MOVWF  3D
130F:  MOVLP  00
1310:  MOVLB  00
1311:  CALL   62D
1312:  MOVLP  10
1313:  MOVF   78,W
1314:  MOVLB  02
1315:  MOVWF  35
....................   aux_in = 0; 
1316:  CLRF   36
....................   for(x=0;x<RegMapNum;x++) { 
1317:  CLRF   2F
1318:  CLRF   2E
1319:  MOVF   2F,F
131A:  BTFSS  03.2
131B:  GOTO   41B
131C:  MOVF   2E,W
131D:  SUBLW  38
131E:  BTFSS  03.0
131F:  GOTO   41B
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
1320:  MOVLW  01
1321:  MOVWF  7A
1322:  MOVLW  8F
1323:  MOVWF  3D
1324:  MOVF   7A,W
1325:  MOVWF  3E
1326:  MOVF   2F,W
1327:  MOVWF  40
1328:  MOVF   2E,W
1329:  MOVWF  3F
132A:  CLRF   42
132B:  MOVLW  06
132C:  MOVWF  41
132D:  MOVLP  08
132E:  MOVLB  00
132F:  CALL   746
1330:  MOVLP  10
1331:  MOVF   78,W
1332:  MOVLB  02
1333:  ADDWF  3D,W
1334:  MOVWF  31
1335:  MOVF   79,W
1336:  ADDWFC 3E,W
1337:  MOVWF  32
....................     romstrcpy(rname,cPtr); 
1338:  MOVLW  20
1339:  MOVWF  3E
133A:  MOVLW  B7
133B:  MOVWF  3D
133C:  MOVF   32,W
133D:  MOVWF  40
133E:  MOVF   31,W
133F:  MOVWF  3F
1340:  MOVLP  08
1341:  MOVLB  00
1342:  CALL   75D
1343:  MOVLP  10
....................   regPtr=RegMap[x].reg_ptr; 
1344:  MOVLB  02
1345:  RLF    2E,W
1346:  MOVWF  3D
1347:  RLF    2F,W
1348:  MOVWF  3E
1349:  RLF    3D,F
134A:  RLF    3E,F
134B:  MOVLW  FC
134C:  ANDWF  3D,F
134D:  MOVF   3E,W
134E:  MOVWF  7A
134F:  MOVF   3D,W
1350:  MOVWF  3F
1351:  INCF   3D,W
1352:  MOVLP  00
1353:  MOVLB  00
1354:  CALL   043
1355:  MOVLP  10
1356:  MOVWF  7A
1357:  MOVLB  02
1358:  MOVF   3F,W
1359:  MOVLP  00
135A:  MOVLB  00
135B:  CALL   043
135C:  MOVLP  10
135D:  MOVLB  02
135E:  MOVWF  33
135F:  MOVF   7A,W
1360:  MOVWF  34
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
1361:  MOVF   34,W
1362:  MOVWF  7A
1363:  MOVF   33,W
1364:  MOVWF  04
1365:  MOVF   7A,W
1366:  MOVWF  05
1367:  MOVF   00,W
1368:  MOVWF  3D
1369:  MOVLW  5B
136A:  CLRWDT
136B:  MOVLB  00
136C:  BTFSC  11.4
136D:  GOTO   370
136E:  MOVLB  02
136F:  GOTO   36A
1370:  MOVLB  03
1371:  MOVWF  1A
1372:  MOVLW  0B
1373:  MOVWF  04
1374:  MOVLB  02
1375:  MOVF   2F,W
1376:  MOVWF  3F
1377:  MOVF   2E,W
1378:  MOVWF  3E
*
13D6:  MOVLW  5D
13D7:  CLRWDT
13D8:  MOVLB  00
13D9:  BTFSC  11.4
13DA:  GOTO   3DD
13DB:  MOVLB  02
13DC:  GOTO   3D7
13DD:  MOVLB  03
13DE:  MOVWF  1A
13DF:  MOVLW  20
13E0:  CLRWDT
13E1:  MOVLB  00
13E2:  BTFSC  11.4
13E3:  GOTO   3E6
13E4:  MOVLB  03
13E5:  GOTO   3E0
13E6:  MOVLB  03
13E7:  MOVWF  1A
13E8:  MOVLW  20
13E9:  MOVWF  05
13EA:  MOVLW  B7
13EB:  MOVWF  04
13EC:  MOVLP  08
13ED:  MOVLB  00
13EE:  CALL   1DA
13EF:  MOVLP  10
13F0:  MOVLW  20
13F1:  CLRWDT
13F2:  BTFSS  11.4
13F3:  GOTO   3F1
13F4:  MOVLB  03
13F5:  MOVWF  1A
13F6:  MOVLB  02
13F7:  MOVF   3D,W
13F8:  MOVWF  52
13F9:  MOVLW  1B
13FA:  MOVWF  53
13FB:  MOVLP  00
13FC:  MOVLB  00
13FD:  CALL   6CF
13FE:  MOVLP  10
13FF:  MOVLW  09
1400:  CLRWDT
1401:  BTFSS  11.4
1402:  GOTO   400
1403:  MOVLB  03
1404:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
1405:  MOVLB  02
1406:  MOVF   2E,W
1407:  ANDLW  03
1408:  MOVWF  3D
1409:  CLRF   3E
140A:  MOVF   3D,W
140B:  SUBLW  03
140C:  BTFSS  03.2
140D:  GOTO   416
140E:  MOVF   3E,F
140F:  BTFSS  03.2
1410:  GOTO   416
....................       crlf(); 
1411:  MOVLP  00
1412:  MOVLB  00
1413:  CALL   457
1414:  MOVLP  10
1415:  MOVLB  02
....................     } 
....................     restart_wdt(); 
1416:  CLRWDT
....................   } 
1417:  INCF   2E,F
1418:  BTFSC  03.2
1419:  INCF   2F,F
141A:  GOTO   319
....................   for(y=0;y<3;y++) { 
141B:  CLRF   30
141C:  MOVF   30,W
141D:  SUBLW  02
141E:  BTFSS  03.0
141F:  GOTO   436
....................     if(AuxInSW[y]==1) { 
1420:  MOVLW  1F
1421:  ADDWF  30,W
1422:  MOVWF  04
1423:  MOVLW  20
1424:  MOVWF  05
1425:  BTFSC  03.0
1426:  INCF   05,F
1427:  DECFSZ 00,W
1428:  GOTO   434
....................       aux_in += (1<<y); 
1429:  MOVLW  01
142A:  MOVWF  77
142B:  MOVF   30,W
142C:  MOVWF  78
142D:  BTFSC  03.2
142E:  GOTO   432
142F:  LSLF   77,F
1430:  DECFSZ 78,F
1431:  GOTO   42F
1432:  MOVF   77,W
1433:  ADDWF  36,F
....................     } 
....................   } 
1434:  INCF   30,F
1435:  GOTO   41C
....................   putc('\n'); 
1436:  MOVLW  0A
1437:  MOVLP  00
1438:  MOVLB  00
1439:  CALL   2E4
143A:  MOVLP  10
....................   crlf(); 
143B:  MOVLP  00
143C:  CALL   457
143D:  MOVLP  10
....................   printf("COR:%u AuxIn:%u",COR_IN_EFFECTIVE,aux_in); 
143E:  MOVLW  D1
143F:  MOVLB  03
1440:  MOVWF  11
1441:  MOVLW  03
1442:  MOVWF  12
1443:  BCF    03.0
1444:  MOVLW  04
1445:  MOVLB  02
1446:  MOVWF  52
1447:  MOVLP  00
1448:  MOVLB  00
1449:  CALL   65B
144A:  MOVLP  10
144B:  MOVF   61,W
144C:  MOVLB  02
144D:  MOVWF  52
144E:  MOVLW  1B
144F:  MOVWF  53
1450:  MOVLP  00
1451:  MOVLB  00
1452:  CALL   6CF
1453:  MOVLP  10
1454:  MOVLW  D4
1455:  MOVLB  03
1456:  MOVWF  11
1457:  MOVLW  03
1458:  MOVWF  12
1459:  BCF    03.0
145A:  MOVLW  07
145B:  MOVLB  02
145C:  MOVWF  52
145D:  MOVLP  00
145E:  MOVLB  00
145F:  CALL   65B
1460:  MOVLP  10
1461:  MOVLB  02
1462:  MOVF   36,W
1463:  MOVWF  52
1464:  MOVLW  1B
1465:  MOVWF  53
1466:  MOVLP  00
1467:  MOVLB  00
1468:  CALL   6CF
1469:  MOVLP  10
....................   crlf(); 
146A:  MOVLP  00
146B:  CALL   457
146C:  MOVLP  10
....................   printf("DTMF:%u",dtmf_in); 
146D:  MOVLW  D9
146E:  MOVLB  03
146F:  MOVWF  11
1470:  MOVLW  03
1471:  MOVWF  12
1472:  BCF    03.0
1473:  MOVLW  05
1474:  MOVLB  02
1475:  MOVWF  52
1476:  MOVLP  00
1477:  MOVLB  00
1478:  CALL   65B
1479:  MOVLP  10
147A:  MOVLB  02
147B:  MOVF   35,W
147C:  MOVWF  52
147D:  MOVLW  1B
147E:  MOVWF  53
147F:  MOVLP  00
1480:  MOVLB  00
1481:  CALL   6CF
1482:  MOVLP  10
....................   pot_values_to_lcd(); 
1483:  MOVLP  08
1484:  CALL   1F4
1485:  MOVLP  10
....................   PROMPT_FLAG=1; 
1486:  MOVLB  01
1487:  BSF    65.0
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
09F4:  MOVLW  20
09F5:  MOVLB  02
09F6:  MOVWF  44
09F7:  MOVWF  45
09F8:  MOVWF  46
09F9:  MOVWF  47
....................   unsigned pval[4]={0,0,0,0}; 
09FA:  CLRF   48
09FB:  CLRF   49
09FC:  CLRF   4A
09FD:  CLRF   4B
....................   delay_ms(40); 
09FE:  MOVLW  28
09FF:  MOVWF  4C
0A00:  MOVLP  00
0A01:  MOVLB  00
0A02:  CALL   77E
0A03:  MOVLP  08
....................   i2c_start(); 
0A04:  MOVLB  04
0A05:  BSF    16.0
0A06:  BTFSC  16.0
0A07:  GOTO   206
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0A08:  MOVLW  51
0A09:  MOVLB  02
0A0A:  MOVWF  52
0A0B:  MOVLP  00
0A0C:  MOVLB  00
0A0D:  CALL   646
0A0E:  MOVLP  08
0A0F:  MOVF   78,W
0A10:  MOVLB  02
0A11:  BCF    43.1
0A12:  BTFSC  78.0
0A13:  BSF    43.1
....................   for(x=0;x<4;x++) { 
0A14:  CLRF   41
0A15:  MOVF   41,W
0A16:  SUBLW  03
0A17:  BTFSS  03.0
0A18:  GOTO   254
....................     if(x==3) { 
0A19:  MOVF   41,W
0A1A:  SUBLW  03
0A1B:  BTFSS  03.2
0A1C:  GOTO   21F
....................       ack=0; 
0A1D:  BCF    43.0
....................     } else { 
0A1E:  GOTO   220
....................       ack=1; 
0A1F:  BSF    43.0
....................     } 
....................     pot_val=i2c_read(ack); 
0A20:  MOVLW  00
0A21:  BTFSC  43.0
0A22:  MOVLW  01
0A23:  MOVWF  4C
0A24:  MOVF   4C,W
0A25:  MOVWF  77
*
0A34:  MOVF   78,W
0A35:  MOVLB  02
0A36:  MOVWF  42
....................     pot_val=pot_val&0x3F; 
0A37:  MOVLW  3F
0A38:  ANDWF  42,F
....................     pval[x]=pot_val; 
0A39:  MOVLW  C8
0A3A:  ADDWF  41,W
0A3B:  MOVWF  04
0A3C:  MOVLW  20
0A3D:  MOVWF  05
0A3E:  BTFSC  03.0
0A3F:  INCF   05,F
0A40:  MOVF   42,W
0A41:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0A42:  MOVLB  01
0A43:  MOVF   30,W
0A44:  ANDLW  03
0A45:  MOVLB  02
0A46:  SUBWF  41,W
0A47:  BTFSS  03.2
0A48:  GOTO   252
....................       c[x] = '*'; 
0A49:  MOVLW  C4
0A4A:  ADDWF  41,W
0A4B:  MOVWF  04
0A4C:  MOVLW  20
0A4D:  MOVWF  05
0A4E:  BTFSC  03.0
0A4F:  INCF   05,F
0A50:  MOVLW  2A
0A51:  MOVWF  00
....................     } 
....................   } 
0A52:  INCF   41,F
0A53:  GOTO   215
....................   i2c_stop(); 
0A54:  MOVLB  04
0A55:  BSF    16.2
0A56:  BTFSC  16.2
0A57:  GOTO   256
....................   delay_ms(50); 
0A58:  MOVLW  32
0A59:  MOVLB  02
0A5A:  MOVWF  4C
0A5B:  MOVLP  00
0A5C:  MOVLB  00
0A5D:  CALL   77E
0A5E:  MOVLP  08
....................   if ( ack_in!=0 ) { 
0A5F:  MOVLB  02
0A60:  BTFSS  43.1
0A61:  GOTO   282
....................     crlf(); 
0A62:  MOVLP  00
0A63:  MOVLB  00
0A64:  CALL   457
0A65:  MOVLP  08
....................     printf("I2C Error : No ACK from TRIMPOTS : %u",ack); 
0A66:  MOVLW  00
0A67:  MOVLB  02
0A68:  BTFSC  43.0
0A69:  MOVLW  01
0A6A:  MOVWF  4C
0A6B:  MOVLW  DD
0A6C:  MOVLB  03
0A6D:  MOVWF  11
0A6E:  MOVLW  03
0A6F:  MOVWF  12
0A70:  BCF    03.0
0A71:  MOVLW  23
0A72:  MOVLB  02
0A73:  MOVWF  52
0A74:  MOVLP  00
0A75:  MOVLB  00
0A76:  CALL   65B
0A77:  MOVLP  08
0A78:  MOVLB  02
0A79:  MOVF   4C,W
0A7A:  MOVWF  52
0A7B:  MOVLW  1B
0A7C:  MOVWF  53
0A7D:  MOVLP  00
0A7E:  MOVLB  00
0A7F:  CALL   6CF
0A80:  MOVLP  08
0A81:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0A82:  MOVLW  20
0A83:  MOVLB  01
0A84:  MOVWF  67
0A85:  MOVLW  7A
0A86:  MOVWF  66
0A87:  MOVLW  F0
0A88:  MOVLB  03
0A89:  MOVWF  11
0A8A:  MOVLW  03
0A8B:  MOVWF  12
0A8C:  BCF    03.0
0A8D:  MOVLW  04
0A8E:  MOVLB  02
0A8F:  MOVWF  4C
0A90:  MOVLB  00
0A91:  CALL   0A4
0A92:  MOVLB  02
0A93:  MOVF   44,W
0A94:  MOVWF  52
0A95:  MOVLB  00
0A96:  CALL   095
0A97:  MOVLB  02
0A98:  MOVF   48,W
0A99:  MOVWF  4C
0A9A:  MOVLW  18
0A9B:  MOVWF  4D
0A9C:  MOVLB  00
0A9D:  CALL   173
0A9E:  MOVLW  20
0A9F:  MOVLB  02
0AA0:  MOVWF  52
0AA1:  MOVLB  00
0AA2:  CALL   095
0AA3:  MOVLB  02
0AA4:  MOVF   45,W
0AA5:  MOVWF  52
0AA6:  MOVLB  00
0AA7:  CALL   095
0AA8:  MOVLB  02
0AA9:  MOVF   49,W
0AAA:  MOVWF  4C
0AAB:  MOVLW  18
0AAC:  MOVWF  4D
0AAD:  MOVLB  00
0AAE:  CALL   173
0AAF:  MOVLW  20
0AB0:  MOVLB  02
0AB1:  MOVWF  52
0AB2:  MOVLB  00
0AB3:  CALL   095
0AB4:  MOVLB  02
0AB5:  MOVF   46,W
0AB6:  MOVWF  52
0AB7:  MOVLB  00
0AB8:  CALL   095
0AB9:  MOVLB  02
0ABA:  MOVF   4A,W
0ABB:  MOVWF  4C
0ABC:  MOVLW  18
0ABD:  MOVWF  4D
0ABE:  MOVLB  00
0ABF:  CALL   173
0AC0:  MOVLW  20
0AC1:  MOVLB  02
0AC2:  MOVWF  52
0AC3:  MOVLB  00
0AC4:  CALL   095
0AC5:  MOVLB  02
0AC6:  MOVF   47,W
0AC7:  MOVWF  52
0AC8:  MOVLB  00
0AC9:  CALL   095
0ACA:  MOVLB  02
0ACB:  MOVF   4B,W
0ACC:  MOVWF  4C
0ACD:  MOVLW  18
0ACE:  MOVWF  4D
0ACF:  MOVLB  00
0AD0:  CALL   173
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0AD1:  MOVLB  02
0AD2:  CLRF   4C
0AD3:  MOVLW  20
0AD4:  MOVWF  4E
0AD5:  MOVLW  7A
0AD6:  MOVWF  4D
0AD7:  MOVLB  00
0AD8:  CALL   10C
....................   crlf(); 
0AD9:  MOVLP  00
0ADA:  CALL   457
0ADB:  MOVLP  08
....................   printf("%s",LCD_str); 
0ADC:  MOVLW  20
0ADD:  MOVWF  05
0ADE:  MOVLW  7A
0ADF:  MOVWF  04
0AE0:  CALL   1DA
....................  
.................... } // }}} 
0AE1:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
1049:  MOVLB  01
104A:  BTFSS  65.1
104B:  GOTO   05F
....................     putc('\n'); 
104C:  MOVLW  0A
104D:  MOVLP  00
104E:  MOVLB  00
104F:  CALL   2E4
1050:  MOVLP  10
....................     crlf(); 
1051:  MOVLP  00
1052:  CALL   457
1053:  MOVLP  10
....................     printf("ADMIN> "); 
1054:  MOVLW  FC
1055:  MOVLB  03
1056:  MOVWF  11
1057:  MOVLW  03
1058:  MOVWF  12
1059:  MOVLP  00
105A:  MOVLB  00
105B:  CALL   45C
105C:  MOVLP  10
....................   } else { 
105D:  GOTO   070
105E:  MOVLB  01
....................     putc('\n'); 
105F:  MOVLW  0A
1060:  MOVLP  00
1061:  MOVLB  00
1062:  CALL   2E4
1063:  MOVLP  10
....................     crlf(); 
1064:  MOVLP  00
1065:  CALL   457
1066:  MOVLP  10
....................     printf("COMMAND> "); 
1067:  MOVLW  00
1068:  MOVLB  03
1069:  MOVWF  11
106A:  MOVLW  04
106B:  MOVWF  12
106C:  MOVLP  00
106D:  MOVLB  00
106E:  CALL   45C
106F:  MOVLP  10
....................   } 
.................... } // }}} 
1070:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
043D:  MOVLW  10
043E:  MOVLB  01
043F:  MOVWF  69
....................   for (x=0;x<char_num;x++) { 
0440:  CLRF   68
0441:  MOVF   69,W
0442:  SUBWF  68,W
0443:  BTFSC  03.0
0444:  GOTO   44F
....................     sBuffer[x]='\0'; 
0445:  MOVLW  50
0446:  ADDWF  68,W
0447:  MOVWF  04
0448:  MOVLW  20
0449:  MOVWF  05
044A:  BTFSC  03.0
044B:  INCF   05,F
044C:  CLRF   00
....................   } 
044D:  INCF   68,F
044E:  GOTO   441
....................   sBufferIndex=0; 
044F:  CLRF   7C
....................   sBufferFlag=0;   
0450:  BCF    7D.0
....................   argument=-1; 
0451:  MOVLW  FF
0452:  MOVWF  42
....................   argument_name[0]='\0'; 
0453:  CLRF   44
....................   command=0; 
0454:  CLRF   70
.................... } // }}} 
0455:  MOVLB  00
0456:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
05ED:  MOVLW  00
05EE:  MOVLB  01
05EF:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
05F0:  MOVLB  02
05F1:  BCF    47.0
05F2:  MOVF   45,W
05F3:  ANDLW  0F
05F4:  ANDLW  01
05F5:  BTFSS  03.2
05F6:  BSF    47.0
....................   output_bit(DTMF_D0,dbit); 
05F7:  BTFSC  47.0
05F8:  GOTO   5FB
05F9:  BCF    0F.0
05FA:  GOTO   5FC
05FB:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
05FC:  BCF    47.0
05FD:  MOVF   45,W
05FE:  ANDLW  0F
05FF:  ANDLW  02
0600:  BTFSS  03.2
0601:  BSF    47.0
....................   output_bit(DTMF_D1,dbit); 
0602:  BTFSC  47.0
0603:  GOTO   606
0604:  BCF    0F.1
0605:  GOTO   607
0606:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
0607:  BCF    47.0
0608:  MOVF   45,W
0609:  ANDLW  0F
060A:  ANDLW  04
060B:  BTFSS  03.2
060C:  BSF    47.0
....................   output_bit(DTMF_D2,dbit); 
060D:  BTFSC  47.0
060E:  GOTO   611
060F:  BCF    0F.2
0610:  GOTO   612
0611:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
0612:  BCF    47.0
0613:  MOVF   45,W
0614:  ANDLW  0F
0615:  ANDLW  08
0616:  BTFSS  03.2
0617:  BSF    47.0
....................   output_bit(DTMF_D3,dbit); 
0618:  BTFSC  47.0
0619:  GOTO   61C
061A:  BCF    0F.3
061B:  GOTO   61D
061C:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
061D:  MOVF   46,F
061E:  BTFSS  03.2
061F:  GOTO   622
0620:  BCF    0F.6
0621:  GOTO   623
0622:  BSF    0F.6
....................   delay_cycles(2); 
0623:  GOTO   624
....................   output_bit(DTMF_WEB,0); 
0624:  BCF    0F.5
....................   delay_cycles(2); 
0625:  GOTO   626
....................   output_bit(DTMF_WEB,1);   
0626:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
0627:  GOTO   628
....................   set_tris_d(0x0F); 
0628:  MOVLW  0F
0629:  MOVLB  01
062A:  MOVWF  0F
.................... } // }}} 
062B:  MOVLB  00
062C:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
062D:  MOVLW  0F
062E:  MOVLB  01
062F:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
0630:  MOVLB  02
0631:  MOVF   3D,F
0632:  BTFSS  03.2
0633:  GOTO   636
0634:  BCF    0F.6
0635:  GOTO   637
0636:  BSF    0F.6
....................   delay_cycles(1); 
0637:  NOP
....................   output_bit(DTMF_REB,0); 
0638:  BCF    0F.4
....................   delay_cycles(1); 
0639:  NOP
....................   value=input_d(); 
063A:  MOVLB  00
063B:  MOVF   0F,W
063C:  MOVLB  02
063D:  MOVWF  3E
....................   value&=0x0F; 
063E:  MOVLW  0F
063F:  ANDWF  3E,F
....................   output_bit(DTMF_REB,1); 
0640:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
0641:  NOP
....................   return(value); 
0642:  MOVF   3E,W
0643:  MOVWF  78
.................... } // }}} 
0644:  MOVLB  00
0645:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0C7C:  MOVLB  02
0C7D:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0C7E:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0C7F:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0C80:  CLRF   45
0C81:  MOVLW  01
0C82:  MOVWF  46
0C83:  MOVLP  00
0C84:  MOVLB  00
0C85:  CALL   5ED
0C86:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0C87:  MOVLB  02
0C88:  CLRF   45
0C89:  MOVLW  01
0C8A:  MOVWF  46
0C8B:  MOVLP  00
0C8C:  MOVLB  00
0C8D:  CALL   5ED
0C8E:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0C8F:  MOVLW  0C
0C90:  MOVLB  02
0C91:  MOVWF  45
0C92:  MOVLW  01
0C93:  MOVWF  46
0C94:  MOVLP  00
0C95:  MOVLB  00
0C96:  CALL   5ED
0C97:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0C98:  MOVLW  01
0C99:  MOVLB  02
0C9A:  MOVWF  45
0C9B:  MOVWF  46
0C9C:  MOVLP  00
0C9D:  MOVLB  00
0C9E:  CALL   5ED
0C9F:  MOVLP  08
....................     dtmf_read(CONTROL_REG); 
0CA0:  MOVLW  01
0CA1:  MOVLB  02
0CA2:  MOVWF  3D
0CA3:  MOVLP  00
0CA4:  MOVLB  00
0CA5:  CALL   62D
0CA6:  MOVLP  08
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19F3:  MOVF   42,W
19F4:  MOVWF  45
19F5:  CLRF   46
19F6:  MOVLP  00
19F7:  MOVLB  00
19F8:  CALL   5ED
19F9:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19FA:  MOVLW  0C
19FB:  MOVLB  02
19FC:  MOVWF  45
19FD:  MOVLW  01
19FE:  MOVWF  46
19FF:  MOVLP  00
1A00:  MOVLB  00
1A01:  CALL   5ED
1A02:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
1A03:  MOVLW  01
1A04:  MOVLB  02
1A05:  MOVWF  45
1A06:  MOVWF  46
1A07:  MOVLP  00
1A08:  MOVLB  00
1A09:  CALL   5ED
1A0A:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A0B:  MOVLW  05
1A0C:  MOVLB  02
1A0D:  MOVWF  45
1A0E:  MOVLW  01
1A0F:  MOVWF  46
1A10:  MOVLP  00
1A11:  MOVLB  00
1A12:  CALL   5ED
1A13:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A14:  MOVLB  01
1A15:  CLRF   34
1A16:  MOVLW  10
1A17:  MOVWF  33
....................   while(aux_timer) { 
1A18:  MOVF   33,W
1A19:  IORWF  34,W
1A1A:  BTFSC  03.2
1A1B:  GOTO   21E
....................     delay_cycles(1); 
1A1C:  NOP
....................   } 
1A1D:  GOTO   218
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A1E:  MOVLW  04
1A1F:  MOVLB  02
1A20:  MOVWF  45
1A21:  MOVLW  01
1A22:  MOVWF  46
1A23:  MOVLP  00
1A24:  MOVLB  00
1A25:  CALL   5ED
1A26:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
07AA:  MOVLW  01
07AB:  MOVLB  02
07AC:  MOVWF  45
07AD:  CLRF   46
07AE:  MOVLB  00
07AF:  CALL   5ED
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
07B0:  MOVLW  0C
07B1:  MOVLB  02
07B2:  MOVWF  45
07B3:  MOVLW  01
07B4:  MOVWF  46
07B5:  MOVLB  00
07B6:  CALL   5ED
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
07B7:  MOVLW  05
07B8:  MOVLB  02
07B9:  MOVWF  45
07BA:  MOVLW  01
07BB:  MOVWF  46
07BC:  MOVLB  00
07BD:  CALL   5ED
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
07BE:  MOVLW  05
07BF:  MOVLB  02
07C0:  MOVWF  45
07C1:  MOVLW  01
07C2:  MOVWF  46
07C3:  MOVLB  00
07C4:  CALL   5ED
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
07C5:  MOVLB  01
07C6:  CLRF   34
07C7:  MOVLW  02
07C8:  MOVWF  33
....................   while(aux_timer) { 
07C9:  MOVF   33,W
07CA:  IORWF  34,W
07CB:  BTFSC  03.2
07CC:  GOTO   7CF
....................     delay_cycles(1); 
07CD:  NOP
....................   } 
07CE:  GOTO   7C9
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
07CF:  MOVLW  04
07D0:  MOVLB  02
07D1:  MOVWF  45
07D2:  MOVLW  01
07D3:  MOVWF  46
07D4:  MOVLB  00
07D5:  CALL   5ED
....................   restart_wdt(); 
07D6:  CLRWDT
.................... } // }}} 
07D7:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
0800:  MOVLW  01
0801:  MOVLB  02
0802:  MOVWF  45
0803:  CLRF   46
0804:  MOVLP  00
0805:  MOVLB  00
0806:  CALL   5ED
0807:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0808:  MOVLW  0C
0809:  MOVLB  02
080A:  MOVWF  45
080B:  MOVLW  01
080C:  MOVWF  46
080D:  MOVLP  00
080E:  MOVLB  00
080F:  CALL   5ED
0810:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0811:  MOVLW  05
0812:  MOVLB  02
0813:  MOVWF  45
0814:  MOVLW  01
0815:  MOVWF  46
0816:  MOVLP  00
0817:  MOVLB  00
0818:  CALL   5ED
0819:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
081A:  MOVLW  05
081B:  MOVLB  02
081C:  MOVWF  45
081D:  MOVLW  01
081E:  MOVWF  46
081F:  MOVLP  00
0820:  MOVLB  00
0821:  CALL   5ED
0822:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
0823:  MOVLB  01
0824:  CLRF   34
0825:  MOVLW  06
0826:  MOVWF  33
....................   while(aux_timer) { 
0827:  MOVF   33,W
0828:  IORWF  34,W
0829:  BTFSC  03.2
082A:  GOTO   02D
....................     delay_cycles(1); 
082B:  NOP
....................   } 
082C:  GOTO   027
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
082D:  MOVLW  04
082E:  MOVLB  02
082F:  MOVWF  45
0830:  MOVLW  01
0831:  MOVWF  46
0832:  MOVLP  00
0833:  MOVLB  00
0834:  CALL   5ED
0835:  MOVLP  08
....................   restart_wdt(); 
0836:  CLRWDT
.................... } // }}} 
0837:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
04B1:  MOVLB  02
04B2:  MOVF   3A,W
04B3:  MOVWF  04
04B4:  MOVF   3B,W
04B5:  MOVWF  05
04B6:  MOVF   00,W
04B7:  MOVWF  3D
....................   if ( tmp > 127 ) { 
04B8:  MOVF   3D,W
04B9:  SUBLW  7F
04BA:  BTFSS  03.0
....................     tmp++; 
04BB:  INCF   3D,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
04BC:  BCF    03.0
04BD:  RLF    3D,W
04BE:  XORLW  09
04BF:  ADDWF  3C,W
04C0:  MOVWF  3D
....................   *cksum=tmp; 
04C1:  MOVF   3A,W
04C2:  MOVWF  04
04C3:  MOVF   3B,W
04C4:  MOVWF  05
04C5:  MOVF   3D,W
04C6:  MOVWF  00
.................... } // }}} 
04C7:  MOVLB  00
04C8:  RETURN
.................... void print_dtmf_info(void) { // {{{ 
....................   unsigned int x; 
....................   char dtmf; 
....................   char tmp[5]; 
....................   strcpy(LCD_str,"DTMF:"); 
*
1780:  MOVLB  02
1781:  CLRF   20
1782:  CLRF   21
1783:  MOVLW  20
1784:  MOVWF  05
1785:  MOVLW  7A
1786:  MOVWF  04
1787:  MOVF   20,W
1788:  ADDWF  04,F
1789:  MOVLW  00
178A:  ADDWFC 05,F
178B:  MOVF   21,W
178C:  MOVLP  00
178D:  MOVLB  00
178E:  CALL   139
178F:  MOVLP  10
1790:  MOVWF  00
1791:  IORLW  00
1792:  BTFSC  03.2
1793:  GOTO   799
1794:  MOVLB  02
1795:  INCF   21,F
1796:  INCF   20,F
1797:  GOTO   783
1798:  MOVLB  00
....................   crlf(); 
1799:  MOVLP  00
179A:  CALL   457
179B:  MOVLP  10
....................   printf("DTMF="); 
179C:  MOVLW  05
179D:  MOVLB  03
179E:  MOVWF  11
179F:  MOVLW  04
17A0:  MOVWF  12
17A1:  MOVLP  00
17A2:  MOVLB  00
17A3:  CALL   45C
17A4:  MOVLP  10
....................   for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
17A5:  MOVLB  01
17A6:  CLRF   68
17A7:  MOVF   68,W
17A8:  SUBLW  09
17A9:  BTFSS  03.0
17AA:  GOTO   7E4
....................     if(DTMF_ARRAY[x].Strobe) { 
17AB:  MOVLW  66
17AC:  ADDWF  68,W
17AD:  MOVWF  04
17AE:  MOVLW  20
17AF:  MOVWF  05
17B0:  BTFSC  03.0
17B1:  INCF   05,F
17B2:  BTFSS  00.4
17B3:  GOTO   7E1
....................       dtmf=(int)DTMF_ARRAY[x].Key; 
17B4:  MOVLW  66
17B5:  ADDWF  68,W
17B6:  MOVWF  04
17B7:  MOVLW  20
17B8:  MOVWF  05
17B9:  BTFSC  03.0
17BA:  INCF   05,F
17BB:  MOVF   00,W
17BC:  ANDLW  0F
17BD:  MOVWF  69
....................       sprintf(tmp,"%d",dtmf); 
17BE:  MOVLW  20
17BF:  MOVWF  67
17C0:  MOVLW  9A
17C1:  MOVWF  66
17C2:  MOVF   69,W
17C3:  MOVLB  02
17C4:  MOVWF  4C
17C5:  MOVLW  18
17C6:  MOVWF  4D
17C7:  MOVLP  08
17C8:  MOVLB  00
17C9:  CALL   173
17CA:  MOVLP  10
....................       strcat(LCD_str,tmp); 
17CB:  MOVLW  20
17CC:  MOVLB  02
17CD:  MOVWF  2C
17CE:  MOVLW  7A
17CF:  MOVWF  2B
17D0:  MOVLW  20
17D1:  MOVWF  2E
17D2:  MOVLW  9A
17D3:  MOVWF  2D
17D4:  MOVLB  00
17D5:  CALL   6F5
....................       printf("%u",dtmf); 
17D6:  MOVLB  01
17D7:  MOVF   69,W
17D8:  MOVLB  02
17D9:  MOVWF  52
17DA:  MOVLW  1B
17DB:  MOVWF  53
17DC:  MOVLP  00
17DD:  MOVLB  00
17DE:  CALL   6CF
17DF:  MOVLP  10
17E0:  MOVLB  01
....................     } 
....................   restart_wdt(); 
17E1:  CLRWDT
....................   } 
17E2:  INCF   68,F
17E3:  GOTO   7A7
....................   crlf(); 
17E4:  MOVLP  00
17E5:  MOVLB  00
17E6:  CALL   457
17E7:  MOVLP  10
....................   PROMPT_FLAG=1; 
17E8:  MOVLB  01
17E9:  BSF    65.0
....................   lcd_send(2,LCD_str); // Send DTMF on line 3 
17EA:  MOVLW  02
17EB:  MOVLB  02
17EC:  MOVWF  4C
17ED:  MOVLW  20
17EE:  MOVWF  4E
17EF:  MOVLW  7A
17F0:  MOVWF  4D
17F1:  MOVLP  08
17F2:  MOVLB  00
17F3:  CALL   10C
17F4:  MOVLP  10
.................... } // }}} 
17F5:  MOVLP  18
17F6:  GOTO   784 (RETURN)
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
*
04C9:  MOVLW  01
04CA:  MOVLB  02
04CB:  MOVWF  34
....................   eeprom_index=0; 
04CC:  CLRF   35
....................   retVal = 1; 
04CD:  MOVWF  37
....................   crlf(); 
04CE:  MOVLB  00
04CF:  CALL   457
....................   printf("Init RAM <= "); 
04D0:  MOVLW  08
04D1:  MOVLB  03
04D2:  MOVWF  11
04D3:  MOVLW  04
04D4:  MOVWF  12
04D5:  MOVLB  00
04D6:  CALL   45C
....................   if ( source == USE_EEPROM_VARS ) { 
04D7:  MOVLB  02
04D8:  DECFSZ 30,W
04D9:  GOTO   4E3
....................     printf("EEPROM"); 
04DA:  MOVLW  0F
04DB:  MOVLB  03
04DC:  MOVWF  11
04DD:  MOVLW  04
04DE:  MOVWF  12
04DF:  MOVLB  00
04E0:  CALL   45C
....................   } else { 
04E1:  GOTO   4EA
04E2:  MOVLB  02
....................     printf("HW Defaults"); 
04E3:  MOVLW  13
04E4:  MOVLB  03
04E5:  MOVWF  11
04E6:  MOVLW  04
04E7:  MOVWF  12
04E8:  MOVLB  00
04E9:  CALL   45C
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
04EA:  MOVLB  02
04EB:  CLRF   31
04EC:  MOVF   31,W
04ED:  SUBLW  38
04EE:  BTFSS  03.0
04EF:  GOTO   549
....................     regPtr=RegMap[x].reg_ptr; 
04F0:  RLF    31,W
04F1:  MOVWF  77
04F2:  RLF    77,F
04F3:  MOVLW  FC
04F4:  ANDWF  77,F
04F5:  MOVF   77,W
04F6:  MOVWF  39
04F7:  INCF   39,W
04F8:  MOVLB  00
04F9:  CALL   043
04FA:  MOVWF  7A
04FB:  MOVLB  02
04FC:  MOVF   39,W
04FD:  MOVLB  00
04FE:  CALL   043
04FF:  MOVLB  02
0500:  MOVWF  32
0501:  MOVF   7A,W
0502:  MOVWF  33
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
0503:  DECFSZ 30,W
0504:  GOTO   535
0505:  RLF    31,W
0506:  MOVWF  77
0507:  RLF    77,F
0508:  MOVLW  FC
0509:  ANDWF  77,F
050A:  MOVF   77,W
050B:  ADDLW  03
050C:  MOVLB  00
050D:  CALL   043
050E:  MOVWF  78
050F:  BTFSC  78.0
0510:  GOTO   513
0511:  MOVLB  02
0512:  GOTO   535
....................       eeprom_val=read_eeprom(eeprom_index); 
0513:  MOVLB  02
0514:  MOVF   35,W
0515:  MOVLB  03
0516:  MOVWF  11
0517:  BCF    15.7
0518:  BSF    15.0
0519:  MOVF   13,W
051A:  MOVLB  02
051B:  MOVWF  38
....................       *regPtr=eeprom_val; 
051C:  MOVF   32,W
051D:  MOVWF  04
051E:  MOVF   33,W
051F:  MOVWF  05
0520:  MOVF   38,W
0521:  MOVWF  00
....................       update_checksum(&cksum,*regPtr);     
0522:  MOVF   33,W
0523:  MOVWF  7A
0524:  MOVF   32,W
0525:  MOVWF  04
0526:  MOVF   33,W
0527:  MOVWF  05
0528:  MOVF   00,W
0529:  MOVWF  39
052A:  MOVLW  20
052B:  MOVWF  3B
052C:  MOVLW  B4
052D:  MOVWF  3A
052E:  MOVF   39,W
052F:  MOVWF  3C
0530:  MOVLB  00
0531:  CALL   4B1
....................       eeprom_index++; 
0532:  MOVLB  02
0533:  INCF   35,F
....................     } else { 
0534:  GOTO   547
....................       default_value=(int8)RegMap[x].default_value; 
0535:  RLF    31,W
0536:  MOVWF  77
0537:  RLF    77,F
0538:  MOVLW  FC
0539:  ANDWF  77,F
053A:  MOVF   77,W
053B:  ADDLW  02
053C:  MOVLB  00
053D:  CALL   043
053E:  MOVWF  78
053F:  MOVLB  02
0540:  MOVWF  36
....................       *regPtr=default_value; 
0541:  MOVF   32,W
0542:  MOVWF  04
0543:  MOVF   33,W
0544:  MOVWF  05
0545:  MOVF   36,W
0546:  MOVWF  00
....................     } 
....................   } 
0547:  INCF   31,F
0548:  GOTO   4EC
....................   if ( source == USE_EEPROM_VARS ) { 
0549:  DECFSZ 30,W
054A:  GOTO   555
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
054B:  MOVF   35,W
054C:  MOVLB  03
054D:  MOVWF  11
054E:  BCF    15.7
054F:  BSF    15.0
0550:  MOVF   13,W
0551:  MOVLB  02
0552:  SUBWF  34,W
0553:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
0554:  CLRF   37
....................     } 
....................   } 
....................   return (retVal); 
0555:  MOVF   37,W
0556:  MOVWF  78
.................... } // }}} 
0557:  MOVLB  00
0558:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
0559:  MOVLW  01
055A:  MOVLB  02
055B:  MOVWF  34
....................  
....................   eeprom_index=0; 
055C:  CLRF   31
....................   for(x=0;x<RegMapNum;x++) { 
055D:  CLRF   30
055E:  MOVF   30,W
055F:  SUBLW  38
0560:  BTFSS  03.0
0561:  GOTO   5B7
....................     regPtr=RegMap[x].reg_ptr; 
0562:  RLF    30,W
0563:  MOVWF  77
0564:  RLF    77,F
0565:  MOVLW  FC
0566:  ANDWF  77,F
0567:  MOVF   77,W
0568:  MOVWF  36
0569:  INCF   36,W
056A:  MOVLB  00
056B:  CALL   043
056C:  MOVWF  7A
056D:  MOVLB  02
056E:  MOVF   36,W
056F:  MOVLB  00
0570:  CALL   043
0571:  MOVLB  02
0572:  MOVWF  32
0573:  MOVF   7A,W
0574:  MOVWF  33
....................     if ( RegMap[x].non_volatile ) { 
0575:  RLF    30,W
0576:  MOVWF  77
0577:  RLF    77,F
0578:  MOVLW  FC
0579:  ANDWF  77,F
057A:  MOVF   77,W
057B:  ADDLW  03
057C:  MOVLB  00
057D:  CALL   043
057E:  MOVWF  78
057F:  BTFSS  78.0
0580:  GOTO   5B4
....................      value=*regPtr; 
0581:  MOVLB  02
0582:  MOVF   32,W
0583:  MOVWF  04
0584:  MOVF   33,W
0585:  MOVWF  05
0586:  MOVF   00,W
0587:  MOVWF  35
....................      if ( read_eeprom(eeprom_index) != value ) { 
0588:  MOVF   31,W
0589:  MOVLB  03
058A:  MOVWF  11
058B:  BCF    15.7
058C:  BSF    15.0
058D:  MOVF   13,W
058E:  MOVLB  02
058F:  SUBWF  35,W
0590:  BTFSC  03.2
0591:  GOTO   5A9
....................        write_eeprom(eeprom_index,value); 
0592:  MOVF   0B,W
0593:  MOVWF  77
0594:  BCF    0B.7
0595:  MOVF   31,W
0596:  MOVLB  03
0597:  MOVWF  11
0598:  MOVLB  02
0599:  MOVF   35,W
059A:  MOVLB  03
059B:  MOVWF  13
059C:  BCF    15.7
059D:  BSF    15.2
059E:  MOVLW  55
059F:  MOVWF  16
05A0:  MOVLW  AA
05A1:  MOVWF  16
05A2:  BSF    15.1
05A3:  BTFSC  15.1
05A4:  GOTO   5A3
05A5:  BCF    15.2
05A6:  MOVF   77,W
05A7:  IORWF  0B,F
05A8:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
05A9:  MOVLW  20
05AA:  MOVWF  3B
05AB:  MOVLW  B4
05AC:  MOVWF  3A
05AD:  MOVF   35,W
05AE:  MOVWF  3C
05AF:  MOVLB  00
05B0:  CALL   4B1
....................      eeprom_index++; 
05B1:  MOVLB  02
05B2:  INCF   31,F
05B3:  MOVLB  00
....................     } 
....................   } 
05B4:  MOVLB  02
05B5:  INCF   30,F
05B6:  GOTO   55E
....................   write_eeprom(eeprom_index,cksum); 
05B7:  MOVF   0B,W
05B8:  MOVWF  77
05B9:  BCF    0B.7
05BA:  MOVF   31,W
05BB:  MOVLB  03
05BC:  MOVWF  11
05BD:  MOVLB  02
05BE:  MOVF   34,W
05BF:  MOVLB  03
05C0:  MOVWF  13
05C1:  BCF    15.7
05C2:  BSF    15.2
05C3:  MOVLW  55
05C4:  MOVWF  16
05C5:  MOVLW  AA
05C6:  MOVWF  16
05C7:  BSF    15.1
05C8:  BTFSC  15.1
05C9:  GOTO   5C8
05CA:  BCF    15.2
05CB:  MOVF   77,W
05CC:  IORWF  0B,F
....................   crlf(); 
05CD:  MOVLB  00
05CE:  CALL   457
....................   printf("EEPROM<=RAM"); 
05CF:  MOVLW  19
05D0:  MOVLB  03
05D1:  MOVWF  11
05D2:  MOVLW  04
05D3:  MOVWF  12
05D4:  MOVLB  00
05D5:  CALL   45C
.................... } // }}} 
05D6:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
05D7:  MOVLB  02
05D8:  MOVF   2F,W
05D9:  MOVWF  30
05DA:  MOVLB  00
05DB:  CALL   4C9
05DC:  MOVF   78,F
05DD:  BTFSS  03.2
05DE:  GOTO   5EC
....................       crlf(); 
05DF:  CALL   457
....................       printf(" Bad checksum!"); 
05E0:  MOVLW  1F
05E1:  MOVLB  03
05E2:  MOVWF  11
05E3:  MOVLW  04
05E4:  MOVWF  12
05E5:  MOVLB  00
05E6:  CALL   45C
....................         _init_variables(USE_DEFAULT_VARS); 
05E7:  MOVLB  02
05E8:  CLRF   30
05E9:  MOVLB  00
05EA:  CALL   4C9
....................     store_variables(); 
05EB:  CALL   559
....................     } 
.................... } // }}} 
05EC:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0CB7:  MOVLB  02
0CB8:  CLRF   41
0CB9:  CLRF   42
0CBA:  MOVLP  00
0CBB:  MOVLB  00
0CBC:  CALL   71E
0CBD:  MOVLP  08
....................   set_trimpot(1,0); 
0CBE:  MOVLW  01
0CBF:  MOVLB  02
0CC0:  MOVWF  41
0CC1:  CLRF   42
0CC2:  MOVLP  00
0CC3:  MOVLB  00
0CC4:  CALL   71E
0CC5:  MOVLP  08
....................   set_trimpot(2,0); 
0CC6:  MOVLW  02
0CC7:  MOVLB  02
0CC8:  MOVWF  41
0CC9:  CLRF   42
0CCA:  MOVLP  00
0CCB:  MOVLB  00
0CCC:  CALL   71E
0CCD:  MOVLP  08
....................   set_trimpot(3,0); 
0CCE:  MOVLW  03
0CCF:  MOVLB  02
0CD0:  MOVWF  41
0CD1:  CLRF   42
0CD2:  MOVLP  00
0CD3:  MOVLB  00
0CD4:  CALL   71E
0CD5:  MOVLP  08
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0C41:  MOVLP  00
0C42:  CALL   43D
0C43:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0C44:  MOVLB  02
0C45:  CLRF   12
0C46:  CLRF   11
0C47:  CLRF   14
0C48:  CLRF   13
....................   setup_wdt(WDT_2S); 
0C49:  MOVLW  17
0C4A:  MOVLB  01
0C4B:  MOVWF  17
....................   PROCESS_COR_FLAG=0; 
0C4C:  BCF    7D.1
....................   COR_IN_FLAG=0; 
0C4D:  BCF    7D.2
....................   COR_IN=0; 
0C4E:  MOVLB  00
0C4F:  CLRF   60
....................   COR_EMUL=0; 
0C50:  CLRF   6F
....................   COR_AUX=0; 
0C51:  CLRF   71
....................   COR_DROP_FLAG=0; 
0C52:  MOVLB  01
0C53:  BCF    62.0
....................   DTMF_IN_FLAG=0; 
0C54:  BCF    62.5
....................   DTMF_INTERRUPT_FLAG=0; 
0C55:  BCF    62.6
....................   TOT_FLAG_Mask=0; 
0C56:  MOVLB  00
0C57:  CLRF   6A
....................   AuxOutDelayCnt=0; 
0C58:  MOVLB  01
0C59:  CLRF   35
....................   CurrentCorMask=0; 
0C5A:  CLRF   74
....................   CurrentCorPriority=0; 
0C5B:  CLRF   76
....................   CurrentCorIndex=0; 
0C5C:  CLRF   75
....................   CurrentTrimPot=0; 
0C5D:  CLRF   30
....................   set_tris_b(0xFF); 
0C5E:  MOVLW  FF
0C5F:  TRIS   6
....................   set_tris_d(0x00); 
0C60:  MOVLW  00
0C61:  MOVWF  0F
....................   set_tris_e(0xF8); 
0C62:  BCF    10.0
0C63:  BCF    10.1
0C64:  BCF    10.2
0C65:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0C66:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0C67:  BSF    0B.3
0C68:  MOVLW  CF
0C69:  MOVLB  07
0C6A:  IORWF  14,F
0C6B:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0C6C:  BSF    0B.3
0C6D:  BSF    15.4
0C6E:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0C6F:  MOVLW  C0
0C70:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0C71:  MOVLB  02
0C72:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0C73:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0C74:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0C75:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0C76:  MOVLW  01
0C77:  MOVWF  2F
0C78:  MOVLP  00
0C79:  MOVLB  00
0C7A:  CALL   5D7
0C7B:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0CA7:  MOVLB  01
0CA8:  BSF    62.7
....................   Enable_Mask = 0x0F; 
0CA9:  MOVLW  0F
0CAA:  MOVLB  00
0CAB:  MOVWF  63
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0CAC:  MOVF   64,W
0CAD:  ANDLW  0F
0CAE:  IORLW  C0
0CAF:  MOVLB  04
0CB0:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0CB1:  MOVLB  01
0CB2:  BCF    15.7
....................   // }}} 
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0CB3:  MOVLW  9D
0CB4:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0CB5:  MOVLW  80
0CB6:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0CD6:  MOVLB  01
0CD7:  CLRF   32
0CD8:  MOVLW  1E
0CD9:  MOVWF  31
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0CDA:  MOVF   15,W
0CDB:  ANDLW  C0
0CDC:  IORLW  07
0CDD:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0CDE:  BSF    0B.5
....................   update_ptt(0); 
0CDF:  MOVLB  02
0CE0:  CLRF   30
0CE1:  MOVLB  00
0CE2:  CALL   2E2
....................   MinuteCounter=MIN_COUNTER; 
0CE3:  MOVLW  1D
0CE4:  MOVLB  01
0CE5:  MOVWF  64
....................   SecondCounter=SEC_COUNTER; 
0CE6:  MOVLW  3B
0CE7:  MOVWF  63
....................   THIRTY_MIN_FLAG=0; 
0CE8:  BCF    7D.7
....................   MINUTE_FLAG=0; 
0CE9:  BCF    7D.6
....................   PROMPT_FLAG=1; 
0CEA:  BSF    65.0
....................   TailChar=Tail; 
0CEB:  MOVLB  00
0CEC:  MOVF   67,W
0CED:  MOVWF  72
....................   ConfirmChar=0; 
0CEE:  CLRF   73
....................   //AuxOut[0] = PO_AUX_OUT0; 
....................   //AuxOut[1] = PO_AUX_OUT1; 
....................   //AuxOut[2] = PO_AUX_OUT2; 
....................   AuxInSW[0] = 0; 
0CEF:  CLRF   3F
....................   AuxInSW[1] = 0; 
0CF0:  CLRF   40
....................   AuxInSW[2] = 0; 
0CF1:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0CF2:  MOVLB  01
0CF3:  BCF    62.1
....................   COR_IN_EFFECTIVE=0; 
0CF4:  MOVLB  00
0CF5:  CLRF   61
....................   set_admin_mode(0); 
0CF6:  MOVLB  02
0CF7:  CLRF   42
0CF8:  MOVLB  00
0CF9:  CALL   42C
....................   rs232_mode=0; 
0CFA:  MOVLB  01
0CFB:  BCF    65.2
....................   button_state=0; 
0CFC:  CLRF   61
.................... #ifdef LCD_TYPE_PI 
....................   init_lcd(); 
.................... #endif 
....................   setup_adc(ADC_CLOCK_INTERNAL); 
0CFD:  BSF    1E.4
0CFE:  BSF    1E.5
0CFF:  BCF    1E.6
0D00:  BCF    1E.7
0D01:  BSF    1D.0
....................   setup_adc_ports(ADJ_POT|VSS_VDD); 
0D02:  BCF    1E.0
0D03:  BCF    1E.1
0D04:  BCF    1E.2
0D05:  MOVLW  00
0D06:  MOVLB  03
0D07:  MOVWF  0C
0D08:  MOVWF  10
0D09:  MOVLW  20
0D0A:  MOVWF  0D
0D0B:  MOVLW  00
0D0C:  MOVWF  0F
....................   set_adc_channel(13); 
0D0D:  MOVLW  34
0D0E:  MOVWF  78
0D0F:  MOVLB  01
0D10:  MOVF   1D,W
0D11:  ANDLW  83
0D12:  IORWF  78,W
0D13:  MOVWF  1D
....................  
.................... //  setup_adc_ports(ADJ_POT); 
.................... //  set_adc_channel(13); 
.................... //  printf("\n\rInitialization complete"); 
.................... } // }}} 
0D14:  MOVLP  18
0D15:  MOVLB  00
0D16:  GOTO   741 (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180E:  MOVLB  02
180F:  BCF    2A.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
1810:  CLRF   41
1811:  CLRF   42
1812:  MOVLW  20
1813:  MOVWF  05
1814:  MOVLW  AD
1815:  MOVWF  04
1816:  MOVF   41,W
1817:  ADDWF  04,F
1818:  MOVLW  00
1819:  ADDWFC 05,F
181A:  MOVF   42,W
181B:  MOVLP  00
181C:  MOVLB  00
181D:  CALL   140
181E:  MOVLP  18
181F:  MOVWF  00
1820:  IORLW  00
1821:  BTFSC  03.2
1822:  GOTO   028
1823:  MOVLB  02
1824:  INCF   42,F
1825:  INCF   41,F
1826:  GOTO   012
1827:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1828:  MOVLW  20
1829:  MOVLB  02
182A:  MOVWF  42
182B:  MOVLW  50
182C:  MOVWF  41
182D:  MOVLW  20
182E:  MOVWF  44
182F:  MOVLW  AD
1830:  MOVWF  43
1831:  MOVLP  08
1832:  MOVLB  00
1833:  CALL   5DF
1834:  MOVLP  18
1835:  MOVF   79,W
1836:  MOVLB  02
1837:  MOVWF  2C
1838:  MOVF   78,W
1839:  MOVWF  2B
....................   if (sptr!=0) {; 
183A:  MOVF   2B,F
183B:  BTFSS  03.2
183C:  GOTO   040
183D:  MOVF   2C,F
183E:  BTFSC  03.2
183F:  GOTO   05A
....................     strcpy(verb,sptr); 
1840:  MOVF   2C,W
1841:  MOVWF  44
1842:  MOVF   2B,W
1843:  MOVWF  43
1844:  MOVLW  20
1845:  MOVWF  42
1846:  MOVLW  A2
1847:  MOVWF  41
1848:  MOVF   44,W
1849:  MOVWF  05
184A:  MOVF   43,W
184B:  MOVWF  04
184C:  MOVF   00,W
184D:  MOVWF  45
184E:  MOVF   42,W
184F:  MOVWF  05
1850:  MOVF   41,W
1851:  MOVWF  04
1852:  MOVF   45,W
1853:  MOVWF  00
1854:  MOVF   00,F
1855:  BTFSC  03.2
1856:  GOTO   05A
1857:  INCF   41,F
1858:  INCF   43,F
1859:  GOTO   048
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
185A:  CLRF   42
185B:  CLRF   41
185C:  MOVLW  20
185D:  MOVWF  44
185E:  MOVLW  AD
185F:  MOVWF  43
1860:  MOVLP  08
1861:  MOVLB  00
1862:  CALL   5DF
1863:  MOVLP  18
1864:  MOVF   79,W
1865:  MOVLB  02
1866:  MOVWF  2C
1867:  MOVF   78,W
1868:  MOVWF  2B
....................   if (sptr!=0) {; 
1869:  MOVF   2B,F
186A:  BTFSS  03.2
186B:  GOTO   06F
186C:  MOVF   2C,F
186D:  BTFSC  03.2
186E:  GOTO   089
....................     strcpy(argument_name,sptr); 
186F:  MOVF   2C,W
1870:  MOVWF  44
1871:  MOVF   2B,W
1872:  MOVWF  43
1873:  MOVLW  20
1874:  MOVWF  42
1875:  MOVLW  74
1876:  MOVWF  41
1877:  MOVF   44,W
1878:  MOVWF  05
1879:  MOVF   43,W
187A:  MOVWF  04
187B:  MOVF   00,W
187C:  MOVWF  45
187D:  MOVF   42,W
187E:  MOVWF  05
187F:  MOVF   41,W
1880:  MOVWF  04
1881:  MOVF   45,W
1882:  MOVWF  00
1883:  MOVF   00,F
1884:  BTFSC  03.2
1885:  GOTO   089
1886:  INCF   41,F
1887:  INCF   43,F
1888:  GOTO   077
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1889:  CLRF   42
188A:  CLRF   41
188B:  MOVLW  20
188C:  MOVWF  44
188D:  MOVLW  AD
188E:  MOVWF  43
188F:  MOVLP  08
1890:  MOVLB  00
1891:  CALL   5DF
1892:  MOVLP  18
1893:  MOVF   79,W
1894:  MOVLB  02
1895:  MOVWF  2C
1896:  MOVF   78,W
1897:  MOVWF  2B
....................   if (sptr!=0) {; 
1898:  MOVF   2B,F
1899:  BTFSS  03.2
189A:  GOTO   09E
189B:  MOVF   2C,F
189C:  BTFSC  03.2
189D:  GOTO   0C5
....................     strcpy(match_val,sptr); 
189E:  MOVF   2C,W
189F:  MOVWF  44
18A0:  MOVF   2B,W
18A1:  MOVWF  43
18A2:  MOVLW  20
18A3:  MOVWF  42
18A4:  MOVLW  B5
18A5:  MOVWF  41
18A6:  MOVF   44,W
18A7:  MOVWF  05
18A8:  MOVF   43,W
18A9:  MOVWF  04
18AA:  MOVF   00,W
18AB:  MOVWF  45
18AC:  MOVF   42,W
18AD:  MOVWF  05
18AE:  MOVF   41,W
18AF:  MOVWF  04
18B0:  MOVF   45,W
18B1:  MOVWF  00
18B2:  MOVF   00,F
18B3:  BTFSC  03.2
18B4:  GOTO   0B8
18B5:  INCF   41,F
18B6:  INCF   43,F
18B7:  GOTO   0A6
....................     value = str_to_decimal(match_val); 
18B8:  MOVLW  20
18B9:  MOVWF  42
18BA:  MOVLW  B5
18BB:  MOVWF  41
18BC:  MOVLP  08
18BD:  MOVLB  00
18BE:  CALL   6E5
18BF:  MOVLP  18
18C0:  MOVF   78,W
18C1:  MOVLB  01
18C2:  MOVWF  43
....................   } else { 
18C3:  GOTO   0CA
18C4:  MOVLB  02
....................     value = 0; 
18C5:  MOVLB  01
18C6:  CLRF   43
....................     do_get_var = 1; 
18C7:  MOVLB  02
18C8:  BSF    2A.0
18C9:  MOVLB  01
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18CA:  MOVLB  02
18CB:  CLRF   41
18CC:  CLRF   42
18CD:  MOVLW  20
18CE:  MOVWF  05
18CF:  MOVLW  B9
18D0:  MOVWF  04
18D1:  MOVF   41,W
18D2:  ADDWF  04,F
18D3:  MOVLW  00
18D4:  ADDWFC 05,F
18D5:  MOVF   42,W
18D6:  MOVLP  00
18D7:  MOVLB  00
18D8:  CALL   146
18D9:  MOVLP  18
18DA:  MOVWF  00
18DB:  IORLW  00
18DC:  BTFSC  03.2
18DD:  GOTO   0E3
18DE:  MOVLB  02
18DF:  INCF   42,F
18E0:  INCF   41,F
18E1:  GOTO   0CD
18E2:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
18E3:  MOVLW  20
18E4:  MOVLB  02
18E5:  MOVWF  42
18E6:  MOVLW  B9
18E7:  MOVWF  41
18E8:  MOVLW  20
18E9:  MOVWF  44
18EA:  MOVLW  A2
18EB:  MOVWF  43
18EC:  MOVLP  08
18ED:  MOVLB  00
18EE:  CALL   71E
18EF:  MOVLP  18
18F0:  MOVF   78,F
18F1:  BTFSS  03.2
18F2:  GOTO   0FC
....................     if ( do_get_var ) { 
18F3:  MOVLB  02
18F4:  BTFSS  2A.0
18F5:  GOTO   0F9
....................       command=GET_REG; 
18F6:  MOVLW  03
18F7:  MOVWF  70
....................     } else { 
18F8:  GOTO   0FB
....................       command=SET_REG; 
18F9:  MOVLW  02
18FA:  MOVWF  70
18FB:  MOVLB  00
....................     } 
....................   } // }}} 
.................... #if __DEVICE__  == 1939 
....................   // Check for "setb" command {{{ 
....................   strcpy(smatch_reg,"setb");   
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
....................       command=SET_BIT; 
....................   } // }}} 
....................   // Check for "setb" command {{{ 
....................   strcpy(smatch_reg,"clrb");   
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
....................       command=CLEAR_BIT; 
....................   } // }}} 
.................... #endif 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18FC:  MOVLB  02
18FD:  CLRF   41
18FE:  CLRF   42
18FF:  MOVLW  20
1900:  MOVWF  05
1901:  MOVLW  B9
1902:  MOVWF  04
1903:  MOVF   41,W
1904:  ADDWF  04,F
1905:  MOVLW  00
1906:  ADDWFC 05,F
1907:  MOVF   42,W
1908:  MOVLP  00
1909:  MOVLB  00
190A:  CALL   14B
190B:  MOVLP  18
190C:  MOVWF  00
190D:  IORLW  00
190E:  BTFSC  03.2
190F:  GOTO   115
1910:  MOVLB  02
1911:  INCF   42,F
1912:  INCF   41,F
1913:  GOTO   0FF
1914:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1915:  MOVLW  20
1916:  MOVLB  02
1917:  MOVWF  42
1918:  MOVLW  B9
1919:  MOVWF  41
191A:  MOVLW  20
191B:  MOVWF  44
191C:  MOVLW  A2
191D:  MOVWF  43
191E:  MOVLP  08
191F:  MOVLB  00
1920:  CALL   71E
1921:  MOVLP  18
1922:  MOVF   78,F
1923:  BTFSS  03.2
1924:  GOTO   127
....................       command=SAVE_SETTINGS; 
1925:  MOVLW  04
1926:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1927:  MOVLB  02
1928:  CLRF   41
1929:  CLRF   42
192A:  MOVLW  20
192B:  MOVWF  05
192C:  MOVLW  B9
192D:  MOVWF  04
192E:  MOVF   41,W
192F:  ADDWF  04,F
1930:  MOVLW  00
1931:  ADDWFC 05,F
1932:  MOVF   42,W
1933:  MOVLP  00
1934:  MOVLB  00
1935:  CALL   151
1936:  MOVLP  18
1937:  MOVWF  00
1938:  IORLW  00
1939:  BTFSC  03.2
193A:  GOTO   140
193B:  MOVLB  02
193C:  INCF   42,F
193D:  INCF   41,F
193E:  GOTO   12A
193F:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1940:  MOVLW  20
1941:  MOVLB  02
1942:  MOVWF  42
1943:  MOVLW  B9
1944:  MOVWF  41
1945:  MOVLW  20
1946:  MOVWF  44
1947:  MOVLW  A2
1948:  MOVWF  43
1949:  MOVLP  08
194A:  MOVLB  00
194B:  CALL   71E
194C:  MOVLP  18
194D:  MOVF   78,F
194E:  BTFSS  03.2
194F:  GOTO   152
....................       command=RESTORE_SETTINGS; 
1950:  MOVLW  05
1951:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
1952:  MOVLB  02
1953:  CLRF   41
1954:  CLRF   42
1955:  MOVLW  20
1956:  MOVWF  05
1957:  MOVLW  B9
1958:  MOVWF  04
1959:  MOVF   41,W
195A:  ADDWF  04,F
195B:  MOVLW  00
195C:  ADDWFC 05,F
195D:  MOVF   42,W
195E:  MOVLP  00
195F:  MOVLB  00
1960:  CALL   15A
1961:  MOVLP  18
1962:  MOVWF  00
1963:  IORLW  00
1964:  BTFSC  03.2
1965:  GOTO   16B
1966:  MOVLB  02
1967:  INCF   42,F
1968:  INCF   41,F
1969:  GOTO   155
196A:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
196B:  MOVLW  20
196C:  MOVLB  02
196D:  MOVWF  42
196E:  MOVLW  B9
196F:  MOVWF  41
1970:  MOVLW  20
1971:  MOVWF  44
1972:  MOVLW  A2
1973:  MOVWF  43
1974:  MOVLP  08
1975:  MOVLB  00
1976:  CALL   71E
1977:  MOVLP  18
1978:  MOVF   78,F
1979:  BTFSS  03.2
197A:  GOTO   17D
....................     command=STATUS; 
197B:  MOVLW  08
197C:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
197D:  MOVLB  02
197E:  CLRF   41
197F:  CLRF   42
1980:  MOVLW  20
1981:  MOVWF  05
1982:  MOVLW  B9
1983:  MOVWF  04
1984:  MOVF   41,W
1985:  ADDWF  04,F
1986:  MOVLW  00
1987:  ADDWFC 05,F
1988:  MOVF   42,W
1989:  MOVLP  00
198A:  MOVLB  00
198B:  CALL   162
198C:  MOVLP  18
198D:  MOVWF  00
198E:  IORLW  00
198F:  BTFSC  03.2
1990:  GOTO   196
1991:  MOVLB  02
1992:  INCF   42,F
1993:  INCF   41,F
1994:  GOTO   180
1995:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1996:  MOVLW  20
1997:  MOVLB  02
1998:  MOVWF  42
1999:  MOVLW  B9
199A:  MOVWF  41
199B:  MOVLW  20
199C:  MOVWF  44
199D:  MOVLW  A2
199E:  MOVWF  43
199F:  MOVLP  08
19A0:  MOVLB  00
19A1:  CALL   71E
19A2:  MOVLP  18
19A3:  MOVF   78,F
19A4:  BTFSS  03.2
19A5:  GOTO   1AC
....................     command=ADMIN; 
19A6:  MOVLW  09
19A7:  MOVWF  70
....................     argument=REBOOT; 
19A8:  MOVLW  02
19A9:  MOVLB  01
19AA:  MOVWF  42
19AB:  MOVLB  00
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19AC:  MOVLB  02
19AD:  CLRF   41
19AE:  CLRF   42
19AF:  MOVLW  20
19B0:  MOVWF  05
19B1:  MOVLW  B9
19B2:  MOVWF  04
19B3:  MOVF   41,W
19B4:  ADDWF  04,F
19B5:  MOVLW  00
19B6:  ADDWFC 05,F
19B7:  MOVF   42,W
19B8:  MOVLP  00
19B9:  MOVLB  00
19BA:  CALL   16A
19BB:  MOVLP  18
19BC:  MOVWF  00
19BD:  IORLW  00
19BE:  BTFSC  03.2
19BF:  GOTO   1C5
19C0:  MOVLB  02
19C1:  INCF   42,F
19C2:  INCF   41,F
19C3:  GOTO   1AF
19C4:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19C5:  MOVLW  20
19C6:  MOVLB  02
19C7:  MOVWF  42
19C8:  MOVLW  B9
19C9:  MOVWF  41
19CA:  MOVLW  20
19CB:  MOVWF  44
19CC:  MOVLW  A2
19CD:  MOVWF  43
19CE:  MOVLP  08
19CF:  MOVLB  00
19D0:  CALL   71E
19D1:  MOVLP  18
19D2:  MOVF   78,F
19D3:  BTFSS  03.2
19D4:  GOTO   227
....................     //command=DTMF_SEND; 
....................     command=0; 
19D5:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D6:  MOVLW  20
19D7:  MOVLB  02
19D8:  MOVWF  42
19D9:  MOVLW  74
19DA:  MOVWF  41
19DB:  MOVLP  08
19DC:  MOVLB  00
19DD:  CALL   6E5
19DE:  MOVLP  18
19DF:  MOVF   78,W
19E0:  MOVLB  01
19E1:  MOVWF  43
....................     if ( value == d0 ) { 
19E2:  MOVF   43,W
19E3:  SUBLW  0A
19E4:  BTFSS  03.2
19E5:  GOTO   1E8
....................       value = dd; 
19E6:  CLRF   43
....................     } else if (value == dd) { 
19E7:  GOTO   1ED
19E8:  MOVF   43,F
19E9:  BTFSS  03.2
19EA:  GOTO   1ED
....................       value = d0; 
19EB:  MOVLW  0A
19EC:  MOVWF  43
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19ED:  MOVF   43,W
19EE:  ANDLW  0F
19EF:  MOVLB  02
19F0:  MOVWF  41
19F1:  MOVF   41,W
19F2:  MOVWF  42
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A27:  MOVLB  02
1A28:  CLRF   41
1A29:  CLRF   42
1A2A:  MOVLW  20
1A2B:  MOVWF  05
1A2C:  MOVLW  B9
1A2D:  MOVWF  04
1A2E:  MOVF   41,W
1A2F:  ADDWF  04,F
1A30:  MOVLW  00
1A31:  ADDWFC 05,F
1A32:  MOVF   42,W
1A33:  MOVLP  00
1A34:  MOVLB  00
1A35:  CALL   16D
1A36:  MOVLP  18
1A37:  MOVWF  00
1A38:  IORLW  00
1A39:  BTFSC  03.2
1A3A:  GOTO   240
1A3B:  MOVLB  02
1A3C:  INCF   42,F
1A3D:  INCF   41,F
1A3E:  GOTO   22A
1A3F:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A40:  MOVLW  20
1A41:  MOVLB  02
1A42:  MOVWF  42
1A43:  MOVLW  B9
1A44:  MOVWF  41
1A45:  MOVLW  20
1A46:  MOVWF  44
1A47:  MOVLW  A2
1A48:  MOVWF  43
1A49:  MOVLP  08
1A4A:  MOVLB  00
1A4B:  CALL   71E
1A4C:  MOVLP  18
1A4D:  MOVF   78,F
1A4E:  BTFSS  03.2
1A4F:  GOTO   252
....................     command=I2C_SEND; 
1A50:  MOVLW  0C
1A51:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A52:  MOVLB  02
1A53:  CLRF   41
1A54:  CLRF   42
1A55:  MOVLW  20
1A56:  MOVWF  05
1A57:  MOVLW  B9
1A58:  MOVWF  04
1A59:  MOVF   41,W
1A5A:  ADDWF  04,F
1A5B:  MOVLW  00
1A5C:  ADDWFC 05,F
1A5D:  MOVF   42,W
1A5E:  MOVLP  00
1A5F:  MOVLB  00
1A60:  CALL   172
1A61:  MOVLP  18
1A62:  MOVWF  00
1A63:  IORLW  00
1A64:  BTFSC  03.2
1A65:  GOTO   26B
1A66:  MOVLB  02
1A67:  INCF   42,F
1A68:  INCF   41,F
1A69:  GOTO   255
1A6A:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A6B:  MOVLW  20
1A6C:  MOVLB  02
1A6D:  MOVWF  42
1A6E:  MOVLW  B9
1A6F:  MOVWF  41
1A70:  MOVLW  20
1A71:  MOVWF  44
1A72:  MOVLW  A2
1A73:  MOVWF  43
1A74:  MOVLP  08
1A75:  MOVLB  00
1A76:  CALL   71E
1A77:  MOVLP  18
1A78:  MOVF   78,F
1A79:  BTFSS  03.2
1A7A:  GOTO   294
....................     value = str_to_decimal(argument_name); 
1A7B:  MOVLW  20
1A7C:  MOVLB  02
1A7D:  MOVWF  42
1A7E:  MOVLW  74
1A7F:  MOVWF  41
1A80:  MOVLP  08
1A81:  MOVLB  00
1A82:  CALL   6E5
1A83:  MOVLP  18
1A84:  MOVF   78,W
1A85:  MOVLB  01
1A86:  MOVWF  43
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A87:  MOVF   43,W
1A88:  SUBLW  24
1A89:  BTFSS  03.0
1A8A:  GOTO   28F
....................       argument = 0; 
1A8B:  CLRF   42
....................       command  = MORSE_SEND; 
1A8C:  MOVLW  0B
1A8D:  MOVWF  70
....................     } else { 
1A8E:  GOTO   293
....................       command  = ADMIN; 
1A8F:  MOVLW  09
1A90:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A91:  MOVLW  03
1A92:  MOVWF  42
1A93:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A94:  MOVLB  02
1A95:  CLRF   41
1A96:  CLRF   42
1A97:  MOVLW  20
1A98:  MOVWF  05
1A99:  MOVLW  B9
1A9A:  MOVWF  04
1A9B:  MOVF   41,W
1A9C:  ADDWF  04,F
1A9D:  MOVLW  00
1A9E:  ADDWFC 05,F
1A9F:  MOVF   42,W
1AA0:  MOVLP  00
1AA1:  MOVLB  00
1AA2:  CALL   179
1AA3:  MOVLP  18
1AA4:  MOVWF  00
1AA5:  IORLW  00
1AA6:  BTFSC  03.2
1AA7:  GOTO   2AD
1AA8:  MOVLB  02
1AA9:  INCF   42,F
1AAA:  INCF   41,F
1AAB:  GOTO   297
1AAC:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AAD:  MOVLW  20
1AAE:  MOVLB  02
1AAF:  MOVWF  42
1AB0:  MOVLW  B9
1AB1:  MOVWF  41
1AB2:  MOVLW  20
1AB3:  MOVWF  44
1AB4:  MOVLW  A2
1AB5:  MOVWF  43
1AB6:  MOVLP  08
1AB7:  MOVLB  00
1AB8:  CALL   71E
1AB9:  MOVLP  18
1ABA:  MOVF   78,F
1ABB:  BTFSS  03.2
1ABC:  GOTO   2BF
....................     command=INCREMENT_REG; 
1ABD:  MOVLW  06
1ABE:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1ABF:  MOVLB  02
1AC0:  CLRF   41
1AC1:  CLRF   42
1AC2:  MOVLW  20
1AC3:  MOVWF  05
1AC4:  MOVLW  B9
1AC5:  MOVWF  04
1AC6:  MOVF   41,W
1AC7:  ADDWF  04,F
1AC8:  MOVLW  00
1AC9:  ADDWFC 05,F
1ACA:  MOVF   42,W
1ACB:  MOVLP  00
1ACC:  MOVLB  00
1ACD:  CALL   17C
1ACE:  MOVLP  18
1ACF:  MOVWF  00
1AD0:  IORLW  00
1AD1:  BTFSC  03.2
1AD2:  GOTO   2D8
1AD3:  MOVLB  02
1AD4:  INCF   42,F
1AD5:  INCF   41,F
1AD6:  GOTO   2C2
1AD7:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AD8:  MOVLW  20
1AD9:  MOVLB  02
1ADA:  MOVWF  42
1ADB:  MOVLW  B9
1ADC:  MOVWF  41
1ADD:  MOVLW  20
1ADE:  MOVWF  44
1ADF:  MOVLW  A2
1AE0:  MOVWF  43
1AE1:  MOVLP  08
1AE2:  MOVLB  00
1AE3:  CALL   71E
1AE4:  MOVLP  18
1AE5:  MOVF   78,F
1AE6:  BTFSS  03.2
1AE7:  GOTO   2EA
....................     command=DECREMENT_REG; 
1AE8:  MOVLW  07
1AE9:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AEA:  MOVLB  02
1AEB:  CLRF   41
1AEC:  CLRF   42
1AED:  MOVLW  20
1AEE:  MOVWF  05
1AEF:  MOVLW  B9
1AF0:  MOVWF  04
1AF1:  MOVF   41,W
1AF2:  ADDWF  04,F
1AF3:  MOVLW  00
1AF4:  ADDWFC 05,F
1AF5:  MOVF   42,W
1AF6:  MOVLP  00
1AF7:  MOVLB  00
1AF8:  CALL   17F
1AF9:  MOVLP  18
1AFA:  MOVWF  00
1AFB:  IORLW  00
1AFC:  BTFSC  03.2
1AFD:  GOTO   303
1AFE:  MOVLB  02
1AFF:  INCF   42,F
1B00:  INCF   41,F
1B01:  GOTO   2ED
1B02:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B03:  MOVLW  20
1B04:  MOVLB  02
1B05:  MOVWF  42
1B06:  MOVLW  B9
1B07:  MOVWF  41
1B08:  MOVLW  20
1B09:  MOVWF  44
1B0A:  MOVLW  A2
1B0B:  MOVWF  43
1B0C:  MOVLP  08
1B0D:  MOVLB  00
1B0E:  CALL   71E
1B0F:  MOVLP  18
1B10:  MOVF   78,F
1B11:  BTFSS  03.2
1B12:  GOTO   333
....................     command=SET_REG; 
1B13:  MOVLW  02
1B14:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B15:  MOVLW  01
1B16:  MOVLB  01
1B17:  ADDWF  30,W
1B18:  ANDLW  03
1B19:  MOVWF  43
....................     strcpy(argument_name,"CPOT"); 
1B1A:  MOVLB  02
1B1B:  CLRF   41
1B1C:  CLRF   42
1B1D:  MOVLW  20
1B1E:  MOVWF  05
1B1F:  MOVLW  74
1B20:  MOVWF  04
1B21:  MOVF   41,W
1B22:  ADDWF  04,F
1B23:  MOVLW  00
1B24:  ADDWFC 05,F
1B25:  MOVF   42,W
1B26:  MOVLP  00
1B27:  MOVLB  00
1B28:  CALL   182
1B29:  MOVLP  18
1B2A:  MOVWF  00
1B2B:  IORLW  00
1B2C:  BTFSC  03.2
1B2D:  GOTO   333
1B2E:  MOVLB  02
1B2F:  INCF   42,F
1B30:  INCF   41,F
1B31:  GOTO   31D
1B32:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B33:  MOVLB  02
1B34:  CLRF   41
1B35:  CLRF   42
1B36:  MOVLW  20
1B37:  MOVWF  05
1B38:  MOVLW  B9
1B39:  MOVWF  04
1B3A:  MOVF   41,W
1B3B:  ADDWF  04,F
1B3C:  MOVLW  00
1B3D:  ADDWFC 05,F
1B3E:  MOVF   42,W
1B3F:  MOVLP  00
1B40:  MOVLB  00
1B41:  CALL   188
1B42:  MOVLP  18
1B43:  MOVWF  00
1B44:  IORLW  00
1B45:  BTFSC  03.2
1B46:  GOTO   34C
1B47:  MOVLB  02
1B48:  INCF   42,F
1B49:  INCF   41,F
1B4A:  GOTO   336
1B4B:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B4C:  MOVLW  20
1B4D:  MOVLB  02
1B4E:  MOVWF  42
1B4F:  MOVLW  B9
1B50:  MOVWF  41
1B51:  MOVLW  20
1B52:  MOVWF  44
1B53:  MOVLW  A2
1B54:  MOVWF  43
1B55:  MOVLP  08
1B56:  MOVLB  00
1B57:  CALL   71E
1B58:  MOVLP  18
1B59:  MOVF   78,F
1B5A:  BTFSS  03.2
1B5B:  GOTO   36C
....................     AdminMode = ~AdminMode; 
1B5C:  MOVLW  02
1B5D:  MOVLB  01
1B5E:  XORWF  65,F
....................     set_admin_mode(AdminMode); 
1B5F:  MOVLW  00
1B60:  BTFSC  65.1
1B61:  MOVLW  01
1B62:  MOVLB  02
1B63:  MOVWF  41
1B64:  MOVWF  42
1B65:  MOVLP  08
1B66:  MOVLB  00
1B67:  CALL   42C
1B68:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B69:  MOVLB  01
1B6A:  BSF    65.0
1B6B:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... #if __DEVICE__  == 1939 
.................... void set_bit (void) { // {{{ 
....................   int *pObj; 
....................     pObj=RegMap[argument].reg_ptr; 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
....................       *pObj=bit_set(*pObj,(value&0x1F)); 
....................     } 
....................     PROMPT_FLAG; 
.................... } // }}} 
.................... void clear_bit (void) { // {{{ 
....................   int *pObj; 
....................     pObj=RegMap[argument].reg_ptr; 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
....................       *pObj=bit_clear(*pObj,(value&0x1F)); 
....................     } 
....................     PROMPT_FLAG=1; 
.................... } // }}} 
.................... #endif 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
1132:  MOVLB  01
1133:  MOVF   43,W
1134:  SUBLW  FF
1135:  BTFSS  03.2
1136:  GOTO   155
....................     crlf(); 
1137:  MOVLP  00
1138:  MOVLB  00
1139:  CALL   457
113A:  MOVLP  10
....................     printf ("%s %u",argument,value); 
113B:  CLRF   05
113C:  MOVLB  01
113D:  MOVF   42,W
113E:  MOVWF  04
113F:  MOVLP  08
1140:  MOVLB  00
1141:  CALL   1DA
1142:  MOVLP  10
1143:  MOVLW  20
1144:  CLRWDT
1145:  BTFSS  11.4
1146:  GOTO   144
1147:  MOVLB  03
1148:  MOVWF  1A
1149:  MOVLB  01
114A:  MOVF   43,W
114B:  MOVLB  02
114C:  MOVWF  52
114D:  MOVLW  1B
114E:  MOVWF  53
114F:  MOVLP  00
1150:  MOVLB  00
1151:  CALL   6CF
1152:  MOVLP  10
....................   } else { 
1153:  GOTO   1EB
1154:  MOVLB  01
....................     pObj=RegMap[argument].reg_ptr; 
1155:  RLF    42,W
1156:  MOVWF  77
1157:  RLF    77,F
1158:  MOVLW  FC
1159:  ANDWF  77,F
115A:  MOVF   77,W
115B:  MOVLB  02
115C:  MOVWF  31
115D:  INCF   31,W
115E:  MOVLP  00
115F:  MOVLB  00
1160:  CALL   043
1161:  MOVLP  10
1162:  MOVWF  7A
1163:  MOVLB  02
1164:  MOVF   31,W
1165:  MOVLP  00
1166:  MOVLB  00
1167:  CALL   043
1168:  MOVLP  10
1169:  MOVLB  02
116A:  MOVWF  2E
116B:  MOVF   7A,W
116C:  MOVWF  2F
....................     // Consider allowing some registers to be updated outside AdminMode. 
....................     // Example : AuxOut registers, Enable 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
116D:  MOVLP  08
116E:  MOVLB  00
116F:  CALL   788
1170:  MOVLP  10
1171:  MOVF   78,F
1172:  BTFSS  03.2
1173:  GOTO   183
1174:  MOVLB  01
1175:  RLF    42,W
1176:  MOVWF  77
1177:  RLF    77,F
1178:  MOVLW  FC
1179:  ANDWF  77,F
117A:  MOVF   77,W
117B:  ADDLW  03
117C:  MOVLP  00
117D:  MOVLB  00
117E:  CALL   043
117F:  MOVLP  10
1180:  MOVWF  78
1181:  BTFSC  78.1
1182:  GOTO   18C
....................       *pObj=value; 
1183:  MOVLB  02
1184:  MOVF   2E,W
1185:  MOVWF  04
1186:  MOVF   2F,W
1187:  MOVWF  05
1188:  MOVLB  01
1189:  MOVF   43,W
118A:  MOVWF  00
118B:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
118C:  MOVLB  02
118D:  MOVF   2E,W
118E:  MOVWF  04
118F:  MOVF   2F,W
1190:  MOVWF  05
1191:  MOVF   00,W
1192:  MOVWF  30
....................     crlf(); 
1193:  MOVLP  00
1194:  MOVLB  00
1195:  CALL   457
1196:  MOVLP  10
....................     printf ("%s(%u) <= %u",argument_name,argument,lVar); 
1197:  MOVLW  20
1198:  MOVWF  05
1199:  MOVLW  74
119A:  MOVWF  04
119B:  MOVLP  08
119C:  CALL   1DA
119D:  MOVLP  10
119E:  MOVLW  28
119F:  CLRWDT
11A0:  BTFSS  11.4
11A1:  GOTO   19F
11A2:  MOVLB  03
11A3:  MOVWF  1A
11A4:  MOVLB  01
11A5:  MOVF   42,W
11A6:  MOVLB  02
11A7:  MOVWF  52
11A8:  MOVLW  1B
11A9:  MOVWF  53
11AA:  MOVLP  00
11AB:  MOVLB  00
11AC:  CALL   6CF
11AD:  MOVLP  10
11AE:  MOVLW  29
11AF:  MOVLB  03
11B0:  MOVWF  11
11B1:  MOVLW  04
11B2:  MOVWF  12
11B3:  BSF    03.0
11B4:  MOVLW  05
11B5:  MOVLB  02
11B6:  MOVWF  52
11B7:  MOVLP  00
11B8:  MOVLB  00
11B9:  CALL   65B
11BA:  MOVLP  10
11BB:  MOVLB  02
11BC:  MOVF   30,W
11BD:  MOVWF  52
11BE:  MOVLW  1B
11BF:  MOVWF  53
11C0:  MOVLP  00
11C1:  MOVLB  00
11C2:  CALL   6CF
11C3:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
11C4:  MOVLB  02
11C5:  MOVF   2F,W
11C6:  SUBLW  1F
11C7:  BTFSC  03.0
11C8:  GOTO   1DA
11C9:  XORLW  FF
11CA:  BTFSS  03.2
11CB:  GOTO   1D0
11CC:  MOVF   2E,W
11CD:  SUBLW  0B
11CE:  BTFSC  03.0
11CF:  GOTO   1DA
11D0:  MOVF   2F,W
11D1:  SUBLW  20
11D2:  BTFSS  03.0
11D3:  GOTO   1DA
11D4:  BTFSS  03.2
11D5:  GOTO   1E2
11D6:  MOVF   2E,W
11D7:  SUBLW  1B
11D8:  BTFSC  03.0
11D9:  GOTO   1E2
11DA:  MOVF   2E,W
11DB:  SUBLW  60
11DC:  BTFSS  03.2
11DD:  GOTO   1E8
11DE:  MOVF   2F,W
11DF:  SUBLW  20
11E0:  BTFSS  03.2
11E1:  GOTO   1E8
....................       increment(0); // Increment is done in this function. Only update trim pot. 
11E2:  CLRF   31
11E3:  MOVLP  08
11E4:  MOVLB  00
11E5:  CALL   797
11E6:  MOVLP  10
11E7:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
11E8:  MOVLB  01
11E9:  BSF    65.0
11EA:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
0F97:  MOVLB  01
0F98:  MOVF   30,W
0F99:  ANDLW  03
0F9A:  MOVLB  02
0F9B:  MOVWF  35
....................   if ( CurrentCorIndex ) { 
0F9C:  MOVF   75,F
0F9D:  BTFSC  03.2
0F9E:  GOTO   7D6
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
0F9F:  MOVLW  01
0FA0:  SUBWF  75,W
0FA1:  MOVWF  77
0FA2:  RLF    77,F
0FA3:  RLF    77,F
0FA4:  MOVLW  FC
0FA5:  ANDWF  77,F
0FA6:  MOVF   77,W
0FA7:  ADDWF  35,W
0FA8:  ADDLW  0C
0FA9:  MOVWF  78
0FAA:  MOVLW  20
0FAB:  MOVWF  7A
0FAC:  BTFSC  03.0
0FAD:  INCF   7A,F
0FAE:  MOVF   78,W
0FAF:  MOVWF  32
0FB0:  MOVF   7A,W
0FB1:  MOVWF  33
....................     value = *pot_ptr; 
0FB2:  MOVF   32,W
0FB3:  MOVWF  04
0FB4:  MOVF   33,W
0FB5:  MOVWF  05
0FB6:  MOVF   00,W
0FB7:  MOVWF  34
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
0FB8:  MOVF   32,W
0FB9:  MOVWF  04
0FBA:  MOVF   33,W
0FBB:  MOVWF  05
0FBC:  MOVF   31,W
0FBD:  ADDWF  34,W
0FBE:  MOVWF  00
....................     if ( in_admin_mode() ) { 
0FBF:  MOVLB  00
0FC0:  CALL   788
0FC1:  MOVF   78,F
0FC2:  BTFSC  03.2
0FC3:  GOTO   7D5
....................       set_trimpot(CPotPtr,*pot_ptr); 
0FC4:  MOVLB  02
0FC5:  MOVF   33,W
0FC6:  MOVWF  7A
0FC7:  MOVF   32,W
0FC8:  MOVWF  04
0FC9:  MOVF   33,W
0FCA:  MOVWF  05
0FCB:  MOVF   00,W
0FCC:  MOVWF  36
0FCD:  MOVF   35,W
0FCE:  MOVWF  41
0FCF:  MOVF   36,W
0FD0:  MOVWF  42
0FD1:  MOVLP  00
0FD2:  MOVLB  00
0FD3:  CALL   71E
0FD4:  MOVLP  08
0FD5:  MOVLB  02
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
0FD6:  MOVLB  00
0FD7:  CALL   1F4
.................... } // }}} 
0FD8:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
0F5D:  MOVLB  02
0F5E:  CLRF   41
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
0F5F:  MOVF   41,W
0F60:  SUBLW  05
0F61:  BTFSS  03.0
0F62:  GOTO   786
....................     dest[c]=src[c]; 
0F63:  MOVF   41,W
0F64:  ADDWF  3D,W
0F65:  MOVWF  78
0F66:  MOVLW  00
0F67:  ADDWFC 3E,W
0F68:  MOVWF  7A
0F69:  MOVF   78,W
0F6A:  MOVWF  42
0F6B:  MOVF   7A,W
0F6C:  MOVWF  43
0F6D:  MOVF   41,W
0F6E:  ADDWF  3F,W
0F6F:  MOVWF  78
0F70:  MOVLW  00
0F71:  ADDWFC 40,W
0F72:  MOVWF  7A
0F73:  MOVF   78,W
0F74:  MOVLB  03
0F75:  MOVWF  11
0F76:  MOVF   7A,W
0F77:  MOVWF  12
0F78:  MOVLB  02
0F79:  MOVF   43,W
0F7A:  MOVWF  05
0F7B:  MOVF   42,W
0F7C:  MOVWF  04
0F7D:  MOVLW  01
0F7E:  MOVWF  47
0F7F:  MOVLP  00
0F80:  MOVLB  00
0F81:  CALL   797
0F82:  MOVLP  08
....................   c++; 
0F83:  MOVLB  02
0F84:  INCF   41,F
....................   } 
0F85:  GOTO   75F
.................... } // }}} 
0F86:  MOVLB  00
0F87:  RETURN
.................... void ExecAuxOutOp(char op,char arg,char ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
1C7D:  MOVF   2C,W
1C7E:  ANDLW  0F
1C7F:  MOVWF  2E
....................   uarg = (arg & 0xF0) >> 4; 
1C80:  MOVF   2C,W
1C81:  ANDLW  F0
1C82:  MOVWF  77
1C83:  SWAPF  77,W
1C84:  MOVWF  2F
1C85:  MOVLW  0F
1C86:  ANDWF  2F,F
....................   switch(op) { 
1C87:  MOVF   2B,W
1C88:  XORLW  02
1C89:  MOVLB  00
1C8A:  BTFSC  03.2
1C8B:  GOTO   490
1C8C:  XORLW  03
1C8D:  BTFSC  03.2
1C8E:  GOTO   4AA
1C8F:  GOTO   504
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
1C90:  MOVLW  22
1C91:  MOVLB  02
1C92:  ADDWF  2D,W
1C93:  MOVWF  04
1C94:  MOVLW  20
1C95:  MOVWF  05
1C96:  BTFSC  03.0
1C97:  INCF   05,F
1C98:  MOVF   2E,W
1C99:  ANDLW  1F
1C9A:  MOVWF  33
1C9B:  MOVF   7A,W
1C9C:  MOVWF  34
1C9D:  MOVF   2F,W
1C9E:  XORWF  33,F
1C9F:  BTFSS  03.2
1CA0:  GOTO   4A6
1CA1:  MOVF   34,F
1CA2:  BTFSS  03.2
1CA3:  GOTO   4A6
1CA4:  MOVLW  00
1CA5:  GOTO   4A7
1CA6:  MOVLW  01
1CA7:  MOVWF  00
....................     break; 
1CA8:  MOVLB  00
1CA9:  GOTO   504
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       // Only COR_IN_HW is used which corresponds to the COR inputs on the controller. 
....................       // Emulated COR_IN are ignored. 
....................       int1 invert_output = ((arg & AUX_OUT_FOLLOW_COR_INVERT_OUTPUT)!=0); 
....................       int1 cor_active = ((COR_IN_HW & ~TOT_FLAG_Mask & larg) != 0); 
....................       int1 disable_delay_en = ((arg & AUX_OUT_FOLLOW_COR_OFF_DELAY) !=0); 
....................       int1 enable_delay = ((arg & AUX_OUT_FOLLOW_COR_ON_DELAY) !=0); 
....................       int1 disable_delay = (disable_delay_en && (AuxOutDelayCnt != 0)); 
....................       int1 pin_value; 
1CAA:  MOVLB  02
1CAB:  BCF    30.0
1CAC:  MOVF   2C,W
1CAD:  ANDLW  10
1CAE:  BTFSS  03.2
1CAF:  BSF    30.0
1CB0:  BCF    30.1
1CB1:  MOVLB  00
1CB2:  MOVF   6A,W
1CB3:  XORLW  FF
1CB4:  ANDWF  5F,W
1CB5:  MOVLB  02
1CB6:  ANDWF  2E,W
1CB7:  BTFSS  03.2
1CB8:  BSF    30.1
1CB9:  BCF    30.2
1CBA:  MOVF   2C,W
1CBB:  ANDLW  20
1CBC:  BTFSS  03.2
1CBD:  BSF    30.2
1CBE:  BCF    30.3
1CBF:  MOVF   2C,W
1CC0:  ANDLW  40
1CC1:  BTFSS  03.2
1CC2:  BSF    30.3
1CC3:  BCF    30.4
1CC4:  BTFSS  30.2
1CC5:  GOTO   4CE
1CC6:  MOVLB  01
1CC7:  MOVF   35,F
1CC8:  BTFSS  03.2
1CC9:  GOTO   4CC
1CCA:  MOVLB  02
1CCB:  GOTO   4CE
1CCC:  MOVLB  02
1CCD:  BSF    30.4
....................       if ( cor_active ) { 
1CCE:  BTFSS  30.1
1CCF:  GOTO   4F0
....................         // Activate output after several seconds of active QSO 
....................         // or keep the pin active if servicing a disable delay. 
....................         if (enable_delay) { 
1CD0:  BTFSS  30.3
1CD1:  GOTO   4E8
....................           pin_value = (QSO_Duration > QSO_DURATION_DELAY) || disable_delay; 
1CD2:  BCF    30.5
1CD3:  MOVLB  00
1CD4:  MOVF   6C,F
1CD5:  BTFSS  03.2
1CD6:  GOTO   4DF
1CD7:  MOVF   6B,W
1CD8:  SUBLW  05
1CD9:  BTFSS  03.0
1CDA:  GOTO   4DF
1CDB:  MOVLB  02
1CDC:  BTFSS  30.4
1CDD:  GOTO   4E1
1CDE:  MOVLB  00
1CDF:  MOVLB  02
1CE0:  BSF    30.5
....................           if ( pin_value ) { 
1CE1:  BTFSS  30.5
1CE2:  GOTO   4E7
....................             AuxOutDelayCnt = 60; 
1CE3:  MOVLW  3C
1CE4:  MOVLB  01
1CE5:  MOVWF  35
1CE6:  MOVLB  02
....................           } 
....................         } else { 
1CE7:  GOTO   4EF
....................           pin_value = 1; 
1CE8:  BSF    30.5
.................... 	  if ( disable_delay_en ) { 
1CE9:  BTFSS  30.2
1CEA:  GOTO   4EF
....................             AuxOutDelayCnt = 60; 
1CEB:  MOVLW  3C
1CEC:  MOVLB  01
1CED:  MOVWF  35
1CEE:  MOVLB  02
.................... 	  } 
....................         } 
....................       } else { 
1CEF:  GOTO   4F3
....................         pin_value = disable_delay; 
1CF0:  BCF    30.5
1CF1:  BTFSC  30.4
1CF2:  BSF    30.5
....................       } 
....................       AuxOut[ID] = pin_value ^ invert_output; 
1CF3:  MOVLW  22
1CF4:  ADDWF  2D,W
1CF5:  MOVWF  04
1CF6:  MOVLW  20
1CF7:  MOVWF  05
1CF8:  BTFSC  03.0
1CF9:  INCF   05,F
1CFA:  MOVLW  00
1CFB:  BTFSC  30.5
1CFC:  MOVLW  01
1CFD:  MOVWF  34
1CFE:  MOVLW  00
1CFF:  BTFSC  30.0
1D00:  MOVLW  01
1D01:  XORWF  34,W
1D02:  MOVWF  00
....................     break; 
1D03:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0EE5:  MOVLB  02
0EE6:  CLRF   43
0EE7:  CLRF   44
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0EE8:  MOVF   43,W
0EE9:  ADDWF  41,W
0EEA:  MOVWF  04
0EEB:  MOVLW  00
0EEC:  ADDWFC 42,W
0EED:  MOVWF  05
0EEE:  MOVF   00,F
0EEF:  BTFSC  03.2
0EF0:  GOTO   71A
0EF1:  MOVF   43,W
0EF2:  ADDWF  41,W
0EF3:  MOVWF  04
0EF4:  MOVLW  00
0EF5:  ADDWFC 42,W
0EF6:  MOVWF  05
0EF7:  MOVF   00,W
0EF8:  SUBLW  2F
0EF9:  BTFSC  03.0
0EFA:  GOTO   71A
0EFB:  MOVF   43,W
0EFC:  ADDWF  41,W
0EFD:  MOVWF  04
0EFE:  MOVLW  00
0EFF:  ADDWFC 42,W
0F00:  MOVWF  05
0F01:  MOVF   00,W
0F02:  SUBLW  39
0F03:  BTFSS  03.0
0F04:  GOTO   71A
....................     value = (value * 10) + (str[x]-'0'); 
0F05:  MOVF   44,W
0F06:  MOVWF  45
0F07:  MOVLW  0A
0F08:  MOVWF  46
0F09:  MOVLB  00
0F0A:  CALL   6BE
0F0B:  MOVF   78,W
0F0C:  MOVLB  02
0F0D:  MOVWF  45
0F0E:  MOVF   43,W
0F0F:  ADDWF  41,W
0F10:  MOVWF  04
0F11:  MOVLW  00
0F12:  ADDWFC 42,W
0F13:  MOVWF  05
0F14:  MOVLW  30
0F15:  SUBWF  00,W
0F16:  ADDWF  45,W
0F17:  MOVWF  44
....................     x++; 
0F18:  INCF   43,F
....................   } 
0F19:  GOTO   6E8
....................   return(value); 
0F1A:  MOVF   44,W
0F1B:  MOVWF  78
.................... } // }}} 
0F1C:  MOVLB  00
0F1D:  RETURN
.................... void ExecAuxInOp(char op,char arg,char ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
168B:  MOVLB  02
168C:  BCF    2E.0
168D:  MOVLW  1F
168E:  ADDWF  2D,W
168F:  MOVWF  04
1690:  MOVLW  20
1691:  MOVWF  05
1692:  BTFSC  03.0
1693:  INCF   05,F
1694:  MOVF   00,F
1695:  BTFSS  03.2
1696:  BSF    2E.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   // Include arg[4] for COR4 emulation 
....................   larg = arg & 0x1F; 
1697:  MOVF   2C,W
1698:  ANDLW  1F
1699:  MOVWF  2F
....................   uarg = (arg & 0xF0) >> 4; 
169A:  MOVF   2C,W
169B:  ANDLW  F0
169C:  MOVWF  77
169D:  SWAPF  77,W
169E:  MOVWF  30
169F:  MOVLW  0F
16A0:  ANDWF  30,F
....................   switch(op) { 
16A1:  MOVLW  01
16A2:  SUBWF  2B,W
16A3:  ADDLW  FC
16A4:  BTFSC  03.0
16A5:  GOTO   6EA
16A6:  ADDLW  04
16A7:  MOVLB  00
16A8:  GOTO   6ED
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
16A9:  MOVLB  02
16AA:  BTFSS  2E.0
16AB:  GOTO   6B1
....................         Enable_Mask &= arg; 
16AC:  MOVF   2C,W
16AD:  MOVLB  00
16AE:  ANDWF  63,F
....................       } else { // AuxIn is not enabled 
16AF:  GOTO   6B6
16B0:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
16B1:  MOVF   2C,W
16B2:  XORLW  FF
16B3:  ANDLW  0F
16B4:  MOVLB  00
16B5:  IORWF  63,F
....................       } 
....................       break; 
16B6:  MOVLB  02
16B7:  GOTO   6EA
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
16B8:  MOVLB  02
16B9:  BTFSS  2E.0
16BA:  GOTO   6C1
....................         COR_DROP_FLAG=1; 
16BB:  MOVLB  01
16BC:  BSF    62.0
....................         TailChar=arg; 
16BD:  MOVLB  02
16BE:  MOVF   2C,W
16BF:  MOVWF  72
....................       } else { 
16C0:  GOTO   6C2
....................         TailChar=0; 
16C1:  CLRF   72
....................       } 
....................     break; 
16C2:  GOTO   6EA
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
16C3:  MOVLB  02
16C4:  BTFSC  2E.0
16C5:  GOTO   6CC
....................         COR_DROP_FLAG=1; 
16C6:  MOVLB  01
16C7:  BSF    62.0
....................         TailChar=arg; 
16C8:  MOVLB  02
16C9:  MOVF   2C,W
16CA:  MOVWF  72
....................       } else { 
16CB:  GOTO   6CD
....................         TailChar=0; 
16CC:  CLRF   72
....................       } 
....................     break; 
16CD:  GOTO   6EA
....................     case AUXI_EMULATE_COR: 
....................       int1 active_low = (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0; 
16CE:  MOVLB  02
16CF:  BCF    2E.2
16D0:  MOVF   2C,W
16D1:  ANDLW  20
16D2:  BTFSS  03.2
16D3:  BSF    2E.2
....................       tmp_bit = (active_low ^ in_bit); 
16D4:  MOVLW  00
16D5:  BTFSC  2E.2
16D6:  MOVLW  01
16D7:  MOVWF  32
16D8:  MOVLW  00
16D9:  BTFSC  2E.0
16DA:  MOVLW  01
16DB:  XORWF  32,W
16DC:  MOVWF  78
16DD:  BCF    2E.1
16DE:  BTFSC  78.0
16DF:  BSF    2E.1
....................       if ( tmp_bit ) { 
16E0:  BTFSS  2E.1
16E1:  GOTO   6E5
....................         COR_AUX |= larg; 
16E2:  MOVF   2F,W
16E3:  IORWF  71,F
....................       } else { 
16E4:  GOTO   6E8
....................         COR_AUX &= ~larg; 
16E5:  MOVF   2F,W
16E6:  XORLW  FF
16E7:  ANDWF  71,F
....................       } 
....................     break; 
16E8:  GOTO   6EA
16E9:  MOVLB  02
....................   } 
.................... } // }}} 
16EA:  MOVLP  18
16EB:  MOVLB  00
16EC:  GOTO   576 (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
14FE:  MOVLB  01
14FF:  CLRF   68
1500:  MOVF   68,W
1501:  SUBLW  02
1502:  BTFSS  03.0
1503:  GOTO   543
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = ((input(AUX_IN_PIN[x])!=0 )|| (AuxIn[x]!=0)); 
1504:  MOVLW  1F
1505:  ADDWF  68,W
1506:  MOVWF  69
1507:  MOVLW  20
1508:  MOVWF  6A
1509:  BTFSC  03.0
150A:  INCF   6A,F
150B:  MOVF   68,W
150C:  MOVLP  00
150D:  MOVLB  00
150E:  CALL   03F
150F:  MOVLP  10
1510:  MOVLB  01
1511:  MOVWF  6B
1512:  MOVLB  02
1513:  MOVWF  42
1514:  MOVLW  01
1515:  MOVWF  43
1516:  CLRF   45
1517:  MOVLW  80
1518:  MOVWF  44
1519:  MOVLP  00
151A:  MOVLB  00
151B:  CALL   7D8
151C:  MOVLP  10
151D:  MOVLB  01
151E:  MOVF   6B,W
151F:  MOVWF  6C
1520:  CLRF   6E
1521:  CLRF   6D
1522:  MOVLP  08
1523:  MOVLB  00
1524:  GOTO   7D9
1525:  MOVLP  10
1526:  BTFSC  78.0
1527:  GOTO   538
1528:  MOVLW  1C
1529:  MOVLB  01
152A:  ADDWF  68,W
152B:  MOVWF  04
152C:  MOVLW  20
152D:  MOVWF  05
152E:  BTFSC  03.0
152F:  INCF   05,F
1530:  MOVF   00,F
1531:  BTFSC  03.2
1532:  GOTO   535
1533:  MOVLB  00
1534:  GOTO   538
1535:  MOVLW  00
1536:  GOTO   53A
1537:  MOVLB  00
1538:  MOVLW  01
1539:  MOVLB  01
153A:  MOVWF  6C
153B:  MOVF   6A,W
153C:  MOVWF  05
153D:  MOVF   69,W
153E:  MOVWF  04
153F:  MOVF   6C,W
1540:  MOVWF  00
....................   } 
1541:  INCF   68,F
1542:  GOTO   500
.................... } // }}} 
1543:  MOVLP  18
1544:  MOVLB  00
1545:  GOTO   754 (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
1C42:  MOVLW  30
1C43:  MOVLB  01
1C44:  MOVWF  6B
1C45:  MOVWF  6C
1C46:  MOVWF  6D
1C47:  CLRF   6E
....................   char AuxOut_s[4]={'0','0','0',0}; 
1C48:  MOVWF  6F
1C49:  MOVLB  02
1C4A:  MOVWF  20
1C4B:  MOVWF  21
1C4C:  CLRF   22
....................   char ADM[]=" ADMIN"; 
1C4D:  MOVLW  20
1C4E:  MOVWF  23
1C4F:  MOVLW  41
1C50:  MOVWF  24
1C51:  MOVLW  44
1C52:  MOVWF  25
1C53:  MOVLW  4D
1C54:  MOVWF  26
1C55:  MOVLW  49
1C56:  MOVWF  27
1C57:  MOVLW  4E
1C58:  MOVWF  28
1C59:  CLRF   29
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
1C5A:  MOVLB  01
1C5B:  CLRF   68
1C5C:  MOVF   68,W
1C5D:  SUBLW  02
1C5E:  BTFSS  03.0
1C5F:  GOTO   57A
....................     AuxOp = AuxOutOp[x]; 
1C60:  MOVLW  33
1C61:  ADDWF  68,W
1C62:  MOVWF  04
1C63:  MOVLW  20
1C64:  MOVWF  05
1C65:  BTFSC  03.0
1C66:  INCF   05,F
1C67:  MOVF   00,W
1C68:  MOVWF  69
....................     AuxArg = AuxOutArg[x]; 
1C69:  MOVLW  36
1C6A:  ADDWF  68,W
1C6B:  MOVWF  04
1C6C:  MOVLW  20
1C6D:  MOVWF  05
1C6E:  BTFSC  03.0
1C6F:  INCF   05,F
1C70:  MOVF   00,W
1C71:  MOVWF  6A
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
1C72:  MOVF   69,W
1C73:  MOVLB  02
1C74:  MOVWF  2B
1C75:  MOVLB  01
1C76:  MOVF   6A,W
1C77:  MOVLB  02
1C78:  MOVWF  2C
1C79:  MOVLB  01
1C7A:  MOVF   68,W
1C7B:  MOVLB  02
1C7C:  MOVWF  2D
....................     out_bit = (AuxOut[x])==0; 
*
1D04:  MOVLB  02
1D05:  BCF    2A.0
1D06:  MOVLW  22
1D07:  MOVLB  01
1D08:  ADDWF  68,W
1D09:  MOVWF  04
1D0A:  MOVLW  20
1D0B:  MOVWF  05
1D0C:  BTFSC  03.0
1D0D:  INCF   05,F
1D0E:  MOVF   00,F
1D0F:  BTFSS  03.2
1D10:  GOTO   514
1D11:  MOVLB  02
1D12:  BSF    2A.0
1D13:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
1D14:  MOVF   68,W
1D15:  MOVLP  00
1D16:  MOVLB  00
1D17:  CALL   03B
1D18:  MOVLP  18
1D19:  MOVLB  02
1D1A:  MOVWF  2B
1D1B:  MOVLW  00
1D1C:  BTFSC  2A.0
1D1D:  MOVLW  01
1D1E:  MOVWF  77
1D1F:  MOVF   2B,W
1D20:  MOVWF  42
1D21:  MOVF   77,W
1D22:  MOVWF  43
1D23:  MOVLW  01
1D24:  MOVWF  45
1D25:  CLRF   44
1D26:  MOVLP  00
1D27:  MOVLB  00
1D28:  CALL   7D8
1D29:  MOVLP  18
1D2A:  MOVLB  02
1D2B:  MOVF   2B,W
1D2C:  MOVWF  42
1D2D:  CLRF   43
1D2E:  CLRF   45
1D2F:  MOVLW  80
1D30:  MOVWF  44
1D31:  MOVLP  00
1D32:  MOVLB  00
1D33:  CALL   7D8
1D34:  MOVLP  18
....................     if(out_bit==0) { 
1D35:  MOVLB  02
1D36:  BTFSC  2A.0
1D37:  GOTO   543
....................       AuxOut_s[x]='1'; 
1D38:  MOVLW  9F
1D39:  MOVLB  01
1D3A:  ADDWF  68,W
1D3B:  MOVWF  04
1D3C:  MOVLW  20
1D3D:  MOVWF  05
1D3E:  BTFSC  03.0
1D3F:  INCF   05,F
1D40:  MOVLW  31
1D41:  MOVWF  00
1D42:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
1D43:  MOVLW  39
1D44:  MOVLB  01
1D45:  ADDWF  68,W
1D46:  MOVWF  04
1D47:  MOVLW  20
1D48:  MOVWF  05
1D49:  BTFSC  03.0
1D4A:  INCF   05,F
1D4B:  MOVF   00,W
1D4C:  MOVWF  69
....................     AuxArg = AuxInArg[x]; 
1D4D:  MOVLW  3C
1D4E:  ADDWF  68,W
1D4F:  MOVWF  04
1D50:  MOVLW  20
1D51:  MOVWF  05
1D52:  BTFSC  03.0
1D53:  INCF   05,F
1D54:  MOVF   00,W
1D55:  MOVWF  6A
....................     if(AuxInSW[x]==1) { 
1D56:  MOVLW  1F
1D57:  ADDWF  68,W
1D58:  MOVWF  04
1D59:  MOVLW  20
1D5A:  MOVWF  05
1D5B:  BTFSC  03.0
1D5C:  INCF   05,F
1D5D:  DECFSZ 00,W
1D5E:  GOTO   568
....................       AuxIn_s[x]='1'; 
1D5F:  MOVLW  9B
1D60:  ADDWF  68,W
1D61:  MOVWF  04
1D62:  MOVLW  20
1D63:  MOVWF  05
1D64:  BTFSC  03.0
1D65:  INCF   05,F
1D66:  MOVLW  31
1D67:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
1D68:  MOVF   69,W
1D69:  MOVLB  02
1D6A:  MOVWF  2B
1D6B:  MOVLB  01
1D6C:  MOVF   6A,W
1D6D:  MOVLB  02
1D6E:  MOVWF  2C
1D6F:  MOVLB  01
1D70:  MOVF   68,W
1D71:  MOVLB  02
1D72:  MOVWF  2D
1D73:  MOVLP  10
1D74:  MOVLB  00
1D75:  GOTO   68B
1D76:  MOVLP  18
....................     // }}} 
....................   } 
1D77:  MOVLB  01
1D78:  INCF   68,F
1D79:  GOTO   45C
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
1D7A:  MOVLW  20
1D7B:  MOVWF  67
1D7C:  MOVLW  7A
1D7D:  MOVWF  66
1D7E:  MOVLW  49
1D7F:  MOVLB  02
1D80:  MOVWF  52
1D81:  MOVLP  08
1D82:  MOVLB  00
1D83:  CALL   095
1D84:  MOVLP  18
1D85:  MOVLW  3A
1D86:  MOVLB  02
1D87:  MOVWF  52
1D88:  MOVLP  08
1D89:  MOVLB  00
1D8A:  CALL   095
1D8B:  MOVLP  18
1D8C:  MOVLW  20
1D8D:  MOVWF  05
1D8E:  MOVLW  9B
1D8F:  MOVWF  04
1D90:  MOVLP  08
1D91:  CALL   0F7
1D92:  MOVLP  18
1D93:  MOVLW  20
1D94:  MOVLB  02
1D95:  MOVWF  52
1D96:  MOVLP  08
1D97:  MOVLB  00
1D98:  CALL   095
1D99:  MOVLP  18
1D9A:  MOVLW  4F
1D9B:  MOVLB  02
1D9C:  MOVWF  52
1D9D:  MOVLP  08
1D9E:  MOVLB  00
1D9F:  CALL   095
1DA0:  MOVLP  18
1DA1:  MOVLW  3A
1DA2:  MOVLB  02
1DA3:  MOVWF  52
1DA4:  MOVLP  08
1DA5:  MOVLB  00
1DA6:  CALL   095
1DA7:  MOVLP  18
1DA8:  MOVLW  20
1DA9:  MOVWF  05
1DAA:  MOVLW  9F
1DAB:  MOVWF  04
1DAC:  MOVLP  08
1DAD:  CALL   0F7
1DAE:  MOVLP  18
....................   if ( AdminMode ) { 
1DAF:  MOVLB  01
1DB0:  BTFSS  65.1
1DB1:  GOTO   5C0
....................     strcat(LCD_str,ADM); 
1DB2:  MOVLW  20
1DB3:  MOVLB  02
1DB4:  MOVWF  2C
1DB5:  MOVLW  7A
1DB6:  MOVWF  2B
1DB7:  MOVLW  20
1DB8:  MOVWF  2E
1DB9:  MOVLW  A3
1DBA:  MOVWF  2D
1DBB:  MOVLP  10
1DBC:  MOVLB  00
1DBD:  CALL   6F5
1DBE:  MOVLP  18
1DBF:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
1DC0:  MOVLW  03
1DC1:  MOVLB  02
1DC2:  MOVWF  4C
1DC3:  MOVLW  20
1DC4:  MOVWF  4E
1DC5:  MOVLW  7A
1DC6:  MOVWF  4D
1DC7:  MOVLP  08
1DC8:  MOVLB  00
1DC9:  CALL   10C
1DCA:  MOVLP  18
.................... } // }}} 
1DCB:  MOVLP  18
1DCC:  GOTO   775 (RETURN)
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
1071:  MOVLW  01
1072:  MOVLB  02
1073:  MOVWF  30
1074:  MOVLP  08
1075:  MOVLB  00
1076:  CALL   2E2
1077:  MOVLP  10
....................   delay_ms(1000); 
1078:  MOVLW  04
1079:  MOVLB  02
107A:  MOVWF  30
107B:  MOVLW  FA
107C:  MOVWF  4C
107D:  MOVLP  00
107E:  MOVLB  00
107F:  CALL   77E
1080:  MOVLP  10
1081:  MOVLB  02
1082:  DECFSZ 30,F
1083:  GOTO   07B
....................   for(x=0;x<6;x++) { 
1084:  CLRF   2E
1085:  MOVF   2E,W
1086:  SUBLW  05
1087:  BTFSS  03.0
1088:  GOTO   0A5
....................     mchar=Morse[x]; 
1089:  MOVLW  2D
108A:  ADDWF  2E,W
108B:  MOVWF  04
108C:  MOVLW  20
108D:  MOVWF  05
108E:  BTFSC  03.0
108F:  INCF   05,F
1090:  MOVF   00,W
1091:  MOVWF  2F
....................     morse(mchar); 
1092:  MOVF   2F,W
1093:  MOVWF  41
1094:  MOVLP  08
1095:  MOVLB  00
1096:  CALL   038
1097:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
1098:  MOVLB  01
1099:  CLRF   34
109A:  MOVLW  06
109B:  MOVWF  33
....................     while(aux_timer) { 
109C:  MOVF   33,W
109D:  IORWF  34,W
109E:  BTFSC  03.2
109F:  GOTO   0A2
....................       delay_cycles(1); 
10A0:  NOP
....................     } 
10A1:  GOTO   09C
....................   } 
10A2:  MOVLB  02
10A3:  INCF   2E,F
10A4:  GOTO   085
....................   delay_ms(1000); 
10A5:  MOVLW  04
10A6:  MOVWF  30
10A7:  MOVLW  FA
10A8:  MOVWF  4C
10A9:  MOVLP  00
10AA:  MOVLB  00
10AB:  CALL   77E
10AC:  MOVLP  10
10AD:  MOVLB  02
10AE:  DECFSZ 30,F
10AF:  GOTO   0A7
....................   PROCESS_COR_FLAG=1; 
10B0:  BSF    7D.1
.................... } // }}} 
10B1:  MOVLB  00
10B2:  RETURN
.................... void main (void) { // {{{ 
*
1F0E:  CLRF   05
1F0F:  CLRF   04
1F10:  MOVLW  1F
1F11:  ANDWF  03,F
1F12:  MOVLW  72
1F13:  MOVLB  01
1F14:  MOVWF  19
1F15:  BSF    0E.3
1F16:  BSF    0E.4
1F17:  MOVLB  04
1F18:  BCF    17.0
1F19:  BCF    17.1
1F1A:  BCF    17.3
1F1B:  MOVLW  13
1F1C:  MOVWF  12
1F1D:  MOVLW  28
1F1E:  MOVWF  15
1F1F:  BSF    14.7
1F20:  BCF    14.6
1F21:  MOVLW  0C
1F22:  MOVLB  03
1F23:  MOVWF  1B
1F24:  MOVLW  A2
1F25:  MOVWF  1E
1F26:  MOVLW  90
1F27:  MOVWF  1D
1F28:  MOVLB  01
1F29:  BSF    65.3
1F2A:  CLRF   67
1F2B:  CLRF   66
1F2C:  MOVLB  0F
1F2D:  CLRF   11
1F2E:  CLRF   12
1F2F:  CLRF   18
1F30:  CLRF   19
1F31:  CLRF   1A
1F32:  MOVLB  03
1F33:  CLRF   0C
1F34:  CLRF   0D
1F35:  CLRF   0F
1F36:  CLRF   10
1F37:  MOVLB  02
1F38:  CLRF   12
1F39:  CLRF   11
1F3A:  CLRF   14
1F3B:  CLRF   13
....................   initialize(); 
*
1F3F:  MOVLP  08
1F40:  GOTO   441
1F41:  MOVLP  18
.................... #ignore_warnings 203 
....................   while(1) { // {{{ 
.................... #ignore_warnings none 
....................     restart_wdt(); 
1F42:  CLRWDT
....................   process_buttons(); 
1F43:  MOVLP  08
1F44:  GOTO   517
1F45:  MOVLP  18
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "\r" or "+" or "-" is received. 
....................     if ( sBufferFlag ) { 
1F46:  BTFSS  7D.0
1F47:  GOTO   74D
....................       process_sBuffer(); 
1F48:  GOTO   000
....................       clear_sBuffer(); 
1F49:  MOVLP  00
1F4A:  CALL   43D
1F4B:  MOVLP  18
....................       sBufferFlag=0; 
1F4C:  BCF    7D.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1F4D:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1F4E:  MOVLB  01
1F4F:  BTFSS  62.1
1F50:  GOTO   758
....................       update_aux_in(); 
1F51:  MOVLP  10
1F52:  MOVLB  00
1F53:  GOTO   4FE
1F54:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1F55:  MOVLB  01
1F56:  BCF    62.1
....................       AUX_OUT_FLAG=1; 
1F57:  BSF    62.2
....................     } 
....................     do_delay_counters(); 
1F58:  MOVLP  10
1F59:  MOVLB  00
1F5A:  GOTO   546
1F5B:  MOVLP  18
....................     restart_wdt(); 
1F5C:  CLRWDT
....................     if ( COR_IN_FLAG ) { 
1F5D:  BTFSS  7D.2
1F5E:  GOTO   766
....................       PROCESS_COR_FLAG = read_cor_in_ports(); 
1F5F:  MOVLP  10
1F60:  GOTO   5E8
1F61:  MOVLP  18
1F62:  BCF    7D.1
1F63:  BTFSC  78.0
1F64:  BSF    7D.1
....................       COR_IN_FLAG = 0; 
1F65:  BCF    7D.2
....................     } 
....................     if ( PROCESS_COR_FLAG ) { 
1F66:  BTFSS  7D.1
1F67:  GOTO   770
....................       process_cor(); 
1F68:  MOVLP  10
1F69:  GOTO   608
1F6A:  MOVLP  18
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       AUX_OUT_FLAG=1; 
1F6B:  MOVLB  01
1F6C:  BSF    62.2
....................       PROCESS_COR_FLAG=0; 
1F6D:  BCF    7D.1
....................       restart_wdt(); 
1F6E:  CLRWDT
1F6F:  MOVLB  00
....................     } 
....................     if ( AUX_OUT_FLAG ) { 
1F70:  MOVLB  01
1F71:  BTFSS  62.2
1F72:  GOTO   777
....................       update_aux_out();  
1F73:  MOVLB  00
1F74:  GOTO   442
....................       AUX_OUT_FLAG=0; 
1F75:  MOVLB  01
1F76:  BCF    62.2
....................     } 
....................     if ( DTMF_INTERRUPT_FLAG ) { 
1F77:  BTFSS  62.6
1F78:  GOTO   77F
....................       // Extract data from DTMF device 
....................       process_dtmf_interrupt(); 
1F79:  MOVLP  10
1F7A:  MOVLB  00
1F7B:  GOTO   72E
1F7C:  MOVLP  18
....................       DTMF_INTERRUPT_FLAG=0; 
1F7D:  MOVLB  01
1F7E:  BCF    62.6
....................     } 
....................     if ( DTMF_IN_FLAG ) { 
1F7F:  BTFSS  62.5
1F80:  GOTO   788
....................       print_dtmf_info(); 
1F81:  MOVLP  10
1F82:  MOVLB  00
1F83:  GOTO   780
1F84:  MOVLP  18
....................       DTMF_IN_FLAG=0; 
1F85:  MOVLB  01
1F86:  BCF    62.5
....................       restart_wdt(); 
1F87:  CLRWDT
....................     } 
....................     if ( DTMF_FLAG ) { 
1F88:  BTFSS  62.4
1F89:  GOTO   78F
....................       process_dtmf(); 
1F8A:  MOVLB  00
1F8B:  GOTO   5FE
....................       DTMF_FLAG=0; 
1F8C:  MOVLB  01
1F8D:  BCF    62.4
....................     restart_wdt(); 
1F8E:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1F8F:  BTFSS  62.7
1F90:  GOTO   795
....................       clear_dtmf_array(); 
1F91:  MOVLB  00
1F92:  GOTO   6F7
....................       CLEAR_DTMF_FLAG=0; 
1F93:  MOVLB  01
1F94:  BCF    62.7
....................     } 
....................     if ( PROMPT_FLAG ) { 
1F95:  BTFSS  65.0
1F96:  GOTO   79E
....................       prompt(); 
1F97:  MOVLP  10
1F98:  MOVLB  00
1F99:  CALL   049
1F9A:  MOVLP  18
....................       PROMPT_FLAG=0; 
1F9B:  MOVLB  01
1F9C:  BCF    65.0
....................     restart_wdt(); 
1F9D:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1F9E:  MOVLB  00
1F9F:  GOTO   742
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0B0F:  CLRWDT
*
1FA0:  SLEEP
....................   delay_ms(1000); 
*
0B10:  MOVLW  04
0B11:  MOVLB  02
0B12:  MOVWF  41
0B13:  MOVLW  FA
0B14:  MOVWF  4C
0B15:  MOVLP  00
0B16:  MOVLB  00
0B17:  CALL   77E
0B18:  MOVLP  08
0B19:  MOVLB  02
0B1A:  DECFSZ 41,F
0B1B:  GOTO   313
....................   if ( ConfirmChar!=0 ) { 
0B1C:  MOVF   73,F
0B1D:  BTFSC  03.2
0B1E:  GOTO   331
....................     morse(ConfirmChar); 
0B1F:  MOVF   73,W
0B20:  MOVWF  41
0B21:  MOVLB  00
0B22:  CALL   038
....................     ConfirmChar=0; 
0B23:  CLRF   73
....................     restart_wdt(); 
0B24:  CLRWDT
....................     delay_ms(500); 
0B25:  MOVLW  02
0B26:  MOVLB  02
0B27:  MOVWF  41
0B28:  MOVLW  FA
0B29:  MOVWF  4C
0B2A:  MOVLP  00
0B2B:  MOVLB  00
0B2C:  CALL   77E
0B2D:  MOVLP  08
0B2E:  MOVLB  02
0B2F:  DECFSZ 41,F
0B30:  GOTO   328
....................   } 
....................   if (TailChar != 0) { 
0B31:  MOVF   72,F
0B32:  BTFSC  03.2
0B33:  GOTO   346
....................     morse(TailChar); 
0B34:  MOVF   72,W
0B35:  MOVWF  41
0B36:  MOVLB  00
0B37:  CALL   038
....................     TailChar=0; 
0B38:  CLRF   72
....................     restart_wdt(); 
0B39:  CLRWDT
....................     delay_ms(500); 
0B3A:  MOVLW  02
0B3B:  MOVLB  02
0B3C:  MOVWF  41
0B3D:  MOVLW  FA
0B3E:  MOVWF  4C
0B3F:  MOVLP  00
0B40:  MOVLB  00
0B41:  CALL   77E
0B42:  MOVLP  08
0B43:  MOVLB  02
0B44:  DECFSZ 41,F
0B45:  GOTO   33D
....................   } 
....................   restart_wdt(); 
0B46:  CLRWDT
0B47:  MOVLB  01
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
0F88:  MOVLB  01
0F89:  BTFSS  65.1
0F8A:  GOTO   78D
....................     admin_timer = ADMIN_TIMEOUT; 
0F8B:  MOVLW  FF
0F8C:  MOVWF  7E
....................   } 
....................   return(AdminMode||rs232_mode); 
0F8D:  BTFSC  65.1
0F8E:  GOTO   793
0F8F:  BTFSC  65.2
0F90:  GOTO   793
0F91:  MOVLW  00
0F92:  GOTO   794
0F93:  MOVLW  01
0F94:  MOVWF  78
.................... } // }}} 
0F95:  MOVLB  00
0F96:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0C2C:  MOVLB  01
0C2D:  BCF    65.1
0C2E:  MOVLB  02
0C2F:  MOVF   42,F
0C30:  BTFSC  03.2
0C31:  GOTO   435
0C32:  MOVLB  01
0C33:  BSF    65.1
0C34:  MOVLB  02
....................   if (AdminMode) { 
0C35:  MOVLB  01
0C36:  BTFSS  65.1
0C37:  GOTO   43D
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0C38:  MOVLW  0A
0C39:  MOVWF  73
....................     admin_timer = ADMIN_TIMEOUT; 
0C3A:  MOVLW  FF
0C3B:  MOVWF  7E
....................   } else { 
0C3C:  GOTO   43F
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0C3D:  MOVLW  18
0C3E:  MOVWF  73
....................   }  
.................... } // }}} 
0C3F:  MOVLB  00
0C40:  RETURN
.................... // string matchnig function with case insensitive match. 
.................... int1 my_stricmp(char *s1,char *s2) { // {{{ 
*
0F1E:  MOVLB  02
0F1F:  CLRF   45
....................   unsigned int x=0; 
....................   const char AMASK=0xDF; 
....................   while((AMASK&s1[x])==(AMASK&s2[x])) { 
0F20:  MOVF   45,W
0F21:  ADDWF  41,W
0F22:  MOVWF  04
0F23:  MOVLW  00
0F24:  ADDWFC 42,W
0F25:  MOVWF  05
0F26:  MOVF   00,W
0F27:  ANDLW  DF
0F28:  MOVWF  46
0F29:  MOVF   45,W
0F2A:  ADDWF  43,W
0F2B:  MOVWF  04
0F2C:  MOVLW  00
0F2D:  ADDWFC 44,W
0F2E:  MOVWF  05
0F2F:  MOVF   00,W
0F30:  ANDLW  DF
0F31:  SUBWF  46,W
0F32:  BTFSS  03.2
0F33:  GOTO   742
....................     if(s1[x]==0) { 
0F34:  MOVF   45,W
0F35:  ADDWF  41,W
0F36:  MOVWF  04
0F37:  MOVLW  00
0F38:  ADDWFC 42,W
0F39:  MOVWF  05
0F3A:  MOVF   00,F
0F3B:  BTFSS  03.2
0F3C:  GOTO   740
....................       return 0; 
0F3D:  MOVLW  00
0F3E:  MOVWF  78
0F3F:  GOTO   744
....................     } 
....................     x++; 
0F40:  INCF   45,F
....................   } 
0F41:  GOTO   720
....................   // Strings don't match. Return 1. 
....................   return 1; 
0F42:  MOVLW  01
0F43:  MOVWF  78
.................... } // }}} 
0F44:  MOVLB  00
0F45:  RETURN
.................... // Fetches data from MC8888 device upon interrupt 
.................... void process_dtmf_interrupt(void) { // {{{ 
....................   int value,dtmf_status; 
....................   dtmf_status = dtmf_read(CONTROL_REG); 
*
172E:  MOVLW  01
172F:  MOVLB  02
1730:  MOVWF  3D
1731:  MOVLP  00
1732:  MOVLB  00
1733:  CALL   62D
1734:  MOVLP  10
1735:  MOVF   78,W
1736:  MOVLB  01
1737:  MOVWF  69
....................   if ( dtmf_status & DTMF_BUFFER_FULL) { 
1738:  BTFSS  69.2
1739:  GOTO   77D
....................     value=dtmf_read(DATA_REG); 
173A:  MOVLB  02
173B:  CLRF   3D
173C:  MOVLP  00
173D:  MOVLB  00
173E:  CALL   62D
173F:  MOVLP  10
1740:  MOVF   78,W
1741:  MOVLB  01
1742:  MOVWF  68
....................     DTMF_IN_FLAG=1; 
1743:  BSF    62.5
....................     if ( value == dd ) { 
1744:  MOVF   68,F
1745:  BTFSS  03.2
1746:  GOTO   74A
....................       value=d0; 
1747:  MOVLW  0A
1748:  MOVWF  68
....................     } else if ( value == d0 ) { 
1749:  GOTO   74E
174A:  MOVF   68,W
174B:  SUBLW  0A
174C:  BTFSC  03.2
....................       value=dd; 
174D:  CLRF   68
....................     } 
....................     if ( value == ds ) { 
174E:  MOVF   68,W
174F:  SUBLW  0B
1750:  BTFSC  03.2
....................       CLEAR_DTMF_FLAG=1; 
1751:  BSF    62.7
....................     } 
....................     // Check for '#' 
....................     if ( value == dp ) { 
1752:  MOVF   68,W
1753:  SUBLW  0C
1754:  BTFSS  03.2
1755:  GOTO   75E
....................       DTMF_FLAG = 1; 
1756:  BSF    62.4
....................       DTMF_ptr->Last=1; 
1757:  MOVF   40,W
1758:  MOVWF  04
1759:  MOVF   41,W
175A:  MOVWF  05
175B:  ADDFSR 00,FSR0
175C:  BSF    00.5
....................     } else { 
175D:  GOTO   77D
....................       if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
175E:  MOVF   41,W
175F:  SUBLW  20
1760:  BTFSS  03.0
1761:  GOTO   77D
1762:  BTFSS  03.2
1763:  GOTO   768
1764:  MOVF   40,W
1765:  SUBLW  6F
1766:  BTFSS  03.0
1767:  GOTO   77D
....................         DTMF_ptr->Key=value; 
1768:  MOVF   40,W
1769:  MOVWF  04
176A:  MOVF   41,W
176B:  MOVWF  05
176C:  ADDFSR 00,FSR0
176D:  MOVF   68,W
176E:  ANDLW  0F
176F:  MOVWF  77
1770:  MOVLW  F0
1771:  ANDWF  00,W
1772:  IORWF  77,W
1773:  MOVWF  00
....................         DTMF_ptr->Strobe=1; 
1774:  MOVF   40,W
1775:  MOVWF  04
1776:  MOVF   41,W
1777:  MOVWF  05
1778:  ADDFSR 00,FSR0
1779:  BSF    00.4
....................         DTMF_ptr++; 
177A:  INCF   40,F
177B:  BTFSC  03.2
177C:  INCF   41,F
....................       } 
....................     } 
....................   } 
.................... } // }}} 
177D:  MOVLP  18
177E:  MOVLB  00
177F:  GOTO   77C (RETURN)
.................... void init_lcd(void) { // {{{ 
.................... #define INIT 0x18 
.................... #define MODE_SET 0x1C 
.................... #define ENABLE 0x04 
....................   i2c_start(); 
....................   i2c_write(LCD_I2C_ADD<<1); 
....................   // Function set 
....................   // Initialize in 8-bit mode first for 3 clock cycles 
....................   lcd_strobe(0x30);lcd_strobe(0x30);lcd_strobe(0x30); 
....................   // Init 4-bit interface mode 
....................   lcd_strobe(0x20); 
....................   lcd_write(0,0x2C); 
....................   // Display On/Off, Cursor off 
....................   lcd_write(0,0x0C); 
....................   // Display clear 
....................   lcd_write(0,0x01); 
....................   // Entry mode set 
....................   lcd_write(0,0x04); 
....................   i2c_stop(); 
.................... } // }}} 
.................... void do_delay_counters(void) { 
....................   // Second Flag {{{ 
....................   if ( SECOND_FLAG ) { 
*
1546:  BTFSS  7D.5
1547:  GOTO   5AC
....................     if ((COR_IN_EFFECTIVE != 0x00) && (QSO_Duration != 0xFFFF )) { 
1548:  MOVF   61,F
1549:  BTFSC  03.2
154A:  GOTO   553
154B:  INCFSZ 6B,W
154C:  GOTO   550
154D:  INCFSZ 6C,W
154E:  GOTO   550
154F:  GOTO   553
....................       QSO_Duration++;  
1550:  INCF   6B,F
1551:  BTFSC  03.2
1552:  INCF   6C,F
....................     } 
....................     AUX_OUT_FLAG=1; 
1553:  MOVLB  01
1554:  BSF    62.2
....................     // Time Out PTT {{{ 
....................     if ( (TOT_Min > 0) && (QSO_Duration >= (TOT_Min*60))) { 
1555:  MOVLB  00
1556:  MOVF   68,F
1557:  BTFSS  03.2
1558:  GOTO   55C
1559:  MOVF   69,F
155A:  BTFSC  03.2
155B:  GOTO   58F
155C:  MOVF   69,W
155D:  MOVLB  02
155E:  MOVWF  40
155F:  MOVLB  00
1560:  MOVF   68,W
1561:  MOVLB  02
1562:  MOVWF  3F
1563:  CLRF   42
1564:  MOVLW  3C
1565:  MOVWF  41
1566:  MOVLP  08
1567:  MOVLB  00
1568:  CALL   746
1569:  MOVLP  10
156A:  MOVF   79,W
156B:  MOVWF  7A
156C:  MOVF   7A,W
156D:  SUBWF  6C,W
156E:  BTFSS  03.0
156F:  GOTO   58F
1570:  BTFSS  03.2
1571:  GOTO   576
1572:  MOVF   78,W
1573:  SUBWF  6B,W
1574:  BTFSS  03.0
1575:  GOTO   58F
....................       if ( TOT_FLAG_Mask == 0 ) { 
1576:  MOVF   6A,F
1577:  BTFSS  03.2
1578:  GOTO   58D
....................         crlf(); 
1579:  MOVLP  00
157A:  CALL   457
157B:  MOVLP  10
....................         printf("# PTT Timeout!\n"); 
157C:  MOVLW  2E
157D:  MOVLB  03
157E:  MOVWF  11
157F:  MOVLW  04
1580:  MOVWF  12
1581:  MOVLP  00
1582:  MOVLB  00
1583:  CALL   45C
1584:  MOVLP  10
....................         PROMPT_FLAG=1; 
1585:  MOVLB  01
1586:  BSF    65.0
....................         update_ptt(0); 
1587:  MOVLB  02
1588:  CLRF   30
1589:  MOVLP  08
158A:  MOVLB  00
158B:  CALL   2E2
158C:  MOVLP  10
....................       } 
....................       TOT_FLAG_Mask=COR_IN_EFFECTIVE; 
158D:  MOVF   61,W
158E:  MOVWF  6A
....................     } 
....................     // }}} 
....................     // AuxOutDelayCnt {{{ 
....................     if ( AuxOutDelayCnt ) { 
158F:  MOVLB  01
1590:  MOVF   35,F
1591:  BTFSS  03.2
....................       AuxOutDelayCnt--; 
1592:  DECF   35,F
....................     } 
....................     // }}} 
....................     // Admin mode timeout {{{ 
....................     if ( admin_timer ) { 
1593:  MOVF   7E,F
1594:  BTFSC  03.2
1595:  GOTO   598
....................       admin_timer--; 
1596:  DECF   7E,F
....................     } else { 
1597:  GOTO   5A1
....................       // Exit admin mode. 
....................       if ( AdminMode ) { 
1598:  BTFSS  65.1
1599:  GOTO   5A1
....................         set_admin_mode(0); 
159A:  MOVLB  02
159B:  CLRF   42
159C:  MOVLP  08
159D:  MOVLB  00
159E:  CALL   42C
159F:  MOVLP  10
15A0:  MOVLB  01
....................       } 
....................     } 
....................     // }}} 
....................     restart_wdt(); 
15A1:  CLRWDT
....................     if ( SecondCounter ) { 
15A2:  MOVF   63,F
15A3:  BTFSC  03.2
15A4:  GOTO   5A7
....................       SecondCounter--; 
15A5:  DECF   63,F
....................     } else { 
15A6:  GOTO   5AA
....................       SecondCounter=SEC_COUNTER; 
15A7:  MOVLW  3B
15A8:  MOVWF  63
....................       MINUTE_FLAG = 1; 
15A9:  BSF    7D.6
....................     } 
....................     SECOND_FLAG=0; 
15AA:  BCF    7D.5
15AB:  MOVLB  00
....................   } 
....................   // Second Flag }}} 
....................   // Minute flag {{{ 
....................   if ( MINUTE_FLAG ) { 
15AC:  BTFSS  7D.6
15AD:  GOTO   5CE
....................     if ( MinuteCounter ) { 
15AE:  MOVLB  01
15AF:  MOVF   64,F
15B0:  BTFSC  03.2
15B1:  GOTO   5B4
....................       MinuteCounter--; 
15B2:  DECF   64,F
....................     } else { 
15B3:  GOTO   5B7
....................       THIRTY_MIN_FLAG=1; 
15B4:  BSF    7D.7
....................       MinuteCounter = MIN_COUNTER; 
15B5:  MOVLW  1D
15B6:  MOVWF  64
....................     } 
....................     MINUTE_FLAG = 0; 
15B7:  BCF    7D.6
....................     // Link timeout timer {{{ 
....................     if ( Link_TOT != 0 ) { 
15B8:  MOVLB  00
15B9:  MOVF   6D,F
15BA:  BTFSC  03.2
15BB:  GOTO   5CE
....................       if ( LinkDurationTimer ) { 
15BC:  MOVF   6E,F
15BD:  BTFSC  03.2
15BE:  GOTO   5C1
....................         LinkDurationTimer--; 
15BF:  DECF   6E,F
....................       } else { 
15C0:  GOTO   5CE
....................         // Disable Link 
....................         crlf(); 
15C1:  MOVLP  00
15C2:  CALL   457
15C3:  MOVLP  10
....................         printf("# Link TOT!\n"); 
15C4:  MOVLW  36
15C5:  MOVLB  03
15C6:  MOVWF  11
15C7:  MOVLW  04
15C8:  MOVWF  12
15C9:  MOVLP  00
15CA:  MOVLB  00
15CB:  CALL   45C
15CC:  MOVLP  10
....................         Enable&=0xFE; 
15CD:  BCF    62.0
....................       } 
....................     } 
....................     // Link timeout timer }}} 
....................   } 
....................   // Minute flag }}} 
....................   if ( THIRTY_MIN_FLAG ) { // {{{ 
15CE:  BTFSS  7D.7
15CF:  GOTO   5E6
....................     if ( (TXSiteID&0x03) !=0 ) { 
15D0:  MOVF   66,W
15D1:  ANDLW  03
15D2:  BTFSC  03.2
15D3:  GOTO   5E5
....................       // Transmit Site ID every 30 mins when: 
....................       // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................       // E = Transmit every 30 mins 
....................       // M = Transmit only if EnableMask is off 
....................       if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
15D4:  MOVF   66,W
15D5:  ANDLW  01
15D6:  BTFSS  03.2
15D7:  GOTO   5E4
15D8:  MOVF   66,W
15D9:  ANDLW  02
15DA:  BTFSC  03.2
15DB:  GOTO   5E5
15DC:  SWAPF  66,W
15DD:  MOVWF  77
15DE:  MOVLW  0F
15DF:  ANDWF  77,F
15E0:  MOVF   77,W
15E1:  ANDLW  0F
15E2:  ANDWF  62,W
15E3:  BTFSC  03.2
....................         send_morse_id(); 
15E4:  CALL   071
....................       } 
....................     } 
....................     THIRTY_MIN_FLAG=0; 
15E5:  BCF    7D.7
....................   } // }}} 
.................... } 
15E6:  MOVLP  18
15E7:  GOTO   75B (RETURN)
....................  
.................... void crlf(void) { // {{{ 
....................   putc('\n'); 
*
0457:  MOVLW  0A
0458:  CALL   2E4
....................   putc('\r'); 
0459:  MOVLW  0D
045A:  CALL   2E4
.................... } // }}} 
045B:  RETURN
....................  
.................... void process_buttons(void) { // {{{ 
.................... #ifdef BUTTON_STATES 
....................   char enter_b,select_b; 
....................   unsigned _cor_in; 
....................   unsigned int pot_value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
0D17:  MOVLB  01
0D18:  MOVF   30,W
0D19:  ANDLW  03
0D1A:  MOVWF  6C
....................   // Process Enter / select buttons {{{ 
....................   _cor_in = (COR_IN | COR_EMUL ) & 0x0F; 
0D1B:  MOVLB  00
0D1C:  MOVF   60,W
0D1D:  IORWF  6F,W
0D1E:  ANDLW  0F
0D1F:  MOVLB  01
0D20:  MOVWF  6A
....................   if ( input(ENTER_BUTTON)==0 ) { 
0D21:  BSF    0C.7
0D22:  MOVLB  00
0D23:  BTFSC  0C.7
0D24:  GOTO   531
....................     ENTER_PRESSED = (enter_b == DEBOUNCE_COUNT); 
0D25:  BCF    7D.3
0D26:  MOVLB  01
0D27:  MOVF   68,W
0D28:  SUBLW  08
0D29:  BTFSC  03.2
0D2A:  BSF    7D.3
....................     if ( enter_b < DEBOUNCE_COUNT+ 1 ) { 
0D2B:  MOVF   68,W
0D2C:  SUBLW  08
0D2D:  BTFSC  03.0
....................       enter_b++;  
0D2E:  INCF   68,F
....................     } 
....................   } else { 
0D2F:  GOTO   534
0D30:  MOVLB  00
....................     enter_b = 0; 
0D31:  MOVLB  01
0D32:  CLRF   68
....................     ENTER_PRESSED = 0; 
0D33:  BCF    7D.3
....................   } 
....................   if ( input(SELECT_BUTTON)==0 ) { 
0D34:  MOVLB  00
0D35:  BTFSC  10.3
0D36:  GOTO   543
....................     SELECT_PRESSED = (select_b == DEBOUNCE_COUNT); 
0D37:  BCF    7D.4
0D38:  MOVLB  01
0D39:  MOVF   69,W
0D3A:  SUBLW  08
0D3B:  BTFSC  03.2
0D3C:  BSF    7D.4
....................     if ( select_b < DEBOUNCE_COUNT + 1 ) { 
0D3D:  MOVF   69,W
0D3E:  SUBLW  08
0D3F:  BTFSC  03.0
....................       select_b++; 
0D40:  INCF   69,F
....................     } 
....................   } else { 
0D41:  GOTO   546
0D42:  MOVLB  00
....................     select_b = 0; 
0D43:  MOVLB  01
0D44:  CLRF   69
....................     SELECT_PRESSED = 0; 
0D45:  BCF    7D.4
....................   } 
....................   // Define Button States 
....................   // IDLE + ENTER --> TRIM 
....................   // TRIM + ENTER --> Exit 
....................   // TRIM + SELECT --> NextPot 
....................   switch (button_state) { 
0D46:  MOVF   61,W
0D47:  XORLW  00
0D48:  MOVLB  00
0D49:  BTFSC  03.2
0D4A:  GOTO   552
0D4B:  XORLW  10
0D4C:  BTFSC  03.2
0D4D:  GOTO   559
0D4E:  XORLW  1F
0D4F:  BTFSC  03.2
0D50:  GOTO   569
0D51:  GOTO   5D9
....................     case BUTTON_IDLE:   
....................       if ( ENTER_PRESSED == 1 ) { 
0D52:  BTFSS  7D.3
0D53:  GOTO   558
....................         button_state=CALIB; 
0D54:  MOVLW  10
0D55:  MOVLB  01
0D56:  MOVWF  61
0D57:  MOVLB  00
....................       } 
....................     break; 
0D58:  GOTO   5DC
....................     case CALIB: 
....................       adj_value_a = read_adc() >> 2; 
0D59:  MOVLB  01
0D5A:  BSF    1D.1
0D5B:  BTFSC  1D.1
0D5C:  GOTO   55B
0D5D:  RRF    1C,W
0D5E:  MOVWF  5F
0D5F:  RRF    5F,F
0D60:  MOVLW  3F
0D61:  ANDWF  5F,F
....................       adj_value_b = adj_value_a; 
0D62:  MOVF   5F,W
0D63:  MOVWF  60
....................       button_state=TRIM; 
0D64:  MOVLW  0F
0D65:  MOVWF  61
....................       pot_values_to_lcd(); 
0D66:  MOVLB  00
0D67:  CALL   1F4
....................       break; 
0D68:  GOTO   5DC
....................     case TRIM: 
....................        if ( _cor_in != 0 ) { 
0D69:  MOVLB  01
0D6A:  MOVF   6A,F
0D6B:  BTFSC  03.2
0D6C:  GOTO   59E
....................          adj_value_a = read_adc() >> 2; 
0D6D:  BSF    1D.1
0D6E:  BTFSC  1D.1
0D6F:  GOTO   56E
0D70:  RRF    1C,W
0D71:  MOVWF  5F
0D72:  RRF    5F,F
0D73:  MOVLW  3F
0D74:  ANDWF  5F,F
....................          pot_value = 63-adj_value_a; 
0D75:  MOVF   5F,W
0D76:  SUBLW  3F
0D77:  MOVWF  6B
....................          if ( adj_value_a != adj_value_b ) { 
0D78:  MOVF   60,W
0D79:  SUBWF  5F,W
0D7A:  BTFSC  03.2
0D7B:  GOTO   59C
....................            rs232_mode = 1; 
0D7C:  BSF    65.2
....................            set_trimpot(CurrentTrimPot, pot_value); 
0D7D:  MOVF   30,W
0D7E:  MOVLB  02
0D7F:  MOVWF  41
0D80:  MOVLB  01
0D81:  MOVF   6B,W
0D82:  MOVLB  02
0D83:  MOVWF  42
0D84:  MOVLP  00
0D85:  MOVLB  00
0D86:  CALL   71E
0D87:  MOVLP  08
....................            pot_values_to_lcd(); 
0D88:  CALL   1F4
.................... 	   RX_GAIN[CurrentCorIndex-1][CPotPtr]=pot_value; 
0D89:  MOVLW  01
0D8A:  SUBWF  75,W
0D8B:  MOVWF  77
0D8C:  RLF    77,F
0D8D:  RLF    77,F
0D8E:  MOVLW  FC
0D8F:  ANDWF  77,F
0D90:  MOVF   77,W
0D91:  MOVLB  01
0D92:  ADDWF  6C,W
0D93:  ADDLW  0C
0D94:  MOVWF  04
0D95:  MOVLW  20
0D96:  MOVWF  05
0D97:  BTFSC  03.0
0D98:  INCF   05,F
0D99:  MOVF   6B,W
0D9A:  MOVWF  00
....................            rs232_mode = 0; 
0D9B:  BCF    65.2
....................          } 
....................          adj_value_b = adj_value_a; 
0D9C:  MOVF   5F,W
0D9D:  MOVWF  60
.................... 	     } 
....................        if ( SELECT_PRESSED == 1 ) { 
0D9E:  BTFSS  7D.4
0D9F:  GOTO   5A7
....................          CurrentTrimPot = (CurrentTrimPot + 1 ) & 0x03; 
0DA0:  MOVLW  01
0DA1:  ADDWF  30,W
0DA2:  ANDLW  03
0DA3:  MOVWF  30
....................          pot_values_to_lcd(); 
0DA4:  MOVLB  00
0DA5:  CALL   1F4
0DA6:  MOVLB  01
....................        } 
....................        if ( ENTER_PRESSED == 1 ) { 
0DA7:  BTFSS  7D.3
0DA8:  GOTO   5B1
....................          // Hold SELECT and press ENTER to store settings in EEPROM 
....................          if ( input(SELECT_BUTTON)==0 ) { 
0DA9:  MOVLB  00
0DAA:  BTFSC  10.3
0DAB:  GOTO   5AF
....................            store_variables(); 
0DAC:  MOVLP  00
0DAD:  CALL   559
0DAE:  MOVLP  08
....................          } 
....................          button_state = BUTTON_IDLE; 
0DAF:  MOVLB  01
0DB0:  CLRF   61
.................... 	     }  
....................        status_led(); 
....................     break; 
*
0DD7:  MOVLB  00
0DD8:  GOTO   5DC
....................     default: 
....................   		button_state = BUTTON_IDLE; 
0DD9:  MOVLB  01
0DDA:  CLRF   61
....................     break; 
0DDB:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0DDC:  CLRWDT
....................   // }}} 
.................... #endif 
.................... } // }}} 
0DDD:  MOVLP  18
0DDE:  GOTO   745 (RETURN)

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
