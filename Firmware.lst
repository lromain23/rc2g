CCS PCM C Compiler, Version 4.140, 64991               29-Aug-22 21:14

               Filename:   C:\Users\luc\Projects\MBPAB IDE\RC2Gb\EricLaroche\65\Firmware.lst

               ROM used:   8106 words (99%)
                           Largest free fragment is 53
               RAM used:   165 (32%) at main() level
                           232 (45%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   72B
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   348
002D:  MOVLP  00
002E:  GOTO   36F
002F:  MOVLP  00
0030:  GOTO   2EB
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #device ADC=8; 
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
1647:  MOVLB  02
1648:  MOVF   29,W
1649:  MOVWF  2D
164A:  MOVF   28,W
164B:  MOVWF  2C
164C:  MOVF   2D,W
164D:  MOVWF  7A
164E:  MOVF   2C,W
164F:  MOVWF  04
1650:  MOVF   7A,W
1651:  MOVWF  05
1652:  MOVF   00,F
1653:  BTFSC  03.2
1654:  GOTO   659
1655:  INCF   2C,F
1656:  BTFSC  03.2
1657:  INCF   2D,F
1658:  GOTO   64C
....................    while(*s2 != '\0') 
....................    { 
1659:  MOVF   2B,W
165A:  MOVWF  7A
165B:  MOVF   2A,W
165C:  MOVWF  04
165D:  MOVF   7A,W
165E:  MOVWF  05
165F:  MOVF   00,F
1660:  BTFSC  03.2
1661:  GOTO   675
....................       *s = *s2; 
1662:  MOVF   2A,W
1663:  MOVWF  04
1664:  MOVF   2B,W
1665:  MOVWF  05
1666:  MOVF   00,W
1667:  MOVWF  30
1668:  MOVF   2D,W
1669:  MOVWF  05
166A:  MOVF   2C,W
166B:  MOVWF  04
166C:  MOVF   30,W
166D:  MOVWF  00
....................       ++s; 
166E:  INCF   2C,F
166F:  BTFSC  03.2
1670:  INCF   2D,F
....................       ++s2; 
1671:  INCF   2A,F
1672:  BTFSC  03.2
1673:  INCF   2B,F
....................    } 
1674:  GOTO   659
....................  
....................    *s = '\0'; 
1675:  MOVF   2C,W
1676:  MOVWF  04
1677:  MOVF   2D,W
1678:  MOVWF  05
1679:  CLRF   00
....................    return(s1); 
167A:  MOVF   28,W
167B:  MOVWF  78
167C:  MOVF   29,W
167D:  MOVWF  79
.................... } 
167E:  MOVLB  00
167F:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0ED4:  MOVF   48,W
0ED5:  MOVWF  4C
0ED6:  MOVF   47,W
0ED7:  MOVWF  4B
0ED8:  MOVF   4C,W
0ED9:  MOVWF  7A
0EDA:  MOVF   4B,W
0EDB:  MOVWF  04
0EDC:  MOVF   7A,W
0EDD:  MOVWF  05
0EDE:  MOVF   00,F
0EDF:  BTFSC  03.2
0EE0:  GOTO   70D
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0EE1:  MOVF   4A,W
0EE2:  MOVWF  4E
0EE3:  MOVF   49,W
0EE4:  MOVWF  4D
0EE5:  MOVF   4E,W
0EE6:  MOVWF  7A
0EE7:  MOVF   4D,W
0EE8:  MOVWF  04
0EE9:  MOVF   7A,W
0EEA:  MOVWF  05
0EEB:  MOVF   00,F
0EEC:  BTFSC  03.2
0EED:  GOTO   709
....................          if (*sc1 == *sc2) 
0EEE:  MOVF   4C,W
0EEF:  MOVWF  7A
0EF0:  MOVF   4B,W
0EF1:  MOVWF  04
0EF2:  MOVF   7A,W
0EF3:  MOVWF  05
0EF4:  MOVF   00,W
0EF5:  MOVWF  4F
0EF6:  MOVF   4E,W
0EF7:  MOVWF  7A
0EF8:  MOVF   4D,W
0EF9:  MOVWF  04
0EFA:  MOVF   7A,W
0EFB:  MOVWF  05
0EFC:  MOVF   00,W
0EFD:  SUBWF  4F,W
0EFE:  BTFSS  03.2
0EFF:  GOTO   705
....................             return(sc1); 
0F00:  MOVF   4B,W
0F01:  MOVWF  78
0F02:  MOVF   4C,W
0F03:  MOVWF  79
0F04:  GOTO   710
0F05:  INCF   4D,F
0F06:  BTFSC  03.2
0F07:  INCF   4E,F
0F08:  GOTO   6E5
0F09:  INCF   4B,F
0F0A:  BTFSC  03.2
0F0B:  INCF   4C,F
0F0C:  GOTO   6D8
....................    return(0); 
0F0D:  MOVLW  00
0F0E:  MOVWF  78
0F0F:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E6D:  MOVF   48,W
0E6E:  MOVWF  4C
0E6F:  MOVF   47,W
0E70:  MOVWF  4B
0E71:  MOVF   4C,W
0E72:  MOVWF  7A
0E73:  MOVF   4B,W
0E74:  MOVWF  04
0E75:  MOVF   7A,W
0E76:  MOVWF  05
0E77:  MOVF   00,F
0E78:  BTFSC  03.2
0E79:  GOTO   6AB
....................       for (sc2 = s2; ; sc2++) 
0E7A:  MOVF   4A,W
0E7B:  MOVWF  4E
0E7C:  MOVF   49,W
0E7D:  MOVWF  4D
....................     if (*sc2 == '\0') 
0E7E:  MOVF   4E,W
0E7F:  MOVWF  7A
0E80:  MOVF   4D,W
0E81:  MOVWF  04
0E82:  MOVF   7A,W
0E83:  MOVWF  05
0E84:  MOVF   00,F
0E85:  BTFSS  03.2
0E86:  GOTO   691
....................        return(sc1 - s1); 
0E87:  MOVF   47,W
0E88:  SUBWF  4B,W
0E89:  MOVWF  77
0E8A:  MOVF   48,W
0E8B:  SUBWFC 4C,W
0E8C:  MOVWF  7A
0E8D:  MOVF   77,W
0E8E:  MOVWF  78
0E8F:  GOTO   6B3
....................          else if (*sc1 == *sc2) 
0E90:  GOTO   6A3
0E91:  MOVF   4C,W
0E92:  MOVWF  7A
0E93:  MOVF   4B,W
0E94:  MOVWF  04
0E95:  MOVF   7A,W
0E96:  MOVWF  05
0E97:  MOVF   00,W
0E98:  MOVWF  4F
0E99:  MOVF   4E,W
0E9A:  MOVWF  7A
0E9B:  MOVF   4D,W
0E9C:  MOVWF  04
0E9D:  MOVF   7A,W
0E9E:  MOVWF  05
0E9F:  MOVF   00,W
0EA0:  SUBWF  4F,W
0EA1:  BTFSC  03.2
....................             break; 
0EA2:  GOTO   6A7
0EA3:  INCF   4D,F
0EA4:  BTFSC  03.2
0EA5:  INCF   4E,F
0EA6:  GOTO   67E
0EA7:  INCF   4B,F
0EA8:  BTFSC  03.2
0EA9:  INCF   4C,F
0EAA:  GOTO   671
....................    return(sc1 - s1); 
0EAB:  MOVF   47,W
0EAC:  SUBWF  4B,W
0EAD:  MOVWF  77
0EAE:  MOVF   48,W
0EAF:  SUBWFC 4C,W
0EB0:  MOVWF  7A
0EB1:  MOVF   77,W
0EB2:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1F59:  MOVLB  00
1F5A:  CLRF   26
1F5B:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0E54:  MOVLB  02
0E55:  MOVF   3F,W
0E56:  IORWF  40,W
0E57:  BTFSC  03.2
0E58:  GOTO   65D
0E59:  MOVF   40,W
0E5A:  MOVWF  7A
0E5B:  MOVF   3F,W
0E5C:  GOTO   662
0E5D:  MOVLB  00
0E5E:  MOVF   27,W
0E5F:  MOVWF  7A
0E60:  MOVF   26,W
0E61:  MOVLB  02
0E62:  MOVWF  43
0E63:  MOVF   7A,W
0E64:  MOVWF  44
....................    beg += strspn(beg, s2); 
0E65:  MOVF   44,W
0E66:  MOVWF  48
0E67:  MOVF   43,W
0E68:  MOVWF  47
0E69:  MOVF   42,W
0E6A:  MOVWF  4A
0E6B:  MOVF   41,W
0E6C:  MOVWF  49
*
0EB3:  MOVF   78,W
0EB4:  ADDWF  43,F
0EB5:  MOVLW  00
0EB6:  ADDWFC 44,F
....................    if (*beg == '\0') 
0EB7:  MOVF   44,W
0EB8:  MOVWF  7A
0EB9:  MOVF   43,W
0EBA:  MOVWF  04
0EBB:  MOVF   7A,W
0EBC:  MOVWF  05
0EBD:  MOVF   00,F
0EBE:  BTFSS  03.2
0EBF:  GOTO   6CC
....................    { 
....................       *save = ' '; 
0EC0:  MOVLB  00
0EC1:  MOVF   26,W
0EC2:  MOVWF  04
0EC3:  MOVF   27,W
0EC4:  MOVWF  05
0EC5:  MOVLW  20
0EC6:  MOVWF  00
....................       return(0); 
0EC7:  MOVLW  00
0EC8:  MOVWF  78
0EC9:  MOVWF  79
0ECA:  GOTO   731
0ECB:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0ECC:  MOVF   44,W
0ECD:  MOVWF  48
0ECE:  MOVF   43,W
0ECF:  MOVWF  47
0ED0:  MOVF   42,W
0ED1:  MOVWF  4A
0ED2:  MOVF   41,W
0ED3:  MOVWF  49
*
0F10:  MOVF   79,W
0F11:  MOVWF  46
0F12:  MOVF   78,W
0F13:  MOVWF  45
....................    if (*end != '\0') 
0F14:  MOVF   46,W
0F15:  MOVWF  7A
0F16:  MOVF   45,W
0F17:  MOVWF  04
0F18:  MOVF   7A,W
0F19:  MOVWF  05
0F1A:  MOVF   00,F
0F1B:  BTFSC  03.2
0F1C:  GOTO   725
....................    { 
....................       *end = '\0'; 
0F1D:  MOVF   45,W
0F1E:  MOVWF  04
0F1F:  MOVF   46,W
0F20:  MOVWF  05
0F21:  CLRF   00
....................       end++; 
0F22:  INCF   45,F
0F23:  BTFSC  03.2
0F24:  INCF   46,F
....................    } 
....................    save = end; 
0F25:  MOVF   46,W
0F26:  MOVLB  00
0F27:  MOVWF  27
0F28:  MOVLB  02
0F29:  MOVF   45,W
0F2A:  MOVLB  00
0F2B:  MOVWF  26
....................    return(beg); 
0F2C:  MOVLB  02
0F2D:  MOVF   43,W
0F2E:  MOVWF  78
0F2F:  MOVF   44,W
0F30:  MOVWF  79
0F31:  MOVLB  00
.................... } 
0F32:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
.................... #define BUTTON_STATES 
.................... #define POT_MAX 63 
....................  
.................... #define RS 0x01 
.................... #define LCD_READ 0x02   
.................... #define LCD_WRITE 0x00   
.................... #define E 0x04 
.................... #define BT 0x08 
.................... #define CHANGE_LINE 0x80 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
07DA:  MOVLW  20
07DB:  MOVWF  05
07DC:  MOVLW  CA
07DD:  MOVWF  04
07DE:  MOVF   00,W
07DF:  BTFSC  03.2
07E0:  GOTO   7F2
07E1:  MOVLW  02
07E2:  MOVWF  78
07E3:  MOVLW  BF
07E4:  MOVWF  77
07E5:  CLRWDT
07E6:  DECFSZ 77,F
07E7:  GOTO   7E5
07E8:  DECFSZ 78,F
07E9:  GOTO   7E3
07EA:  MOVLW  96
07EB:  MOVWF  77
07EC:  DECFSZ 77,F
07ED:  GOTO   7EC
07EE:  GOTO   7EF
07EF:  CLRWDT
07F0:  DECFSZ 00,F
07F1:  GOTO   7E1
07F2:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
0697:  MOVLB  04
0698:  BCF    15.7
0699:  MOVLB  00
069A:  BCF    11.3
069B:  MOVLB  02
069C:  MOVF   50,W
069D:  MOVLB  04
069E:  MOVWF  11
069F:  MOVLW  02
06A0:  BTFSC  15.7
06A1:  GOTO   6A9
06A2:  MOVLB  00
06A3:  BTFSS  11.3
06A4:  GOTO   6A3
06A5:  MOVLW  00
06A6:  MOVLB  04
06A7:  BTFSC  16.6
06A8:  MOVLW  01
06A9:  MOVWF  78
06AA:  MOVLB  00
06AB:  RETURN
*
0A89:  MOVLB  04
0A8A:  BCF    15.6
0A8B:  BSF    16.3
0A8C:  BTFSC  16.3
0A8D:  GOTO   28C
0A8E:  BTFSC  77.0
0A8F:  BCF    16.5
0A90:  BTFSS  77.0
0A91:  BSF    16.5
0A92:  BSF    16.4
0A93:  BTFSC  16.4
0A94:  GOTO   293
0A95:  MOVF   11,W
0A96:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02E4:  CLRWDT
02E5:  BTFSS  11.4
02E6:  GOTO   2E4
02E7:  MOVLB  03
02E8:  MOVWF  1A
02E9:  MOVLB  00
02EA:  RETURN
.................... //#use fast_io (a) 
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void process_dtmf_interrupt(void); 
.................... void init_lcd(void); 
.................... void send_tail(void); 
.................... void status_led(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
.................... void print_dfmf_info(void); 
.................... void do_delay_counters(void); 
.................... void process_buttons(void); 
.................... int1 my_stricmp(char *, char *); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN; 
.................... unsigned int Enable; 
.................... unsigned int Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned int TOT_Min; 
.................... unsigned int Link_TOT,LinkDurationTimer; 
.................... unsigned int COR_EMUL; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... char COR_IN_EFFECTIVE; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... // 
.................... // Button calibration states 
.................... // 
.................... #define BUTTON_IDLE 0 
.................... #define CALIB 16 
.................... #define TRIM 15  
.................... // 
.................... // Command settings 
.................... // 
.................... #define LINK_CMD 1 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define DEBOUNCE_COUNT 8 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... // Arguments 
.................... #define AUXI_EMULATE_COR0 0x01 
.................... #define AUXI_EMULATE_COR1 0x02 
.................... #define AUXI_EMULATE_COR2 0x04 
.................... #define AUXI_EMULATE_COR3 0x08 
.................... #define AUXI_EMULATE_COR4 0x10 // COR from AUX only for DTMF control (No audio feed-thru) 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x20 
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... unsigned int command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... unsigned int  LastRegisterIndex; 
.................... unsigned int  LastRegisterIndexValid; 
....................  
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
....................   int  usage : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1 ENTER_PRESSED; 
.................... int1 SELECT_PRESSED; 
.................... int  adj_value_a,adj_value_b; 
.................... char button_state; 
.................... int1       COR_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... int1       STATUS_LED; 
.................... unsigned long TOT_SecondCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1       DTMF_INTERRUPT_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... // PROTECTED -- Must be in admin mode to set value 
.................... // PUBLIC    -- Register can be set in any mode 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
.................... #define PROTECTED 1 
.................... #define PUBLIC    0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 AuxIn[0] 
.................... 	{"XI2"},	  // 19 AuxIn[1] 
.................... 	{"XI3"},	  // 20 AuxIn[2] 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"LTO"},  // 54 
....................     {"COR"},  // 55 
....................     {"CPOT"}  // 56 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
.................... #define SITE_ID_VAL  	65 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... #define ENABLE_DEFAULT 15 
.................... #define TOT_MIN 5 
.................... #define LINK_TOT 0 
.................... #define DEFAULT_GAIN 32 
.................... //#define LCD_TYPE_PI 0 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('a') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('t') 
.................... #define MORSEID5	MCHAR('e') 
....................  
.................... #define AUXOUTOP0 0 
.................... #define AUXOUTARG0 0 
.................... #define AUXOUTOP1 0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2 0 
.................... #define AUXOUTARG2 0 
....................  
.................... //#define AUXINOP0 AUXI_ENABLE 
.................... //#define AUXINARG0 AUXI_ENABLE2|AUXI_ENABLE3|AUXI_ENABLE4 
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  0 
.................... #define AUXINARG0 0 
.................... #define AUXINOP1 AUXI_TAIL_WHEN_HI 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
.................... #define RX1_PTT 0x0F 
.................... #define RX2_PTT 0x0F 
.................... #define RX3_PTT 0x0F 
.................... #define RX4_PTT 0x0F 
....................  
.................... // Define default variables {{{ 
.................... #ifdef LCD_TYPE_PI 
....................   #define LCD_I2C_ADD 0x27 
.................... #else 
....................   #define LCD_I2C_ADD 0x60 
.................... #endif 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... #ifndef RX1_PTT 
....................   #define RX1_PTT 0x0E 
.................... #endif 
.................... #ifndef RX2_PTT 
....................   #define RX2_PTT 0x0D 
.................... #endif 
.................... #ifndef RX3_PTT 
....................   #define RX3_PTT 0x0B  
.................... #endif 
.................... #ifndef RX4_PTT 
....................   #define RX4_PTT 0x07 
.................... #endif 
.................... #ifndef DEFAULT_GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... // }}} 
....................  
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  , EEPROM,PUBLIC}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL, EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&AuxIn[0]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[1]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[2]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[0]     ,PO_AUX_OUT0     , EEPROM,PROTECTED}, 
.................... 	{&AuxOut[1]     ,PO_AUX_OUT1     , EEPROM,PROTECTED}, 
.................... 	{&AuxOut[2]     ,PO_AUX_OUT2     , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[0] ,4               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[1] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[2] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[3] ,2               , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[0]     ,RX1_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[1]     ,RX2_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[2]     ,RX3_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[3]     ,RX4_PTT         , EEPROM,PROTECTED}, 
.................... 	{&SiteID        ,SITE_ID_VAL     , EEPROM,PROTECTED}, 
.................... 	{&TXSiteID      ,0x12            , EEPROM,PROTECTED}, 
....................   {&Morse[0]      ,MORSEID0        , EEPROM,PROTECTED}, 
....................   {&Morse[1]      ,MORSEID1        , EEPROM,PROTECTED}, 
....................   {&Morse[2]      ,MORSEID2        , EEPROM,PROTECTED}, 
....................   {&Morse[3]      ,MORSEID3        , EEPROM,PROTECTED}, 
....................   {&Morse[4]      ,MORSEID4        , EEPROM,PROTECTED}, 
....................   {&Morse[5]      ,MORSEID5        , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2      , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2        , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2       , EEPROM,PROTECTED}, 
....................   {&Tail          ,TAIL_CHAR       , EEPROM,PROTECTED}, 
....................   {&TOT_Min       ,TOT_MIN         , EEPROM,PROTECTED}, 
....................   {&Link_TOT      ,LINK_TOT        , EEPROM,PROTECTED}, 
.................... 	{&COR_EMUL      ,0x00            , RAM   ,PUBLIC}, 
.................... 	{&CurrentTrimPot,0x00            , RAM   ,PROTECTED}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02EB:  BTFSS  11.5
02EC:  GOTO   342
....................     c = getc(); 
02ED:  CLRWDT
02EE:  BTFSS  11.5
02EF:  GOTO   2ED
02F0:  MOVLB  03
02F1:  MOVF   19,W
02F2:  MOVLB  02
02F3:  MOVWF  55
....................     if ( c == '\b' ) { 
02F4:  MOVF   55,W
02F5:  SUBLW  08
02F6:  BTFSS  03.2
02F7:  GOTO   320
....................       if ( sBufferIndex > 0 ) { 
02F8:  MOVF   71,F
02F9:  BTFSC  03.2
02FA:  GOTO   31A
....................         sBufferIndex--; 
02FB:  DECF   71,F
....................         sBuffer[sBufferIndex]='\0'; 
02FC:  MOVLW  50
02FD:  ADDWF  71,W
02FE:  MOVWF  04
02FF:  MOVLW  20
0300:  MOVWF  05
0301:  BTFSC  03.0
0302:  INCF   05,F
0303:  CLRF   00
....................         putc('\b'); 
0304:  MOVLW  08
0305:  MOVLB  00
0306:  CALL   2E4
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
0307:  MOVLW  1B
0308:  CALL   2E4
....................   printf("[K"); 
0309:  MOVLW  5B
030A:  CLRWDT
030B:  BTFSS  11.4
030C:  GOTO   30A
030D:  MOVLB  03
030E:  MOVWF  1A
030F:  MOVLW  4B
0310:  CLRWDT
0311:  MOVLB  00
0312:  BTFSC  11.4
0313:  GOTO   316
0314:  MOVLB  03
0315:  GOTO   310
0316:  MOVLB  03
0317:  MOVWF  1A
....................       } else { 
0318:  GOTO   31E
0319:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
031A:  MOVLW  07
031B:  MOVLB  00
031C:  CALL   2E4
031D:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
031E:  GOTO   344
031F:  MOVLB  02
0320:  MOVF   71,W
0321:  SUBLW  0F
0322:  BTFSS  03.0
0323:  GOTO   33F
....................       putc(c); // echo the character 
0324:  MOVF   55,W
0325:  MOVLB  00
0326:  CALL   2E4
....................       sBuffer[sBufferIndex++] = c; 
0327:  MOVF   71,W
0328:  INCF   71,F
0329:  ADDLW  50
032A:  MOVWF  04
032B:  MOVLW  20
032C:  MOVWF  05
032D:  BTFSC  03.0
032E:  INCF   05,F
032F:  MOVLB  02
0330:  MOVF   55,W
0331:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0332:  MOVF   55,W
0333:  SUBLW  0D
0334:  BTFSC  03.2
0335:  GOTO   33D
0336:  MOVF   55,W
0337:  SUBLW  2B
0338:  BTFSC  03.2
0339:  GOTO   33D
033A:  MOVF   55,W
033B:  SUBLW  2D
033C:  BTFSC  03.2
....................         sBufferFlag=1; 
033D:  BSF    72.0
....................       } 
....................     } else { 
033E:  GOTO   343
....................       putc('\a'); // Send alert. Avoid buffer overflow 
033F:  MOVLW  07
0340:  MOVLB  00
0341:  CALL   2E4
0342:  MOVLB  02
0343:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
0344:  MOVLB  00
0345:  BCF    11.5
0346:  MOVLP  00
0347:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   int LAST_COR_IN; 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if(IOCBF&0x0F) { // Check for interrupts on RB[3:0] only 
0348:  MOVLB  07
0349:  MOVF   16,W
034A:  ANDLW  0F
034B:  BTFSC  03.2
034C:  GOTO   35E
....................     LAST_COR_IN=COR_IN; 
034D:  MOVLB  00
034E:  MOVF   5F,W
034F:  MOVLB  02
0350:  MOVWF  55
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
0351:  MOVLB  00
0352:  MOVF   0D,W
0353:  XORWF  62,W
0354:  ANDLW  0F
0355:  MOVWF  5F
....................     if ( LAST_COR_IN != COR_IN ) { 
0356:  MOVF   5F,W
0357:  MOVLB  02
0358:  SUBWF  55,W
0359:  BTFSS  03.2
....................       COR_FLAG = 1; 
035A:  BSF    72.3
....................     } 
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
035B:  MOVLW  F0
035C:  MOVLB  07
035D:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
035E:  BTFSS  0B.0
035F:  GOTO   364
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     DTMF_INTERRUPT_FLAG = 1; 
0360:  MOVLB  01
0361:  BSF    5D.4
....................     clear_interrupt(INT_RB4_H2L); 
0362:  MOVLB  07
0363:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
0364:  BTFSS  0B.0
0365:  GOTO   36B
....................     AUX_IN_FLAG=1; 
0366:  MOVLB  01
0367:  BSF    5D.0
....................     clear_interrupt(INT_RB6|INT_RB7); 
0368:  MOVLW  3F
0369:  MOVLB  07
036A:  ANDWF  16,F
....................   } 
.................... } // }}} 
036B:  BCF    0B.0
036C:  MOVLP  00
036D:  MOVLB  00
036E:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
036F:  MOVLB  01
0370:  MOVF   30,W
0371:  IORWF  31,W
0372:  BTFSC  03.2
0373:  GOTO   379
....................     rtcc_cnt--; 
0374:  MOVF   30,W
0375:  BTFSC  03.2
0376:  DECF   31,F
0377:  DECF   30,F
....................   } else { 
0378:  GOTO   385
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
0379:  MOVLB  00
037A:  MOVF   0D,W
037B:  XORWF  62,W
037C:  ANDLW  0F
037D:  MOVWF  5F
....................     COR_FLAG=1; 
037E:  BSF    72.3
....................     SECOND_FLAG=1; 
037F:  BSF    72.4
....................     AUX_IN_FLAG=1; 
0380:  MOVLB  01
0381:  BSF    5D.0
....................     rtcc_cnt=30; 
0382:  CLRF   31
0383:  MOVLW  1E
0384:  MOVWF  30
....................   } 
....................   if (aux_timer ) { 
0385:  MOVF   32,W
0386:  IORWF  33,W
0387:  BTFSC  03.2
0388:  GOTO   38D
....................     aux_timer--; 
0389:  MOVF   32,W
038A:  BTFSC  03.2
038B:  DECF   33,F
038C:  DECF   32,F
....................   } 
.................... } // }}} 
038D:  BCF    0B.2
038E:  MOVLP  00
038F:  MOVLB  00
0390:  GOTO   020
.................... int1 warn_no_lcd = 1; 
....................  
.................... void lcd_strobe(char data) { // {{{ 
....................   i2c_write(data | E); 
....................   i2c_write(data & ~E); 
.................... } // }}} 
....................  
.................... void lcd_write(char rs, char data) { // {{{ 
....................   char lcd_word_a,lcd_word_b; 
....................   lcd_word_a = LCD_WRITE | BT | (data&0xF0); 
....................   lcd_word_b = LCD_WRITE | BT | ((data<<4)&0xF0); 
....................   if ( rs ) { 
....................     lcd_word_a |= RS; 
....................     lcd_word_b |= RS; 
....................   }  
....................   lcd_strobe(lcd_word_a); 
....................   lcd_strobe(lcd_word_b); 
.................... } // }}} 
....................  
.................... void lcd_send(char line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   i2c_start(); 
*
0973:  MOVLB  04
0974:  BSF    16.0
0975:  BTFSC  16.0
0976:  GOTO   175
....................   #ifdef LCD_TYPE_PI 
....................   ack=i2c_write(LCD_I2C_ADD << 1); 
.................... //  ack=i2c_write(line&0x03); 
.................... // Change line 
....................   switch(line&0x03) { 
....................     case 0x00: lcd_write(0,CHANGE_LINE);break; 
....................     case 0x01: lcd_write(0,CHANGE_LINE+0x40);break; 
....................     case 0x02: lcd_write(0,CHANGE_LINE+0x14);break; 
....................     case 0x03: lcd_write(0,CHANGE_LINE+0x54);break; 
....................   } 
....................   restart_wdt(); 
....................   #else 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
0977:  BCF    03.0
0978:  MOVLB  02
0979:  RLF    4A,W
097A:  ANDLW  0E
097B:  IORLW  60
097C:  MOVWF  4D
....................   ack=i2c_write(lcd_cmd); 
097D:  MOVF   4D,W
097E:  MOVWF  50
097F:  MOVLP  00
0980:  MOVLB  00
0981:  CALL   697
0982:  MOVLP  08
0983:  MOVF   78,W
0984:  MOVLB  02
0985:  BCF    4E.0
0986:  BTFSC  78.0
0987:  BSF    4E.0
....................   #endif 
....................   if ( ack!=0 ) { 
0988:  BTFSS  4E.0
0989:  GOTO   1AC
....................     if ( warn_no_lcd ) { 
098A:  MOVLB  01
098B:  BTFSS  62.1
098C:  GOTO   1AA
....................       printf("\n\rI2C : No ACK from LCD : %u",ack); 
098D:  MOVLW  00
098E:  MOVLB  02
098F:  BTFSC  4E.0
0990:  MOVLW  01
0991:  MOVWF  4F
0992:  MOVLW  91
0993:  MOVLB  03
0994:  MOVWF  11
0995:  MOVLW  03
0996:  MOVWF  12
0997:  BCF    03.0
0998:  MOVLW  1A
0999:  MOVLB  02
099A:  MOVWF  50
099B:  MOVLP  00
099C:  MOVLB  00
099D:  CALL   6AC
099E:  MOVLP  08
099F:  MOVLB  02
09A0:  MOVF   4F,W
09A1:  MOVWF  50
09A2:  MOVLW  1B
09A3:  MOVWF  51
09A4:  MOVLP  00
09A5:  MOVLB  00
09A6:  CALL   720
09A7:  MOVLP  08
....................       warn_no_lcd = 0; 
09A8:  MOVLB  01
09A9:  BCF    62.1
....................     } 
....................   } else { 
09AA:  GOTO   1AE
09AB:  MOVLB  02
....................     warn_no_lcd = 1; 
09AC:  MOVLB  01
09AD:  BSF    62.1
....................   } 
....................   while(*s) { 
09AE:  MOVLB  02
09AF:  MOVF   4C,W
09B0:  MOVWF  7A
09B1:  MOVF   4B,W
09B2:  MOVWF  04
09B3:  MOVF   7A,W
09B4:  MOVWF  05
09B5:  MOVF   00,F
09B6:  BTFSC  03.2
09B7:  GOTO   1CB
.................... #ifdef LCD_TYPE_PI 
....................     if ( *s != '\r' && *s != '\n') { 
....................       lcd_write(1,*s); 
....................     } 
....................     s++; 
.................... #else 
....................    i2c_write(*s++); 
09B8:  MOVF   4C,W
09B9:  MOVWF  7A
09BA:  MOVF   4B,W
09BB:  INCF   4B,F
09BC:  BTFSC  03.2
09BD:  INCF   4C,F
09BE:  MOVWF  04
09BF:  MOVF   7A,W
09C0:  MOVWF  05
09C1:  MOVF   00,W
09C2:  MOVWF  4F
09C3:  MOVWF  50
09C4:  MOVLP  00
09C5:  MOVLB  00
09C6:  CALL   697
09C7:  MOVLP  08
.................... #endif 
....................   } 
09C8:  MOVLB  01
09C9:  GOTO   1AE
09CA:  MOVLB  02
.................... #ifndef LCD_TYPE_PI 
....................   i2c_write(0); // EOL 
09CB:  CLRF   50
09CC:  MOVLP  00
09CD:  MOVLB  00
09CE:  CALL   697
09CF:  MOVLP  08
.................... #endif 
....................   i2c_stop(); 
09D0:  MOVLB  04
09D1:  BSF    16.2
09D2:  BTFSC  16.2
09D3:  GOTO   1D2
.................... #endif 
.................... } // }}} 
09D4:  MOVLB  00
09D5:  RETURN
.................... #ifdef BUTTON_STATES 
.................... void status_led(void) { // {{{ 
....................   char cnt_val; 
....................   STATUS_LED=0; 
*
0E26:  BCF    5D.1
....................   cnt_val = rtcc_cnt>>3; 
0E27:  RRF    31,W
0E28:  MOVWF  7A
0E29:  RRF    30,W
0E2A:  MOVWF  79
0E2B:  RRF    7A,F
0E2C:  RRF    79,F
0E2D:  RRF    7A,F
0E2E:  RRF    79,F
0E2F:  MOVF   79,W
0E30:  MOVWF  6A
....................   if ( button_state!=0 ) { 
0E31:  MOVF   5C,F
0E32:  BTFSC  03.2
0E33:  GOTO   642
....................     if ( (rtcc_cnt & 0x04) ) { 
0E34:  MOVF   30,W
0E35:  ANDLW  04
0E36:  MOVWF  77
0E37:  CLRF   7A
0E38:  MOVF   77,W
0E39:  IORWF  7A,W
0E3A:  BTFSC  03.2
0E3B:  GOTO   642
....................       STATUS_LED = (cnt_val < (CurrentTrimPot+1));  
0E3C:  BCF    5D.1
0E3D:  MOVLW  01
0E3E:  ADDWF  74,W
0E3F:  SUBWF  6A,W
0E40:  BTFSS  03.0
0E41:  BSF    5D.1
....................     } 
....................   }  
....................   output_bit(STATUS_LED_PIN,STATUS_LED); 
0E42:  BTFSC  5D.1
0E43:  GOTO   648
0E44:  MOVLB  02
0E45:  BCF    0C.6
0E46:  GOTO   64A
0E47:  MOVLB  01
0E48:  MOVLB  02
0E49:  BSF    0C.6
0E4A:  MOVLB  01
0E4B:  BCF    0C.6
.................... } // }}} 
.................... #endif 
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
10F5:  MOVF   70,F
10F6:  BTFSC  03.2
10F7:  GOTO   159
....................     printf("\n\rProcessing Command:"); 
10F8:  MOVLW  A0
10F9:  MOVLB  03
10FA:  MOVWF  11
10FB:  MOVLW  03
10FC:  MOVWF  12
10FD:  MOVLP  00
10FE:  MOVLB  00
10FF:  CALL   4BB
1100:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
1101:  MOVLW  AB
1102:  MOVLB  03
1103:  MOVWF  11
1104:  MOVLW  03
1105:  MOVWF  12
1106:  BCF    03.0
1107:  MOVLW  0E
1108:  MOVLB  02
1109:  MOVWF  50
110A:  MOVLP  00
110B:  MOVLB  00
110C:  CALL   6AC
110D:  MOVLP  10
110E:  MOVF   63,W
110F:  MOVLB  02
1110:  MOVWF  50
1111:  MOVLW  1B
1112:  MOVWF  51
1113:  MOVLP  00
1114:  MOVLB  00
1115:  CALL   720
1116:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
1117:  MOVLW  B4
1118:  MOVLB  03
1119:  MOVWF  11
111A:  MOVLW  03
111B:  MOVWF  12
111C:  BCF    03.0
111D:  MOVLW  0E
111E:  MOVLB  02
111F:  MOVWF  50
1120:  MOVLP  00
1121:  MOVLB  00
1122:  CALL   6AC
1123:  MOVLP  10
1124:  MOVF   70,W
1125:  MOVLB  02
1126:  MOVWF  50
1127:  MOVLW  1B
1128:  MOVWF  51
1129:  MOVLP  00
112A:  MOVLB  00
112B:  CALL   720
112C:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
112D:  MOVLW  BD
112E:  MOVLB  03
112F:  MOVWF  11
1130:  MOVLW  03
1131:  MOVWF  12
1132:  BCF    03.0
1133:  MOVLW  0E
1134:  MOVLB  02
1135:  MOVWF  50
1136:  MOVLP  00
1137:  MOVLB  00
1138:  CALL   6AC
1139:  MOVLP  10
113A:  MOVF   75,W
113B:  MOVLB  02
113C:  MOVWF  50
113D:  MOVLW  1B
113E:  MOVWF  51
113F:  MOVLP  00
1140:  MOVLB  00
1141:  CALL   720
1142:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
1143:  MOVLW  C6
1144:  MOVLB  03
1145:  MOVWF  11
1146:  MOVLW  03
1147:  MOVWF  12
1148:  BCF    03.0
1149:  MOVLW  0E
114A:  MOVLB  02
114B:  MOVWF  50
114C:  MOVLP  00
114D:  MOVLB  00
114E:  CALL   6AC
114F:  MOVLP  10
1150:  MOVF   76,W
1151:  MOVLB  02
1152:  MOVWF  50
1153:  MOVLW  1B
1154:  MOVWF  51
1155:  MOVLP  00
1156:  MOVLB  00
1157:  CALL   720
1158:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
1159:  MOVLW  02
115A:  SUBWF  70,W
115B:  ADDLW  F5
115C:  BTFSC  03.0
115D:  GOTO   567
115E:  ADDLW  0B
115F:  GOTO   568
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
1224:  GOTO   567
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
1225:  RLF    75,W
1226:  MOVWF  77
1227:  RLF    77,F
1228:  MOVLW  FC
1229:  ANDWF  77,F
122A:  MOVF   77,W
122B:  MOVLB  02
122C:  MOVWF  2C
122D:  INCF   2C,W
122E:  MOVLP  00
122F:  MOVLB  00
1230:  CALL   043
1231:  MOVLP  10
1232:  MOVWF  7A
1233:  MOVLB  02
1234:  MOVF   2C,W
1235:  MOVLP  00
1236:  MOVLB  00
1237:  CALL   043
1238:  MOVLP  10
1239:  MOVLB  02
123A:  MOVWF  20
123B:  MOVF   7A,W
123C:  MOVWF  21
....................       LastRegisterIndex = argument; 
123D:  MOVF   75,W
123E:  MOVWF  7C
....................       LastRegisterIndexValid=1; 
123F:  MOVLW  01
1240:  MOVWF  7D
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
1241:  MOVLW  01
1242:  MOVWF  7A
1243:  MOVLW  8F
1244:  MOVWF  2C
1245:  MOVF   7A,W
1246:  MOVWF  2D
1247:  CLRF   2F
1248:  MOVF   75,W
1249:  MOVWF  2E
124A:  MOVF   2F,W
124B:  MOVWF  3E
124C:  MOVF   2E,W
124D:  MOVWF  3D
124E:  CLRF   40
124F:  MOVLW  06
1250:  MOVWF  3F
1251:  MOVLP  08
1252:  MOVLB  00
1253:  CALL   7BB
1254:  MOVLP  10
1255:  MOVF   78,W
1256:  MOVLB  02
1257:  ADDWF  2C,W
1258:  MOVWF  24
1259:  MOVF   79,W
125A:  ADDWFC 2D,W
125B:  MOVWF  25
....................       romstrcpy(rname,cPtr); 
125C:  MOVLW  20
125D:  MOVWF  3C
125E:  MOVLW  A6
125F:  MOVWF  3B
1260:  MOVF   25,W
1261:  MOVWF  3E
1262:  MOVF   24,W
1263:  MOVWF  3D
1264:  MOVLP  08
1265:  MOVLB  00
1266:  CALL   7D2
1267:  MOVLP  10
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
1268:  MOVLB  02
1269:  MOVF   21,W
126A:  MOVWF  7A
126B:  MOVF   20,W
126C:  MOVWF  04
126D:  MOVF   21,W
126E:  MOVWF  05
126F:  MOVF   00,W
1270:  MOVWF  2C
1271:  MOVLW  20
1272:  MOVLB  01
1273:  MOVWF  64
1274:  MOVLW  76
1275:  MOVWF  63
1276:  MOVLW  5B
1277:  MOVLB  02
1278:  MOVWF  50
1279:  MOVLP  08
127A:  MOVLB  00
127B:  CALL   0FC
127C:  MOVLP  10
127D:  MOVF   75,W
127E:  MOVLB  02
127F:  MOVWF  2D
1280:  MOVLW  01
1281:  MOVWF  2E
1282:  MOVLB  00
1283:  CALL   052
1284:  MOVLW  5D
1285:  MOVLB  02
1286:  MOVWF  50
1287:  MOVLP  08
1288:  MOVLB  00
1289:  CALL   0FC
128A:  MOVLP  10
128B:  MOVLW  20
128C:  MOVLB  02
128D:  MOVWF  50
128E:  MOVLP  08
128F:  MOVLB  00
1290:  CALL   0FC
1291:  MOVLP  10
1292:  MOVLW  20
1293:  MOVWF  05
1294:  MOVLW  A6
1295:  MOVWF  04
1296:  MOVLP  08
1297:  CALL   15E
1298:  MOVLP  10
1299:  MOVLW  20
129A:  MOVLB  02
129B:  MOVWF  50
129C:  MOVLP  08
129D:  MOVLB  00
129E:  CALL   0FC
129F:  MOVLP  10
12A0:  MOVLB  02
12A1:  MOVF   2C,W
12A2:  MOVWF  2D
12A3:  MOVLW  1B
12A4:  MOVWF  2E
12A5:  MOVLB  00
12A6:  CALL   052
12A7:  MOVLW  0A
12A8:  MOVLB  02
12A9:  MOVWF  50
12AA:  MOVLP  08
12AB:  MOVLB  00
12AC:  CALL   0FC
12AD:  MOVLP  10
12AE:  MOVLW  0D
12AF:  MOVLB  02
12B0:  MOVWF  50
12B1:  MOVLP  08
12B2:  MOVLB  00
12B3:  CALL   0FC
12B4:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
12B5:  MOVLW  0A
12B6:  CLRWDT
12B7:  BTFSS  11.4
12B8:  GOTO   2B6
12B9:  MOVLB  03
12BA:  MOVWF  1A
12BB:  MOVLW  0D
12BC:  CLRWDT
12BD:  MOVLB  00
12BE:  BTFSC  11.4
12BF:  GOTO   2C2
12C0:  MOVLB  03
12C1:  GOTO   2BC
12C2:  MOVLB  03
12C3:  MOVWF  1A
12C4:  MOVLW  20
12C5:  MOVWF  05
12C6:  MOVLW  76
12C7:  MOVWF  04
12C8:  MOVLP  08
12C9:  MOVLB  00
12CA:  CALL   23D
12CB:  MOVLP  10
....................       lcd_send(2,LCD_str); 
12CC:  MOVLW  02
12CD:  MOVLB  02
12CE:  MOVWF  4A
12CF:  MOVLW  20
12D0:  MOVWF  4C
12D1:  MOVLW  76
12D2:  MOVWF  4B
12D3:  MOVLP  08
12D4:  MOVLB  00
12D5:  CALL   173
12D6:  MOVLP  10
....................       prompt(); 
12D7:  CALL   09B
....................       break; 
12D8:  GOTO   567
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
12D9:  CALL   000
12DA:  MOVF   78,F
12DB:  BTFSC  03.2
12DC:  GOTO   2E0
....................         store_variables(); 
12DD:  MOVLP  00
12DE:  CALL   5AE
12DF:  MOVLP  10
....................       } 
....................       break; 
12E0:  GOTO   567
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
12E1:  DECFSZ 76,W
12E2:  GOTO   2E7
....................         init_src=USE_EEPROM_VARS; 
12E3:  MOVLB  02
12E4:  BSF    22.0
....................       } else { 
12E5:  GOTO   2E9
12E6:  MOVLB  00
....................         init_src=USE_DEFAULT_VARS; 
12E7:  MOVLB  02
12E8:  BCF    22.0
....................       } 
....................       if ( in_admin_mode() ) { 
12E9:  MOVLB  00
12EA:  CALL   000
12EB:  MOVF   78,F
12EC:  BTFSC  03.2
12ED:  GOTO   2F8
....................         init_variables(init_src); 
12EE:  MOVLW  00
12EF:  MOVLB  02
12F0:  BTFSC  22.0
12F1:  MOVLW  01
12F2:  MOVWF  2C
12F3:  MOVWF  2D
12F4:  MOVLP  00
12F5:  MOVLB  00
12F6:  CALL   629
12F7:  MOVLP  10
....................       } 
....................       break; 
12F8:  GOTO   567
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
12F9:  MOVF   75,W
12FA:  ANDLW  03
12FB:  MOVWF  74
....................       increment(value); 
12FC:  MOVF   76,W
12FD:  MOVLB  02
12FE:  MOVWF  2F
12FF:  MOVLB  00
1300:  CALL   00F
....................       PROMPT_FLAG=1; 
1301:  MOVLB  01
1302:  BSF    5D.6
....................       break; 
1303:  MOVLB  00
1304:  GOTO   567
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1305:  MOVF   75,W
1306:  ANDLW  03
1307:  MOVWF  74
....................       increment(-1*value); 
1308:  MOVLW  FF
1309:  MOVLB  02
130A:  MOVWF  43
130B:  MOVF   76,W
130C:  MOVWF  44
130D:  MOVLP  08
130E:  MOVLB  00
130F:  CALL   733
1310:  MOVLP  10
1311:  MOVF   78,W
1312:  MOVLB  02
1313:  MOVWF  2C
1314:  MOVWF  2F
1315:  MOVLB  00
1316:  CALL   00F
....................       PROMPT_FLAG=1; 
1317:  MOVLB  01
1318:  BSF    5D.6
....................       break; 
1319:  MOVLB  00
131A:  GOTO   567
....................     case STATUS: 
....................       status(); 
....................       break; 
*
14E4:  MOVLB  00
14E5:  GOTO   567
....................     case ADMIN: 
....................       switch(argument) { 
14E6:  MOVF   75,W
14E7:  XORLW  02
14E8:  BTFSC  03.2
14E9:  GOTO   4F1
14EA:  XORLW  03
14EB:  BTFSC  03.2
14EC:  GOTO   4F6
14ED:  XORLW  02
14EE:  BTFSC  03.2
14EF:  GOTO   4FE
14F0:  GOTO   500
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
14F1:  CALL   000
14F2:  MOVF   78,F
14F3:  BTFSS  03.2
....................             reset_cpu(); 
14F4:  RESET
....................           } 
....................           break; 
14F5:  GOTO   506
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
14F6:  MOVLW  01
14F7:  MOVLB  02
14F8:  MOVWF  40
14F9:  MOVLP  08
14FA:  MOVLB  00
14FB:  CALL   49F
14FC:  MOVLP  10
....................           break; 
14FD:  GOTO   506
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
14FE:  CALL   0B3
....................         break; 
14FF:  GOTO   506
....................         default: 
....................           set_admin_mode(0); 
1500:  MOVLB  02
1501:  CLRF   40
1502:  MOVLP  08
1503:  MOVLB  00
1504:  CALL   49F
1505:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
1506:  GOTO   567
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
.................... #ifdef LCD_TYPE_PI 
....................       switch(value) { 
....................         case 0 : init_lcd();break;   
....................         case 1 : lcd_write(0,0x01); 
....................       } 
.................... #else 
....................       lcd_cmd=4+(value&0x03); 
1507:  MOVF   76,W
1508:  ANDLW  03
1509:  ADDLW  04
150A:  MOVLB  02
150B:  MOVWF  23
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
150C:  MOVLW  20
150D:  MOVLB  01
150E:  MOVWF  64
150F:  MOVLW  76
1510:  MOVWF  63
1511:  MOVLW  CF
1512:  MOVLB  03
1513:  MOVWF  11
1514:  MOVLW  03
1515:  MOVWF  12
1516:  BCF    03.0
1517:  MOVLW  04
1518:  MOVLB  02
1519:  MOVWF  4A
151A:  MOVLP  08
151B:  MOVLB  00
151C:  CALL   10B
151D:  MOVLP  10
151E:  MOVLW  60
151F:  MOVLB  02
1520:  MOVWF  4A
1521:  MOVLW  18
1522:  MOVWF  4B
1523:  MOVLP  08
1524:  MOVLB  00
1525:  CALL   1D6
1526:  MOVLP  10
1527:  MOVLW  D2
1528:  MOVLB  03
1529:  MOVWF  11
152A:  MOVLW  03
152B:  MOVWF  12
152C:  BCF    03.0
152D:  MOVLW  08
152E:  MOVLB  02
152F:  MOVWF  4A
1530:  MOVLP  08
1531:  MOVLB  00
1532:  CALL   10B
1533:  MOVLP  10
1534:  MOVLB  02
1535:  MOVF   23,W
1536:  MOVWF  4A
1537:  MOVLW  18
1538:  MOVWF  4B
1539:  MOVLP  08
153A:  MOVLB  00
153B:  CALL   1D6
153C:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
153D:  MOVLW  0A
153E:  CLRWDT
153F:  BTFSS  11.4
1540:  GOTO   53E
1541:  MOVLB  03
1542:  MOVWF  1A
1543:  MOVLW  0D
1544:  CLRWDT
1545:  MOVLB  00
1546:  BTFSC  11.4
1547:  GOTO   54A
1548:  MOVLB  03
1549:  GOTO   544
154A:  MOVLB  03
154B:  MOVWF  1A
154C:  MOVLW  20
154D:  MOVWF  05
154E:  MOVLW  76
154F:  MOVWF  04
1550:  MOVLP  08
1551:  MOVLB  00
1552:  CALL   23D
1553:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
1554:  MOVLB  02
1555:  MOVF   23,W
1556:  MOVWF  4A
1557:  MOVLW  20
1558:  MOVWF  4C
1559:  MOVLW  76
155A:  MOVWF  4B
155B:  MOVLP  08
155C:  MOVLB  00
155D:  CALL   173
155E:  MOVLP  10
.................... #endif 
....................       break; 
155F:  GOTO   567
....................     case MORSE_SEND: 
....................       morse(value); 
1560:  MOVF   76,W
1561:  MOVLB  02
1562:  MOVWF  3F
1563:  MOVLP  08
1564:  MOVLB  00
1565:  CALL   083
1566:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
1567:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  4A
1803:  MOVLW  20
1804:  MOVWF  4C
1805:  MOVLW  50
1806:  MOVWF  4B
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   173
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVWF  75
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B62:  MOVLB  01
1B63:  CLRF   66
1B64:  CLRF   65
1B65:  MOVF   66,F
1B66:  BTFSS  03.2
1B67:  GOTO   3B6
1B68:  MOVF   65,W
1B69:  SUBLW  38
1B6A:  BTFSS  03.0
1B6B:  GOTO   3B6
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B6C:  MOVLW  01
1B6D:  MOVWF  7A
1B6E:  MOVLW  8F
1B6F:  MOVLB  02
1B70:  MOVWF  20
1B71:  MOVF   7A,W
1B72:  MOVWF  21
1B73:  MOVLB  01
1B74:  MOVF   66,W
1B75:  MOVLB  02
1B76:  MOVWF  3E
1B77:  MOVLB  01
1B78:  MOVF   65,W
1B79:  MOVLB  02
1B7A:  MOVWF  3D
1B7B:  CLRF   40
1B7C:  MOVLW  06
1B7D:  MOVWF  3F
1B7E:  MOVLP  08
1B7F:  MOVLB  00
1B80:  CALL   7BB
1B81:  MOVLP  18
1B82:  MOVF   78,W
1B83:  MOVLB  02
1B84:  ADDWF  20,W
1B85:  MOVLB  01
1B86:  MOVWF  67
1B87:  MOVF   79,W
1B88:  MOVLB  02
1B89:  ADDWFC 21,W
1B8A:  MOVLB  01
1B8B:  MOVWF  68
....................     romstrcpy(rname,cPtr); 
1B8C:  MOVLW  20
1B8D:  MOVLB  02
1B8E:  MOVWF  3C
1B8F:  MOVLW  99
1B90:  MOVWF  3B
1B91:  MOVLB  01
1B92:  MOVF   68,W
1B93:  MOVLB  02
1B94:  MOVWF  3E
1B95:  MOVLB  01
1B96:  MOVF   67,W
1B97:  MOVLB  02
1B98:  MOVWF  3D
1B99:  MOVLP  08
1B9A:  MOVLB  00
1B9B:  CALL   7D2
1B9C:  MOVLP  18
....................     if(my_stricmp(argument_name,rname)==0) { 
1B9D:  MOVLW  20
1B9E:  MOVLB  02
1B9F:  MOVWF  40
1BA0:  MOVLW  70
1BA1:  MOVWF  3F
1BA2:  MOVLW  20
1BA3:  MOVWF  42
1BA4:  MOVLW  99
1BA5:  MOVWF  41
1BA6:  MOVLP  08
1BA7:  MOVLB  00
1BA8:  CALL   793
1BA9:  MOVLP  18
1BAA:  MOVF   78,F
1BAB:  BTFSS  03.2
1BAC:  GOTO   3B1
....................       argument=x; 
1BAD:  MOVLB  01
1BAE:  MOVF   65,W
1BAF:  MOVWF  75
1BB0:  MOVLB  00
....................     } 
....................   } 
1BB1:  MOVLB  01
1BB2:  INCF   65,F
1BB3:  BTFSC  03.2
1BB4:  INCF   66,F
1BB5:  GOTO   365
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BB6:  MOVF   75,W
1BB7:  SUBLW  FF
1BB8:  BTFSS  03.2
1BB9:  GOTO   41A
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BBA:  MOVLW  20
1BBB:  MOVLB  02
1BBC:  MOVWF  40
1BBD:  MOVLW  70
1BBE:  MOVWF  3F
1BBF:  MOVLP  08
1BC0:  MOVLB  00
1BC1:  CALL   75A
1BC2:  MOVLP  18
1BC3:  MOVF   78,W
1BC4:  MOVWF  76
....................     strcpy(rname,"eeprom"); 
1BC5:  MOVLB  02
1BC6:  CLRF   20
1BC7:  CLRF   21
1BC8:  MOVLW  20
1BC9:  MOVWF  05
1BCA:  MOVLW  99
1BCB:  MOVWF  04
1BCC:  MOVF   20,W
1BCD:  ADDWF  04,F
1BCE:  MOVLW  00
1BCF:  ADDWFC 05,F
1BD0:  MOVF   21,W
1BD1:  MOVLP  00
1BD2:  MOVLB  00
1BD3:  CALL   128
1BD4:  MOVLP  18
1BD5:  MOVWF  00
1BD6:  IORLW  00
1BD7:  BTFSC  03.2
1BD8:  GOTO   3DE
1BD9:  MOVLB  02
1BDA:  INCF   21,F
1BDB:  INCF   20,F
1BDC:  GOTO   3C8
1BDD:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1BDE:  MOVLW  20
1BDF:  MOVLB  02
1BE0:  MOVWF  40
1BE1:  MOVLW  70
1BE2:  MOVWF  3F
1BE3:  MOVLW  20
1BE4:  MOVWF  42
1BE5:  MOVLW  99
1BE6:  MOVWF  41
1BE7:  MOVLP  08
1BE8:  MOVLB  00
1BE9:  CALL   793
1BEA:  MOVLP  18
1BEB:  MOVF   78,F
1BEC:  BTFSS  03.2
1BED:  GOTO   3F0
....................       value=USE_EEPROM_VARS; 
1BEE:  MOVLW  01
1BEF:  MOVWF  76
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BF0:  MOVLB  02
1BF1:  CLRF   20
1BF2:  CLRF   21
1BF3:  MOVLW  20
1BF4:  MOVWF  05
1BF5:  MOVLW  99
1BF6:  MOVWF  04
1BF7:  MOVF   20,W
1BF8:  ADDWF  04,F
1BF9:  MOVLW  00
1BFA:  ADDWFC 05,F
1BFB:  MOVF   21,W
1BFC:  MOVLP  00
1BFD:  MOVLB  00
1BFE:  CALL   130
1BFF:  MOVLP  18
1C00:  MOVWF  00
1C01:  IORLW  00
1C02:  BTFSC  03.2
1C03:  GOTO   409
1C04:  MOVLB  02
1C05:  INCF   21,F
1C06:  INCF   20,F
1C07:  GOTO   3F3
1C08:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C09:  MOVLW  20
1C0A:  MOVLB  02
1C0B:  MOVWF  40
1C0C:  MOVLW  70
1C0D:  MOVWF  3F
1C0E:  MOVLW  20
1C0F:  MOVWF  42
1C10:  MOVLW  99
1C11:  MOVWF  41
1C12:  MOVLP  08
1C13:  MOVLB  00
1C14:  CALL   793
1C15:  MOVLP  18
1C16:  MOVF   78,F
1C17:  BTFSC  03.2
....................       value=USE_DEFAULT_VARS; 
1C18:  CLRF   76
1C19:  MOVLB  01
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C1A:  MOVF   70,W
1C1B:  SUBLW  06
1C1C:  BTFSC  03.2
1C1D:  GOTO   422
1C1E:  MOVF   70,W
1C1F:  SUBLW  07
1C20:  BTFSS  03.2
1C21:  GOTO   426
....................     value = 1; 
1C22:  MOVLW  01
1C23:  MOVWF  76
....................     argument = CurrentTrimPot; 
1C24:  MOVF   74,W
1C25:  MOVWF  75
....................   } 
....................   rs232_mode = 1; 
1C26:  BSF    62.0
....................   execute_command(); 
1C27:  MOVLP  10
1C28:  MOVLB  00
1C29:  CALL   0F5
1C2A:  MOVLP  18
....................   rs232_mode = 0; 
1C2B:  MOVLB  01
1C2C:  BCF    62.0
.................... } // }}} 
1C2D:  MOVLP  18
1C2E:  MOVLB  00
1C2F:  GOTO   766 (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
131B:  MOVLW  1B
131C:  MOVLP  00
131D:  CALL   2E4
131E:  MOVLP  10
....................   printf("[2J"); 
131F:  MOVLW  5B
1320:  CLRWDT
1321:  BTFSS  11.4
1322:  GOTO   320
1323:  MOVLB  03
1324:  MOVWF  1A
1325:  MOVLW  32
1326:  CLRWDT
1327:  MOVLB  00
1328:  BTFSC  11.4
1329:  GOTO   32C
132A:  MOVLB  03
132B:  GOTO   326
132C:  MOVLB  03
132D:  MOVWF  1A
132E:  MOVLW  4A
132F:  CLRWDT
1330:  MOVLB  00
1331:  BTFSC  11.4
1332:  GOTO   335
1333:  MOVLB  03
1334:  GOTO   32F
1335:  MOVLB  03
1336:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
1337:  MOVLW  1B
1338:  MOVLP  00
1339:  MOVLB  00
133A:  CALL   2E4
133B:  MOVLP  10
....................   printf("[0;0H"); 
133C:  MOVLW  D8
133D:  MOVLB  03
133E:  MOVWF  11
133F:  MOVLW  03
1340:  MOVWF  12
1341:  MOVLP  00
1342:  MOVLB  00
1343:  CALL   4BB
1344:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
076F:  MOVLB  02
0770:  SWAPF  3F,W
0771:  MOVWF  41
0772:  RLF    41,F
0773:  RLF    41,F
0774:  MOVLW  C0
0775:  ANDWF  41,F
....................   tx_value=tx_value + (value & 0x3F); 
0776:  MOVF   40,W
0777:  ANDLW  3F
0778:  ADDWF  41,F
....................   i2c_start(); 
0779:  MOVLB  04
077A:  BSF    16.0
077B:  BTFSC  16.0
077C:  GOTO   77B
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
077D:  MOVLW  50
077E:  MOVLB  02
077F:  MOVWF  50
0780:  MOVLB  00
0781:  CALL   697
0782:  MOVF   78,W
0783:  MOVLB  02
0784:  BCF    42.0
0785:  BTFSC  78.0
0786:  BSF    42.0
....................   if ( ack != 0) { 
0787:  BTFSS  42.0
0788:  GOTO   7A0
....................     printf("\n\rI2C : No ACK : %u",ack); 
0789:  MOVLW  00
078A:  BTFSC  42.0
078B:  MOVLW  01
078C:  MOVWF  43
078D:  MOVLW  DB
078E:  MOVLB  03
078F:  MOVWF  11
0790:  MOVLW  03
0791:  MOVWF  12
0792:  BCF    03.0
0793:  MOVLW  11
0794:  MOVLB  02
0795:  MOVWF  50
0796:  MOVLB  00
0797:  CALL   6AC
0798:  MOVLB  02
0799:  MOVF   43,W
079A:  MOVWF  50
079B:  MOVLW  1B
079C:  MOVWF  51
079D:  MOVLB  00
079E:  CALL   720
079F:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
07A0:  MOVF   41,W
07A1:  MOVWF  50
07A2:  MOVLB  00
07A3:  CALL   697
....................   i2c_stop();   
07A4:  MOVLB  04
07A5:  BSF    16.2
07A6:  BTFSC  16.2
07A7:  GOTO   7A6
....................   printf("\n\rPot(%u)<=%u",pot,value); 
07A8:  MOVLW  E5
07A9:  MOVLB  03
07AA:  MOVWF  11
07AB:  MOVLW  03
07AC:  MOVWF  12
07AD:  BCF    03.0
07AE:  MOVLW  06
07AF:  MOVLB  02
07B0:  MOVWF  50
07B1:  MOVLB  00
07B2:  CALL   6AC
07B3:  MOVLB  02
07B4:  MOVF   3F,W
07B5:  MOVWF  50
07B6:  MOVLW  1B
07B7:  MOVWF  51
07B8:  MOVLB  00
07B9:  CALL   720
07BA:  MOVLW  29
07BB:  CLRWDT
07BC:  BTFSS  11.4
07BD:  GOTO   7BB
07BE:  MOVLB  03
07BF:  MOVWF  1A
07C0:  MOVLW  3C
07C1:  CLRWDT
07C2:  MOVLB  00
07C3:  BTFSC  11.4
07C4:  GOTO   7C7
07C5:  MOVLB  03
07C6:  GOTO   7C1
07C7:  MOVLB  03
07C8:  MOVWF  1A
07C9:  MOVLW  3D
07CA:  CLRWDT
07CB:  MOVLB  00
07CC:  BTFSC  11.4
07CD:  GOTO   7D0
07CE:  MOVLB  03
07CF:  GOTO   7CA
07D0:  MOVLB  03
07D1:  MOVWF  1A
07D2:  MOVLB  02
07D3:  MOVF   40,W
07D4:  MOVWF  50
07D5:  MOVLW  1B
07D6:  MOVWF  51
07D7:  MOVLB  00
07D8:  CALL   720
....................  
.................... } // }}} 
07D9:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
0883:  MOVLW  DB
0884:  MOVLB  02
0885:  ADDWF  3F,W
0886:  MOVWF  43
0887:  MOVLW  1F
0888:  MOVWF  44
0889:  BTFSC  03.0
088A:  INCF   44,F
088B:  MOVF   44,W
088C:  MOVLB  03
088D:  MOVWF  12
088E:  MOVLB  02
088F:  MOVF   43,W
0890:  MOVLB  03
0891:  MOVWF  11
0892:  MOVLW  20
0893:  MOVWF  05
0894:  MOVLW  C0
0895:  MOVWF  04
0896:  MOVLW  01
0897:  MOVLB  02
0898:  MOVWF  45
0899:  MOVLB  00
089A:  CALL   000
....................    
....................   PROMPT_FLAG=1; 
089B:  MOVLB  01
089C:  BSF    5D.6
....................   for(x=0;x<4;x++) { 
089D:  MOVLB  02
089E:  CLRF   41
089F:  MOVF   41,W
08A0:  SUBLW  03
08A1:  BTFSS  03.0
08A2:  GOTO   0C9
....................     do_delay=1; 
08A3:  BSF    42.0
....................     switch(mc & 0xc0) { // Check two MSB's 
08A4:  MOVF   40,W
08A5:  ANDLW  C0
08A6:  XORLW  40
08A7:  MOVLB  00
08A8:  BTFSC  03.2
08A9:  GOTO   0AE
08AA:  XORLW  C0
08AB:  BTFSC  03.2
08AC:  GOTO   0B0
08AD:  GOTO   0B2
....................       case(0x40): 
....................         dit(); 
08AE:  CALL   013
....................         break; 
08AF:  GOTO   0B5
....................       case(0x80): 
....................         dah(); 
08B0:  CALL   04B
....................         break; 
08B1:  GOTO   0B5
....................       default: 
....................         do_delay=0; 
08B2:  MOVLB  02
08B3:  BCF    42.0
....................         break; 
08B4:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
08B5:  MOVLB  02
08B6:  RLF    40,F
08B7:  RLF    40,F
08B8:  MOVLW  FC
08B9:  ANDWF  40,F
....................     if ( do_delay ) { 
08BA:  BTFSS  42.0
08BB:  GOTO   0C7
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
08BC:  MOVLB  01
08BD:  CLRF   33
08BE:  MOVLW  02
08BF:  MOVWF  32
....................       while(aux_timer) { 
08C0:  MOVF   32,W
08C1:  IORWF  33,W
08C2:  BTFSC  03.2
08C3:  GOTO   0C6
....................         delay_cycles(1); 
08C4:  NOP
....................       } 
08C5:  GOTO   0C0
08C6:  MOVLB  02
....................     } 
....................   } 
08C7:  INCF   41,F
08C8:  GOTO   09F
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
08C9:  MOVF   3F,W
08CA:  SUBLW  09
08CB:  BTFSS  03.0
08CC:  GOTO   0D8
....................     if ( c < 5 ) { 
08CD:  MOVF   3F,W
08CE:  SUBLW  04
08CF:  BTFSS  03.0
08D0:  GOTO   0D5
....................       dah(); 
08D1:  MOVLB  00
08D2:  CALL   04B
....................     } 
....................     else { 
08D3:  GOTO   0D7
08D4:  MOVLB  02
....................       dit(); 
08D5:  MOVLB  00
08D6:  CALL   013
08D7:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
08D8:  MOVLB  00
08D9:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0B4B:  MOVLW  30
0B4C:  MOVLB  02
0B4D:  MOVWF  34
0B4E:  MOVWF  35
0B4F:  MOVWF  36
0B50:  MOVWF  37
0B51:  CLRF   38
....................   char PTT_s[5]={'0','0','0','0',0}; 
0B52:  MOVWF  39
0B53:  MOVWF  3A
0B54:  MOVWF  3B
0B55:  MOVWF  3C
0B56:  CLRF   3D
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0B57:  MOVF   2E,W
0B58:  MOVLB  00
0B59:  MOVWF  6D
....................  
....................   if ( cor ) { 
0B5A:  MOVLB  02
0B5B:  MOVF   2E,F
0B5C:  BTFSC  03.2
0B5D:  GOTO   36F
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0B5E:  MOVLW  01
0B5F:  SUBWF  2E,W
0B60:  ADDLW  29
0B61:  MOVWF  04
0B62:  MOVLW  20
0B63:  MOVWF  05
0B64:  BTFSC  03.0
0B65:  INCF   05,F
0B66:  MOVF   00,W
0B67:  MOVWF  3F
0B68:  MOVLB  00
0B69:  MOVF   60,W
0B6A:  ANDWF  61,W
0B6B:  MOVLB  02
0B6C:  ANDWF  3F,W
0B6D:  MOVWF  33
....................   } else { 
0B6E:  GOTO   3B8
....................     ptt=0; 
0B6F:  CLRF   33
....................     if ( COR_DROP_FLAG ) { 
0B70:  BTFSS  72.7
0B71:  GOTO   3B8
....................       COR_DROP_FLAG=0; 
0B72:  BCF    72.7
....................       if ( ConfirmChar || TailChar ) { 
0B73:  MOVLB  00
0B74:  MOVF   6B,F
0B75:  BTFSS  03.2
0B76:  GOTO   37A
0B77:  MOVF   6A,F
0B78:  BTFSC  03.2
0B79:  GOTO   3B7
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0BB8:  MOVLW  01
0BB9:  MOVWF  32
....................   for(x=0;x<4;x++) { 
0BBA:  CLRF   2F
0BBB:  MOVF   2F,W
0BBC:  SUBLW  03
0BBD:  BTFSS  03.0
0BBE:  GOTO   423
....................     if ( !cor ) { 
0BBF:  MOVF   2E,F
0BC0:  BTFSS  03.2
0BC1:  GOTO   3C5
....................       rx_bit=0; 
0BC2:  BCF    3E.0
....................       ptt_bit=0; 
0BC3:  BCF    3E.1
....................     } else { 
0BC4:  GOTO   3D8
....................       if ( cor == (x+1) ) { 
0BC5:  MOVLW  01
0BC6:  ADDWF  2F,W
0BC7:  SUBWF  2E,W
0BC8:  BTFSS  03.2
0BC9:  GOTO   3D0
....................         rx_bit=1; 
0BCA:  BSF    3E.0
....................         CurrentCorMask=mask; 
0BCB:  MOVF   32,W
0BCC:  MOVLB  00
0BCD:  MOVWF  6C
....................       } else { 
0BCE:  GOTO   3D2
0BCF:  MOVLB  02
....................         rx_bit=0; 
0BD0:  BCF    3E.0
0BD1:  MOVLB  00
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0BD2:  MOVLB  02
0BD3:  BCF    3E.1
0BD4:  MOVF   33,W
0BD5:  ANDWF  32,W
0BD6:  BTFSS  03.2
0BD7:  BSF    3E.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0BD8:  MOVF   2F,W
0BD9:  MOVLP  00
0BDA:  MOVLB  00
0BDB:  CALL   031
0BDC:  MOVLP  08
0BDD:  MOVLB  02
0BDE:  MOVWF  3F
0BDF:  MOVLW  00
0BE0:  BTFSC  3E.0
0BE1:  MOVLW  01
0BE2:  MOVWF  77
0BE3:  MOVF   3F,W
0BE4:  MOVWF  40
0BE5:  MOVF   77,W
0BE6:  MOVWF  41
0BE7:  MOVLW  01
0BE8:  MOVWF  43
0BE9:  CLRF   42
0BEA:  MOVLB  00
0BEB:  CALL   0DA
0BEC:  MOVLB  02
0BED:  MOVF   3F,W
0BEE:  MOVWF  40
0BEF:  CLRF   41
0BF0:  CLRF   43
0BF1:  MOVLW  80
0BF2:  MOVWF  42
0BF3:  MOVLB  00
0BF4:  CALL   0DA
....................     output_bit(PTT_PIN[x],ptt_bit); 
0BF5:  MOVLB  02
0BF6:  MOVF   2F,W
0BF7:  MOVLP  00
0BF8:  MOVLB  00
0BF9:  CALL   036
0BFA:  MOVLP  08
0BFB:  MOVLB  02
0BFC:  MOVWF  3F
0BFD:  MOVLW  00
0BFE:  BTFSC  3E.1
0BFF:  MOVLW  01
0C00:  MOVWF  77
0C01:  MOVF   3F,W
0C02:  MOVWF  40
0C03:  MOVF   77,W
0C04:  MOVWF  41
0C05:  MOVLW  01
0C06:  MOVWF  43
0C07:  CLRF   42
0C08:  MOVLB  00
0C09:  CALL   0DA
0C0A:  MOVLB  02
0C0B:  MOVF   3F,W
0C0C:  MOVWF  40
0C0D:  CLRF   41
0C0E:  CLRF   43
0C0F:  MOVLW  80
0C10:  MOVWF  42
0C11:  MOVLB  00
0C12:  CALL   0DA
....................     if(ptt_bit) { 
0C13:  MOVLB  02
0C14:  BTFSS  3E.1
0C15:  GOTO   41F
....................       PTT_s[x]='1'; 
0C16:  MOVLW  B9
0C17:  ADDWF  2F,W
0C18:  MOVWF  04
0C19:  MOVLW  20
0C1A:  MOVWF  05
0C1B:  BTFSC  03.0
0C1C:  INCF   05,F
0C1D:  MOVLW  31
0C1E:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C1F:  BCF    03.0
0C20:  RLF    32,F
....................   }  
0C21:  INCF   2F,F
0C22:  GOTO   3BB
....................   if(!cor) { 
0C23:  MOVF   2E,F
0C24:  BTFSS  03.2
0C25:  GOTO   42A
....................     CurrentCorPriority=0; 
0C26:  MOVLB  00
0C27:  CLRF   6E
....................   } else { 
0C28:  GOTO   45A
0C29:  MOVLB  02
....................     CurrentCorPriority=RXPriority[cor-1]; 
0C2A:  MOVLW  01
0C2B:  SUBWF  2E,W
0C2C:  ADDLW  25
0C2D:  MOVWF  04
0C2E:  MOVLW  20
0C2F:  MOVWF  05
0C30:  BTFSC  03.0
0C31:  INCF   05,F
0C32:  MOVF   00,W
0C33:  MOVLB  00
0C34:  MOVWF  6E
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0C35:  MOVLB  02
0C36:  CLRF   30
0C37:  MOVF   30,W
0C38:  SUBLW  03
0C39:  BTFSS  03.0
0C3A:  GOTO   457
....................       pot_val=RX_GAIN[cor-1][pot]; 
0C3B:  MOVLW  01
0C3C:  SUBWF  2E,W
0C3D:  MOVWF  77
0C3E:  RLF    77,F
0C3F:  RLF    77,F
0C40:  MOVLW  FC
0C41:  ANDWF  77,F
0C42:  MOVF   77,W
0C43:  ADDWF  30,W
0C44:  ADDLW  0C
0C45:  MOVWF  04
0C46:  MOVLW  20
0C47:  MOVWF  05
0C48:  BTFSC  03.0
0C49:  INCF   05,F
0C4A:  MOVF   00,W
0C4B:  MOVWF  31
....................       set_trimpot(pot,pot_val); 
0C4C:  MOVF   30,W
0C4D:  MOVWF  3F
0C4E:  MOVF   31,W
0C4F:  MOVWF  40
0C50:  MOVLP  00
0C51:  MOVLB  00
0C52:  CALL   76F
0C53:  MOVLP  08
....................     } 
0C54:  MOVLB  02
0C55:  INCF   30,F
0C56:  GOTO   437
....................     PROMPT_FLAG=1; 
0C57:  MOVLB  01
0C58:  BSF    5D.6
0C59:  MOVLB  00
....................   } 
....................   if(cor>0) { 
0C5A:  MOVLB  02
0C5B:  MOVF   2E,F
0C5C:  BTFSC  03.2
0C5D:  GOTO   468
....................     COR_s[cor-1]='1'; 
0C5E:  MOVLW  01
0C5F:  SUBWF  2E,W
0C60:  ADDLW  B4
0C61:  MOVWF  04
0C62:  MOVLW  20
0C63:  MOVWF  05
0C64:  BTFSC  03.0
0C65:  INCF   05,F
0C66:  MOVLW  31
0C67:  MOVWF  00
....................   } 
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0C68:  MOVLW  20
0C69:  MOVLB  01
0C6A:  MOVWF  64
0C6B:  MOVLW  76
0C6C:  MOVWF  63
0C6D:  MOVLW  EC
0C6E:  MOVLB  03
0C6F:  MOVWF  11
0C70:  MOVLW  03
0C71:  MOVWF  12
0C72:  BCF    03.0
0C73:  MOVLW  04
0C74:  MOVLB  02
0C75:  MOVWF  4A
0C76:  MOVLB  00
0C77:  CALL   10B
0C78:  MOVLW  20
0C79:  MOVWF  05
0C7A:  MOVLW  B4
0C7B:  MOVWF  04
0C7C:  CALL   15E
0C7D:  MOVLW  EF
0C7E:  MOVLB  03
0C7F:  MOVWF  11
0C80:  MOVLW  03
0C81:  MOVWF  12
0C82:  BCF    03.0
0C83:  MOVLW  05
0C84:  MOVLB  02
0C85:  MOVWF  4A
0C86:  MOVLB  00
0C87:  CALL   10B
0C88:  MOVLW  20
0C89:  MOVWF  05
0C8A:  MOVLW  B9
0C8B:  MOVWF  04
0C8C:  CALL   15E
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0C8D:  MOVLW  01
0C8E:  MOVLB  02
0C8F:  MOVWF  4A
0C90:  MOVLW  20
0C91:  MOVWF  4C
0C92:  MOVLW  76
0C93:  MOVWF  4B
0C94:  MOVLB  00
0C95:  CALL   173
....................   delay_ms(50); 
0C96:  MOVLW  32
0C97:  MOVLB  02
0C98:  MOVWF  4A
0C99:  MOVLP  00
0C9A:  MOVLB  00
0C9B:  CALL   7DA
0C9C:  MOVLP  08
....................   pot_values_to_lcd(); 
0C9D:  CALL   257
.................... }// }}} 
0C9E:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1E74:  MOVF   67,W
1E75:  SUBLW  0A
1E76:  BTFSS  03.0
1E77:  GOTO   692
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1E78:  MOVLW  64
1E79:  ADDWF  67,W
1E7A:  MOVWF  04
1E7B:  MOVLW  20
1E7C:  MOVWF  05
1E7D:  BTFSC  03.0
1E7E:  INCF   05,F
1E7F:  BTFSS  00.4
1E80:  GOTO   690
1E81:  MOVLW  64
1E82:  ADDWF  67,W
1E83:  MOVWF  04
1E84:  MOVLW  20
1E85:  MOVWF  05
1E86:  BTFSC  03.0
1E87:  INCF   05,F
1E88:  MOVF   00,W
1E89:  ANDLW  0F
1E8A:  SUBLW  0C
1E8B:  BTFSC  03.2
1E8C:  GOTO   690
....................       strobe=1; 
1E8D:  MOVLW  01
1E8E:  MOVWF  68
....................      } else { 
1E8F:  GOTO   691
....................       strobe = 0; 
1E90:  CLRF   68
....................     }  
....................   } else { 
1E91:  GOTO   693
....................     strobe=0; 
1E92:  CLRF   68
....................   } 
....................   return(strobe); 
1E93:  MOVF   68,W
1E94:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
17C0:  MOVLB  01
17C1:  MOVF   67,W
17C2:  SUBWF  68,W
17C3:  BTFSS  03.0
17C4:  GOTO   7EA
17C5:  MOVF   67,W
17C6:  SUBLW  09
17C7:  BTFSS  03.0
17C8:  GOTO   7EA
....................     valid=1; 
17C9:  BSF    6B.0
....................     for(x=a;x<=b;x++) { 
17CA:  MOVF   67,W
17CB:  MOVWF  6A
17CC:  MOVF   6A,W
17CD:  SUBWF  68,W
17CE:  BTFSS  03.0
17CF:  GOTO   7E9
....................       key=(int)DTMF_ARRAY[x].Key; 
17D0:  MOVLW  64
17D1:  ADDWF  6A,W
17D2:  MOVWF  04
17D3:  MOVLW  20
17D4:  MOVWF  05
17D5:  BTFSC  03.0
17D6:  INCF   05,F
17D7:  MOVF   00,W
17D8:  ANDLW  0F
17D9:  MOVWF  69
....................       if(! DTMF_ARRAY[x].Strobe ) { 
17DA:  MOVLW  64
17DB:  ADDWF  6A,W
17DC:  MOVWF  04
17DD:  MOVLW  20
17DE:  MOVWF  05
17DF:  BTFSC  03.0
17E0:  INCF   05,F
17E1:  BTFSS  00.4
....................         valid=0; 
17E2:  BCF    6B.0
....................       } 
....................      if(key==dp) { 
17E3:  MOVF   69,W
17E4:  SUBLW  0C
17E5:  BTFSC  03.2
....................         valid=0; 
17E6:  BCF    6B.0
....................       } 
....................     } 
17E7:  INCF   6A,F
17E8:  GOTO   7CC
....................   } else { 
17E9:  GOTO   7EB
....................     valid=0; 
17EA:  BCF    6B.0
....................   } 
....................   return(valid); 
17EB:  MOVLW  00
17EC:  BTFSC  6B.0
17ED:  MOVLW  01
17EE:  MOVWF  78
.................... } // }}} 
17EF:  MOVLB  00
17F0:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   unsigned site_id; 
....................   unsigned digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 01 : Link commands 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : -- UNUSED -- 
....................   // 11 : Morse send 
....................   // 12 : Send to I2C 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   command=0; 
*
1E21:  CLRF   70
....................   if ( ValidKeyRange(0,3)) { 
1E22:  MOVLB  01
1E23:  CLRF   67
1E24:  MOVLW  03
1E25:  MOVWF  68
1E26:  MOVLP  10
1E27:  MOVLB  00
1E28:  CALL   7C0
1E29:  MOVLP  18
1E2A:  MOVF   78,F
1E2B:  BTFSC  03.2
1E2C:  GOTO   6D8
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1E2D:  MOVLB  01
1E2E:  MOVF   34,W
1E2F:  ANDLW  0F
1E30:  MOVWF  68
1E31:  MOVLB  02
1E32:  MOVWF  43
1E33:  MOVLW  0A
1E34:  MOVWF  44
1E35:  MOVLP  08
1E36:  MOVLB  00
1E37:  CALL   733
1E38:  MOVLP  18
1E39:  MOVF   78,W
1E3A:  MOVLB  01
1E3B:  MOVWF  67
1E3C:  MOVF   35,W
1E3D:  ANDLW  0F
1E3E:  ADDWF  67,W
1E3F:  MOVWF  65
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1E40:  MOVF   36,W
1E41:  ANDLW  0F
1E42:  MOVWF  68
1E43:  MOVLB  02
1E44:  MOVWF  43
1E45:  MOVLW  0A
1E46:  MOVWF  44
1E47:  MOVLP  08
1E48:  MOVLB  00
1E49:  CALL   733
1E4A:  MOVLP  18
1E4B:  MOVF   78,W
1E4C:  MOVLB  01
1E4D:  MOVWF  67
1E4E:  MOVF   37,W
1E4F:  ANDLW  0F
1E50:  ADDWF  67,W
1E51:  MOVWF  70
....................     if ( ValidKeyRange(4,5) ) { 
1E52:  MOVLW  04
1E53:  MOVWF  67
1E54:  MOVLW  05
1E55:  MOVWF  68
1E56:  MOVLP  10
1E57:  MOVLB  00
1E58:  CALL   7C0
1E59:  MOVLP  18
1E5A:  MOVF   78,F
1E5B:  BTFSC  03.2
1E5C:  GOTO   6B3
....................       // Admin mode {{{ 
....................       argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1E5D:  MOVLB  01
1E5E:  MOVF   38,W
1E5F:  ANDLW  0F
1E60:  MOVWF  68
1E61:  MOVLB  02
1E62:  MOVWF  43
1E63:  MOVLW  0A
1E64:  MOVWF  44
1E65:  MOVLP  08
1E66:  MOVLB  00
1E67:  CALL   733
1E68:  MOVLP  18
1E69:  MOVF   78,W
1E6A:  MOVLB  01
1E6B:  MOVWF  67
1E6C:  MOVF   39,W
1E6D:  ANDLW  0F
1E6E:  ADDWF  67,W
1E6F:  MOVWF  75
....................       digit=6; 
1E70:  MOVLW  06
1E71:  MOVWF  66
....................       while(ValidKey(digit)) { 
1E72:  MOVF   66,W
1E73:  MOVWF  67
*
1E95:  MOVF   78,F
1E96:  BTFSC  03.2
1E97:  GOTO   6B1
....................        value = value * 10 + DTMF_ARRAY[digit].Key; 
1E98:  MOVF   76,W
1E99:  MOVLB  02
1E9A:  MOVWF  43
1E9B:  MOVLW  0A
1E9C:  MOVWF  44
1E9D:  MOVLP  08
1E9E:  MOVLB  00
1E9F:  CALL   733
1EA0:  MOVLP  18
1EA1:  MOVF   78,W
1EA2:  MOVLB  01
1EA3:  MOVWF  67
1EA4:  MOVLW  64
1EA5:  ADDWF  66,W
1EA6:  MOVWF  04
1EA7:  MOVLW  20
1EA8:  MOVWF  05
1EA9:  BTFSC  03.0
1EAA:  INCF   05,F
1EAB:  MOVF   00,W
1EAC:  ANDLW  0F
1EAD:  ADDWF  67,W
1EAE:  MOVWF  76
....................        digit++; 
1EAF:  INCF   66,F
....................       } 
1EB0:  GOTO   672
....................       // Admin mode }}} 
....................     } else { 
1EB1:  GOTO   6C5
1EB2:  MOVLB  00
....................       // User function {{{ 
....................       // Only 4 digits were entered.  
....................       // Use 'command' value as user function. 
....................       switch(command) { 
1EB3:  MOVF   70,W
1EB4:  XORLW  0A
1EB5:  BTFSC  03.2
1EB6:  GOTO   6BB
1EB7:  XORLW  01
1EB8:  BTFSC  03.2
1EB9:  GOTO   6BF
1EBA:  GOTO   6C2
....................         // Commands 10 (disable link) and 11 (enable link) 
....................         case(10): 
....................           argument = 0; 
1EBB:  CLRF   75
....................           value = 0x0E; 
1EBC:  MOVLW  0E
1EBD:  MOVWF  76
....................   	      break; 
1EBE:  GOTO   6C2
....................         case(11): 
....................           argument = 0; 
1EBF:  CLRF   75
....................           value = 0x0F; 
1EC0:  MOVLW  0F
1EC1:  MOVWF  76
....................    		    break; 
....................       } 
....................       // Override command 
....................       command=SET_REG; 
1EC2:  MOVLW  02
1EC3:  MOVWF  70
1EC4:  MOVLB  01
....................       // User function }}} 
....................     } 
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1EC5:  MOVF   70,W
1EC6:  XORLW  04
1EC7:  MOVLB  00
1EC8:  BTFSC  03.2
1EC9:  GOTO   6CD
1ECA:  XORLW  01
1ECB:  BTFSS  03.2
1ECC:  GOTO   6CF
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1ECD:  MOVF   75,W
1ECE:  MOVWF  76
....................         break; 
....................     } 
....................     if ( site_id == SiteID ) { 
1ECF:  MOVF   63,W
1ED0:  MOVLB  01
1ED1:  SUBWF  65,W
1ED2:  BTFSS  03.2
1ED3:  GOTO   6D9
....................       execute_command(); 
1ED4:  MOVLP  10
1ED5:  MOVLB  00
1ED6:  CALL   0F5
1ED7:  MOVLP  18
1ED8:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1ED9:  MOVF   34,W
1EDA:  ANDLW  0F
1EDB:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1EDC:  BTFSS  5D.7
1EDD:  GOTO   710
1EDE:  CLRF   67
1EDF:  CLRF   68
1EE0:  MOVLP  10
1EE1:  MOVLB  00
1EE2:  CALL   7C0
1EE3:  MOVLP  18
1EE4:  MOVF   78,F
1EE5:  BTFSS  03.2
1EE6:  GOTO   6E9
1EE7:  MOVLB  01
1EE8:  GOTO   710
....................     restart_wdt(); 
1EE9:  CLRWDT
....................     switch(command) { 
1EEA:  MOVF   70,W
1EEB:  XORLW  0E
1EEC:  BTFSC  03.2
1EED:  GOTO   6F5
1EEE:  XORLW  01
1EEF:  BTFSC  03.2
1EF0:  GOTO   6FD
1EF1:  XORLW  05
1EF2:  BTFSC  03.2
1EF3:  GOTO   705
1EF4:  GOTO   70C
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1EF5:  MOVLW  01
1EF6:  ADDWF  74,W
1EF7:  ANDLW  03
1EF8:  MOVWF  74
....................         pot_values_to_lcd(); 
1EF9:  MOVLP  08
1EFA:  CALL   257
1EFB:  MOVLP  18
....................         break; 
1EFC:  GOTO   70C
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1EFD:  MOVLW  FF
1EFE:  MOVLB  02
1EFF:  MOVWF  2F
1F00:  MOVLP  10
1F01:  MOVLB  00
1F02:  CALL   00F
1F03:  MOVLP  18
....................         break; 
1F04:  GOTO   70C
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1F05:  MOVLW  01
1F06:  MOVLB  02
1F07:  MOVWF  2F
1F08:  MOVLP  10
1F09:  MOVLB  00
1F0A:  CALL   00F
1F0B:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1F0C:  MOVLP  10
1F0D:  CALL   000
1F0E:  MOVLP  18
1F0F:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1F10:  BSF    5D.5
.................... } // }}} 
1F11:  MOVLP  18
1F12:  MOVLB  00
1F13:  GOTO   791 (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int cor_index; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
1CB0:  MOVLW  01
1CB1:  MOVLB  01
1CB2:  MOVWF  65
....................   do_update_ptt=0; 
1CB3:  CLRF   68
....................   // Allow emulated COR[4] for DTMF control (No audio feed-thru) 
....................   cor_in = COR_IN | (COR_EMUL&0x1F); 
1CB4:  MOVLB  00
1CB5:  MOVF   69,W
1CB6:  ANDLW  1F
1CB7:  IORWF  5F,W
1CB8:  MOVLB  01
1CB9:  MOVWF  67
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in&CurrentCorMask) ) { 
1CBA:  MOVLB  00
1CBB:  MOVF   6E,F
1CBC:  BTFSC  03.2
1CBD:  GOTO   4D5
1CBE:  MOVLB  01
1CBF:  MOVF   67,W
1CC0:  MOVLB  00
1CC1:  ANDWF  6C,W
1CC2:  BTFSS  03.2
1CC3:  GOTO   4D5
....................     CurrentCorPriority=0; 
1CC4:  CLRF   6E
....................     CurrentCorMask=0; 
1CC5:  CLRF   6C
....................     do_update_ptt=1; 
1CC6:  MOVLW  01
1CC7:  MOVLB  01
1CC8:  MOVWF  68
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
1CC9:  MOVF   67,W
1CCA:  MOVLB  00
1CCB:  ANDWF  60,W
1CCC:  ANDWF  61,W
1CCD:  BTFSS  03.2
1CCE:  GOTO   4D5
....................       COR_DROP_FLAG=1; 
1CCF:  BSF    72.7
....................       if ( Tail ) { 
1CD0:  MOVF   65,F
1CD1:  BTFSC  03.2
1CD2:  GOTO   4D5
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
1CD3:  MOVF   65,W
1CD4:  MOVWF  6A
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
1CD5:  MOVLB  01
1CD6:  CLRF   69
....................   for(x=0;x<4;x++) { 
1CD7:  CLRF   6A
1CD8:  MOVF   6A,W
1CD9:  SUBLW  03
1CDA:  BTFSS  03.0
1CDB:  GOTO   51C
....................     if ( cor_in & cor_mask ) { 
1CDC:  MOVF   67,W
1CDD:  ANDWF  65,W
1CDE:  BTFSC  03.2
1CDF:  GOTO   518
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
1CE0:  MOVLB  00
1CE1:  MOVF   60,W
1CE2:  ANDWF  61,W
1CE3:  MOVLB  01
1CE4:  ANDWF  65,W
1CE5:  BTFSC  03.2
1CE6:  GOTO   4F1
....................         rx_priority=RXPriority[x]; 
1CE7:  MOVLW  25
1CE8:  ADDWF  6A,W
1CE9:  MOVWF  04
1CEA:  MOVLW  20
1CEB:  MOVWF  05
1CEC:  BTFSC  03.0
1CED:  INCF   05,F
1CEE:  MOVF   00,W
1CEF:  MOVWF  66
....................       } else { 
1CF0:  GOTO   4F3
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
1CF1:  MOVLW  01
1CF2:  MOVWF  66
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1CF3:  MOVF   66,W
1CF4:  MOVLB  00
1CF5:  SUBWF  6E,W
1CF6:  BTFSC  03.0
1CF7:  GOTO   517
....................         if ( ! CurrentCorPriority ) { 
1CF8:  MOVF   6E,F
1CF9:  BTFSS  03.2
1CFA:  GOTO   4FF
....................           CurrentCorPriority = rx_priority; 
1CFB:  MOVLB  01
1CFC:  MOVF   66,W
1CFD:  MOVLB  00
1CFE:  MOVWF  6E
....................         } 
....................         cor_index=x+1; 
1CFF:  MOVLW  01
1D00:  MOVLB  01
1D01:  ADDWF  6A,W
1D02:  MOVWF  69
....................         do_update_ptt=1; 
1D03:  MOVLW  01
1D04:  MOVWF  68
....................         TOT_SecondCounter= 60 * TOT_Min; 
1D05:  MOVLW  3C
1D06:  MOVLB  02
1D07:  MOVWF  43
1D08:  MOVLB  00
1D09:  MOVF   66,W
1D0A:  MOVLB  02
1D0B:  MOVWF  44
1D0C:  MOVLP  08
1D0D:  MOVLB  00
1D0E:  CALL   733
1D0F:  MOVLP  18
1D10:  MOVLB  01
1D11:  CLRF   61
1D12:  MOVF   78,W
1D13:  MOVWF  60
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
1D14:  MOVF   65,W
1D15:  MOVLB  00
1D16:  MOVWF  6F
1D17:  MOVLB  01
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
1D18:  BCF    03.0
1D19:  RLF    65,F
....................   } 
1D1A:  INCF   6A,F
1D1B:  GOTO   4D8
....................   if ( do_update_ptt ) { 
1D1C:  MOVF   68,F
1D1D:  BTFSC  03.2
1D1E:  GOTO   528
....................     update_ptt(cor_index); 
1D1F:  MOVF   69,W
1D20:  MOVLB  02
1D21:  MOVWF  2E
1D22:  MOVLP  08
1D23:  MOVLB  00
1D24:  CALL   34B
1D25:  MOVLP  18
....................     PROMPT_FLAG=1; 
1D26:  MOVLB  01
1D27:  BSF    5D.6
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
1D28:  MOVF   67,F
1D29:  BTFSS  03.2
1D2A:  GOTO   52F
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
1D2B:  BSF    5D.5
....................     COR_IN_EFFECTIVE=0; 
1D2C:  MOVLB  00
1D2D:  CLRF   6F
1D2E:  MOVLB  01
....................   } 
....................   // Refresh Link Time-out timer when COR is received. 
....................   // Any COR value refreshes teh link TOT timer. 
....................   if ( Link_TOT != 0 && (cor_in)!=0 ) { 
1D2F:  MOVLB  00
1D30:  MOVF   67,F
1D31:  BTFSC  03.2
1D32:  GOTO   53C
1D33:  MOVLB  01
1D34:  MOVF   67,F
1D35:  BTFSS  03.2
1D36:  GOTO   539
1D37:  MOVLB  00
1D38:  GOTO   53C
....................     LinkDurationTimer = Link_TOT; 
1D39:  MOVLB  00
1D3A:  MOVF   67,W
1D3B:  MOVWF  68
....................   } 
.................... } // }}} 
1D3C:  MOVLP  18
1D3D:  GOTO   77A (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
1F14:  MOVLB  01
1F15:  CLRF   65
1F16:  MOVF   65,W
1F17:  SUBLW  09
1F18:  BTFSS  03.0
1F19:  GOTO   724
....................     DTMF_ARRAY[x]=(sDTMF)0; 
1F1A:  MOVLW  64
1F1B:  ADDWF  65,W
1F1C:  MOVWF  04
1F1D:  MOVLW  20
1F1E:  MOVWF  05
1F1F:  BTFSC  03.0
1F20:  INCF   05,F
1F21:  CLRF   00
....................   } 
1F22:  INCF   65,F
1F23:  GOTO   716
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
1F24:  MOVLW  20
1F25:  MOVWF  3F
1F26:  MOVLW  64
1F27:  MOVWF  3E
.................... } // }}} 
1F28:  MOVLP  18
1F29:  MOVLB  00
1F2A:  GOTO   798 (RETURN)
.................... void header (void) { // {{{ 
.................... //  putc(ESC); 
.................... //  printf("[47;34m\n\rRadio Repeater Controller - "); 
.................... //  putc(ESC); 
.................... //  printf("[47;31mVE2LRS"); 
.................... //  putc(ESC); 
.................... //  printf("[47;34m (C) 2013\n\n\r"); 
.................... //  putc(ESC); 
.................... //  printf("[40;37m"); 
.................... } // }}} 
*
0003:  RETURN
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   header(); 
*
1345:  MOVLP  00
1346:  CALL   003
1347:  MOVLP  10
....................   dtmf_in=dtmf_read(CONTROL_REG); 
1348:  MOVLW  01
1349:  MOVLB  02
134A:  MOVWF  3B
134B:  MOVLP  00
134C:  MOVLB  00
134D:  CALL   67E
134E:  MOVLP  10
134F:  MOVF   78,W
1350:  MOVLB  02
1351:  MOVWF  33
....................   aux_in = 0; 
1352:  CLRF   34
....................   for(x=0;x<RegMapNum;x++) { 
1353:  CLRF   2D
1354:  CLRF   2C
1355:  MOVF   2D,F
1356:  BTFSS  03.2
1357:  GOTO   45C
1358:  MOVF   2C,W
1359:  SUBLW  38
135A:  BTFSS  03.0
135B:  GOTO   45C
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
135C:  MOVLW  01
135D:  MOVWF  7A
135E:  MOVLW  8F
135F:  MOVWF  3B
1360:  MOVF   7A,W
1361:  MOVWF  3C
1362:  MOVF   2D,W
1363:  MOVWF  3E
1364:  MOVF   2C,W
1365:  MOVWF  3D
1366:  CLRF   40
1367:  MOVLW  06
1368:  MOVWF  3F
1369:  MOVLP  08
136A:  MOVLB  00
136B:  CALL   7BB
136C:  MOVLP  10
136D:  MOVF   78,W
136E:  MOVLB  02
136F:  ADDWF  3B,W
1370:  MOVWF  2F
1371:  MOVF   79,W
1372:  ADDWFC 3C,W
1373:  MOVWF  30
....................     romstrcpy(rname,cPtr); 
1374:  MOVLW  20
1375:  MOVWF  3C
1376:  MOVLW  B5
1377:  MOVWF  3B
1378:  MOVF   30,W
1379:  MOVWF  3E
137A:  MOVF   2F,W
137B:  MOVWF  3D
137C:  MOVLP  08
137D:  MOVLB  00
137E:  CALL   7D2
137F:  MOVLP  10
....................   regPtr=RegMap[x].reg_ptr; 
1380:  MOVLB  02
1381:  RLF    2C,W
1382:  MOVWF  3B
1383:  RLF    2D,W
1384:  MOVWF  3C
1385:  RLF    3B,F
1386:  RLF    3C,F
1387:  MOVLW  FC
1388:  ANDWF  3B,F
1389:  MOVF   3C,W
138A:  MOVWF  7A
138B:  MOVF   3B,W
138C:  MOVWF  3D
138D:  INCF   3B,W
138E:  MOVLP  00
138F:  MOVLB  00
1390:  CALL   043
1391:  MOVLP  10
1392:  MOVWF  7A
1393:  MOVLB  02
1394:  MOVF   3D,W
1395:  MOVLP  00
1396:  MOVLB  00
1397:  CALL   043
1398:  MOVLP  10
1399:  MOVLB  02
139A:  MOVWF  31
139B:  MOVF   7A,W
139C:  MOVWF  32
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
139D:  MOVF   32,W
139E:  MOVWF  7A
139F:  MOVF   31,W
13A0:  MOVWF  04
13A1:  MOVF   7A,W
13A2:  MOVWF  05
13A3:  MOVF   00,W
13A4:  MOVWF  3B
13A5:  MOVLW  5B
13A6:  CLRWDT
13A7:  MOVLB  00
13A8:  BTFSC  11.4
13A9:  GOTO   3AC
13AA:  MOVLB  02
13AB:  GOTO   3A6
13AC:  MOVLB  03
13AD:  MOVWF  1A
13AE:  MOVLW  0B
13AF:  MOVWF  04
13B0:  MOVLB  02
13B1:  MOVF   2D,W
13B2:  MOVWF  3D
13B3:  MOVF   2C,W
13B4:  MOVWF  3C
*
1412:  MOVLW  5D
1413:  CLRWDT
1414:  MOVLB  00
1415:  BTFSC  11.4
1416:  GOTO   419
1417:  MOVLB  02
1418:  GOTO   413
1419:  MOVLB  03
141A:  MOVWF  1A
141B:  MOVLW  20
141C:  CLRWDT
141D:  MOVLB  00
141E:  BTFSC  11.4
141F:  GOTO   422
1420:  MOVLB  03
1421:  GOTO   41C
1422:  MOVLB  03
1423:  MOVWF  1A
1424:  MOVLW  20
1425:  MOVWF  05
1426:  MOVLW  B5
1427:  MOVWF  04
1428:  MOVLP  08
1429:  MOVLB  00
142A:  CALL   23D
142B:  MOVLP  10
142C:  MOVLW  20
142D:  CLRWDT
142E:  BTFSS  11.4
142F:  GOTO   42D
1430:  MOVLB  03
1431:  MOVWF  1A
1432:  MOVLB  02
1433:  MOVF   3B,W
1434:  MOVWF  50
1435:  MOVLW  1B
1436:  MOVWF  51
1437:  MOVLP  00
1438:  MOVLB  00
1439:  CALL   720
143A:  MOVLP  10
143B:  MOVLW  09
143C:  CLRWDT
143D:  BTFSS  11.4
143E:  GOTO   43C
143F:  MOVLB  03
1440:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
1441:  MOVLB  02
1442:  MOVF   2C,W
1443:  ANDLW  03
1444:  MOVWF  3B
1445:  CLRF   3C
1446:  MOVF   3B,W
1447:  SUBLW  03
1448:  BTFSS  03.2
1449:  GOTO   457
144A:  MOVF   3C,F
144B:  BTFSS  03.2
144C:  GOTO   457
....................       putc('\n'); 
144D:  MOVLW  0A
144E:  MOVLP  00
144F:  MOVLB  00
1450:  CALL   2E4
1451:  MOVLP  10
....................       putc('\r'); 
1452:  MOVLW  0D
1453:  MOVLP  00
1454:  CALL   2E4
1455:  MOVLP  10
1456:  MOVLB  02
....................     } 
....................     restart_wdt(); 
1457:  CLRWDT
....................   } 
1458:  INCF   2C,F
1459:  BTFSC  03.2
145A:  INCF   2D,F
145B:  GOTO   355
....................   for(y=0;y<3;y++) { 
145C:  CLRF   2E
145D:  MOVF   2E,W
145E:  SUBLW  02
145F:  BTFSS  03.0
1460:  GOTO   477
....................     if(AuxInSW[y]==1) { 
1461:  MOVLW  1F
1462:  ADDWF  2E,W
1463:  MOVWF  04
1464:  MOVLW  20
1465:  MOVWF  05
1466:  BTFSC  03.0
1467:  INCF   05,F
1468:  DECFSZ 00,W
1469:  GOTO   475
....................       aux_in += 2<<y; 
146A:  MOVLW  02
146B:  MOVWF  77
146C:  MOVF   2E,W
146D:  MOVWF  78
146E:  BTFSC  03.2
146F:  GOTO   473
1470:  LSLF   77,F
1471:  DECFSZ 78,F
1472:  GOTO   470
1473:  MOVF   77,W
1474:  ADDWF  34,F
....................     } 
....................   } 
1475:  INCF   2E,F
1476:  GOTO   45D
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u",COR_IN,COR_EMUL,aux_in); 
1477:  MOVLW  F3
1478:  MOVLB  03
1479:  MOVWF  11
147A:  MOVLW  03
147B:  MOVWF  12
147C:  BCF    03.0
147D:  MOVLW  07
147E:  MOVLB  02
147F:  MOVWF  50
1480:  MOVLP  00
1481:  MOVLB  00
1482:  CALL   6AC
1483:  MOVLP  10
1484:  MOVF   5F,W
1485:  MOVLB  02
1486:  MOVWF  50
1487:  MOVLW  1B
1488:  MOVWF  51
1489:  MOVLP  00
148A:  MOVLB  00
148B:  CALL   720
148C:  MOVLP  10
148D:  MOVLW  F7
148E:  MOVLB  03
148F:  MOVWF  11
1490:  MOVLW  03
1491:  MOVWF  12
1492:  BSF    03.0
1493:  MOVLW  07
1494:  MOVLB  02
1495:  MOVWF  50
1496:  MOVLP  00
1497:  MOVLB  00
1498:  CALL   6AC
1499:  MOVLP  10
149A:  MOVF   69,W
149B:  MOVLB  02
149C:  MOVWF  50
149D:  MOVLW  1B
149E:  MOVWF  51
149F:  MOVLP  00
14A0:  MOVLB  00
14A1:  CALL   720
14A2:  MOVLP  10
14A3:  MOVLW  FC
14A4:  MOVLB  03
14A5:  MOVWF  11
14A6:  MOVLW  03
14A7:  MOVWF  12
14A8:  BCF    03.0
14A9:  MOVLW  09
14AA:  MOVLB  02
14AB:  MOVWF  50
14AC:  MOVLP  00
14AD:  MOVLB  00
14AE:  CALL   6AC
14AF:  MOVLP  10
14B0:  MOVLB  02
14B1:  MOVF   34,W
14B2:  MOVWF  50
14B3:  MOVLW  1B
14B4:  MOVWF  51
14B5:  MOVLP  00
14B6:  MOVLB  00
14B7:  CALL   720
14B8:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
14B9:  MOVLW  02
14BA:  MOVLB  03
14BB:  MOVWF  11
14BC:  MOVLW  04
14BD:  MOVWF  12
14BE:  BCF    03.0
14BF:  MOVLW  10
14C0:  MOVLB  02
14C1:  MOVWF  50
14C2:  MOVLP  00
14C3:  MOVLB  00
14C4:  CALL   6AC
14C5:  MOVLP  10
14C6:  MOVLB  02
14C7:  MOVF   33,W
14C8:  MOVWF  50
14C9:  MOVLW  1B
14CA:  MOVWF  51
14CB:  MOVLP  00
14CC:  MOVLB  00
14CD:  CALL   720
14CE:  MOVLP  10
14CF:  MOVLW  0A
14D0:  CLRWDT
14D1:  BTFSS  11.4
14D2:  GOTO   4D0
14D3:  MOVLB  03
14D4:  MOVWF  1A
14D5:  MOVLW  0D
14D6:  CLRWDT
14D7:  MOVLB  00
14D8:  BTFSC  11.4
14D9:  GOTO   4DC
14DA:  MOVLB  03
14DB:  GOTO   4D6
14DC:  MOVLB  03
14DD:  MOVWF  1A
....................   pot_values_to_lcd(); 
14DE:  MOVLP  08
14DF:  MOVLB  00
14E0:  CALL   257
14E1:  MOVLP  10
....................   PROMPT_FLAG=1; 
14E2:  MOVLB  01
14E3:  BSF    5D.6
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0A57:  MOVLW  20
0A58:  MOVLB  02
0A59:  MOVWF  42
0A5A:  MOVWF  43
0A5B:  MOVWF  44
0A5C:  MOVWF  45
....................   unsigned pval[4]={0,0,0,0}; 
0A5D:  CLRF   46
0A5E:  CLRF   47
0A5F:  CLRF   48
0A60:  CLRF   49
....................   delay_ms(40); 
0A61:  MOVLW  28
0A62:  MOVWF  4A
0A63:  MOVLP  00
0A64:  MOVLB  00
0A65:  CALL   7DA
0A66:  MOVLP  08
....................   i2c_start(); 
0A67:  MOVLB  04
0A68:  BSF    16.0
0A69:  BTFSC  16.0
0A6A:  GOTO   269
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0A6B:  MOVLW  51
0A6C:  MOVLB  02
0A6D:  MOVWF  50
0A6E:  MOVLP  00
0A6F:  MOVLB  00
0A70:  CALL   697
0A71:  MOVLP  08
0A72:  MOVF   78,W
0A73:  MOVLB  02
0A74:  BCF    41.1
0A75:  BTFSC  78.0
0A76:  BSF    41.1
....................   for(x=0;x<4;x++) { 
0A77:  CLRF   3F
0A78:  MOVF   3F,W
0A79:  SUBLW  03
0A7A:  BTFSS  03.0
0A7B:  GOTO   2B5
....................     if(x==3) { 
0A7C:  MOVF   3F,W
0A7D:  SUBLW  03
0A7E:  BTFSS  03.2
0A7F:  GOTO   282
....................       ack=0; 
0A80:  BCF    41.0
....................     } else { 
0A81:  GOTO   283
....................       ack=1; 
0A82:  BSF    41.0
....................     } 
....................     pot_val=i2c_read(ack); 
0A83:  MOVLW  00
0A84:  BTFSC  41.0
0A85:  MOVLW  01
0A86:  MOVWF  4A
0A87:  MOVF   4A,W
0A88:  MOVWF  77
*
0A97:  MOVF   78,W
0A98:  MOVLB  02
0A99:  MOVWF  40
....................     pot_val=pot_val&0x3F; 
0A9A:  MOVLW  3F
0A9B:  ANDWF  40,F
....................     pval[x]=pot_val; 
0A9C:  MOVLW  C6
0A9D:  ADDWF  3F,W
0A9E:  MOVWF  04
0A9F:  MOVLW  20
0AA0:  MOVWF  05
0AA1:  BTFSC  03.0
0AA2:  INCF   05,F
0AA3:  MOVF   40,W
0AA4:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0AA5:  MOVF   74,W
0AA6:  ANDLW  03
0AA7:  SUBWF  3F,W
0AA8:  BTFSS  03.2
0AA9:  GOTO   2B3
....................       c[x] = '*'; 
0AAA:  MOVLW  C2
0AAB:  ADDWF  3F,W
0AAC:  MOVWF  04
0AAD:  MOVLW  20
0AAE:  MOVWF  05
0AAF:  BTFSC  03.0
0AB0:  INCF   05,F
0AB1:  MOVLW  2A
0AB2:  MOVWF  00
....................     } 
....................   } 
0AB3:  INCF   3F,F
0AB4:  GOTO   278
....................   i2c_stop(); 
0AB5:  MOVLB  04
0AB6:  BSF    16.2
0AB7:  BTFSC  16.2
0AB8:  GOTO   2B7
....................   delay_ms(50); 
0AB9:  MOVLW  32
0ABA:  MOVLB  02
0ABB:  MOVWF  4A
0ABC:  MOVLP  00
0ABD:  MOVLB  00
0ABE:  CALL   7DA
0ABF:  MOVLP  08
....................   if ( ack_in!=0 ) { 
0AC0:  MOVLB  02
0AC1:  BTFSS  41.1
0AC2:  GOTO   2DE
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0AC3:  MOVLW  00
0AC4:  BTFSC  41.0
0AC5:  MOVLW  01
0AC6:  MOVWF  4A
0AC7:  MOVLW  0D
0AC8:  MOVLB  03
0AC9:  MOVWF  11
0ACA:  MOVLW  04
0ACB:  MOVWF  12
0ACC:  BCF    03.0
0ACD:  MOVLW  25
0ACE:  MOVLB  02
0ACF:  MOVWF  50
0AD0:  MOVLP  00
0AD1:  MOVLB  00
0AD2:  CALL   6AC
0AD3:  MOVLP  08
0AD4:  MOVLB  02
0AD5:  MOVF   4A,W
0AD6:  MOVWF  50
0AD7:  MOVLW  1B
0AD8:  MOVWF  51
0AD9:  MOVLP  00
0ADA:  MOVLB  00
0ADB:  CALL   720
0ADC:  MOVLP  08
0ADD:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0ADE:  MOVLW  20
0ADF:  MOVLB  01
0AE0:  MOVWF  64
0AE1:  MOVLW  76
0AE2:  MOVWF  63
0AE3:  MOVLW  21
0AE4:  MOVLB  03
0AE5:  MOVWF  11
0AE6:  MOVLW  04
0AE7:  MOVWF  12
0AE8:  BCF    03.0
0AE9:  MOVLW  04
0AEA:  MOVLB  02
0AEB:  MOVWF  4A
0AEC:  MOVLB  00
0AED:  CALL   10B
0AEE:  MOVLB  02
0AEF:  MOVF   42,W
0AF0:  MOVWF  50
0AF1:  MOVLB  00
0AF2:  CALL   0FC
0AF3:  MOVLB  02
0AF4:  MOVF   46,W
0AF5:  MOVWF  4A
0AF6:  MOVLW  18
0AF7:  MOVWF  4B
0AF8:  MOVLB  00
0AF9:  CALL   1D6
0AFA:  MOVLW  20
0AFB:  MOVLB  02
0AFC:  MOVWF  50
0AFD:  MOVLB  00
0AFE:  CALL   0FC
0AFF:  MOVLB  02
0B00:  MOVF   43,W
0B01:  MOVWF  50
0B02:  MOVLB  00
0B03:  CALL   0FC
0B04:  MOVLB  02
0B05:  MOVF   47,W
0B06:  MOVWF  4A
0B07:  MOVLW  18
0B08:  MOVWF  4B
0B09:  MOVLB  00
0B0A:  CALL   1D6
0B0B:  MOVLW  20
0B0C:  MOVLB  02
0B0D:  MOVWF  50
0B0E:  MOVLB  00
0B0F:  CALL   0FC
0B10:  MOVLB  02
0B11:  MOVF   44,W
0B12:  MOVWF  50
0B13:  MOVLB  00
0B14:  CALL   0FC
0B15:  MOVLB  02
0B16:  MOVF   48,W
0B17:  MOVWF  4A
0B18:  MOVLW  18
0B19:  MOVWF  4B
0B1A:  MOVLB  00
0B1B:  CALL   1D6
0B1C:  MOVLW  20
0B1D:  MOVLB  02
0B1E:  MOVWF  50
0B1F:  MOVLB  00
0B20:  CALL   0FC
0B21:  MOVLB  02
0B22:  MOVF   45,W
0B23:  MOVWF  50
0B24:  MOVLB  00
0B25:  CALL   0FC
0B26:  MOVLB  02
0B27:  MOVF   49,W
0B28:  MOVWF  4A
0B29:  MOVLW  18
0B2A:  MOVWF  4B
0B2B:  MOVLB  00
0B2C:  CALL   1D6
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0B2D:  MOVLB  02
0B2E:  CLRF   4A
0B2F:  MOVLW  20
0B30:  MOVWF  4C
0B31:  MOVLW  76
0B32:  MOVWF  4B
0B33:  MOVLB  00
0B34:  CALL   173
....................   printf("\n\r%s",LCD_str); 
0B35:  MOVLW  0A
0B36:  CLRWDT
0B37:  BTFSS  11.4
0B38:  GOTO   336
0B39:  MOVLB  03
0B3A:  MOVWF  1A
0B3B:  MOVLW  0D
0B3C:  CLRWDT
0B3D:  MOVLB  00
0B3E:  BTFSC  11.4
0B3F:  GOTO   342
0B40:  MOVLB  03
0B41:  GOTO   33C
0B42:  MOVLB  03
0B43:  MOVWF  1A
0B44:  MOVLW  20
0B45:  MOVWF  05
0B46:  MOVLW  76
0B47:  MOVWF  04
0B48:  MOVLB  00
0B49:  CALL   23D
....................  
.................... } // }}} 
0B4A:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
109B:  MOVLB  01
109C:  BTFSS  5D.7
109D:  GOTO   0A9
....................     printf("\n\n\rADMIN> "); 
109E:  MOVLW  2D
109F:  MOVLB  03
10A0:  MOVWF  11
10A1:  MOVLW  04
10A2:  MOVWF  12
10A3:  MOVLP  00
10A4:  MOVLB  00
10A5:  CALL   4BB
10A6:  MOVLP  10
....................   } else { 
10A7:  GOTO   0B2
10A8:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
10A9:  MOVLW  33
10AA:  MOVLB  03
10AB:  MOVWF  11
10AC:  MOVLW  04
10AD:  MOVWF  12
10AE:  MOVLP  00
10AF:  MOVLB  00
10B0:  CALL   4BB
10B1:  MOVLP  10
....................   } 
.................... } // }}} 
10B2:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
04A1:  MOVLW  10
04A2:  MOVLB  01
04A3:  MOVWF  66
....................   for (x=0;x<char_num;x++) { 
04A4:  CLRF   65
04A5:  MOVF   66,W
04A6:  SUBWF  65,W
04A7:  BTFSC  03.0
04A8:  GOTO   4B3
....................     sBuffer[x]='\0'; 
04A9:  MOVLW  50
04AA:  ADDWF  65,W
04AB:  MOVWF  04
04AC:  MOVLW  20
04AD:  MOVWF  05
04AE:  BTFSC  03.0
04AF:  INCF   05,F
04B0:  CLRF   00
....................   } 
04B1:  INCF   65,F
04B2:  GOTO   4A5
....................   sBufferIndex=0; 
04B3:  CLRF   71
....................   sBufferFlag=0;   
04B4:  BCF    72.0
....................   argument=-1; 
04B5:  MOVLW  FF
04B6:  MOVWF  75
....................   argument_name[0]='\0'; 
04B7:  CLRF   40
....................   command=0; 
04B8:  CLRF   70
.................... } // }}} 
04B9:  MOVLB  00
04BA:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
063E:  MOVLW  00
063F:  MOVLB  01
0640:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
0641:  MOVLB  02
0642:  BCF    45.0
0643:  MOVF   43,W
0644:  ANDLW  0F
0645:  ANDLW  01
0646:  BTFSS  03.2
0647:  BSF    45.0
....................   output_bit(DTMF_D0,dbit); 
0648:  BTFSC  45.0
0649:  GOTO   64C
064A:  BCF    0F.0
064B:  GOTO   64D
064C:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
064D:  BCF    45.0
064E:  MOVF   43,W
064F:  ANDLW  0F
0650:  ANDLW  02
0651:  BTFSS  03.2
0652:  BSF    45.0
....................   output_bit(DTMF_D1,dbit); 
0653:  BTFSC  45.0
0654:  GOTO   657
0655:  BCF    0F.1
0656:  GOTO   658
0657:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
0658:  BCF    45.0
0659:  MOVF   43,W
065A:  ANDLW  0F
065B:  ANDLW  04
065C:  BTFSS  03.2
065D:  BSF    45.0
....................   output_bit(DTMF_D2,dbit); 
065E:  BTFSC  45.0
065F:  GOTO   662
0660:  BCF    0F.2
0661:  GOTO   663
0662:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
0663:  BCF    45.0
0664:  MOVF   43,W
0665:  ANDLW  0F
0666:  ANDLW  08
0667:  BTFSS  03.2
0668:  BSF    45.0
....................   output_bit(DTMF_D3,dbit); 
0669:  BTFSC  45.0
066A:  GOTO   66D
066B:  BCF    0F.3
066C:  GOTO   66E
066D:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
066E:  MOVF   44,F
066F:  BTFSS  03.2
0670:  GOTO   673
0671:  BCF    0F.6
0672:  GOTO   674
0673:  BSF    0F.6
....................   delay_cycles(2); 
0674:  GOTO   675
....................   output_bit(DTMF_WEB,0); 
0675:  BCF    0F.5
....................   delay_cycles(2); 
0676:  GOTO   677
....................   output_bit(DTMF_WEB,1);   
0677:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
0678:  GOTO   679
....................   set_tris_d(0x0F); 
0679:  MOVLW  0F
067A:  MOVLB  01
067B:  MOVWF  0F
.................... } // }}} 
067C:  MOVLB  00
067D:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
067E:  MOVLW  0F
067F:  MOVLB  01
0680:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
0681:  MOVLB  02
0682:  MOVF   3B,F
0683:  BTFSS  03.2
0684:  GOTO   687
0685:  BCF    0F.6
0686:  GOTO   688
0687:  BSF    0F.6
....................   delay_cycles(1); 
0688:  NOP
....................   output_bit(DTMF_REB,0); 
0689:  BCF    0F.4
....................   delay_cycles(1); 
068A:  NOP
....................   value=input_d(); 
068B:  MOVLB  00
068C:  MOVF   0F,W
068D:  MOVLB  02
068E:  MOVWF  3C
....................   value&=0x0F; 
068F:  MOVLW  0F
0690:  ANDWF  3C,F
....................   output_bit(DTMF_REB,1); 
0691:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
0692:  NOP
....................   return(value); 
0693:  MOVF   3C,W
0694:  MOVWF  78
.................... } // }}} 
0695:  MOVLB  00
0696:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0CED:  MOVLB  02
0CEE:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0CEF:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0CF0:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0CF1:  CLRF   43
0CF2:  MOVLW  01
0CF3:  MOVWF  44
0CF4:  MOVLP  00
0CF5:  MOVLB  00
0CF6:  CALL   63E
0CF7:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0CF8:  MOVLB  02
0CF9:  CLRF   43
0CFA:  MOVLW  01
0CFB:  MOVWF  44
0CFC:  MOVLP  00
0CFD:  MOVLB  00
0CFE:  CALL   63E
0CFF:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0D00:  MOVLW  0C
0D01:  MOVLB  02
0D02:  MOVWF  43
0D03:  MOVLW  01
0D04:  MOVWF  44
0D05:  MOVLP  00
0D06:  MOVLB  00
0D07:  CALL   63E
0D08:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0D09:  MOVLW  01
0D0A:  MOVLB  02
0D0B:  MOVWF  43
0D0C:  MOVWF  44
0D0D:  MOVLP  00
0D0E:  MOVLB  00
0D0F:  CALL   63E
0D10:  MOVLP  08
....................     dtmf_read(CONTROL_REG); 
0D11:  MOVLW  01
0D12:  MOVLB  02
0D13:  MOVWF  3B
0D14:  MOVLP  00
0D15:  MOVLB  00
0D16:  CALL   67E
0D17:  MOVLP  08
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19EC:  MOVF   40,W
19ED:  MOVWF  43
19EE:  CLRF   44
19EF:  MOVLP  00
19F0:  MOVLB  00
19F1:  CALL   63E
19F2:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19F3:  MOVLW  0C
19F4:  MOVLB  02
19F5:  MOVWF  43
19F6:  MOVLW  01
19F7:  MOVWF  44
19F8:  MOVLP  00
19F9:  MOVLB  00
19FA:  CALL   63E
19FB:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
19FC:  MOVLW  01
19FD:  MOVLB  02
19FE:  MOVWF  43
19FF:  MOVWF  44
1A00:  MOVLP  00
1A01:  MOVLB  00
1A02:  CALL   63E
1A03:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A04:  MOVLW  05
1A05:  MOVLB  02
1A06:  MOVWF  43
1A07:  MOVLW  01
1A08:  MOVWF  44
1A09:  MOVLP  00
1A0A:  MOVLB  00
1A0B:  CALL   63E
1A0C:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A0D:  MOVLB  01
1A0E:  CLRF   33
1A0F:  MOVLW  10
1A10:  MOVWF  32
....................   while(aux_timer) { 
1A11:  MOVF   32,W
1A12:  IORWF  33,W
1A13:  BTFSC  03.2
1A14:  GOTO   217
....................     delay_cycles(1); 
1A15:  NOP
....................   } 
1A16:  GOTO   211
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A17:  MOVLW  04
1A18:  MOVLB  02
1A19:  MOVWF  43
1A1A:  MOVLW  01
1A1B:  MOVWF  44
1A1C:  MOVLP  00
1A1D:  MOVLB  00
1A1E:  CALL   63E
1A1F:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
0813:  MOVLW  01
0814:  MOVLB  02
0815:  MOVWF  43
0816:  CLRF   44
0817:  MOVLP  00
0818:  MOVLB  00
0819:  CALL   63E
081A:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
081B:  MOVLW  0C
081C:  MOVLB  02
081D:  MOVWF  43
081E:  MOVLW  01
081F:  MOVWF  44
0820:  MOVLP  00
0821:  MOVLB  00
0822:  CALL   63E
0823:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0824:  MOVLW  05
0825:  MOVLB  02
0826:  MOVWF  43
0827:  MOVLW  01
0828:  MOVWF  44
0829:  MOVLP  00
082A:  MOVLB  00
082B:  CALL   63E
082C:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
082D:  MOVLW  05
082E:  MOVLB  02
082F:  MOVWF  43
0830:  MOVLW  01
0831:  MOVWF  44
0832:  MOVLP  00
0833:  MOVLB  00
0834:  CALL   63E
0835:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
0836:  MOVLB  01
0837:  CLRF   33
0838:  MOVLW  02
0839:  MOVWF  32
....................   while(aux_timer) { 
083A:  MOVF   32,W
083B:  IORWF  33,W
083C:  BTFSC  03.2
083D:  GOTO   040
....................     delay_cycles(1); 
083E:  NOP
....................   } 
083F:  GOTO   03A
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0840:  MOVLW  04
0841:  MOVLB  02
0842:  MOVWF  43
0843:  MOVLW  01
0844:  MOVWF  44
0845:  MOVLP  00
0846:  MOVLB  00
0847:  CALL   63E
0848:  MOVLP  08
....................   restart_wdt(); 
0849:  CLRWDT
.................... } // }}} 
084A:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
084B:  MOVLW  01
084C:  MOVLB  02
084D:  MOVWF  43
084E:  CLRF   44
084F:  MOVLP  00
0850:  MOVLB  00
0851:  CALL   63E
0852:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0853:  MOVLW  0C
0854:  MOVLB  02
0855:  MOVWF  43
0856:  MOVLW  01
0857:  MOVWF  44
0858:  MOVLP  00
0859:  MOVLB  00
085A:  CALL   63E
085B:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
085C:  MOVLW  05
085D:  MOVLB  02
085E:  MOVWF  43
085F:  MOVLW  01
0860:  MOVWF  44
0861:  MOVLP  00
0862:  MOVLB  00
0863:  CALL   63E
0864:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0865:  MOVLW  05
0866:  MOVLB  02
0867:  MOVWF  43
0868:  MOVLW  01
0869:  MOVWF  44
086A:  MOVLP  00
086B:  MOVLB  00
086C:  CALL   63E
086D:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
086E:  MOVLB  01
086F:  CLRF   33
0870:  MOVLW  06
0871:  MOVWF  32
....................   while(aux_timer) { 
0872:  MOVF   32,W
0873:  IORWF  33,W
0874:  BTFSC  03.2
0875:  GOTO   078
....................     delay_cycles(1); 
0876:  NOP
....................   } 
0877:  GOTO   072
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0878:  MOVLW  04
0879:  MOVLB  02
087A:  MOVWF  43
087B:  MOVLW  01
087C:  MOVWF  44
087D:  MOVLP  00
087E:  MOVLB  00
087F:  CALL   63E
0880:  MOVLP  08
....................   restart_wdt(); 
0881:  CLRWDT
.................... } // }}} 
0882:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
0510:  MOVLB  02
0511:  MOVF   38,W
0512:  MOVWF  04
0513:  MOVF   39,W
0514:  MOVWF  05
0515:  MOVF   00,W
0516:  MOVWF  3B
....................   if ( tmp > 127 ) { 
0517:  MOVF   3B,W
0518:  SUBLW  7F
0519:  BTFSS  03.0
....................     tmp++; 
051A:  INCF   3B,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
051B:  BCF    03.0
051C:  RLF    3B,W
051D:  XORLW  09
051E:  ADDWF  3A,W
051F:  MOVWF  3B
....................   *cksum=tmp; 
0520:  MOVF   38,W
0521:  MOVWF  04
0522:  MOVF   39,W
0523:  MOVWF  05
0524:  MOVF   3B,W
0525:  MOVWF  00
.................... } // }}} 
0526:  MOVLB  00
0527:  RETURN
.................... void print_dtmf_info(void) { // {{{ 
....................   unsigned int x; 
....................   char dtmf; 
....................   char tmp[5]; 
....................   strcpy(LCD_str,"DTMF:"); 
*
1D90:  MOVLB  01
1D91:  CLRF   6C
1D92:  CLRF   6D
1D93:  MOVLW  20
1D94:  MOVWF  05
1D95:  MOVLW  76
1D96:  MOVWF  04
1D97:  MOVF   6C,W
1D98:  ADDWF  04,F
1D99:  MOVLW  00
1D9A:  ADDWFC 05,F
1D9B:  MOVF   6D,W
1D9C:  MOVLP  00
1D9D:  MOVLB  00
1D9E:  CALL   139
1D9F:  MOVLP  18
1DA0:  MOVWF  00
1DA1:  IORLW  00
1DA2:  BTFSC  03.2
1DA3:  GOTO   5A9
1DA4:  MOVLB  01
1DA5:  INCF   6D,F
1DA6:  INCF   6C,F
1DA7:  GOTO   593
1DA8:  MOVLB  00
....................   printf("\n\rDTMF="); 
1DA9:  MOVLW  3A
1DAA:  MOVLB  03
1DAB:  MOVWF  11
1DAC:  MOVLW  04
1DAD:  MOVWF  12
1DAE:  MOVLP  00
1DAF:  MOVLB  00
1DB0:  CALL   4BB
1DB1:  MOVLP  18
....................   for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1DB2:  MOVLB  01
1DB3:  CLRF   65
1DB4:  MOVF   65,W
1DB5:  SUBLW  09
1DB6:  BTFSS  03.0
1DB7:  GOTO   600
....................     if(DTMF_ARRAY[x].Strobe) { 
1DB8:  MOVLW  64
1DB9:  ADDWF  65,W
1DBA:  MOVWF  04
1DBB:  MOVLW  20
1DBC:  MOVWF  05
1DBD:  BTFSC  03.0
1DBE:  INCF   05,F
1DBF:  BTFSS  00.4
1DC0:  GOTO   5FD
....................       dtmf=(int)DTMF_ARRAY[x].Key; 
1DC1:  MOVLW  64
1DC2:  ADDWF  65,W
1DC3:  MOVWF  04
1DC4:  MOVLW  20
1DC5:  MOVWF  05
1DC6:  BTFSC  03.0
1DC7:  INCF   05,F
1DC8:  MOVF   00,W
1DC9:  ANDLW  0F
1DCA:  MOVWF  66
....................       sprintf(tmp,"%d ",dtmf); 
1DCB:  MOVLW  20
1DCC:  MOVWF  64
1DCD:  MOVLW  97
1DCE:  MOVWF  63
1DCF:  MOVF   66,W
1DD0:  MOVLB  02
1DD1:  MOVWF  4A
1DD2:  MOVLW  18
1DD3:  MOVWF  4B
1DD4:  MOVLP  08
1DD5:  MOVLB  00
1DD6:  CALL   1D6
1DD7:  MOVLP  18
1DD8:  MOVLW  20
1DD9:  MOVLB  02
1DDA:  MOVWF  50
1DDB:  MOVLP  08
1DDC:  MOVLB  00
1DDD:  CALL   0FC
1DDE:  MOVLP  18
....................       strcat(LCD_str,tmp); 
1DDF:  MOVLW  20
1DE0:  MOVLB  02
1DE1:  MOVWF  29
1DE2:  MOVLW  76
1DE3:  MOVWF  28
1DE4:  MOVLW  20
1DE5:  MOVWF  2B
1DE6:  MOVLW  97
1DE7:  MOVWF  2A
1DE8:  MOVLP  10
1DE9:  MOVLB  00
1DEA:  CALL   647
1DEB:  MOVLP  18
....................       printf(" %u",dtmf); 
1DEC:  MOVLW  20
1DED:  CLRWDT
1DEE:  BTFSS  11.4
1DEF:  GOTO   5ED
1DF0:  MOVLB  03
1DF1:  MOVWF  1A
1DF2:  MOVLB  01
1DF3:  MOVF   66,W
1DF4:  MOVLB  02
1DF5:  MOVWF  50
1DF6:  MOVLW  1B
1DF7:  MOVWF  51
1DF8:  MOVLP  00
1DF9:  MOVLB  00
1DFA:  CALL   720
1DFB:  MOVLP  18
1DFC:  MOVLB  01
....................     } 
....................   restart_wdt(); 
1DFD:  CLRWDT
....................   } 
1DFE:  INCF   65,F
1DFF:  GOTO   5B4
....................   printf("\n\r"); 
1E00:  MOVLW  0A
1E01:  CLRWDT
1E02:  MOVLB  00
1E03:  BTFSC  11.4
1E04:  GOTO   607
1E05:  MOVLB  01
1E06:  GOTO   601
1E07:  MOVLB  03
1E08:  MOVWF  1A
1E09:  MOVLW  0D
1E0A:  CLRWDT
1E0B:  MOVLB  00
1E0C:  BTFSC  11.4
1E0D:  GOTO   610
1E0E:  MOVLB  03
1E0F:  GOTO   60A
1E10:  MOVLB  03
1E11:  MOVWF  1A
....................   PROMPT_FLAG=1; 
1E12:  MOVLB  01
1E13:  BSF    5D.6
....................   lcd_send(2,LCD_str); // Send DTMF on line 3 
1E14:  MOVLW  02
1E15:  MOVLB  02
1E16:  MOVWF  4A
1E17:  MOVLW  20
1E18:  MOVWF  4C
1E19:  MOVLW  76
1E1A:  MOVWF  4B
1E1B:  MOVLP  08
1E1C:  MOVLB  00
1E1D:  CALL   173
1E1E:  MOVLP  18
.................... } // }}} 
1E1F:  MOVLP  18
1E20:  GOTO   78A (RETURN)
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
*
0528:  MOVLW  01
0529:  MOVLB  02
052A:  MOVWF  32
....................   eeprom_index=0; 
052B:  CLRF   33
....................   retVal = 1; 
052C:  MOVWF  35
....................   if ( source == USE_EEPROM_VARS ) { 
052D:  DECFSZ 2E,W
052E:  GOTO   538
....................     printf("\n\rInit RAM <= EEPROM"); 
052F:  MOVLW  3E
0530:  MOVLB  03
0531:  MOVWF  11
0532:  MOVLW  04
0533:  MOVWF  12
0534:  MOVLB  00
0535:  CALL   4BB
....................   } else { 
0536:  GOTO   53F
0537:  MOVLB  02
....................     printf("\n\rInit RAM <= HW Defaults"); 
0538:  MOVLW  49
0539:  MOVLB  03
053A:  MOVWF  11
053B:  MOVLW  04
053C:  MOVWF  12
053D:  MOVLB  00
053E:  CALL   4BB
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
053F:  MOVLB  02
0540:  CLRF   2F
0541:  MOVF   2F,W
0542:  SUBLW  38
0543:  BTFSS  03.0
0544:  GOTO   59E
....................     regPtr=RegMap[x].reg_ptr; 
0545:  RLF    2F,W
0546:  MOVWF  77
0547:  RLF    77,F
0548:  MOVLW  FC
0549:  ANDWF  77,F
054A:  MOVF   77,W
054B:  MOVWF  37
054C:  INCF   37,W
054D:  MOVLB  00
054E:  CALL   043
054F:  MOVWF  7A
0550:  MOVLB  02
0551:  MOVF   37,W
0552:  MOVLB  00
0553:  CALL   043
0554:  MOVLB  02
0555:  MOVWF  30
0556:  MOVF   7A,W
0557:  MOVWF  31
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
0558:  DECFSZ 2E,W
0559:  GOTO   58A
055A:  RLF    2F,W
055B:  MOVWF  77
055C:  RLF    77,F
055D:  MOVLW  FC
055E:  ANDWF  77,F
055F:  MOVF   77,W
0560:  ADDLW  03
0561:  MOVLB  00
0562:  CALL   043
0563:  MOVWF  78
0564:  BTFSC  78.0
0565:  GOTO   568
0566:  MOVLB  02
0567:  GOTO   58A
....................       eeprom_val=read_eeprom(eeprom_index); 
0568:  MOVLB  02
0569:  MOVF   33,W
056A:  MOVLB  03
056B:  MOVWF  11
056C:  BCF    15.7
056D:  BSF    15.0
056E:  MOVF   13,W
056F:  MOVLB  02
0570:  MOVWF  36
....................       *regPtr=eeprom_val; 
0571:  MOVF   30,W
0572:  MOVWF  04
0573:  MOVF   31,W
0574:  MOVWF  05
0575:  MOVF   36,W
0576:  MOVWF  00
....................       update_checksum(&cksum,*regPtr);     
0577:  MOVF   31,W
0578:  MOVWF  7A
0579:  MOVF   30,W
057A:  MOVWF  04
057B:  MOVF   31,W
057C:  MOVWF  05
057D:  MOVF   00,W
057E:  MOVWF  37
057F:  MOVLW  20
0580:  MOVWF  39
0581:  MOVLW  B2
0582:  MOVWF  38
0583:  MOVF   37,W
0584:  MOVWF  3A
0585:  MOVLB  00
0586:  CALL   510
....................       eeprom_index++; 
0587:  MOVLB  02
0588:  INCF   33,F
....................     } else { 
0589:  GOTO   59C
....................       default_value=(int8)RegMap[x].default_value; 
058A:  RLF    2F,W
058B:  MOVWF  77
058C:  RLF    77,F
058D:  MOVLW  FC
058E:  ANDWF  77,F
058F:  MOVF   77,W
0590:  ADDLW  02
0591:  MOVLB  00
0592:  CALL   043
0593:  MOVWF  78
0594:  MOVLB  02
0595:  MOVWF  34
....................       *regPtr=default_value; 
0596:  MOVF   30,W
0597:  MOVWF  04
0598:  MOVF   31,W
0599:  MOVWF  05
059A:  MOVF   34,W
059B:  MOVWF  00
....................     } 
....................   } 
059C:  INCF   2F,F
059D:  GOTO   541
....................   if ( source == USE_EEPROM_VARS ) { 
059E:  DECFSZ 2E,W
059F:  GOTO   5AA
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
05A0:  MOVF   33,W
05A1:  MOVLB  03
05A2:  MOVWF  11
05A3:  BCF    15.7
05A4:  BSF    15.0
05A5:  MOVF   13,W
05A6:  MOVLB  02
05A7:  SUBWF  32,W
05A8:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
05A9:  CLRF   35
....................     } 
....................   } 
....................   return (retVal); 
05AA:  MOVF   35,W
05AB:  MOVWF  78
.................... } // }}} 
05AC:  MOVLB  00
05AD:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
05AE:  MOVLW  01
05AF:  MOVLB  02
05B0:  MOVWF  32
....................  
....................   eeprom_index=0; 
05B1:  CLRF   2F
....................   for(x=0;x<RegMapNum;x++) { 
05B2:  CLRF   2E
05B3:  MOVF   2E,W
05B4:  SUBLW  38
05B5:  BTFSS  03.0
05B6:  GOTO   60C
....................     regPtr=RegMap[x].reg_ptr; 
05B7:  RLF    2E,W
05B8:  MOVWF  77
05B9:  RLF    77,F
05BA:  MOVLW  FC
05BB:  ANDWF  77,F
05BC:  MOVF   77,W
05BD:  MOVWF  34
05BE:  INCF   34,W
05BF:  MOVLB  00
05C0:  CALL   043
05C1:  MOVWF  7A
05C2:  MOVLB  02
05C3:  MOVF   34,W
05C4:  MOVLB  00
05C5:  CALL   043
05C6:  MOVLB  02
05C7:  MOVWF  30
05C8:  MOVF   7A,W
05C9:  MOVWF  31
....................     if ( RegMap[x].non_volatile ) { 
05CA:  RLF    2E,W
05CB:  MOVWF  77
05CC:  RLF    77,F
05CD:  MOVLW  FC
05CE:  ANDWF  77,F
05CF:  MOVF   77,W
05D0:  ADDLW  03
05D1:  MOVLB  00
05D2:  CALL   043
05D3:  MOVWF  78
05D4:  BTFSS  78.0
05D5:  GOTO   609
....................      value=*regPtr; 
05D6:  MOVLB  02
05D7:  MOVF   30,W
05D8:  MOVWF  04
05D9:  MOVF   31,W
05DA:  MOVWF  05
05DB:  MOVF   00,W
05DC:  MOVWF  33
....................      if ( read_eeprom(eeprom_index) != value ) { 
05DD:  MOVF   2F,W
05DE:  MOVLB  03
05DF:  MOVWF  11
05E0:  BCF    15.7
05E1:  BSF    15.0
05E2:  MOVF   13,W
05E3:  MOVLB  02
05E4:  SUBWF  33,W
05E5:  BTFSC  03.2
05E6:  GOTO   5FE
....................        write_eeprom(eeprom_index,value); 
05E7:  MOVF   0B,W
05E8:  MOVWF  77
05E9:  BCF    0B.7
05EA:  MOVF   2F,W
05EB:  MOVLB  03
05EC:  MOVWF  11
05ED:  MOVLB  02
05EE:  MOVF   33,W
05EF:  MOVLB  03
05F0:  MOVWF  13
05F1:  BCF    15.7
05F2:  BSF    15.2
05F3:  MOVLW  55
05F4:  MOVWF  16
05F5:  MOVLW  AA
05F6:  MOVWF  16
05F7:  BSF    15.1
05F8:  BTFSC  15.1
05F9:  GOTO   5F8
05FA:  BCF    15.2
05FB:  MOVF   77,W
05FC:  IORWF  0B,F
05FD:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
05FE:  MOVLW  20
05FF:  MOVWF  39
0600:  MOVLW  B2
0601:  MOVWF  38
0602:  MOVF   33,W
0603:  MOVWF  3A
0604:  MOVLB  00
0605:  CALL   510
....................      eeprom_index++; 
0606:  MOVLB  02
0607:  INCF   2F,F
0608:  MOVLB  00
....................     } 
....................   } 
0609:  MOVLB  02
060A:  INCF   2E,F
060B:  GOTO   5B3
....................   write_eeprom(eeprom_index,cksum); 
060C:  MOVF   0B,W
060D:  MOVWF  77
060E:  BCF    0B.7
060F:  MOVF   2F,W
0610:  MOVLB  03
0611:  MOVWF  11
0612:  MOVLB  02
0613:  MOVF   32,W
0614:  MOVLB  03
0615:  MOVWF  13
0616:  BCF    15.7
0617:  BSF    15.2
0618:  MOVLW  55
0619:  MOVWF  16
061A:  MOVLW  AA
061B:  MOVWF  16
061C:  BSF    15.1
061D:  BTFSC  15.1
061E:  GOTO   61D
061F:  BCF    15.2
0620:  MOVF   77,W
0621:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
0622:  MOVLW  56
0623:  MOVWF  11
0624:  MOVLW  04
0625:  MOVWF  12
0626:  MOVLB  00
0627:  CALL   4BB
.................... } // }}} 
0628:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
0629:  MOVLB  02
062A:  MOVF   2D,W
062B:  MOVWF  2E
062C:  MOVLB  00
062D:  CALL   528
062E:  MOVF   78,F
062F:  BTFSS  03.2
0630:  GOTO   63D
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
0631:  MOVLW  69
0632:  MOVLB  03
0633:  MOVWF  11
0634:  MOVLW  04
0635:  MOVWF  12
0636:  MOVLB  00
0637:  CALL   4BB
....................         _init_variables(USE_DEFAULT_VARS); 
0638:  MOVLB  02
0639:  CLRF   2E
063A:  MOVLB  00
063B:  CALL   528
....................     store_variables(); 
063C:  CALL   5AE
....................     } 
.................... } // }}} 
063D:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0D2C:  MOVLB  02
0D2D:  CLRF   3F
0D2E:  CLRF   40
0D2F:  MOVLP  00
0D30:  MOVLB  00
0D31:  CALL   76F
0D32:  MOVLP  08
....................   set_trimpot(1,0); 
0D33:  MOVLW  01
0D34:  MOVLB  02
0D35:  MOVWF  3F
0D36:  CLRF   40
0D37:  MOVLP  00
0D38:  MOVLB  00
0D39:  CALL   76F
0D3A:  MOVLP  08
....................   set_trimpot(2,0); 
0D3B:  MOVLW  02
0D3C:  MOVLB  02
0D3D:  MOVWF  3F
0D3E:  CLRF   40
0D3F:  MOVLP  00
0D40:  MOVLB  00
0D41:  CALL   76F
0D42:  MOVLP  08
....................   set_trimpot(3,0); 
0D43:  MOVLW  03
0D44:  MOVLB  02
0D45:  MOVWF  3F
0D46:  CLRF   40
0D47:  MOVLP  00
0D48:  MOVLB  00
0D49:  CALL   76F
0D4A:  MOVLP  08
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0CB6:  MOVLP  00
0CB7:  CALL   4A1
0CB8:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0CB9:  MOVLB  02
0CBA:  CLRF   12
0CBB:  CLRF   11
0CBC:  CLRF   14
0CBD:  CLRF   13
....................   setup_wdt(WDT_2S); 
0CBE:  MOVLW  17
0CBF:  MOVLB  01
0CC0:  MOVWF  17
....................   COR_IN=0; 
0CC1:  MOVLB  00
0CC2:  CLRF   5F
....................   COR_DROP_FLAG=0; 
0CC3:  BCF    72.7
....................   DTMF_IN_FLAG=0; 
0CC4:  MOVLB  01
0CC5:  BCF    5D.3
....................   DTMF_INTERRUPT_FLAG=0; 
0CC6:  BCF    5D.4
....................   LastRegisterIndexValid=0; 
0CC7:  CLRF   7D
....................   LastRegisterIndex=0; 
0CC8:  CLRF   7C
....................   CurrentCorMask=0; 
0CC9:  MOVLB  00
0CCA:  CLRF   6C
....................   CurrentCorPriority=0; 
0CCB:  CLRF   6E
....................   CurrentCorIndex=0; 
0CCC:  CLRF   6D
....................   CurrentTrimPot=0; 
0CCD:  CLRF   74
....................   set_tris_b(0xFF); 
0CCE:  MOVLW  FF
0CCF:  TRIS   6
....................   set_tris_d(0x00); 
0CD0:  MOVLW  00
0CD1:  MOVLB  01
0CD2:  MOVWF  0F
....................   // 0b11111000 
....................   set_tris_e(0xF8); 
0CD3:  BCF    10.0
0CD4:  BCF    10.1
0CD5:  BCF    10.2
0CD6:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0CD7:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0CD8:  BSF    0B.3
0CD9:  MOVLW  CF
0CDA:  MOVLB  07
0CDB:  IORWF  14,F
0CDC:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0CDD:  BSF    0B.3
0CDE:  BSF    15.4
0CDF:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0CE0:  MOVLW  C0
0CE1:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0CE2:  MOVLB  02
0CE3:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0CE4:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0CE5:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0CE6:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0CE7:  MOVLW  01
0CE8:  MOVWF  2D
0CE9:  MOVLP  00
0CEA:  MOVLB  00
0CEB:  CALL   629
0CEC:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D18:  MOVLB  01
0D19:  BSF    5D.5
....................   Enable_Mask = 0x0F; 
0D1A:  MOVLW  0F
0D1B:  MOVLB  00
0D1C:  MOVWF  61
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D1D:  MOVF   62,W
0D1E:  ANDLW  0F
0D1F:  IORLW  C0
0D20:  MOVLB  04
0D21:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D22:  MOVLB  01
0D23:  BCF    15.7
....................   // }}} 
....................   header(); 
0D24:  MOVLP  00
0D25:  MOVLB  00
0D26:  CALL   003
0D27:  MOVLP  08
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D28:  MOVLW  9D
0D29:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0D2A:  MOVLW  80
0D2B:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0D4B:  MOVLB  01
0D4C:  CLRF   31
0D4D:  MOVLW  1E
0D4E:  MOVWF  30
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0D4F:  MOVF   15,W
0D50:  ANDLW  C0
0D51:  IORLW  07
0D52:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0D53:  BSF    0B.5
....................   update_ptt(0); 
0D54:  MOVLB  02
0D55:  CLRF   2E
0D56:  MOVLB  00
0D57:  CALL   34B
....................   MinuteCounter=MIN_COUNTER; 
0D58:  MOVLW  1D
0D59:  MOVLB  01
0D5A:  MOVWF  5F
....................   SecondCounter=SEC_COUNTER; 
0D5B:  MOVLW  3B
0D5C:  MOVWF  5E
....................   THIRTY_MIN_FLAG=0; 
0D5D:  BCF    72.6
....................   MINUTE_FLAG=0; 
0D5E:  BCF    72.5
....................   PROMPT_FLAG=1; 
0D5F:  BSF    5D.6
....................   TailChar=Tail; 
0D60:  MOVLB  00
0D61:  MOVF   65,W
0D62:  MOVWF  6A
....................   ConfirmChar=0; 
0D63:  CLRF   6B
....................   AuxInSW[0] = 0; 
0D64:  CLRF   3F
....................   AuxInSW[1] = 0; 
0D65:  CLRF   40
....................   AuxInSW[2] = 0; 
0D66:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0D67:  MOVLB  01
0D68:  BCF    5D.0
....................   COR_IN_EFFECTIVE=0; 
0D69:  MOVLB  00
0D6A:  CLRF   6F
....................   set_admin_mode(0); 
0D6B:  MOVLB  02
0D6C:  CLRF   40
0D6D:  MOVLB  00
0D6E:  CALL   49F
....................   rs232_mode=0; 
0D6F:  MOVLB  01
0D70:  BCF    62.0
....................   button_state=0; 
0D71:  CLRF   5C
.................... #ifdef LCD_TYPE_PI 
....................   init_lcd(); 
.................... #endif 
....................   setup_adc(ADC_CLOCK_INTERNAL); 
0D72:  BSF    1E.4
0D73:  BSF    1E.5
0D74:  BCF    1E.6
0D75:  BCF    1E.7
0D76:  BSF    1D.0
....................   setup_adc_ports(ADJ_POT|VSS_VDD); 
0D77:  BCF    1E.0
0D78:  BCF    1E.1
0D79:  BCF    1E.2
0D7A:  MOVLW  00
0D7B:  MOVLB  03
0D7C:  MOVWF  0C
0D7D:  MOVWF  10
0D7E:  MOVLW  20
0D7F:  MOVWF  0D
0D80:  MOVLW  00
0D81:  MOVWF  0F
....................   set_adc_channel(13); 
0D82:  MOVLW  34
0D83:  MOVWF  78
0D84:  MOVLB  01
0D85:  MOVF   1D,W
0D86:  ANDLW  83
0D87:  IORWF  78,W
0D88:  MOVWF  1D
....................  
.................... //  setup_adc_ports(ADJ_POT); 
.................... //  set_adc_channel(13); 
.................... //  printf("\n\rInitialization complete"); 
.................... } // }}} 
0D89:  MOVLP  18
0D8A:  MOVLB  00
0D8B:  GOTO   75E (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180D:  MOVLB  02
180E:  BCF    28.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
180F:  CLRF   3F
1810:  CLRF   40
1811:  MOVLW  20
1812:  MOVWF  05
1813:  MOVLW  AB
1814:  MOVWF  04
1815:  MOVF   3F,W
1816:  ADDWF  04,F
1817:  MOVLW  00
1818:  ADDWFC 05,F
1819:  MOVF   40,W
181A:  MOVLP  00
181B:  MOVLB  00
181C:  CALL   140
181D:  MOVLP  18
181E:  MOVWF  00
181F:  IORLW  00
1820:  BTFSC  03.2
1821:  GOTO   027
1822:  MOVLB  02
1823:  INCF   40,F
1824:  INCF   3F,F
1825:  GOTO   011
1826:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1827:  MOVLW  20
1828:  MOVLB  02
1829:  MOVWF  40
182A:  MOVLW  50
182B:  MOVWF  3F
182C:  MOVLW  20
182D:  MOVWF  42
182E:  MOVLW  AB
182F:  MOVWF  41
1830:  MOVLP  08
1831:  MOVLB  00
1832:  CALL   654
1833:  MOVLP  18
1834:  MOVF   79,W
1835:  MOVLB  02
1836:  MOVWF  2A
1837:  MOVF   78,W
1838:  MOVWF  29
....................   if (sptr!=0) {; 
1839:  MOVF   29,F
183A:  BTFSS  03.2
183B:  GOTO   03F
183C:  MOVF   2A,F
183D:  BTFSC  03.2
183E:  GOTO   059
....................     strcpy(verb,sptr); 
183F:  MOVF   2A,W
1840:  MOVWF  42
1841:  MOVF   29,W
1842:  MOVWF  41
1843:  MOVLW  20
1844:  MOVWF  40
1845:  MOVLW  A0
1846:  MOVWF  3F
1847:  MOVF   42,W
1848:  MOVWF  05
1849:  MOVF   41,W
184A:  MOVWF  04
184B:  MOVF   00,W
184C:  MOVWF  43
184D:  MOVF   40,W
184E:  MOVWF  05
184F:  MOVF   3F,W
1850:  MOVWF  04
1851:  MOVF   43,W
1852:  MOVWF  00
1853:  MOVF   00,F
1854:  BTFSC  03.2
1855:  GOTO   059
1856:  INCF   3F,F
1857:  INCF   41,F
1858:  GOTO   047
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
1859:  CLRF   40
185A:  CLRF   3F
185B:  MOVLW  20
185C:  MOVWF  42
185D:  MOVLW  AB
185E:  MOVWF  41
185F:  MOVLP  08
1860:  MOVLB  00
1861:  CALL   654
1862:  MOVLP  18
1863:  MOVF   79,W
1864:  MOVLB  02
1865:  MOVWF  2A
1866:  MOVF   78,W
1867:  MOVWF  29
....................   if (sptr!=0) {; 
1868:  MOVF   29,F
1869:  BTFSS  03.2
186A:  GOTO   06E
186B:  MOVF   2A,F
186C:  BTFSC  03.2
186D:  GOTO   088
....................     strcpy(argument_name,sptr); 
186E:  MOVF   2A,W
186F:  MOVWF  42
1870:  MOVF   29,W
1871:  MOVWF  41
1872:  MOVLW  20
1873:  MOVWF  40
1874:  MOVLW  70
1875:  MOVWF  3F
1876:  MOVF   42,W
1877:  MOVWF  05
1878:  MOVF   41,W
1879:  MOVWF  04
187A:  MOVF   00,W
187B:  MOVWF  43
187C:  MOVF   40,W
187D:  MOVWF  05
187E:  MOVF   3F,W
187F:  MOVWF  04
1880:  MOVF   43,W
1881:  MOVWF  00
1882:  MOVF   00,F
1883:  BTFSC  03.2
1884:  GOTO   088
1885:  INCF   3F,F
1886:  INCF   41,F
1887:  GOTO   076
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1888:  CLRF   40
1889:  CLRF   3F
188A:  MOVLW  20
188B:  MOVWF  42
188C:  MOVLW  AB
188D:  MOVWF  41
188E:  MOVLP  08
188F:  MOVLB  00
1890:  CALL   654
1891:  MOVLP  18
1892:  MOVF   79,W
1893:  MOVLB  02
1894:  MOVWF  2A
1895:  MOVF   78,W
1896:  MOVWF  29
....................   if (sptr!=0) {; 
1897:  MOVF   29,F
1898:  BTFSS  03.2
1899:  GOTO   09D
189A:  MOVF   2A,F
189B:  BTFSC  03.2
189C:  GOTO   0C3
....................     strcpy(match_val,sptr); 
189D:  MOVF   2A,W
189E:  MOVWF  42
189F:  MOVF   29,W
18A0:  MOVWF  41
18A1:  MOVLW  20
18A2:  MOVWF  40
18A3:  MOVLW  B3
18A4:  MOVWF  3F
18A5:  MOVF   42,W
18A6:  MOVWF  05
18A7:  MOVF   41,W
18A8:  MOVWF  04
18A9:  MOVF   00,W
18AA:  MOVWF  43
18AB:  MOVF   40,W
18AC:  MOVWF  05
18AD:  MOVF   3F,W
18AE:  MOVWF  04
18AF:  MOVF   43,W
18B0:  MOVWF  00
18B1:  MOVF   00,F
18B2:  BTFSC  03.2
18B3:  GOTO   0B7
18B4:  INCF   3F,F
18B5:  INCF   41,F
18B6:  GOTO   0A5
....................     value = str_to_decimal(match_val); 
18B7:  MOVLW  20
18B8:  MOVWF  40
18B9:  MOVLW  B3
18BA:  MOVWF  3F
18BB:  MOVLP  08
18BC:  MOVLB  00
18BD:  CALL   75A
18BE:  MOVLP  18
18BF:  MOVF   78,W
18C0:  MOVWF  76
....................   } else { 
18C1:  GOTO   0C6
18C2:  MOVLB  02
....................     value = 0; 
18C3:  CLRF   76
....................     do_get_var = 1; 
18C4:  BSF    28.0
18C5:  MOVLB  00
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18C6:  MOVLB  02
18C7:  CLRF   3F
18C8:  CLRF   40
18C9:  MOVLW  20
18CA:  MOVWF  05
18CB:  MOVLW  B7
18CC:  MOVWF  04
18CD:  MOVF   3F,W
18CE:  ADDWF  04,F
18CF:  MOVLW  00
18D0:  ADDWFC 05,F
18D1:  MOVF   40,W
18D2:  MOVLP  00
18D3:  MOVLB  00
18D4:  CALL   146
18D5:  MOVLP  18
18D6:  MOVWF  00
18D7:  IORLW  00
18D8:  BTFSC  03.2
18D9:  GOTO   0DF
18DA:  MOVLB  02
18DB:  INCF   40,F
18DC:  INCF   3F,F
18DD:  GOTO   0C9
18DE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
18DF:  MOVLW  20
18E0:  MOVLB  02
18E1:  MOVWF  40
18E2:  MOVLW  B7
18E3:  MOVWF  3F
18E4:  MOVLW  20
18E5:  MOVWF  42
18E6:  MOVLW  A0
18E7:  MOVWF  41
18E8:  MOVLP  08
18E9:  MOVLB  00
18EA:  CALL   793
18EB:  MOVLP  18
18EC:  MOVF   78,F
18ED:  BTFSS  03.2
18EE:  GOTO   0F8
....................     if ( do_get_var ) { 
18EF:  MOVLB  02
18F0:  BTFSS  28.0
18F1:  GOTO   0F5
....................       command=GET_REG; 
18F2:  MOVLW  03
18F3:  MOVWF  70
....................     } else { 
18F4:  GOTO   0F7
....................       command=SET_REG; 
18F5:  MOVLW  02
18F6:  MOVWF  70
18F7:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18F8:  MOVLB  02
18F9:  CLRF   3F
18FA:  CLRF   40
18FB:  MOVLW  20
18FC:  MOVWF  05
18FD:  MOVLW  B7
18FE:  MOVWF  04
18FF:  MOVF   3F,W
1900:  ADDWF  04,F
1901:  MOVLW  00
1902:  ADDWFC 05,F
1903:  MOVF   40,W
1904:  MOVLP  00
1905:  MOVLB  00
1906:  CALL   14B
1907:  MOVLP  18
1908:  MOVWF  00
1909:  IORLW  00
190A:  BTFSC  03.2
190B:  GOTO   111
190C:  MOVLB  02
190D:  INCF   40,F
190E:  INCF   3F,F
190F:  GOTO   0FB
1910:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1911:  MOVLW  20
1912:  MOVLB  02
1913:  MOVWF  40
1914:  MOVLW  B7
1915:  MOVWF  3F
1916:  MOVLW  20
1917:  MOVWF  42
1918:  MOVLW  A0
1919:  MOVWF  41
191A:  MOVLP  08
191B:  MOVLB  00
191C:  CALL   793
191D:  MOVLP  18
191E:  MOVF   78,F
191F:  BTFSS  03.2
1920:  GOTO   123
....................       command=SAVE_SETTINGS; 
1921:  MOVLW  04
1922:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1923:  MOVLB  02
1924:  CLRF   3F
1925:  CLRF   40
1926:  MOVLW  20
1927:  MOVWF  05
1928:  MOVLW  B7
1929:  MOVWF  04
192A:  MOVF   3F,W
192B:  ADDWF  04,F
192C:  MOVLW  00
192D:  ADDWFC 05,F
192E:  MOVF   40,W
192F:  MOVLP  00
1930:  MOVLB  00
1931:  CALL   151
1932:  MOVLP  18
1933:  MOVWF  00
1934:  IORLW  00
1935:  BTFSC  03.2
1936:  GOTO   13C
1937:  MOVLB  02
1938:  INCF   40,F
1939:  INCF   3F,F
193A:  GOTO   126
193B:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
193C:  MOVLW  20
193D:  MOVLB  02
193E:  MOVWF  40
193F:  MOVLW  B7
1940:  MOVWF  3F
1941:  MOVLW  20
1942:  MOVWF  42
1943:  MOVLW  A0
1944:  MOVWF  41
1945:  MOVLP  08
1946:  MOVLB  00
1947:  CALL   793
1948:  MOVLP  18
1949:  MOVF   78,F
194A:  BTFSS  03.2
194B:  GOTO   14E
....................       command=RESTORE_SETTINGS; 
194C:  MOVLW  05
194D:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
194E:  MOVLB  02
194F:  CLRF   3F
1950:  CLRF   40
1951:  MOVLW  20
1952:  MOVWF  05
1953:  MOVLW  B7
1954:  MOVWF  04
1955:  MOVF   3F,W
1956:  ADDWF  04,F
1957:  MOVLW  00
1958:  ADDWFC 05,F
1959:  MOVF   40,W
195A:  MOVLP  00
195B:  MOVLB  00
195C:  CALL   15A
195D:  MOVLP  18
195E:  MOVWF  00
195F:  IORLW  00
1960:  BTFSC  03.2
1961:  GOTO   167
1962:  MOVLB  02
1963:  INCF   40,F
1964:  INCF   3F,F
1965:  GOTO   151
1966:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1967:  MOVLW  20
1968:  MOVLB  02
1969:  MOVWF  40
196A:  MOVLW  B7
196B:  MOVWF  3F
196C:  MOVLW  20
196D:  MOVWF  42
196E:  MOVLW  A0
196F:  MOVWF  41
1970:  MOVLP  08
1971:  MOVLB  00
1972:  CALL   793
1973:  MOVLP  18
1974:  MOVF   78,F
1975:  BTFSS  03.2
1976:  GOTO   179
....................     command=STATUS; 
1977:  MOVLW  08
1978:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
1979:  MOVLB  02
197A:  CLRF   3F
197B:  CLRF   40
197C:  MOVLW  20
197D:  MOVWF  05
197E:  MOVLW  B7
197F:  MOVWF  04
1980:  MOVF   3F,W
1981:  ADDWF  04,F
1982:  MOVLW  00
1983:  ADDWFC 05,F
1984:  MOVF   40,W
1985:  MOVLP  00
1986:  MOVLB  00
1987:  CALL   162
1988:  MOVLP  18
1989:  MOVWF  00
198A:  IORLW  00
198B:  BTFSC  03.2
198C:  GOTO   192
198D:  MOVLB  02
198E:  INCF   40,F
198F:  INCF   3F,F
1990:  GOTO   17C
1991:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1992:  MOVLW  20
1993:  MOVLB  02
1994:  MOVWF  40
1995:  MOVLW  B7
1996:  MOVWF  3F
1997:  MOVLW  20
1998:  MOVWF  42
1999:  MOVLW  A0
199A:  MOVWF  41
199B:  MOVLP  08
199C:  MOVLB  00
199D:  CALL   793
199E:  MOVLP  18
199F:  MOVF   78,F
19A0:  BTFSS  03.2
19A1:  GOTO   1A6
....................     command=ADMIN; 
19A2:  MOVLW  09
19A3:  MOVWF  70
....................     argument=REBOOT; 
19A4:  MOVLW  02
19A5:  MOVWF  75
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19A6:  MOVLB  02
19A7:  CLRF   3F
19A8:  CLRF   40
19A9:  MOVLW  20
19AA:  MOVWF  05
19AB:  MOVLW  B7
19AC:  MOVWF  04
19AD:  MOVF   3F,W
19AE:  ADDWF  04,F
19AF:  MOVLW  00
19B0:  ADDWFC 05,F
19B1:  MOVF   40,W
19B2:  MOVLP  00
19B3:  MOVLB  00
19B4:  CALL   16A
19B5:  MOVLP  18
19B6:  MOVWF  00
19B7:  IORLW  00
19B8:  BTFSC  03.2
19B9:  GOTO   1BF
19BA:  MOVLB  02
19BB:  INCF   40,F
19BC:  INCF   3F,F
19BD:  GOTO   1A9
19BE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19BF:  MOVLW  20
19C0:  MOVLB  02
19C1:  MOVWF  40
19C2:  MOVLW  B7
19C3:  MOVWF  3F
19C4:  MOVLW  20
19C5:  MOVWF  42
19C6:  MOVLW  A0
19C7:  MOVWF  41
19C8:  MOVLP  08
19C9:  MOVLB  00
19CA:  CALL   793
19CB:  MOVLP  18
19CC:  MOVF   78,F
19CD:  BTFSS  03.2
19CE:  GOTO   220
....................     //command=DTMF_SEND; 
....................     command=0; 
19CF:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D0:  MOVLW  20
19D1:  MOVLB  02
19D2:  MOVWF  40
19D3:  MOVLW  70
19D4:  MOVWF  3F
19D5:  MOVLP  08
19D6:  MOVLB  00
19D7:  CALL   75A
19D8:  MOVLP  18
19D9:  MOVF   78,W
19DA:  MOVWF  76
....................     if ( value == d0 ) { 
19DB:  MOVF   76,W
19DC:  SUBLW  0A
19DD:  BTFSS  03.2
19DE:  GOTO   1E1
....................       value = dd; 
19DF:  CLRF   76
....................     } else if (value == dd) { 
19E0:  GOTO   1E6
19E1:  MOVF   76,F
19E2:  BTFSS  03.2
19E3:  GOTO   1E6
....................       value = d0; 
19E4:  MOVLW  0A
19E5:  MOVWF  76
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19E6:  MOVF   76,W
19E7:  ANDLW  0F
19E8:  MOVLB  02
19E9:  MOVWF  3F
19EA:  MOVF   3F,W
19EB:  MOVWF  40
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A20:  MOVLB  02
1A21:  CLRF   3F
1A22:  CLRF   40
1A23:  MOVLW  20
1A24:  MOVWF  05
1A25:  MOVLW  B7
1A26:  MOVWF  04
1A27:  MOVF   3F,W
1A28:  ADDWF  04,F
1A29:  MOVLW  00
1A2A:  ADDWFC 05,F
1A2B:  MOVF   40,W
1A2C:  MOVLP  00
1A2D:  MOVLB  00
1A2E:  CALL   16D
1A2F:  MOVLP  18
1A30:  MOVWF  00
1A31:  IORLW  00
1A32:  BTFSC  03.2
1A33:  GOTO   239
1A34:  MOVLB  02
1A35:  INCF   40,F
1A36:  INCF   3F,F
1A37:  GOTO   223
1A38:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A39:  MOVLW  20
1A3A:  MOVLB  02
1A3B:  MOVWF  40
1A3C:  MOVLW  B7
1A3D:  MOVWF  3F
1A3E:  MOVLW  20
1A3F:  MOVWF  42
1A40:  MOVLW  A0
1A41:  MOVWF  41
1A42:  MOVLP  08
1A43:  MOVLB  00
1A44:  CALL   793
1A45:  MOVLP  18
1A46:  MOVF   78,F
1A47:  BTFSS  03.2
1A48:  GOTO   24B
....................     command=I2C_SEND; 
1A49:  MOVLW  0C
1A4A:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A4B:  MOVLB  02
1A4C:  CLRF   3F
1A4D:  CLRF   40
1A4E:  MOVLW  20
1A4F:  MOVWF  05
1A50:  MOVLW  B7
1A51:  MOVWF  04
1A52:  MOVF   3F,W
1A53:  ADDWF  04,F
1A54:  MOVLW  00
1A55:  ADDWFC 05,F
1A56:  MOVF   40,W
1A57:  MOVLP  00
1A58:  MOVLB  00
1A59:  CALL   172
1A5A:  MOVLP  18
1A5B:  MOVWF  00
1A5C:  IORLW  00
1A5D:  BTFSC  03.2
1A5E:  GOTO   264
1A5F:  MOVLB  02
1A60:  INCF   40,F
1A61:  INCF   3F,F
1A62:  GOTO   24E
1A63:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A64:  MOVLW  20
1A65:  MOVLB  02
1A66:  MOVWF  40
1A67:  MOVLW  B7
1A68:  MOVWF  3F
1A69:  MOVLW  20
1A6A:  MOVWF  42
1A6B:  MOVLW  A0
1A6C:  MOVWF  41
1A6D:  MOVLP  08
1A6E:  MOVLB  00
1A6F:  CALL   793
1A70:  MOVLP  18
1A71:  MOVF   78,F
1A72:  BTFSS  03.2
1A73:  GOTO   28B
....................     value = str_to_decimal(argument_name); 
1A74:  MOVLW  20
1A75:  MOVLB  02
1A76:  MOVWF  40
1A77:  MOVLW  70
1A78:  MOVWF  3F
1A79:  MOVLP  08
1A7A:  MOVLB  00
1A7B:  CALL   75A
1A7C:  MOVLP  18
1A7D:  MOVF   78,W
1A7E:  MOVWF  76
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A7F:  MOVF   76,W
1A80:  SUBLW  24
1A81:  BTFSS  03.0
1A82:  GOTO   287
....................       argument = 0; 
1A83:  CLRF   75
....................       command  = MORSE_SEND; 
1A84:  MOVLW  0B
1A85:  MOVWF  70
....................     } else { 
1A86:  GOTO   28B
....................       command  = ADMIN; 
1A87:  MOVLW  09
1A88:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A89:  MOVLW  03
1A8A:  MOVWF  75
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A8B:  MOVLB  02
1A8C:  CLRF   3F
1A8D:  CLRF   40
1A8E:  MOVLW  20
1A8F:  MOVWF  05
1A90:  MOVLW  B7
1A91:  MOVWF  04
1A92:  MOVF   3F,W
1A93:  ADDWF  04,F
1A94:  MOVLW  00
1A95:  ADDWFC 05,F
1A96:  MOVF   40,W
1A97:  MOVLP  00
1A98:  MOVLB  00
1A99:  CALL   179
1A9A:  MOVLP  18
1A9B:  MOVWF  00
1A9C:  IORLW  00
1A9D:  BTFSC  03.2
1A9E:  GOTO   2A4
1A9F:  MOVLB  02
1AA0:  INCF   40,F
1AA1:  INCF   3F,F
1AA2:  GOTO   28E
1AA3:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AA4:  MOVLW  20
1AA5:  MOVLB  02
1AA6:  MOVWF  40
1AA7:  MOVLW  B7
1AA8:  MOVWF  3F
1AA9:  MOVLW  20
1AAA:  MOVWF  42
1AAB:  MOVLW  A0
1AAC:  MOVWF  41
1AAD:  MOVLP  08
1AAE:  MOVLB  00
1AAF:  CALL   793
1AB0:  MOVLP  18
1AB1:  MOVF   78,F
1AB2:  BTFSS  03.2
1AB3:  GOTO   2B6
....................     command=INCREMENT_REG; 
1AB4:  MOVLW  06
1AB5:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1AB6:  MOVLB  02
1AB7:  CLRF   3F
1AB8:  CLRF   40
1AB9:  MOVLW  20
1ABA:  MOVWF  05
1ABB:  MOVLW  B7
1ABC:  MOVWF  04
1ABD:  MOVF   3F,W
1ABE:  ADDWF  04,F
1ABF:  MOVLW  00
1AC0:  ADDWFC 05,F
1AC1:  MOVF   40,W
1AC2:  MOVLP  00
1AC3:  MOVLB  00
1AC4:  CALL   17C
1AC5:  MOVLP  18
1AC6:  MOVWF  00
1AC7:  IORLW  00
1AC8:  BTFSC  03.2
1AC9:  GOTO   2CF
1ACA:  MOVLB  02
1ACB:  INCF   40,F
1ACC:  INCF   3F,F
1ACD:  GOTO   2B9
1ACE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1ACF:  MOVLW  20
1AD0:  MOVLB  02
1AD1:  MOVWF  40
1AD2:  MOVLW  B7
1AD3:  MOVWF  3F
1AD4:  MOVLW  20
1AD5:  MOVWF  42
1AD6:  MOVLW  A0
1AD7:  MOVWF  41
1AD8:  MOVLP  08
1AD9:  MOVLB  00
1ADA:  CALL   793
1ADB:  MOVLP  18
1ADC:  MOVF   78,F
1ADD:  BTFSS  03.2
1ADE:  GOTO   2E1
....................     command=DECREMENT_REG; 
1ADF:  MOVLW  07
1AE0:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AE1:  MOVLB  02
1AE2:  CLRF   3F
1AE3:  CLRF   40
1AE4:  MOVLW  20
1AE5:  MOVWF  05
1AE6:  MOVLW  B7
1AE7:  MOVWF  04
1AE8:  MOVF   3F,W
1AE9:  ADDWF  04,F
1AEA:  MOVLW  00
1AEB:  ADDWFC 05,F
1AEC:  MOVF   40,W
1AED:  MOVLP  00
1AEE:  MOVLB  00
1AEF:  CALL   17F
1AF0:  MOVLP  18
1AF1:  MOVWF  00
1AF2:  IORLW  00
1AF3:  BTFSC  03.2
1AF4:  GOTO   2FA
1AF5:  MOVLB  02
1AF6:  INCF   40,F
1AF7:  INCF   3F,F
1AF8:  GOTO   2E4
1AF9:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AFA:  MOVLW  20
1AFB:  MOVLB  02
1AFC:  MOVWF  40
1AFD:  MOVLW  B7
1AFE:  MOVWF  3F
1AFF:  MOVLW  20
1B00:  MOVWF  42
1B01:  MOVLW  A0
1B02:  MOVWF  41
1B03:  MOVLP  08
1B04:  MOVLB  00
1B05:  CALL   793
1B06:  MOVLP  18
1B07:  MOVF   78,F
1B08:  BTFSS  03.2
1B09:  GOTO   329
....................     command=SET_REG; 
1B0A:  MOVLW  02
1B0B:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B0C:  MOVLW  01
1B0D:  ADDWF  74,W
1B0E:  ANDLW  03
1B0F:  MOVWF  76
....................     strcpy(argument_name,"CPOT"); 
1B10:  MOVLB  02
1B11:  CLRF   3F
1B12:  CLRF   40
1B13:  MOVLW  20
1B14:  MOVWF  05
1B15:  MOVLW  70
1B16:  MOVWF  04
1B17:  MOVF   3F,W
1B18:  ADDWF  04,F
1B19:  MOVLW  00
1B1A:  ADDWFC 05,F
1B1B:  MOVF   40,W
1B1C:  MOVLP  00
1B1D:  MOVLB  00
1B1E:  CALL   182
1B1F:  MOVLP  18
1B20:  MOVWF  00
1B21:  IORLW  00
1B22:  BTFSC  03.2
1B23:  GOTO   329
1B24:  MOVLB  02
1B25:  INCF   40,F
1B26:  INCF   3F,F
1B27:  GOTO   313
1B28:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B29:  MOVLB  02
1B2A:  CLRF   3F
1B2B:  CLRF   40
1B2C:  MOVLW  20
1B2D:  MOVWF  05
1B2E:  MOVLW  B7
1B2F:  MOVWF  04
1B30:  MOVF   3F,W
1B31:  ADDWF  04,F
1B32:  MOVLW  00
1B33:  ADDWFC 05,F
1B34:  MOVF   40,W
1B35:  MOVLP  00
1B36:  MOVLB  00
1B37:  CALL   188
1B38:  MOVLP  18
1B39:  MOVWF  00
1B3A:  IORLW  00
1B3B:  BTFSC  03.2
1B3C:  GOTO   342
1B3D:  MOVLB  02
1B3E:  INCF   40,F
1B3F:  INCF   3F,F
1B40:  GOTO   32C
1B41:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B42:  MOVLW  20
1B43:  MOVLB  02
1B44:  MOVWF  40
1B45:  MOVLW  B7
1B46:  MOVWF  3F
1B47:  MOVLW  20
1B48:  MOVWF  42
1B49:  MOVLW  A0
1B4A:  MOVWF  41
1B4B:  MOVLP  08
1B4C:  MOVLB  00
1B4D:  CALL   793
1B4E:  MOVLP  18
1B4F:  MOVF   78,F
1B50:  BTFSS  03.2
1B51:  GOTO   362
....................     AdminMode = ~AdminMode; 
1B52:  MOVLW  80
1B53:  MOVLB  01
1B54:  XORWF  5D,F
....................     set_admin_mode(AdminMode); 
1B55:  MOVLW  00
1B56:  BTFSC  5D.7
1B57:  MOVLW  01
1B58:  MOVLB  02
1B59:  MOVWF  3F
1B5A:  MOVWF  40
1B5B:  MOVLP  08
1B5C:  MOVLB  00
1B5D:  CALL   49F
1B5E:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B5F:  MOVLB  01
1B60:  BSF    5D.6
1B61:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
1160:  MOVF   76,W
1161:  SUBLW  FF
1162:  BTFSS  03.2
1163:  GOTO   18A
....................     printf ("\n\r%s %u",argument,value); 
1164:  MOVLW  0A
1165:  CLRWDT
1166:  BTFSS  11.4
1167:  GOTO   165
1168:  MOVLB  03
1169:  MOVWF  1A
116A:  MOVLW  0D
116B:  CLRWDT
116C:  MOVLB  00
116D:  BTFSC  11.4
116E:  GOTO   171
116F:  MOVLB  03
1170:  GOTO   16B
1171:  MOVLB  03
1172:  MOVWF  1A
1173:  CLRF   05
1174:  MOVF   75,W
1175:  MOVWF  04
1176:  MOVLP  08
1177:  MOVLB  00
1178:  CALL   23D
1179:  MOVLP  10
117A:  MOVLW  20
117B:  CLRWDT
117C:  BTFSS  11.4
117D:  GOTO   17B
117E:  MOVLB  03
117F:  MOVWF  1A
1180:  MOVF   76,W
1181:  MOVLB  02
1182:  MOVWF  50
1183:  MOVLW  1B
1184:  MOVWF  51
1185:  MOVLP  00
1186:  MOVLB  00
1187:  CALL   720
1188:  MOVLP  10
....................   } else { 
1189:  GOTO   224
....................     pObj=RegMap[argument].reg_ptr; 
118A:  RLF    75,W
118B:  MOVWF  77
118C:  RLF    77,F
118D:  MOVLW  FC
118E:  ANDWF  77,F
118F:  MOVF   77,W
1190:  MOVLB  02
1191:  MOVWF  2F
1192:  INCF   2F,W
1193:  MOVLP  00
1194:  MOVLB  00
1195:  CALL   043
1196:  MOVLP  10
1197:  MOVWF  7A
1198:  MOVLB  02
1199:  MOVF   2F,W
119A:  MOVLP  00
119B:  MOVLB  00
119C:  CALL   043
119D:  MOVLP  10
119E:  MOVLB  02
119F:  MOVWF  2C
11A0:  MOVF   7A,W
11A1:  MOVWF  2D
....................     // Consider allowing some registers to be updated outside AdminMode. 
....................     // Example : AuxOut registers, Enable 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
11A2:  MOVLB  00
11A3:  CALL   000
11A4:  MOVF   78,F
11A5:  BTFSS  03.2
11A6:  GOTO   1B4
11A7:  RLF    75,W
11A8:  MOVWF  77
11A9:  RLF    77,F
11AA:  MOVLW  FC
11AB:  ANDWF  77,F
11AC:  MOVF   77,W
11AD:  ADDLW  03
11AE:  MOVLP  00
11AF:  CALL   043
11B0:  MOVLP  10
11B1:  MOVWF  78
11B2:  BTFSC  78.1
11B3:  GOTO   1BC
....................       *pObj=value; 
11B4:  MOVLB  02
11B5:  MOVF   2C,W
11B6:  MOVWF  04
11B7:  MOVF   2D,W
11B8:  MOVWF  05
11B9:  MOVF   76,W
11BA:  MOVWF  00
11BB:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
11BC:  MOVLB  02
11BD:  MOVF   2C,W
11BE:  MOVWF  04
11BF:  MOVF   2D,W
11C0:  MOVWF  05
11C1:  MOVF   00,W
11C2:  MOVWF  2E
....................     LastRegisterIndex = argument; 
11C3:  MOVF   75,W
11C4:  MOVWF  7C
....................     LastRegisterIndexValid=1; 
11C5:  MOVLW  01
11C6:  MOVWF  7D
....................     printf ("\n\rSetting %s(%u) to %u",argument_name,argument,lVar); 
11C7:  MOVLW  82
11C8:  MOVLB  03
11C9:  MOVWF  11
11CA:  MOVLW  04
11CB:  MOVWF  12
11CC:  BCF    03.0
11CD:  MOVLW  0A
11CE:  MOVLB  02
11CF:  MOVWF  50
11D0:  MOVLP  00
11D1:  MOVLB  00
11D2:  CALL   6AC
11D3:  MOVLP  10
11D4:  MOVLW  20
11D5:  MOVWF  05
11D6:  MOVLW  70
11D7:  MOVWF  04
11D8:  MOVLP  08
11D9:  CALL   23D
11DA:  MOVLP  10
11DB:  MOVLW  28
11DC:  CLRWDT
11DD:  BTFSS  11.4
11DE:  GOTO   1DC
11DF:  MOVLB  03
11E0:  MOVWF  1A
11E1:  MOVF   75,W
11E2:  MOVLB  02
11E3:  MOVWF  50
11E4:  MOVLW  1B
11E5:  MOVWF  51
11E6:  MOVLP  00
11E7:  MOVLB  00
11E8:  CALL   720
11E9:  MOVLP  10
11EA:  MOVLW  89
11EB:  MOVLB  03
11EC:  MOVWF  11
11ED:  MOVLW  04
11EE:  MOVWF  12
11EF:  BSF    03.0
11F0:  MOVLW  05
11F1:  MOVLB  02
11F2:  MOVWF  50
11F3:  MOVLP  00
11F4:  MOVLB  00
11F5:  CALL   6AC
11F6:  MOVLP  10
11F7:  MOVLB  02
11F8:  MOVF   2E,W
11F9:  MOVWF  50
11FA:  MOVLW  1B
11FB:  MOVWF  51
11FC:  MOVLP  00
11FD:  MOVLB  00
11FE:  CALL   720
11FF:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
1200:  MOVLB  02
1201:  MOVF   2D,W
1202:  SUBLW  1F
1203:  BTFSC  03.0
1204:  GOTO   216
1205:  XORLW  FF
1206:  BTFSS  03.2
1207:  GOTO   20C
1208:  MOVF   2C,W
1209:  SUBLW  0B
120A:  BTFSC  03.0
120B:  GOTO   216
120C:  MOVF   2D,W
120D:  SUBLW  20
120E:  BTFSS  03.0
120F:  GOTO   216
1210:  BTFSS  03.2
1211:  GOTO   21D
1212:  MOVF   2C,W
1213:  SUBLW  1B
1214:  BTFSC  03.0
1215:  GOTO   21D
1216:  MOVF   2C,W
1217:  SUBLW  74
1218:  BTFSS  03.2
1219:  GOTO   221
121A:  MOVF   2D,F
121B:  BTFSS  03.2
121C:  GOTO   221
....................       increment(0); // Increment is done in this function. Only update trim pot. 
121D:  CLRF   2F
121E:  MOVLB  00
121F:  CALL   00F
1220:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
1221:  MOVLB  01
1222:  BSF    5D.6
1223:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
100F:  MOVF   74,W
1010:  ANDLW  03
1011:  MOVLB  02
1012:  MOVWF  33
....................   if ( CurrentCorIndex ) { 
1013:  MOVLB  00
1014:  MOVF   6D,F
1015:  BTFSC  03.2
1016:  GOTO   04E
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
1017:  MOVLW  01
1018:  SUBWF  6D,W
1019:  MOVWF  77
101A:  RLF    77,F
101B:  RLF    77,F
101C:  MOVLW  FC
101D:  ANDWF  77,F
101E:  MOVF   77,W
101F:  MOVLB  02
1020:  ADDWF  33,W
1021:  ADDLW  0C
1022:  MOVWF  78
1023:  MOVLW  20
1024:  MOVWF  7A
1025:  BTFSC  03.0
1026:  INCF   7A,F
1027:  MOVF   78,W
1028:  MOVWF  30
1029:  MOVF   7A,W
102A:  MOVWF  31
....................     value = *pot_ptr; 
102B:  MOVF   30,W
102C:  MOVWF  04
102D:  MOVF   31,W
102E:  MOVWF  05
102F:  MOVF   00,W
1030:  MOVWF  32
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
1031:  MOVF   30,W
1032:  MOVWF  04
1033:  MOVF   31,W
1034:  MOVWF  05
1035:  MOVF   2F,W
1036:  ADDWF  32,W
1037:  MOVWF  00
....................     if ( in_admin_mode() ) { 
1038:  MOVLB  00
1039:  CALL   000
103A:  MOVF   78,F
103B:  BTFSC  03.2
103C:  GOTO   04E
....................       set_trimpot(CPotPtr,*pot_ptr); 
103D:  MOVLB  02
103E:  MOVF   31,W
103F:  MOVWF  7A
1040:  MOVF   30,W
1041:  MOVWF  04
1042:  MOVF   31,W
1043:  MOVWF  05
1044:  MOVF   00,W
1045:  MOVWF  34
1046:  MOVF   33,W
1047:  MOVWF  3F
1048:  MOVF   34,W
1049:  MOVWF  40
104A:  MOVLP  00
104B:  MOVLB  00
104C:  CALL   76F
104D:  MOVLP  10
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
104E:  MOVLP  08
104F:  CALL   257
1050:  MOVLP  10
.................... } // }}} 
1051:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
0FD2:  MOVLB  02
0FD3:  CLRF   3F
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
0FD4:  MOVF   3F,W
0FD5:  SUBLW  05
0FD6:  BTFSS  03.0
0FD7:  GOTO   7F9
....................     dest[c]=src[c]; 
0FD8:  MOVF   3F,W
0FD9:  ADDWF  3B,W
0FDA:  MOVWF  78
0FDB:  MOVLW  00
0FDC:  ADDWFC 3C,W
0FDD:  MOVWF  7A
0FDE:  MOVF   78,W
0FDF:  MOVWF  40
0FE0:  MOVF   7A,W
0FE1:  MOVWF  41
0FE2:  MOVF   3F,W
0FE3:  ADDWF  3D,W
0FE4:  MOVWF  78
0FE5:  MOVLW  00
0FE6:  ADDWFC 3E,W
0FE7:  MOVWF  7A
0FE8:  MOVF   78,W
0FE9:  MOVLB  03
0FEA:  MOVWF  11
0FEB:  MOVF   7A,W
0FEC:  MOVWF  12
0FED:  MOVLB  02
0FEE:  MOVF   41,W
0FEF:  MOVWF  05
0FF0:  MOVF   40,W
0FF1:  MOVWF  04
0FF2:  MOVLW  01
0FF3:  MOVWF  45
0FF4:  MOVLB  00
0FF5:  CALL   000
....................   c++; 
0FF6:  MOVLB  02
0FF7:  INCF   3F,F
....................   } 
0FF8:  GOTO   7D4
.................... } // }}} 
0FF9:  MOVLB  00
0FFA:  RETURN
.................... void ExecAuxOutOp(int op,int arg,int ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
16BB:  MOVF   29,W
16BC:  ANDLW  0F
16BD:  MOVWF  2B
....................   uarg = (arg & 0xF0) >> 4; 
16BE:  MOVF   29,W
16BF:  ANDLW  F0
16C0:  MOVWF  77
16C1:  SWAPF  77,W
16C2:  MOVWF  2C
16C3:  MOVLW  0F
16C4:  ANDWF  2C,F
....................   switch(op) { 
16C5:  MOVF   28,W
16C6:  XORLW  01
16C7:  MOVLB  00
16C8:  BTFSC  03.2
16C9:  GOTO   6CE
16CA:  XORLW  03
16CB:  BTFSC  03.2
16CC:  GOTO   6E3
16CD:  GOTO   6FC
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       AuxOut[ID] = ((COR_IN_EFFECTIVE ^ uarg) & larg) != 0; 
16CE:  MOVLW  22
16CF:  MOVLB  02
16D0:  ADDWF  2A,W
16D1:  MOVWF  04
16D2:  MOVLW  20
16D3:  MOVWF  05
16D4:  BTFSC  03.0
16D5:  INCF   05,F
16D6:  MOVLB  00
16D7:  MOVF   6F,W
16D8:  MOVLB  02
16D9:  XORWF  2C,W
16DA:  ANDWF  2B,W
16DB:  BTFSS  03.2
16DC:  GOTO   6DF
16DD:  MOVLW  00
16DE:  GOTO   6E0
16DF:  MOVLW  01
16E0:  MOVWF  00
....................     break; 
16E1:  MOVLB  00
16E2:  GOTO   6FC
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
16E3:  MOVLW  22
16E4:  MOVLB  02
16E5:  ADDWF  2A,W
16E6:  MOVWF  04
16E7:  MOVLW  20
16E8:  MOVWF  05
16E9:  BTFSC  03.0
16EA:  INCF   05,F
16EB:  MOVF   2B,W
16EC:  ANDLW  1F
16ED:  MOVWF  2F
16EE:  MOVF   7A,W
16EF:  MOVWF  30
16F0:  MOVF   2C,W
16F1:  XORWF  2F,F
16F2:  BTFSS  03.2
16F3:  GOTO   6F9
16F4:  MOVF   30,F
16F5:  BTFSS  03.2
16F6:  GOTO   6F9
16F7:  MOVLW  00
16F8:  GOTO   6FA
16F9:  MOVLW  01
16FA:  MOVWF  00
....................     break; 
16FB:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0F5A:  MOVLB  02
0F5B:  CLRF   41
0F5C:  CLRF   42
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0F5D:  MOVF   41,W
0F5E:  ADDWF  3F,W
0F5F:  MOVWF  04
0F60:  MOVLW  00
0F61:  ADDWFC 40,W
0F62:  MOVWF  05
0F63:  MOVF   00,F
0F64:  BTFSC  03.2
0F65:  GOTO   78F
0F66:  MOVF   41,W
0F67:  ADDWF  3F,W
0F68:  MOVWF  04
0F69:  MOVLW  00
0F6A:  ADDWFC 40,W
0F6B:  MOVWF  05
0F6C:  MOVF   00,W
0F6D:  SUBLW  2F
0F6E:  BTFSC  03.0
0F6F:  GOTO   78F
0F70:  MOVF   41,W
0F71:  ADDWF  3F,W
0F72:  MOVWF  04
0F73:  MOVLW  00
0F74:  ADDWFC 40,W
0F75:  MOVWF  05
0F76:  MOVF   00,W
0F77:  SUBLW  39
0F78:  BTFSS  03.0
0F79:  GOTO   78F
....................     value = (value * 10) + (str[x]-'0'); 
0F7A:  MOVF   42,W
0F7B:  MOVWF  43
0F7C:  MOVLW  0A
0F7D:  MOVWF  44
0F7E:  MOVLB  00
0F7F:  CALL   733
0F80:  MOVF   78,W
0F81:  MOVLB  02
0F82:  MOVWF  43
0F83:  MOVF   41,W
0F84:  ADDWF  3F,W
0F85:  MOVWF  04
0F86:  MOVLW  00
0F87:  ADDWFC 40,W
0F88:  MOVWF  05
0F89:  MOVLW  30
0F8A:  SUBWF  00,W
0F8B:  ADDWF  43,W
0F8C:  MOVWF  42
....................     x++; 
0F8D:  INCF   41,F
....................   } 
0F8E:  GOTO   75D
....................   return(value); 
0F8F:  MOVF   42,W
0F90:  MOVWF  78
.................... } // }}} 
0F91:  MOVLB  00
0F92:  RETURN
.................... void ExecAuxInOp(int op,int arg,int ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
15DB:  MOVLB  02
15DC:  BCF    2B.0
15DD:  MOVLW  1F
15DE:  ADDWF  2A,W
15DF:  MOVWF  04
15E0:  MOVLW  20
15E1:  MOVWF  05
15E2:  BTFSC  03.0
15E3:  INCF   05,F
15E4:  MOVF   00,F
15E5:  BTFSS  03.2
15E6:  BSF    2B.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   // Include arg[4] for COR4 emulation 
....................   larg = arg & 0x1F; 
15E7:  MOVF   29,W
15E8:  ANDLW  1F
15E9:  MOVWF  2C
....................   uarg = (arg & 0xF0) >> 4; 
15EA:  MOVF   29,W
15EB:  ANDLW  F0
15EC:  MOVWF  77
15ED:  SWAPF  77,W
15EE:  MOVWF  2D
15EF:  MOVLW  0F
15F0:  ANDWF  2D,F
....................   switch(op) { 
15F1:  MOVLW  01
15F2:  SUBWF  28,W
15F3:  ADDLW  FC
15F4:  BTFSC  03.0
15F5:  GOTO   63C
15F6:  ADDLW  04
15F7:  MOVLB  00
15F8:  GOTO   63F
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
15F9:  MOVLB  02
15FA:  BTFSS  2B.0
15FB:  GOTO   601
....................         Enable_Mask &= arg; 
15FC:  MOVF   29,W
15FD:  MOVLB  00
15FE:  ANDWF  61,F
....................       } else { // AuxIn is not enabled 
15FF:  GOTO   606
1600:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
1601:  MOVF   29,W
1602:  XORLW  FF
1603:  ANDLW  0F
1604:  MOVLB  00
1605:  IORWF  61,F
....................       } 
....................       break; 
1606:  MOVLB  02
1607:  GOTO   63C
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
1608:  MOVLB  02
1609:  BTFSS  2B.0
160A:  GOTO   611
....................         COR_DROP_FLAG=1; 
160B:  BSF    72.7
....................         TailChar=arg; 
160C:  MOVF   29,W
160D:  MOVLB  00
160E:  MOVWF  6A
....................       } else { 
160F:  GOTO   613
1610:  MOVLB  02
....................         TailChar=0; 
1611:  MOVLB  00
1612:  CLRF   6A
....................       } 
....................     break; 
1613:  MOVLB  02
1614:  GOTO   63C
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
1615:  MOVLB  02
1616:  BTFSC  2B.0
1617:  GOTO   61E
....................         COR_DROP_FLAG=1; 
1618:  BSF    72.7
....................         TailChar=arg; 
1619:  MOVF   29,W
161A:  MOVLB  00
161B:  MOVWF  6A
....................       } else { 
161C:  GOTO   620
161D:  MOVLB  02
....................         TailChar=0; 
161E:  MOVLB  00
161F:  CLRF   6A
....................       } 
....................     break; 
1620:  MOVLB  02
1621:  GOTO   63C
....................     case AUXI_EMULATE_COR: 
....................       if ( (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0 ) { 
1622:  MOVLB  02
1623:  MOVF   29,W
1624:  ANDLW  20
1625:  BTFSC  03.2
1626:  GOTO   62B
....................         tmp_bit = ~in_bit; 
1627:  BCF    2B.1
1628:  BTFSS  2B.0
1629:  BSF    2B.1
....................       } else { 
162A:  GOTO   62E
....................         tmp_bit = in_bit; 
162B:  BCF    2B.1
162C:  BTFSC  2B.0
162D:  BSF    2B.1
....................       } 
....................       if ( tmp_bit ) { 
162E:  BTFSS  2B.1
162F:  GOTO   635
....................         COR_EMUL |= larg; 
1630:  MOVF   2C,W
1631:  MOVLB  00
1632:  IORWF  69,F
....................       } else { 
1633:  GOTO   639
1634:  MOVLB  02
....................         COR_EMUL &= ~larg; 
1635:  MOVF   2C,W
1636:  XORLW  FF
1637:  MOVLB  00
1638:  ANDWF  69,F
....................       } 
....................     break; 
1639:  MOVLB  02
163A:  GOTO   63C
163B:  MOVLB  02
....................   } 
.................... } // }}} 
163C:  MOVLP  10
163D:  MOVLB  00
163E:  GOTO   76D (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
1591:  MOVLB  01
1592:  CLRF   65
1593:  MOVF   65,W
1594:  SUBLW  02
1595:  BTFSS  03.0
1596:  GOTO   5D8
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = (input(AUX_IN_PIN[x])!=0) || (AuxIn[x]!=0); 
1597:  MOVLW  1F
1598:  ADDWF  65,W
1599:  MOVWF  78
159A:  MOVLW  20
159B:  MOVWF  7A
159C:  BTFSC  03.0
159D:  INCF   7A,F
159E:  MOVF   78,W
159F:  MOVWF  66
15A0:  MOVF   7A,W
15A1:  MOVWF  67
15A2:  MOVF   65,W
15A3:  MOVLP  00
15A4:  MOVLB  00
15A5:  CALL   03F
15A6:  MOVLP  10
15A7:  MOVLB  01
15A8:  MOVWF  68
15A9:  MOVLB  02
15AA:  MOVWF  40
15AB:  MOVLW  01
15AC:  MOVWF  41
15AD:  CLRF   43
15AE:  MOVLW  80
15AF:  MOVWF  42
15B0:  MOVLP  08
15B1:  MOVLB  00
15B2:  CALL   0DA
15B3:  MOVLP  10
15B4:  MOVLB  01
15B5:  MOVF   68,W
15B6:  MOVWF  69
15B7:  CLRF   6B
15B8:  CLRF   6A
15B9:  MOVLB  00
15BA:  GOTO   577
15BB:  BTFSC  78.0
15BC:  GOTO   5CD
15BD:  MOVLW  1C
15BE:  MOVLB  01
15BF:  ADDWF  65,W
15C0:  MOVWF  04
15C1:  MOVLW  20
15C2:  MOVWF  05
15C3:  BTFSC  03.0
15C4:  INCF   05,F
15C5:  MOVF   00,F
15C6:  BTFSC  03.2
15C7:  GOTO   5CA
15C8:  MOVLB  00
15C9:  GOTO   5CD
15CA:  MOVLW  00
15CB:  GOTO   5CF
15CC:  MOVLB  00
15CD:  MOVLW  01
15CE:  MOVLB  01
15CF:  MOVWF  69
15D0:  MOVF   67,W
15D1:  MOVWF  05
15D2:  MOVF   66,W
15D3:  MOVWF  04
15D4:  MOVF   69,W
15D5:  MOVWF  00
....................   } 
15D6:  INCF   65,F
15D7:  GOTO   593
.................... } // }}} 
15D8:  MOVLP  18
15D9:  MOVLB  00
15DA:  GOTO   771 (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
1680:  MOVLW  30
1681:  MOVLB  01
1682:  MOVWF  68
1683:  MOVWF  69
1684:  MOVWF  6A
1685:  CLRF   6B
....................   char AuxOut_s[4]={'0','0','0',0}; 
1686:  MOVWF  6C
1687:  MOVWF  6D
1688:  MOVWF  6E
1689:  CLRF   6F
....................   char ADM[]=" ADMIN"; 
168A:  MOVLW  20
168B:  MOVLB  02
168C:  MOVWF  20
168D:  MOVLW  41
168E:  MOVWF  21
168F:  MOVLW  44
1690:  MOVWF  22
1691:  MOVLW  4D
1692:  MOVWF  23
1693:  MOVLW  49
1694:  MOVWF  24
1695:  MOVLW  4E
1696:  MOVWF  25
1697:  CLRF   26
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
1698:  MOVLB  01
1699:  CLRF   65
169A:  MOVF   65,W
169B:  SUBLW  02
169C:  BTFSS  03.0
169D:  GOTO   770
....................     AuxOp = AuxOutOp[x]; 
169E:  MOVLW  33
169F:  ADDWF  65,W
16A0:  MOVWF  04
16A1:  MOVLW  20
16A2:  MOVWF  05
16A3:  BTFSC  03.0
16A4:  INCF   05,F
16A5:  MOVF   00,W
16A6:  MOVWF  66
....................     AuxArg = AuxOutArg[x]; 
16A7:  MOVLW  36
16A8:  ADDWF  65,W
16A9:  MOVWF  04
16AA:  MOVLW  20
16AB:  MOVWF  05
16AC:  BTFSC  03.0
16AD:  INCF   05,F
16AE:  MOVF   00,W
16AF:  MOVWF  67
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
16B0:  MOVF   66,W
16B1:  MOVLB  02
16B2:  MOVWF  28
16B3:  MOVLB  01
16B4:  MOVF   67,W
16B5:  MOVLB  02
16B6:  MOVWF  29
16B7:  MOVLB  01
16B8:  MOVF   65,W
16B9:  MOVLB  02
16BA:  MOVWF  2A
....................     out_bit = (AuxOut[x])==0; 
*
16FC:  MOVLB  02
16FD:  BCF    27.0
16FE:  MOVLW  22
16FF:  MOVLB  01
1700:  ADDWF  65,W
1701:  MOVWF  04
1702:  MOVLW  20
1703:  MOVWF  05
1704:  BTFSC  03.0
1705:  INCF   05,F
1706:  MOVF   00,F
1707:  BTFSS  03.2
1708:  GOTO   70C
1709:  MOVLB  02
170A:  BSF    27.0
170B:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
170C:  MOVF   65,W
170D:  MOVLP  00
170E:  MOVLB  00
170F:  CALL   03B
1710:  MOVLP  10
1711:  MOVLB  02
1712:  MOVWF  28
1713:  MOVLW  00
1714:  BTFSC  27.0
1715:  MOVLW  01
1716:  MOVWF  77
1717:  MOVF   28,W
1718:  MOVWF  40
1719:  MOVF   77,W
171A:  MOVWF  41
171B:  MOVLW  01
171C:  MOVWF  43
171D:  CLRF   42
171E:  MOVLP  08
171F:  MOVLB  00
1720:  CALL   0DA
1721:  MOVLP  10
1722:  MOVLB  02
1723:  MOVF   28,W
1724:  MOVWF  40
1725:  CLRF   41
1726:  CLRF   43
1727:  MOVLW  80
1728:  MOVWF  42
1729:  MOVLP  08
172A:  MOVLB  00
172B:  CALL   0DA
172C:  MOVLP  10
....................     if(out_bit==0) { 
172D:  MOVLB  02
172E:  BTFSC  27.0
172F:  GOTO   73B
....................       AuxOut_s[x]='1'; 
1730:  MOVLW  9C
1731:  MOVLB  01
1732:  ADDWF  65,W
1733:  MOVWF  04
1734:  MOVLW  20
1735:  MOVWF  05
1736:  BTFSC  03.0
1737:  INCF   05,F
1738:  MOVLW  31
1739:  MOVWF  00
173A:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
173B:  MOVLW  39
173C:  MOVLB  01
173D:  ADDWF  65,W
173E:  MOVWF  04
173F:  MOVLW  20
1740:  MOVWF  05
1741:  BTFSC  03.0
1742:  INCF   05,F
1743:  MOVF   00,W
1744:  MOVWF  66
....................     AuxArg = AuxInArg[x]; 
1745:  MOVLW  3C
1746:  ADDWF  65,W
1747:  MOVWF  04
1748:  MOVLW  20
1749:  MOVWF  05
174A:  BTFSC  03.0
174B:  INCF   05,F
174C:  MOVF   00,W
174D:  MOVWF  67
....................     if(AuxInSW[x]==1) { 
174E:  MOVLW  1F
174F:  ADDWF  65,W
1750:  MOVWF  04
1751:  MOVLW  20
1752:  MOVWF  05
1753:  BTFSC  03.0
1754:  INCF   05,F
1755:  DECFSZ 00,W
1756:  GOTO   760
....................       AuxIn_s[x]='1'; 
1757:  MOVLW  98
1758:  ADDWF  65,W
1759:  MOVWF  04
175A:  MOVLW  20
175B:  MOVWF  05
175C:  BTFSC  03.0
175D:  INCF   05,F
175E:  MOVLW  31
175F:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
1760:  MOVF   66,W
1761:  MOVLB  02
1762:  MOVWF  28
1763:  MOVLB  01
1764:  MOVF   67,W
1765:  MOVLB  02
1766:  MOVWF  29
1767:  MOVLB  01
1768:  MOVF   65,W
1769:  MOVLB  02
176A:  MOVWF  2A
176B:  MOVLB  00
176C:  GOTO   5DB
....................     // }}} 
....................   } 
176D:  MOVLB  01
176E:  INCF   65,F
176F:  GOTO   69A
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
1770:  MOVLW  20
1771:  MOVWF  64
1772:  MOVLW  76
1773:  MOVWF  63
1774:  MOVLW  49
1775:  MOVLB  02
1776:  MOVWF  50
1777:  MOVLP  08
1778:  MOVLB  00
1779:  CALL   0FC
177A:  MOVLP  10
177B:  MOVLW  3A
177C:  MOVLB  02
177D:  MOVWF  50
177E:  MOVLP  08
177F:  MOVLB  00
1780:  CALL   0FC
1781:  MOVLP  10
1782:  MOVLW  20
1783:  MOVWF  05
1784:  MOVLW  98
1785:  MOVWF  04
1786:  MOVLP  08
1787:  CALL   15E
1788:  MOVLP  10
1789:  MOVLW  20
178A:  MOVLB  02
178B:  MOVWF  50
178C:  MOVLP  08
178D:  MOVLB  00
178E:  CALL   0FC
178F:  MOVLP  10
1790:  MOVLW  4F
1791:  MOVLB  02
1792:  MOVWF  50
1793:  MOVLP  08
1794:  MOVLB  00
1795:  CALL   0FC
1796:  MOVLP  10
1797:  MOVLW  3A
1798:  MOVLB  02
1799:  MOVWF  50
179A:  MOVLP  08
179B:  MOVLB  00
179C:  CALL   0FC
179D:  MOVLP  10
179E:  MOVLW  20
179F:  MOVWF  05
17A0:  MOVLW  9C
17A1:  MOVWF  04
17A2:  MOVLP  08
17A3:  CALL   15E
17A4:  MOVLP  10
....................   if ( AdminMode ) { 
17A5:  MOVLB  01
17A6:  BTFSS  5D.7
17A7:  GOTO   7B4
....................     strcat(LCD_str,ADM); 
17A8:  MOVLW  20
17A9:  MOVLB  02
17AA:  MOVWF  29
17AB:  MOVLW  76
17AC:  MOVWF  28
17AD:  MOVLW  20
17AE:  MOVWF  2B
17AF:  MOVLW  A0
17B0:  MOVWF  2A
17B1:  MOVLB  00
17B2:  CALL   647
17B3:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
17B4:  MOVLW  03
17B5:  MOVLB  02
17B6:  MOVWF  4A
17B7:  MOVLW  20
17B8:  MOVWF  4C
17B9:  MOVLW  76
17BA:  MOVWF  4B
17BB:  MOVLP  08
17BC:  MOVLB  00
17BD:  CALL   173
17BE:  MOVLP  10
.................... } // }}} 
17BF:  RETURN
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
10B3:  MOVLW  01
10B4:  MOVLB  02
10B5:  MOVWF  2E
10B6:  MOVLP  08
10B7:  MOVLB  00
10B8:  CALL   34B
10B9:  MOVLP  10
....................   delay_ms(1000); 
10BA:  MOVLW  04
10BB:  MOVLB  02
10BC:  MOVWF  2E
10BD:  MOVLW  FA
10BE:  MOVWF  4A
10BF:  MOVLP  00
10C0:  MOVLB  00
10C1:  CALL   7DA
10C2:  MOVLP  10
10C3:  MOVLB  02
10C4:  DECFSZ 2E,F
10C5:  GOTO   0BD
....................   for(x=0;x<6;x++) { 
10C6:  CLRF   2C
10C7:  MOVF   2C,W
10C8:  SUBLW  05
10C9:  BTFSS  03.0
10CA:  GOTO   0E7
....................     mchar=Morse[x]; 
10CB:  MOVLW  2D
10CC:  ADDWF  2C,W
10CD:  MOVWF  04
10CE:  MOVLW  20
10CF:  MOVWF  05
10D0:  BTFSC  03.0
10D1:  INCF   05,F
10D2:  MOVF   00,W
10D3:  MOVWF  2D
....................     morse(mchar); 
10D4:  MOVF   2D,W
10D5:  MOVWF  3F
10D6:  MOVLP  08
10D7:  MOVLB  00
10D8:  CALL   083
10D9:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
10DA:  MOVLB  01
10DB:  CLRF   33
10DC:  MOVLW  06
10DD:  MOVWF  32
....................     while(aux_timer) { 
10DE:  MOVF   32,W
10DF:  IORWF  33,W
10E0:  BTFSC  03.2
10E1:  GOTO   0E4
....................       delay_cycles(1); 
10E2:  NOP
....................     } 
10E3:  GOTO   0DE
....................   } 
10E4:  MOVLB  02
10E5:  INCF   2C,F
10E6:  GOTO   0C7
....................   delay_ms(1000); 
10E7:  MOVLW  04
10E8:  MOVWF  2E
10E9:  MOVLW  FA
10EA:  MOVWF  4A
10EB:  MOVLP  00
10EC:  MOVLB  00
10ED:  CALL   7DA
10EE:  MOVLP  10
10EF:  MOVLB  02
10F0:  DECFSZ 2E,F
10F1:  GOTO   0E9
....................   COR_FLAG=1; 
10F2:  BSF    72.3
.................... } // }}} 
10F3:  MOVLB  00
10F4:  RETURN
.................... void main (void) { // {{{ 
*
1F2B:  CLRF   05
1F2C:  CLRF   04
1F2D:  MOVLW  1F
1F2E:  ANDWF  03,F
1F2F:  MOVLW  72
1F30:  MOVLB  01
1F31:  MOVWF  19
1F32:  BSF    0E.3
1F33:  BSF    0E.4
1F34:  MOVLB  04
1F35:  BCF    17.0
1F36:  BCF    17.1
1F37:  BCF    17.3
1F38:  MOVLW  13
1F39:  MOVWF  12
1F3A:  MOVLW  28
1F3B:  MOVWF  15
1F3C:  BSF    14.7
1F3D:  BCF    14.6
1F3E:  MOVLW  0C
1F3F:  MOVLB  03
1F40:  MOVWF  1B
1F41:  MOVLW  A2
1F42:  MOVWF  1E
1F43:  MOVLW  90
1F44:  MOVWF  1D
1F45:  MOVLB  01
1F46:  BSF    62.1
1F47:  CLRF   64
1F48:  CLRF   63
1F49:  MOVLB  0F
1F4A:  CLRF   11
1F4B:  CLRF   12
1F4C:  CLRF   18
1F4D:  CLRF   19
1F4E:  CLRF   1A
1F4F:  MOVLB  03
1F50:  CLRF   0C
1F51:  CLRF   0D
1F52:  CLRF   0F
1F53:  CLRF   10
1F54:  MOVLB  02
1F55:  CLRF   12
1F56:  CLRF   11
1F57:  CLRF   14
1F58:  CLRF   13
....................   initialize(); 
*
1F5C:  MOVLP  08
1F5D:  GOTO   4B6
1F5E:  MOVLP  18
.................... #ignore_warnings 203 
....................   while(1) { // {{{ 
.................... #ignore_warnings none 
....................     restart_wdt(); 
1F5F:  CLRWDT
....................   process_buttons(); 
1F60:  MOVLP  08
1F61:  GOTO   58C
1F62:  MOVLP  18
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "\r" or "+" or "-" is received. 
....................     if ( sBufferFlag ) { 
1F63:  BTFSS  72.0
1F64:  GOTO   76A
....................       process_sBuffer(); 
1F65:  GOTO   000
....................       clear_sBuffer(); 
1F66:  MOVLP  00
1F67:  CALL   4A1
1F68:  MOVLP  18
....................       sBufferFlag=0; 
1F69:  BCF    72.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1F6A:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1F6B:  MOVLB  01
1F6C:  BTFSS  5D.0
1F6D:  GOTO   774
....................       update_aux_in(); 
1F6E:  MOVLP  10
1F6F:  MOVLB  00
1F70:  GOTO   591
1F71:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1F72:  MOVLB  01
1F73:  BCF    5D.0
....................     } 
....................     do_delay_counters(); 
1F74:  MOVLB  00
1F75:  GOTO   430
....................     restart_wdt(); 
1F76:  CLRWDT
....................     if ( COR_FLAG ) { 
1F77:  BTFSS  72.3
1F78:  GOTO   77F
....................       process_cor(); 
1F79:  GOTO   4B0
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       update_aux_out();  
1F7A:  MOVLP  10
1F7B:  CALL   680
1F7C:  MOVLP  18
....................       COR_FLAG=0; 
1F7D:  BCF    72.3
....................       restart_wdt(); 
1F7E:  CLRWDT
....................     } 
....................     if ( DTMF_INTERRUPT_FLAG ) { 
1F7F:  MOVLB  01
1F80:  BTFSS  5D.4
1F81:  GOTO   786
....................       // Extract data from DTMF device 
....................       process_dtmf_interrupt(); 
1F82:  MOVLB  00
1F83:  GOTO   53E
....................       DTMF_INTERRUPT_FLAG=0; 
1F84:  MOVLB  01
1F85:  BCF    5D.4
....................     } 
....................     if ( DTMF_IN_FLAG ) { 
1F86:  BTFSS  5D.3
1F87:  GOTO   78D
....................       print_dtmf_info(); 
1F88:  MOVLB  00
1F89:  GOTO   590
....................       DTMF_IN_FLAG=0; 
1F8A:  MOVLB  01
1F8B:  BCF    5D.3
....................       restart_wdt(); 
1F8C:  CLRWDT
....................     } 
....................     if ( DTMF_FLAG ) { 
1F8D:  BTFSS  5D.2
1F8E:  GOTO   794
....................       process_dtmf(); 
1F8F:  MOVLB  00
1F90:  GOTO   621
....................       DTMF_FLAG=0; 
1F91:  MOVLB  01
1F92:  BCF    5D.2
....................     restart_wdt(); 
1F93:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1F94:  BTFSS  5D.5
1F95:  GOTO   79A
....................       clear_dtmf_array(); 
1F96:  MOVLB  00
1F97:  GOTO   714
....................       CLEAR_DTMF_FLAG=0; 
1F98:  MOVLB  01
1F99:  BCF    5D.5
....................     } 
....................     if ( PROMPT_FLAG ) { 
1F9A:  BTFSS  5D.6
1F9B:  GOTO   7A3
....................       prompt(); 
1F9C:  MOVLP  10
1F9D:  MOVLB  00
1F9E:  CALL   09B
1F9F:  MOVLP  18
....................       PROMPT_FLAG=0; 
1FA0:  MOVLB  01
1FA1:  BCF    5D.6
....................     restart_wdt(); 
1FA2:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1FA3:  MOVLB  00
1FA4:  GOTO   75F
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0B7A:  CLRWDT
*
1FA5:  SLEEP
....................   delay_ms(1000); 
*
0B7B:  MOVLW  04
0B7C:  MOVLB  02
0B7D:  MOVWF  3F
0B7E:  MOVLW  FA
0B7F:  MOVWF  4A
0B80:  MOVLP  00
0B81:  MOVLB  00
0B82:  CALL   7DA
0B83:  MOVLP  08
0B84:  MOVLB  02
0B85:  DECFSZ 3F,F
0B86:  GOTO   37E
....................   if ( ConfirmChar!=0 ) { 
0B87:  MOVLB  00
0B88:  MOVF   6B,F
0B89:  BTFSC  03.2
0B8A:  GOTO   39F
....................     morse(ConfirmChar); 
0B8B:  MOVF   6B,W
0B8C:  MOVLB  02
0B8D:  MOVWF  3F
0B8E:  MOVLB  00
0B8F:  CALL   083
....................     ConfirmChar=0; 
0B90:  CLRF   6B
....................     restart_wdt(); 
0B91:  CLRWDT
....................     delay_ms(500); 
0B92:  MOVLW  02
0B93:  MOVLB  02
0B94:  MOVWF  3F
0B95:  MOVLW  FA
0B96:  MOVWF  4A
0B97:  MOVLP  00
0B98:  MOVLB  00
0B99:  CALL   7DA
0B9A:  MOVLP  08
0B9B:  MOVLB  02
0B9C:  DECFSZ 3F,F
0B9D:  GOTO   395
0B9E:  MOVLB  00
....................   } 
....................   if (TailChar != 0) { 
0B9F:  MOVF   6A,F
0BA0:  BTFSC  03.2
0BA1:  GOTO   3B6
....................     morse(TailChar); 
0BA2:  MOVF   6A,W
0BA3:  MOVLB  02
0BA4:  MOVWF  3F
0BA5:  MOVLB  00
0BA6:  CALL   083
....................     TailChar=0; 
0BA7:  CLRF   6A
....................     restart_wdt(); 
0BA8:  CLRWDT
....................     delay_ms(500); 
0BA9:  MOVLW  02
0BAA:  MOVLB  02
0BAB:  MOVWF  3F
0BAC:  MOVLW  FA
0BAD:  MOVWF  4A
0BAE:  MOVLP  00
0BAF:  MOVLB  00
0BB0:  CALL   7DA
0BB1:  MOVLP  08
0BB2:  MOVLB  02
0BB3:  DECFSZ 3F,F
0BB4:  GOTO   3AC
0BB5:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0BB6:  CLRWDT
0BB7:  MOVLB  02
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
1000:  MOVLB  01
1001:  BTFSS  5D.7
1002:  GOTO   005
....................     admin_timer = ADMIN_TIMEOUT; 
1003:  MOVLW  FF
1004:  MOVWF  73
....................   } 
....................   return(AdminMode||rs232_mode); 
1005:  BTFSC  5D.7
1006:  GOTO   00B
1007:  BTFSC  62.0
1008:  GOTO   00B
1009:  MOVLW  00
100A:  GOTO   00C
100B:  MOVLW  01
100C:  MOVWF  78
.................... } // }}} 
100D:  MOVLB  00
100E:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0C9F:  MOVLB  01
0CA0:  BCF    5D.7
0CA1:  MOVLB  02
0CA2:  MOVF   40,F
0CA3:  BTFSC  03.2
0CA4:  GOTO   4A8
0CA5:  MOVLB  01
0CA6:  BSF    5D.7
0CA7:  MOVLB  02
....................   if (AdminMode) { 
0CA8:  MOVLB  01
0CA9:  BTFSS  5D.7
0CAA:  GOTO   4B2
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0CAB:  MOVLW  0A
0CAC:  MOVLB  00
0CAD:  MOVWF  6B
....................     admin_timer = ADMIN_TIMEOUT; 
0CAE:  MOVLW  FF
0CAF:  MOVWF  73
....................   } else { 
0CB0:  GOTO   4B5
0CB1:  MOVLB  01
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0CB2:  MOVLW  18
0CB3:  MOVLB  00
0CB4:  MOVWF  6B
....................   }  
.................... } // }}} 
0CB5:  RETURN
.................... // string matchnig function with case insensitive match. 
.................... int1 my_stricmp(char *s1,char *s2) { // {{{ 
*
0F93:  MOVLB  02
0F94:  CLRF   43
....................   unsigned int x=0; 
....................   const char AMASK=0xDF; 
....................   while((AMASK&s1[x])==(AMASK&s2[x])) { 
0F95:  MOVF   43,W
0F96:  ADDWF  3F,W
0F97:  MOVWF  04
0F98:  MOVLW  00
0F99:  ADDWFC 40,W
0F9A:  MOVWF  05
0F9B:  MOVF   00,W
0F9C:  ANDLW  DF
0F9D:  MOVWF  44
0F9E:  MOVF   43,W
0F9F:  ADDWF  41,W
0FA0:  MOVWF  04
0FA1:  MOVLW  00
0FA2:  ADDWFC 42,W
0FA3:  MOVWF  05
0FA4:  MOVF   00,W
0FA5:  ANDLW  DF
0FA6:  SUBWF  44,W
0FA7:  BTFSS  03.2
0FA8:  GOTO   7B7
....................     if(s1[x]==0) { 
0FA9:  MOVF   43,W
0FAA:  ADDWF  3F,W
0FAB:  MOVWF  04
0FAC:  MOVLW  00
0FAD:  ADDWFC 40,W
0FAE:  MOVWF  05
0FAF:  MOVF   00,F
0FB0:  BTFSS  03.2
0FB1:  GOTO   7B5
....................       return 0; 
0FB2:  MOVLW  00
0FB3:  MOVWF  78
0FB4:  GOTO   7B9
....................     } 
....................     x++; 
0FB5:  INCF   43,F
....................   } 
0FB6:  GOTO   795
....................   // Strings don't match. Return 1. 
....................   return 1; 
0FB7:  MOVLW  01
0FB8:  MOVWF  78
.................... } // }}} 
0FB9:  MOVLB  00
0FBA:  RETURN
.................... // Fetches data from MC8888 device upon interrupt 
.................... void process_dtmf_interrupt(void) { // {{{ 
....................   int value,dtmf_status; 
....................   dtmf_status = dtmf_read(CONTROL_REG); 
*
1D3E:  MOVLW  01
1D3F:  MOVLB  02
1D40:  MOVWF  3B
1D41:  MOVLP  00
1D42:  MOVLB  00
1D43:  CALL   67E
1D44:  MOVLP  18
1D45:  MOVF   78,W
1D46:  MOVLB  01
1D47:  MOVWF  66
....................   if ( dtmf_status & DTMF_BUFFER_FULL) { 
1D48:  BTFSS  66.2
1D49:  GOTO   58D
....................     value=dtmf_read(DATA_REG); 
1D4A:  MOVLB  02
1D4B:  CLRF   3B
1D4C:  MOVLP  00
1D4D:  MOVLB  00
1D4E:  CALL   67E
1D4F:  MOVLP  18
1D50:  MOVF   78,W
1D51:  MOVLB  01
1D52:  MOVWF  65
....................     DTMF_IN_FLAG=1; 
1D53:  BSF    5D.3
....................     if ( value == dd ) { 
1D54:  MOVF   65,F
1D55:  BTFSS  03.2
1D56:  GOTO   55A
....................       value=d0; 
1D57:  MOVLW  0A
1D58:  MOVWF  65
....................     } else if ( value == d0 ) { 
1D59:  GOTO   55E
1D5A:  MOVF   65,W
1D5B:  SUBLW  0A
1D5C:  BTFSC  03.2
....................       value=dd; 
1D5D:  CLRF   65
....................     } 
....................     if ( value == ds ) { 
1D5E:  MOVF   65,W
1D5F:  SUBLW  0B
1D60:  BTFSC  03.2
....................       CLEAR_DTMF_FLAG=1; 
1D61:  BSF    5D.5
....................     } 
....................     // Check for '#' 
....................     if ( value == dp ) { 
1D62:  MOVF   65,W
1D63:  SUBLW  0C
1D64:  BTFSS  03.2
1D65:  GOTO   56E
....................       DTMF_FLAG = 1; 
1D66:  BSF    5D.2
....................       DTMF_ptr->Last=1; 
1D67:  MOVF   3E,W
1D68:  MOVWF  04
1D69:  MOVF   3F,W
1D6A:  MOVWF  05
1D6B:  ADDFSR 00,FSR0
1D6C:  BSF    00.5
....................     } else { 
1D6D:  GOTO   58D
....................       if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
1D6E:  MOVF   3F,W
1D6F:  SUBLW  20
1D70:  BTFSS  03.0
1D71:  GOTO   58D
1D72:  BTFSS  03.2
1D73:  GOTO   578
1D74:  MOVF   3E,W
1D75:  SUBLW  6D
1D76:  BTFSS  03.0
1D77:  GOTO   58D
....................         DTMF_ptr->Key=value; 
1D78:  MOVF   3E,W
1D79:  MOVWF  04
1D7A:  MOVF   3F,W
1D7B:  MOVWF  05
1D7C:  ADDFSR 00,FSR0
1D7D:  MOVF   65,W
1D7E:  ANDLW  0F
1D7F:  MOVWF  77
1D80:  MOVLW  F0
1D81:  ANDWF  00,W
1D82:  IORWF  77,W
1D83:  MOVWF  00
....................         DTMF_ptr->Strobe=1; 
1D84:  MOVF   3E,W
1D85:  MOVWF  04
1D86:  MOVF   3F,W
1D87:  MOVWF  05
1D88:  ADDFSR 00,FSR0
1D89:  BSF    00.4
....................         DTMF_ptr++; 
1D8A:  INCF   3E,F
1D8B:  BTFSC  03.2
1D8C:  INCF   3F,F
....................       } 
....................     } 
....................   } 
.................... } // }}} 
1D8D:  MOVLP  18
1D8E:  MOVLB  00
1D8F:  GOTO   784 (RETURN)
.................... void init_lcd(void) { // {{{ 
.................... #define INIT 0x18 
.................... #define MODE_SET 0x1C 
.................... #define ENABLE 0x04 
....................   i2c_start(); 
....................   i2c_write(LCD_I2C_ADD<<1); 
....................   // Function set 
....................   // Initialize in 8-bit mode first for 3 clock cycles 
....................   lcd_strobe(0x30);lcd_strobe(0x30);lcd_strobe(0x30); 
....................   // Init 4-bit interface mode 
....................   lcd_strobe(0x20); 
....................   lcd_write(0,0x2C); 
....................   // Display On/Off, Cursor off 
....................   lcd_write(0,0x0C); 
....................   // Display clear 
....................   lcd_write(0,0x01); 
....................   // Entry mode set 
....................   lcd_write(0,0x04); 
....................   i2c_stop(); 
.................... } // }}} 
.................... void do_delay_counters(void) { 
....................   // Second Flag {{{ 
....................   if ( SECOND_FLAG ) { 
*
1C30:  BTFSS  72.4
1C31:  GOTO   474
....................     update_aux_out(); 
1C32:  MOVLP  10
1C33:  CALL   680
1C34:  MOVLP  18
....................     // Time Out PTT {{{ 
....................     if ( TOT_SecondCounter || TOT_Min == 0) { 
1C35:  MOVLB  01
1C36:  MOVF   60,W
1C37:  IORWF  61,W
1C38:  BTFSS  03.2
1C39:  GOTO   43F
1C3A:  MOVLB  00
1C3B:  MOVF   66,F
1C3C:  BTFSS  03.2
1C3D:  GOTO   445
1C3E:  MOVLB  01
....................       TOT_SecondCounter--; 
1C3F:  MOVF   60,W
1C40:  BTFSC  03.2
1C41:  DECF   61,F
1C42:  DECF   60,F
....................     } else if ( COR_IN != 0x00 ) { 
1C43:  GOTO   459
1C44:  MOVLB  00
1C45:  MOVF   5F,F
1C46:  BTFSC  03.2
1C47:  GOTO   45A
....................       update_ptt(0); 
1C48:  MOVLB  02
1C49:  CLRF   2E
1C4A:  MOVLP  08
1C4B:  MOVLB  00
1C4C:  CALL   34B
1C4D:  MOVLP  18
....................       printf("\n\r# PTT Timeout!\n"); 
1C4E:  MOVLW  8E
1C4F:  MOVLB  03
1C50:  MOVWF  11
1C51:  MOVLW  04
1C52:  MOVWF  12
1C53:  MOVLP  00
1C54:  MOVLB  00
1C55:  CALL   4BB
1C56:  MOVLP  18
....................       PROMPT_FLAG=1; 
1C57:  MOVLB  01
1C58:  BSF    5D.6
1C59:  MOVLB  00
....................     } 
....................     // }}} 
....................     // Admin mode timeout {{{ 
....................     if ( admin_timer ) { 
1C5A:  MOVF   73,F
1C5B:  BTFSC  03.2
1C5C:  GOTO   45F
....................       admin_timer--; 
1C5D:  DECF   73,F
....................     } else { 
1C5E:  GOTO   468
....................       // Exit admin mode. 
....................       if ( AdminMode ) { 
1C5F:  MOVLB  01
1C60:  BTFSS  5D.7
1C61:  GOTO   469
....................         set_admin_mode(0); 
1C62:  MOVLB  02
1C63:  CLRF   40
1C64:  MOVLP  08
1C65:  MOVLB  00
1C66:  CALL   49F
1C67:  MOVLP  18
1C68:  MOVLB  01
....................       } 
....................     } 
....................     // }}} 
....................     restart_wdt(); 
1C69:  CLRWDT
....................     if ( SecondCounter ) { 
1C6A:  MOVF   5E,F
1C6B:  BTFSC  03.2
1C6C:  GOTO   46F
....................       SecondCounter--; 
1C6D:  DECF   5E,F
....................     } else { 
1C6E:  GOTO   472
....................       SecondCounter=SEC_COUNTER; 
1C6F:  MOVLW  3B
1C70:  MOVWF  5E
....................       MINUTE_FLAG = 1; 
1C71:  BSF    72.5
....................     } 
....................     SECOND_FLAG=0; 
1C72:  BCF    72.4
1C73:  MOVLB  00
....................   } 
....................   // Second Flag }}} 
....................   // Minute flag {{{ 
....................   if ( MINUTE_FLAG ) { 
1C74:  BTFSS  72.5
1C75:  GOTO   493
....................     if ( MinuteCounter ) { 
1C76:  MOVLB  01
1C77:  MOVF   5F,F
1C78:  BTFSC  03.2
1C79:  GOTO   47C
....................       MinuteCounter--; 
1C7A:  DECF   5F,F
....................     } else { 
1C7B:  GOTO   47F
....................       THIRTY_MIN_FLAG=1; 
1C7C:  BSF    72.6
....................       MinuteCounter = MIN_COUNTER; 
1C7D:  MOVLW  1D
1C7E:  MOVWF  5F
....................     } 
....................     MINUTE_FLAG = 0; 
1C7F:  BCF    72.5
....................     // Link timeout timer {{{ 
....................     if ( Link_TOT != 0 ) { 
1C80:  MOVLB  00
1C81:  MOVF   67,F
1C82:  BTFSC  03.2
1C83:  GOTO   493
....................       if ( LinkDurationTimer ) { 
1C84:  MOVF   68,F
1C85:  BTFSC  03.2
1C86:  GOTO   489
....................         LinkDurationTimer--; 
1C87:  DECF   68,F
....................       } else { 
1C88:  GOTO   493
....................         // Disable Link 
....................         printf("\n\r# Link Timeout!\n"); 
1C89:  MOVLW  97
1C8A:  MOVLB  03
1C8B:  MOVWF  11
1C8C:  MOVLW  04
1C8D:  MOVWF  12
1C8E:  MOVLP  00
1C8F:  MOVLB  00
1C90:  CALL   4BB
1C91:  MOVLP  18
....................         Enable&=0xFE; 
1C92:  BCF    60.0
....................       } 
....................     } 
....................     // Link timeout timer }}} 
....................   } 
....................   // Minute flag }}} 
....................   if ( THIRTY_MIN_FLAG ) { // {{{ 
1C93:  BTFSS  72.6
1C94:  GOTO   4AE
....................     if ( (TXSiteID&0x03) !=0 ) { 
1C95:  MOVF   64,W
1C96:  ANDLW  03
1C97:  BTFSC  03.2
1C98:  GOTO   4AD
....................       // Transmit Site ID every 30 mins when: 
....................       // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................       // E = Transmit every 30 mins 
....................       // M = Transmit only if EnableMask is off 
....................       if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
1C99:  MOVF   64,W
1C9A:  ANDLW  01
1C9B:  BTFSS  03.2
1C9C:  GOTO   4AA
1C9D:  MOVF   64,W
1C9E:  ANDLW  02
1C9F:  BTFSC  03.2
1CA0:  GOTO   4AD
1CA1:  SWAPF  64,W
1CA2:  MOVWF  77
1CA3:  MOVLW  0F
1CA4:  ANDWF  77,F
1CA5:  MOVF   77,W
1CA6:  ANDLW  0F
1CA7:  ANDWF  60,W
1CA8:  BTFSS  03.2
1CA9:  GOTO   4AD
....................         send_morse_id(); 
1CAA:  MOVLP  10
1CAB:  CALL   0B3
1CAC:  MOVLP  18
....................       } 
....................     } 
....................     THIRTY_MIN_FLAG=0; 
1CAD:  BCF    72.6
....................   } // }}} 
.................... } 
1CAE:  MOVLP  18
1CAF:  GOTO   776 (RETURN)
.................... void process_buttons(void) { // {{{ 
.................... #ifdef BUTTON_STATES 
....................   char enter_b,select_b; 
....................   unsigned _cor_in; 
....................   unsigned int pot_value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
0D8C:  MOVF   74,W
0D8D:  ANDLW  03
0D8E:  MOVLB  01
0D8F:  MOVWF  69
....................   // Process Enter / select buttons {{{ 
....................   _cor_in = (COR_IN | COR_EMUL ) & 0x0F; 
0D90:  MOVLB  00
0D91:  MOVF   5F,W
0D92:  IORWF  69,W
0D93:  ANDLW  0F
0D94:  MOVLB  01
0D95:  MOVWF  67
....................   if ( input(ENTER_BUTTON)==0 ) { 
0D96:  BSF    0C.7
0D97:  MOVLB  00
0D98:  BTFSC  0C.7
0D99:  GOTO   5A6
....................     ENTER_PRESSED = (enter_b == DEBOUNCE_COUNT); 
0D9A:  BCF    72.1
0D9B:  MOVLB  01
0D9C:  MOVF   65,W
0D9D:  SUBLW  08
0D9E:  BTFSC  03.2
0D9F:  BSF    72.1
....................     if ( enter_b < DEBOUNCE_COUNT+ 1 ) { 
0DA0:  MOVF   65,W
0DA1:  SUBLW  08
0DA2:  BTFSC  03.0
....................       enter_b++;  
0DA3:  INCF   65,F
....................     } 
....................   } else { 
0DA4:  GOTO   5A9
0DA5:  MOVLB  00
....................     enter_b = 0; 
0DA6:  MOVLB  01
0DA7:  CLRF   65
....................     ENTER_PRESSED = 0; 
0DA8:  BCF    72.1
....................   } 
....................   if ( input(SELECT_BUTTON)==0 ) { 
0DA9:  MOVLB  00
0DAA:  BTFSC  10.3
0DAB:  GOTO   5B8
....................     SELECT_PRESSED = (select_b == DEBOUNCE_COUNT); 
0DAC:  BCF    72.2
0DAD:  MOVLB  01
0DAE:  MOVF   66,W
0DAF:  SUBLW  08
0DB0:  BTFSC  03.2
0DB1:  BSF    72.2
....................     if ( select_b < DEBOUNCE_COUNT + 1 ) { 
0DB2:  MOVF   66,W
0DB3:  SUBLW  08
0DB4:  BTFSC  03.0
....................       select_b++; 
0DB5:  INCF   66,F
....................     } 
....................   } else { 
0DB6:  GOTO   5BB
0DB7:  MOVLB  00
....................     select_b = 0; 
0DB8:  MOVLB  01
0DB9:  CLRF   66
....................     SELECT_PRESSED = 0; 
0DBA:  BCF    72.2
....................   } 
....................   // Define Button States 
....................   // IDLE + ENTER --> TRIM 
....................   // TRIM + ENTER --> Exit 
....................   // TRIM + SELECT --> NextPot 
....................   switch (button_state) { 
0DBB:  MOVF   5C,W
0DBC:  XORLW  00
0DBD:  MOVLB  00
0DBE:  BTFSC  03.2
0DBF:  GOTO   5C7
0DC0:  XORLW  10
0DC1:  BTFSC  03.2
0DC2:  GOTO   5CE
0DC3:  XORLW  1F
0DC4:  BTFSC  03.2
0DC5:  GOTO   5DE
0DC6:  GOTO   64E
....................     case BUTTON_IDLE:   
....................       if ( ENTER_PRESSED == 1 ) { 
0DC7:  BTFSS  72.1
0DC8:  GOTO   5CD
....................         button_state=CALIB; 
0DC9:  MOVLW  10
0DCA:  MOVLB  01
0DCB:  MOVWF  5C
0DCC:  MOVLB  00
....................       } 
....................     break; 
0DCD:  GOTO   651
....................     case CALIB: 
....................       adj_value_a = read_adc() >> 2; 
0DCE:  MOVLB  01
0DCF:  BSF    1D.1
0DD0:  BTFSC  1D.1
0DD1:  GOTO   5D0
0DD2:  RRF    1C,W
0DD3:  MOVWF  7E
0DD4:  RRF    7E,F
0DD5:  MOVLW  3F
0DD6:  ANDWF  7E,F
....................       adj_value_b = adj_value_a; 
0DD7:  MOVF   7E,W
0DD8:  MOVWF  5B
....................       button_state=TRIM; 
0DD9:  MOVLW  0F
0DDA:  MOVWF  5C
....................       pot_values_to_lcd(); 
0DDB:  MOVLB  00
0DDC:  CALL   257
....................       break; 
0DDD:  GOTO   651
....................     case TRIM: 
....................        if ( _cor_in != 0 ) { 
0DDE:  MOVLB  01
0DDF:  MOVF   67,F
0DE0:  BTFSC  03.2
0DE1:  GOTO   613
....................          adj_value_a = read_adc() >> 2; 
0DE2:  BSF    1D.1
0DE3:  BTFSC  1D.1
0DE4:  GOTO   5E3
0DE5:  RRF    1C,W
0DE6:  MOVWF  7E
0DE7:  RRF    7E,F
0DE8:  MOVLW  3F
0DE9:  ANDWF  7E,F
....................          pot_value = 63-adj_value_a; 
0DEA:  MOVF   7E,W
0DEB:  SUBLW  3F
0DEC:  MOVWF  68
....................          if ( adj_value_a != adj_value_b ) { 
0DED:  MOVF   5B,W
0DEE:  SUBWF  7E,W
0DEF:  BTFSC  03.2
0DF0:  GOTO   611
....................            rs232_mode = 1; 
0DF1:  BSF    62.0
....................            set_trimpot(CurrentTrimPot, pot_value); 
0DF2:  MOVF   74,W
0DF3:  MOVLB  02
0DF4:  MOVWF  3F
0DF5:  MOVLB  01
0DF6:  MOVF   68,W
0DF7:  MOVLB  02
0DF8:  MOVWF  40
0DF9:  MOVLP  00
0DFA:  MOVLB  00
0DFB:  CALL   76F
0DFC:  MOVLP  08
....................            pot_values_to_lcd(); 
0DFD:  CALL   257
.................... 	   RX_GAIN[CurrentCorIndex-1][CPotPtr]=pot_value; 
0DFE:  MOVLW  01
0DFF:  SUBWF  6D,W
0E00:  MOVWF  77
0E01:  RLF    77,F
0E02:  RLF    77,F
0E03:  MOVLW  FC
0E04:  ANDWF  77,F
0E05:  MOVF   77,W
0E06:  MOVLB  01
0E07:  ADDWF  69,W
0E08:  ADDLW  0C
0E09:  MOVWF  04
0E0A:  MOVLW  20
0E0B:  MOVWF  05
0E0C:  BTFSC  03.0
0E0D:  INCF   05,F
0E0E:  MOVF   68,W
0E0F:  MOVWF  00
....................            rs232_mode = 0; 
0E10:  BCF    62.0
....................          } 
....................          adj_value_b = adj_value_a; 
0E11:  MOVF   7E,W
0E12:  MOVWF  5B
.................... 	     } 
....................        if ( SELECT_PRESSED == 1 ) { 
0E13:  BTFSS  72.2
0E14:  GOTO   61C
....................          CurrentTrimPot = (CurrentTrimPot + 1 ) & 0x03; 
0E15:  MOVLW  01
0E16:  ADDWF  74,W
0E17:  ANDLW  03
0E18:  MOVWF  74
....................          pot_values_to_lcd(); 
0E19:  MOVLB  00
0E1A:  CALL   257
0E1B:  MOVLB  01
....................        } 
....................        if ( ENTER_PRESSED == 1 ) { 
0E1C:  BTFSS  72.1
0E1D:  GOTO   626
....................          // Hold SELECT and press ENTER to store settings in EEPROM 
....................          if ( input(SELECT_BUTTON)==0 ) { 
0E1E:  MOVLB  00
0E1F:  BTFSC  10.3
0E20:  GOTO   624
....................            store_variables(); 
0E21:  MOVLP  00
0E22:  CALL   5AE
0E23:  MOVLP  08
....................          } 
....................          button_state = BUTTON_IDLE; 
0E24:  MOVLB  01
0E25:  CLRF   5C
.................... 	     }  
....................        status_led(); 
....................     break; 
*
0E4C:  MOVLB  00
0E4D:  GOTO   651
....................     default: 
....................   		button_state = BUTTON_IDLE; 
0E4E:  MOVLB  01
0E4F:  CLRF   5C
....................     break; 
0E50:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0E51:  CLRWDT
....................   // }}} 
.................... #endif 
.................... } // }}} 
0E52:  MOVLP  18
0E53:  GOTO   762 (RETURN)

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
