CCS PCM C Compiler, Version 4.140, 64991               28-Apr-20 20:49

               Filename:   C:\Users\Luc\Projects\RC2G\Firmware.lst

               ROM used:   8159 words (100%)
                           Largest free fragment is 17
               RAM used:   171 (33%) at main() level
                           239 (47%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   5C4
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   357
002D:  MOVLP  00
002E:  GOTO   3CA
002F:  MOVLP  00
0030:  GOTO   2E1
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #device ADC=8; 
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
1659:  MOVLB  02
165A:  MOVF   2F,W
165B:  MOVWF  33
165C:  MOVF   2E,W
165D:  MOVWF  32
165E:  MOVF   33,W
165F:  MOVWF  7A
1660:  MOVF   32,W
1661:  MOVWF  04
1662:  MOVF   7A,W
1663:  MOVWF  05
1664:  MOVF   00,F
1665:  BTFSC  03.2
1666:  GOTO   66B
1667:  INCF   32,F
1668:  BTFSC  03.2
1669:  INCF   33,F
166A:  GOTO   65E
....................    while(*s2 != '\0') 
....................    { 
166B:  MOVF   31,W
166C:  MOVWF  7A
166D:  MOVF   30,W
166E:  MOVWF  04
166F:  MOVF   7A,W
1670:  MOVWF  05
1671:  MOVF   00,F
1672:  BTFSC  03.2
1673:  GOTO   687
....................       *s = *s2; 
1674:  MOVF   30,W
1675:  MOVWF  04
1676:  MOVF   31,W
1677:  MOVWF  05
1678:  MOVF   00,W
1679:  MOVWF  36
167A:  MOVF   33,W
167B:  MOVWF  05
167C:  MOVF   32,W
167D:  MOVWF  04
167E:  MOVF   36,W
167F:  MOVWF  00
....................       ++s; 
1680:  INCF   32,F
1681:  BTFSC  03.2
1682:  INCF   33,F
....................       ++s2; 
1683:  INCF   30,F
1684:  BTFSC  03.2
1685:  INCF   31,F
....................    } 
1686:  GOTO   66B
....................  
....................    *s = '\0'; 
1687:  MOVF   32,W
1688:  MOVWF  04
1689:  MOVF   33,W
168A:  MOVWF  05
168B:  CLRF   00
....................    return(s1); 
168C:  MOVF   2E,W
168D:  MOVWF  78
168E:  MOVF   2F,W
168F:  MOVWF  79
.................... } 
1690:  MOVLB  00
1691:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E8F:  MOVF   4D,W
0E90:  MOVWF  51
0E91:  MOVF   4C,W
0E92:  MOVWF  50
0E93:  MOVF   51,W
0E94:  MOVWF  7A
0E95:  MOVF   50,W
0E96:  MOVWF  04
0E97:  MOVF   7A,W
0E98:  MOVWF  05
0E99:  MOVF   00,F
0E9A:  BTFSC  03.2
0E9B:  GOTO   6C8
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0E9C:  MOVF   4F,W
0E9D:  MOVWF  53
0E9E:  MOVF   4E,W
0E9F:  MOVWF  52
0EA0:  MOVF   53,W
0EA1:  MOVWF  7A
0EA2:  MOVF   52,W
0EA3:  MOVWF  04
0EA4:  MOVF   7A,W
0EA5:  MOVWF  05
0EA6:  MOVF   00,F
0EA7:  BTFSC  03.2
0EA8:  GOTO   6C4
....................          if (*sc1 == *sc2) 
0EA9:  MOVF   51,W
0EAA:  MOVWF  7A
0EAB:  MOVF   50,W
0EAC:  MOVWF  04
0EAD:  MOVF   7A,W
0EAE:  MOVWF  05
0EAF:  MOVF   00,W
0EB0:  MOVWF  54
0EB1:  MOVF   53,W
0EB2:  MOVWF  7A
0EB3:  MOVF   52,W
0EB4:  MOVWF  04
0EB5:  MOVF   7A,W
0EB6:  MOVWF  05
0EB7:  MOVF   00,W
0EB8:  SUBWF  54,W
0EB9:  BTFSS  03.2
0EBA:  GOTO   6C0
....................             return(sc1); 
0EBB:  MOVF   50,W
0EBC:  MOVWF  78
0EBD:  MOVF   51,W
0EBE:  MOVWF  79
0EBF:  GOTO   6CB
0EC0:  INCF   52,F
0EC1:  BTFSC  03.2
0EC2:  INCF   53,F
0EC3:  GOTO   6A0
0EC4:  INCF   50,F
0EC5:  BTFSC  03.2
0EC6:  INCF   51,F
0EC7:  GOTO   693
....................    return(0); 
0EC8:  MOVLW  00
0EC9:  MOVWF  78
0ECA:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E28:  MOVF   4D,W
0E29:  MOVWF  51
0E2A:  MOVF   4C,W
0E2B:  MOVWF  50
0E2C:  MOVF   51,W
0E2D:  MOVWF  7A
0E2E:  MOVF   50,W
0E2F:  MOVWF  04
0E30:  MOVF   7A,W
0E31:  MOVWF  05
0E32:  MOVF   00,F
0E33:  BTFSC  03.2
0E34:  GOTO   666
....................       for (sc2 = s2; ; sc2++) 
0E35:  MOVF   4F,W
0E36:  MOVWF  53
0E37:  MOVF   4E,W
0E38:  MOVWF  52
....................     if (*sc2 == '\0') 
0E39:  MOVF   53,W
0E3A:  MOVWF  7A
0E3B:  MOVF   52,W
0E3C:  MOVWF  04
0E3D:  MOVF   7A,W
0E3E:  MOVWF  05
0E3F:  MOVF   00,F
0E40:  BTFSS  03.2
0E41:  GOTO   64C
....................        return(sc1 - s1); 
0E42:  MOVF   4C,W
0E43:  SUBWF  50,W
0E44:  MOVWF  77
0E45:  MOVF   4D,W
0E46:  SUBWFC 51,W
0E47:  MOVWF  7A
0E48:  MOVF   77,W
0E49:  MOVWF  78
0E4A:  GOTO   66E
....................          else if (*sc1 == *sc2) 
0E4B:  GOTO   65E
0E4C:  MOVF   51,W
0E4D:  MOVWF  7A
0E4E:  MOVF   50,W
0E4F:  MOVWF  04
0E50:  MOVF   7A,W
0E51:  MOVWF  05
0E52:  MOVF   00,W
0E53:  MOVWF  54
0E54:  MOVF   53,W
0E55:  MOVWF  7A
0E56:  MOVF   52,W
0E57:  MOVWF  04
0E58:  MOVF   7A,W
0E59:  MOVWF  05
0E5A:  MOVF   00,W
0E5B:  SUBWF  54,W
0E5C:  BTFSC  03.2
....................             break; 
0E5D:  GOTO   662
0E5E:  INCF   52,F
0E5F:  BTFSC  03.2
0E60:  INCF   53,F
0E61:  GOTO   639
0E62:  INCF   50,F
0E63:  BTFSC  03.2
0E64:  INCF   51,F
0E65:  GOTO   62C
....................    return(sc1 - s1); 
0E66:  MOVF   4C,W
0E67:  SUBWF  50,W
0E68:  MOVWF  77
0E69:  MOVF   4D,W
0E6A:  SUBWFC 51,W
0E6B:  MOVWF  7A
0E6C:  MOVF   77,W
0E6D:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1DF2:  MOVLB  00
1DF3:  CLRF   26
1DF4:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0E0F:  MOVLB  02
0E10:  MOVF   44,W
0E11:  IORWF  45,W
0E12:  BTFSC  03.2
0E13:  GOTO   618
0E14:  MOVF   45,W
0E15:  MOVWF  7A
0E16:  MOVF   44,W
0E17:  GOTO   61D
0E18:  MOVLB  00
0E19:  MOVF   27,W
0E1A:  MOVWF  7A
0E1B:  MOVF   26,W
0E1C:  MOVLB  02
0E1D:  MOVWF  48
0E1E:  MOVF   7A,W
0E1F:  MOVWF  49
....................    beg += strspn(beg, s2); 
0E20:  MOVF   49,W
0E21:  MOVWF  4D
0E22:  MOVF   48,W
0E23:  MOVWF  4C
0E24:  MOVF   47,W
0E25:  MOVWF  4F
0E26:  MOVF   46,W
0E27:  MOVWF  4E
*
0E6E:  MOVF   78,W
0E6F:  ADDWF  48,F
0E70:  MOVLW  00
0E71:  ADDWFC 49,F
....................    if (*beg == '\0') 
0E72:  MOVF   49,W
0E73:  MOVWF  7A
0E74:  MOVF   48,W
0E75:  MOVWF  04
0E76:  MOVF   7A,W
0E77:  MOVWF  05
0E78:  MOVF   00,F
0E79:  BTFSS  03.2
0E7A:  GOTO   687
....................    { 
....................       *save = ' '; 
0E7B:  MOVLB  00
0E7C:  MOVF   26,W
0E7D:  MOVWF  04
0E7E:  MOVF   27,W
0E7F:  MOVWF  05
0E80:  MOVLW  20
0E81:  MOVWF  00
....................       return(0); 
0E82:  MOVLW  00
0E83:  MOVWF  78
0E84:  MOVWF  79
0E85:  GOTO   6EC
0E86:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0E87:  MOVF   49,W
0E88:  MOVWF  4D
0E89:  MOVF   48,W
0E8A:  MOVWF  4C
0E8B:  MOVF   47,W
0E8C:  MOVWF  4F
0E8D:  MOVF   46,W
0E8E:  MOVWF  4E
*
0ECB:  MOVF   79,W
0ECC:  MOVWF  4B
0ECD:  MOVF   78,W
0ECE:  MOVWF  4A
....................    if (*end != '\0') 
0ECF:  MOVF   4B,W
0ED0:  MOVWF  7A
0ED1:  MOVF   4A,W
0ED2:  MOVWF  04
0ED3:  MOVF   7A,W
0ED4:  MOVWF  05
0ED5:  MOVF   00,F
0ED6:  BTFSC  03.2
0ED7:  GOTO   6E0
....................    { 
....................       *end = '\0'; 
0ED8:  MOVF   4A,W
0ED9:  MOVWF  04
0EDA:  MOVF   4B,W
0EDB:  MOVWF  05
0EDC:  CLRF   00
....................       end++; 
0EDD:  INCF   4A,F
0EDE:  BTFSC  03.2
0EDF:  INCF   4B,F
....................    } 
....................    save = end; 
0EE0:  MOVF   4B,W
0EE1:  MOVLB  00
0EE2:  MOVWF  27
0EE3:  MOVLB  02
0EE4:  MOVF   4A,W
0EE5:  MOVLB  00
0EE6:  MOVWF  26
....................    return(beg); 
0EE7:  MOVLB  02
0EE8:  MOVF   48,W
0EE9:  MOVWF  78
0EEA:  MOVF   49,W
0EEB:  MOVWF  79
0EEC:  MOVLB  00
.................... } 
0EED:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
0F4E:  MOVLB  02
0F4F:  MOVF   45,W
0F50:  MOVWF  7A
0F51:  MOVF   44,W
0F52:  MOVWF  04
0F53:  MOVF   7A,W
0F54:  MOVWF  05
0F55:  MOVF   00,W
0F56:  MOVWF  48
0F57:  MOVF   47,W
0F58:  MOVWF  7A
0F59:  MOVF   46,W
0F5A:  MOVWF  04
0F5B:  MOVF   7A,W
0F5C:  MOVWF  05
0F5D:  MOVF   00,W
0F5E:  SUBWF  48,W
0F5F:  BTFSC  03.2
0F60:  GOTO   7B7
0F61:  MOVF   45,W
0F62:  MOVWF  7A
0F63:  MOVF   44,W
0F64:  MOVWF  04
0F65:  MOVF   7A,W
0F66:  MOVWF  05
0F67:  MOVF   00,W
0F68:  MOVWF  48
0F69:  MOVF   48,W
0F6A:  SUBLW  40
0F6B:  BTFSC  03.0
0F6C:  GOTO   771
0F6D:  MOVF   48,W
0F6E:  SUBLW  5A
0F6F:  BTFSC  03.0
0F70:  GOTO   779
0F71:  MOVF   48,W
0F72:  SUBLW  60
0F73:  BTFSC  03.0
0F74:  GOTO   7CD
0F75:  MOVF   48,W
0F76:  SUBLW  7A
0F77:  BTFSS  03.0
0F78:  GOTO   7CD
0F79:  MOVF   47,W
0F7A:  MOVWF  7A
0F7B:  MOVF   46,W
0F7C:  MOVWF  04
0F7D:  MOVF   7A,W
0F7E:  MOVWF  05
0F7F:  MOVF   00,W
0F80:  MOVWF  48
0F81:  MOVF   48,W
0F82:  SUBLW  40
0F83:  BTFSC  03.0
0F84:  GOTO   789
0F85:  MOVF   48,W
0F86:  SUBLW  5A
0F87:  BTFSC  03.0
0F88:  GOTO   791
0F89:  MOVF   48,W
0F8A:  SUBLW  60
0F8B:  BTFSC  03.0
0F8C:  GOTO   7CD
0F8D:  MOVF   48,W
0F8E:  SUBLW  7A
0F8F:  BTFSS  03.0
0F90:  GOTO   7CD
0F91:  MOVF   45,W
0F92:  MOVWF  7A
0F93:  MOVF   44,W
0F94:  MOVWF  04
0F95:  MOVF   7A,W
0F96:  MOVWF  05
0F97:  MOVF   00,W
0F98:  MOVWF  48
0F99:  MOVF   47,W
0F9A:  MOVWF  7A
0F9B:  MOVF   46,W
0F9C:  MOVWF  04
0F9D:  MOVF   7A,W
0F9E:  MOVWF  05
0F9F:  MOVLW  20
0FA0:  ADDWF  00,W
0FA1:  SUBWF  48,W
0FA2:  BTFSC  03.2
0FA3:  GOTO   7B7
0FA4:  MOVF   47,W
0FA5:  MOVWF  7A
0FA6:  MOVF   46,W
0FA7:  MOVWF  04
0FA8:  MOVF   7A,W
0FA9:  MOVWF  05
0FAA:  MOVF   00,W
0FAB:  MOVWF  48
0FAC:  MOVF   45,W
0FAD:  MOVWF  7A
0FAE:  MOVF   44,W
0FAF:  MOVWF  04
0FB0:  MOVF   7A,W
0FB1:  MOVWF  05
0FB2:  MOVLW  20
0FB3:  ADDWF  00,W
0FB4:  SUBWF  48,W
0FB5:  BTFSS  03.2
0FB6:  GOTO   7CD
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
0FB7:  MOVF   45,W
0FB8:  MOVWF  7A
0FB9:  MOVF   44,W
0FBA:  MOVWF  04
0FBB:  MOVF   7A,W
0FBC:  MOVWF  05
0FBD:  MOVF   00,F
0FBE:  BTFSS  03.2
0FBF:  GOTO   7C3
....................        return(0); 
0FC0:  MOVLW  00
0FC1:  MOVWF  78
0FC2:  GOTO   7E3
0FC3:  MOVF   45,W
0FC4:  MOVWF  7A
0FC5:  MOVF   44,W
0FC6:  INCF   44,F
0FC7:  BTFSC  03.2
0FC8:  INCF   45,F
0FC9:  INCF   46,F
0FCA:  BTFSC  03.2
0FCB:  INCF   47,F
0FCC:  GOTO   74F
....................  return((*s1 < *s2) ? -1: 1); 
0FCD:  MOVF   45,W
0FCE:  MOVWF  7A
0FCF:  MOVF   44,W
0FD0:  MOVWF  04
0FD1:  MOVF   45,W
0FD2:  MOVWF  05
0FD3:  MOVF   00,W
0FD4:  MOVWF  48
0FD5:  MOVF   47,W
0FD6:  MOVWF  7A
0FD7:  MOVF   46,W
0FD8:  MOVWF  04
0FD9:  MOVF   47,W
0FDA:  MOVWF  05
0FDB:  MOVF   00,W
0FDC:  SUBWF  48,W
0FDD:  BTFSC  03.0
0FDE:  GOTO   7E1
0FDF:  MOVLW  FF
0FE0:  GOTO   7E2
0FE1:  MOVLW  01
0FE2:  MOVWF  78
.................... } 
0FE3:  MOVLB  00
0FE4:  RETURN
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
.................... #define BUTTON_STATES 
.................... #define POT_MAX 63 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
07C4:  MOVLW  20
07C5:  MOVWF  05
07C6:  MOVLW  CF
07C7:  MOVWF  04
07C8:  MOVF   00,W
07C9:  BTFSC  03.2
07CA:  GOTO   7DC
07CB:  MOVLW  02
07CC:  MOVWF  78
07CD:  MOVLW  BF
07CE:  MOVWF  77
07CF:  CLRWDT
07D0:  DECFSZ 77,F
07D1:  GOTO   7CF
07D2:  DECFSZ 78,F
07D3:  GOTO   7CD
07D4:  MOVLW  96
07D5:  MOVWF  77
07D6:  DECFSZ 77,F
07D7:  GOTO   7D6
07D8:  GOTO   7D9
07D9:  CLRWDT
07DA:  DECFSZ 00,F
07DB:  GOTO   7CB
07DC:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
06EC:  MOVLB  04
06ED:  BCF    15.7
06EE:  MOVLB  00
06EF:  BCF    11.3
06F0:  MOVLB  02
06F1:  MOVF   55,W
06F2:  MOVLB  04
06F3:  MOVWF  11
06F4:  MOVLW  02
06F5:  BTFSC  15.7
06F6:  GOTO   6FE
06F7:  MOVLB  00
06F8:  BTFSS  11.3
06F9:  GOTO   6F8
06FA:  MOVLW  00
06FB:  MOVLB  04
06FC:  BTFSC  16.6
06FD:  MOVLW  01
06FE:  MOVWF  78
06FF:  MOVLB  00
0700:  RETURN
*
0AF1:  MOVLB  04
0AF2:  BCF    15.6
0AF3:  BSF    16.3
0AF4:  BTFSC  16.3
0AF5:  GOTO   2F4
0AF6:  BTFSC  77.0
0AF7:  BCF    16.5
0AF8:  BTFSS  77.0
0AF9:  BSF    16.5
0AFA:  BSF    16.4
0AFB:  BTFSC  16.4
0AFC:  GOTO   2FB
0AFD:  MOVF   11,W
0AFE:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02DA:  CLRWDT
02DB:  BTFSS  11.4
02DC:  GOTO   2DA
02DD:  MOVLB  03
02DE:  MOVWF  1A
02DF:  MOVLB  00
02E0:  RETURN
.................... //#use fast_io (a) 
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void send_tail(void); 
.................... void status_led(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN; 
.................... unsigned int Enable,Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned int TOT_Min; 
.................... unsigned int COR_EMUL; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define DEBOUNCE_COUNT 8 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... //#define DTMF_SEND_OLD 10 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR0 0x01 
.................... #define AUX_OUT_FOLLOW_COR1 0x02 
.................... #define AUX_OUT_FOLLOW_COR2 0x04 
.................... #define AUX_OUT_FOLLOW_COR3 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT0 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x10 
.................... #define AUXI_EMULATE_COR0 0x01 
.................... #define AUXI_EMULATE_COR1 0x02 
.................... #define AUXI_EMULATE_COR2 0x04 
.................... #define AUXI_EMULATE_COR3 0x08 
....................  
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... #define LCD_I2C_ADD 0x60 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... char command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... unsigned int  LastRegisterIndex; 
.................... unsigned int  LastRegisterIndexValid; 
....................  
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... //	int      reg_name_index; 
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1 ENTER_PRESSED; 
.................... int1 SELECT_PRESSED; 
.................... int  adj_value_a,adj_value_b; 
.................... char button_state; 
.................... int1       COR_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... int1       STATUS_LED; 
.................... unsigned long TOT_SecondCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... #define PTT_TIMEOUT_SECS 60 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... #ifndef GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 
.................... 	{"XI2"},	  // 19 
.................... 	{"XI3"},	  // 20 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"COR"},  // 54 
....................     {"CPOT"}  // 55 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
....................  
.................... #define SITE_ID_VAL  	20 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... #define ENABLE_DEFAULT 15 
.................... #define TOT_MIN 5 
.................... #define DEFAULT_GAIN 32 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('e') 
.................... #define MORSEID5	MCHAR('h') 
....................  
.................... #define AUXOUTOP0 0 
.................... #define AUXOUTARG0 0 
.................... #define AUXOUTOP1 0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2 0 
.................... #define AUXOUTARG2 0 
....................  
.................... //#define AUXINOP0 AUXI_ENABLE 
.................... //#define AUXINARG0 AUXI_ENABLE2|AUXI_ENABLE3|AUXI_ENABLE4 
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  0 
.................... #define AUXINARG0 0 
.................... #define AUXINOP1 0 
.................... #define AUXINARG1 0 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
....................  
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  ,EEPROM}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL,EEPROM}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN, EEPROM}, 
.................... 	{&AuxIn[0]      ,0           , EEPROM}, 
.................... 	{&AuxIn[1]      ,0           , EEPROM}, 
.................... 	{&AuxIn[2]      ,0           , EEPROM}, 
.................... 	{&AuxOut[0]     ,0           , EEPROM}, 
.................... 	{&AuxOut[1]     ,0           , EEPROM}, 
.................... 	{&AuxOut[2]     ,0           , EEPROM}, 
.................... 	{&RXPriority[0] ,4           , EEPROM}, 
.................... 	{&RXPriority[1] ,6           , EEPROM}, 
.................... 	{&RXPriority[2] ,6           , EEPROM}, 
.................... 	{&RXPriority[3] ,2           , EEPROM}, 
.................... 	{&RX_PTT[0]     ,0x0E        , EEPROM}, 
.................... 	{&RX_PTT[1]     ,0x0D        , EEPROM}, 
.................... 	{&RX_PTT[2]     ,0x0B        , EEPROM}, 
.................... 	{&RX_PTT[3]     ,0x07        , EEPROM}, 
.................... 	{&SiteID        ,SITE_ID_VAL , EEPROM}, 
.................... 	{&TXSiteID      ,0x12        , EEPROM}, 
....................     {&Morse[0]      ,MORSEID0    , EEPROM}, 
....................     {&Morse[1]      ,MORSEID1    , EEPROM}, 
....................     {&Morse[2]      ,MORSEID2    , EEPROM}, 
....................     {&Morse[3]      ,MORSEID3    , EEPROM}, 
....................     {&Morse[4]      ,MORSEID4    , EEPROM}, 
....................     {&Morse[5]      ,MORSEID5    , EEPROM}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0   , EEPROM}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1   , EEPROM}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2   , EEPROM}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0  , EEPROM}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1  , EEPROM}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2  , EEPROM}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0    , EEPROM}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1    , EEPROM}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2    , EEPROM}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0   , EEPROM}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1   , EEPROM}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2   , EEPROM}, 
....................   {&Tail          ,TAIL_CHAR   , EEPROM}, 
....................   {&TOT_Min       ,TOT_MIN     , EEPROM}, 
.................... 	{&COR_EMUL      ,0x00        , RAM}, 
.................... 	{&CurrentTrimPot,0x00        , RAM}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02E1:  BTFSS  11.5
02E2:  GOTO   338
....................     c = getc(); 
02E3:  CLRWDT
02E4:  BTFSS  11.5
02E5:  GOTO   2E3
02E6:  MOVLB  03
02E7:  MOVF   19,W
02E8:  MOVLB  02
02E9:  MOVWF  5A
....................     if ( c == '\b' ) { 
02EA:  MOVF   5A,W
02EB:  SUBLW  08
02EC:  BTFSS  03.2
02ED:  GOTO   316
....................       if ( sBufferIndex > 0 ) { 
02EE:  MOVF   71,F
02EF:  BTFSC  03.2
02F0:  GOTO   310
....................         sBufferIndex--; 
02F1:  DECF   71,F
....................         sBuffer[sBufferIndex]='\0'; 
02F2:  MOVLW  4D
02F3:  ADDWF  71,W
02F4:  MOVWF  04
02F5:  MOVLW  20
02F6:  MOVWF  05
02F7:  BTFSC  03.0
02F8:  INCF   05,F
02F9:  CLRF   00
....................         putc('\b'); 
02FA:  MOVLW  08
02FB:  MOVLB  00
02FC:  CALL   2DA
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
02FD:  MOVLW  1B
02FE:  CALL   2DA
....................   printf("[K"); 
02FF:  MOVLW  5B
0300:  CLRWDT
0301:  BTFSS  11.4
0302:  GOTO   300
0303:  MOVLB  03
0304:  MOVWF  1A
0305:  MOVLW  4B
0306:  CLRWDT
0307:  MOVLB  00
0308:  BTFSC  11.4
0309:  GOTO   30C
030A:  MOVLB  03
030B:  GOTO   306
030C:  MOVLB  03
030D:  MOVWF  1A
....................       } else { 
030E:  GOTO   314
030F:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
0310:  MOVLW  07
0311:  MOVLB  00
0312:  CALL   2DA
0313:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
0314:  GOTO   33A
0315:  MOVLB  02
0316:  MOVF   71,W
0317:  SUBLW  0F
0318:  BTFSS  03.0
0319:  GOTO   335
....................       putc(c); // echo the character 
031A:  MOVF   5A,W
031B:  MOVLB  00
031C:  CALL   2DA
....................       sBuffer[sBufferIndex++] = c; 
031D:  MOVF   71,W
031E:  INCF   71,F
031F:  ADDLW  4D
0320:  MOVWF  04
0321:  MOVLW  20
0322:  MOVWF  05
0323:  BTFSC  03.0
0324:  INCF   05,F
0325:  MOVLB  02
0326:  MOVF   5A,W
0327:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0328:  MOVF   5A,W
0329:  SUBLW  0D
032A:  BTFSC  03.2
032B:  GOTO   333
032C:  MOVF   5A,W
032D:  SUBLW  2B
032E:  BTFSC  03.2
032F:  GOTO   333
0330:  MOVF   5A,W
0331:  SUBLW  2D
0332:  BTFSC  03.2
....................         sBufferFlag=1; 
0333:  BSF    72.0
....................       } 
....................     } else { 
0334:  GOTO   339
....................       putc('\a'); // Send alert. Avoid buffer overflow 
0335:  MOVLW  07
0336:  MOVLB  00
0337:  CALL   2DA
0338:  MOVLB  02
0339:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
....................  
033A:  MOVLB  00
033B:  BCF    11.5
033C:  MOVLP  00
033D:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   int value,dtmf_status; 
....................   int LAST_COR_IN; 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if(IOCBF&0x0F) { // Check for interrupts on RB[3:0] only 
*
0357:  MOVLB  07
0358:  MOVF   16,W
0359:  ANDLW  0F
035A:  BTFSC  03.2
035B:  GOTO   36D
....................     LAST_COR_IN=COR_IN; 
035C:  MOVLB  00
035D:  MOVF   5F,W
035E:  MOVLB  02
035F:  MOVWF  5C
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
0360:  MOVLB  00
0361:  MOVF   0D,W
0362:  XORWF  62,W
0363:  ANDLW  0F
0364:  MOVWF  5F
....................     if ( LAST_COR_IN != COR_IN ) { 
0365:  MOVF   5F,W
0366:  MOVLB  02
0367:  SUBWF  5C,W
0368:  BTFSS  03.2
....................       COR_FLAG = 1; 
0369:  BSF    72.3
....................     } 
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
036A:  MOVLW  F0
036B:  MOVLB  07
036C:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
036D:  BTFSS  0B.0
036E:  GOTO   3BF
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     dtmf_status = dtmf_read(CONTROL_REG); 
036F:  MOVLW  01
0370:  MOVLB  02
0371:  MOVWF  5D
0372:  MOVLB  00
0373:  CALL   33E
0374:  MOVF   78,W
0375:  MOVLB  02
0376:  MOVWF  5B
....................     if ( dtmf_status & DTMF_BUFFER_FULL) { 
0377:  BTFSS  5B.2
0378:  GOTO   3BD
....................       value=dtmf_read(DATA_REG); 
0379:  CLRF   5D
037A:  MOVLB  00
037B:  CALL   33E
037C:  MOVF   78,W
037D:  MOVLB  02
037E:  MOVWF  5A
....................       DTMF_IN_FLAG=1; 
037F:  MOVLB  01
0380:  BSF    5A.3
....................       if ( value == dd ) { 
0381:  MOVLB  02
0382:  MOVF   5A,F
0383:  BTFSS  03.2
0384:  GOTO   388
....................         value=d0; 
0385:  MOVLW  0A
0386:  MOVWF  5A
....................       } else if ( value == d0 ) { 
0387:  GOTO   38C
0388:  MOVF   5A,W
0389:  SUBLW  0A
038A:  BTFSC  03.2
....................         value=dd; 
038B:  CLRF   5A
....................       } 
....................       // Check for '#' 
....................       if ( value == dp ) { 
038C:  MOVF   5A,W
038D:  SUBLW  0C
038E:  BTFSS  03.2
038F:  GOTO   39A
....................         DTMF_FLAG = 1; 
0390:  MOVLB  01
0391:  BSF    5A.2
....................         DTMF_ptr->Last=1; 
0392:  MOVF   3B,W
0393:  MOVWF  04
0394:  MOVF   3C,W
0395:  MOVWF  05
0396:  ADDFSR 00,FSR0
0397:  BSF    00.5
....................       } else { 
0398:  GOTO   3BC
0399:  MOVLB  02
....................         if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
039A:  MOVLB  01
039B:  MOVF   3C,W
039C:  SUBLW  20
039D:  BTFSS  03.0
039E:  GOTO   3BC
039F:  BTFSS  03.2
03A0:  GOTO   3A5
03A1:  MOVF   3B,W
03A2:  SUBLW  6A
03A3:  BTFSS  03.0
03A4:  GOTO   3BC
....................           DTMF_ptr->Key=value; 
03A5:  MOVF   3B,W
03A6:  MOVWF  04
03A7:  MOVF   3C,W
03A8:  MOVWF  05
03A9:  ADDFSR 00,FSR0
03AA:  MOVLB  02
03AB:  MOVF   5A,W
03AC:  ANDLW  0F
03AD:  MOVWF  77
03AE:  MOVLW  F0
03AF:  ANDWF  00,W
03B0:  IORWF  77,W
03B1:  MOVWF  00
....................           DTMF_ptr->Strobe=1; 
03B2:  MOVLB  01
03B3:  MOVF   3B,W
03B4:  MOVWF  04
03B5:  MOVF   3C,W
03B6:  MOVWF  05
03B7:  ADDFSR 00,FSR0
03B8:  BSF    00.4
....................           DTMF_ptr++; 
03B9:  INCF   3B,F
03BA:  BTFSC  03.2
03BB:  INCF   3C,F
03BC:  MOVLB  02
....................         } 
....................       } 
....................     } 
....................   clear_interrupt(INT_RB4_H2L); 
03BD:  MOVLB  07
03BE:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
03BF:  BTFSS  0B.0
03C0:  GOTO   3C6
....................     AUX_IN_FLAG=1; 
03C1:  MOVLB  01
03C2:  BSF    5A.0
....................     clear_interrupt(INT_RB6|INT_RB7); 
03C3:  MOVLW  3F
03C4:  MOVLB  07
03C5:  ANDWF  16,F
....................   } 
.................... } // }}} 
....................  
03C6:  BCF    0B.0
03C7:  MOVLP  00
03C8:  MOVLB  00
03C9:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
03CA:  MOVLB  01
03CB:  MOVF   2D,W
03CC:  IORWF  2E,W
03CD:  BTFSC  03.2
03CE:  GOTO   3D4
....................     rtcc_cnt--; 
03CF:  MOVF   2D,W
03D0:  BTFSC  03.2
03D1:  DECF   2E,F
03D2:  DECF   2D,F
....................   } else { 
03D3:  GOTO   3E0
....................     COR_IN=(input_b() ^ Polarity)&0x0F; 
03D4:  MOVLB  00
03D5:  MOVF   0D,W
03D6:  XORWF  62,W
03D7:  ANDLW  0F
03D8:  MOVWF  5F
....................     COR_FLAG=1; 
03D9:  BSF    72.3
....................     SECOND_FLAG=1; 
03DA:  BSF    72.4
....................     AUX_IN_FLAG=1; 
03DB:  MOVLB  01
03DC:  BSF    5A.0
....................     rtcc_cnt=30; 
03DD:  CLRF   2E
03DE:  MOVLW  1E
03DF:  MOVWF  2D
....................   } 
....................   if (aux_timer ) { 
03E0:  MOVF   2F,W
03E1:  IORWF  30,W
03E2:  BTFSC  03.2
03E3:  GOTO   3E8
....................     aux_timer--; 
03E4:  MOVF   2F,W
03E5:  BTFSC  03.2
03E6:  DECF   30,F
03E7:  DECF   2F,F
....................   } 
.................... } // }}} 
....................  
03E8:  BCF    0B.2
03E9:  MOVLP  00
03EA:  MOVLB  00
03EB:  GOTO   020
.................... int1 warn_no_lcd = 1; 
.................... void lcd_send(int line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
*
09D2:  BCF    03.0
09D3:  MOVLB  02
09D4:  RLF    4F,W
09D5:  ANDLW  0E
09D6:  IORLW  60
09D7:  MOVWF  52
....................   i2c_start(); 
09D8:  MOVLB  04
09D9:  BSF    16.0
09DA:  BTFSC  16.0
09DB:  GOTO   1DA
....................   ack=i2c_write(lcd_cmd); 
09DC:  MOVLB  02
09DD:  MOVF   52,W
09DE:  MOVWF  55
09DF:  MOVLP  00
09E0:  MOVLB  00
09E1:  CALL   6EC
09E2:  MOVLP  08
09E3:  MOVF   78,W
09E4:  MOVLB  02
09E5:  BCF    53.0
09E6:  BTFSC  78.0
09E7:  BSF    53.0
....................   if ( ack!=0 ) { 
09E8:  BTFSS  53.0
09E9:  GOTO   20C
....................     if ( warn_no_lcd ) { 
09EA:  MOVLB  01
09EB:  BTFSS  5F.0
09EC:  GOTO   20A
....................       printf("\n\rI2C ERROR : No ACK from LCD : %u",ack); 
09ED:  MOVLW  00
09EE:  MOVLB  02
09EF:  BTFSC  53.0
09F0:  MOVLW  01
09F1:  MOVWF  54
09F2:  MOVLW  EC
09F3:  MOVLB  03
09F4:  MOVWF  11
09F5:  MOVLW  03
09F6:  MOVWF  12
09F7:  BCF    03.0
09F8:  MOVLW  20
09F9:  MOVLB  02
09FA:  MOVWF  55
09FB:  MOVLP  00
09FC:  MOVLB  00
09FD:  CALL   701
09FE:  MOVLP  08
09FF:  MOVLB  02
0A00:  MOVF   54,W
0A01:  MOVWF  55
0A02:  MOVLW  1B
0A03:  MOVWF  56
0A04:  MOVLP  00
0A05:  MOVLB  00
0A06:  CALL   775
0A07:  MOVLP  08
....................       warn_no_lcd = 0; 
0A08:  MOVLB  01
0A09:  BCF    5F.0
....................     } 
....................   } else { 
0A0A:  GOTO   20E
0A0B:  MOVLB  02
....................     warn_no_lcd = 1; 
0A0C:  MOVLB  01
0A0D:  BSF    5F.0
....................   } 
....................   while(*s) { 
0A0E:  MOVLB  02
0A0F:  MOVF   51,W
0A10:  MOVWF  7A
0A11:  MOVF   50,W
0A12:  MOVWF  04
0A13:  MOVF   7A,W
0A14:  MOVWF  05
0A15:  MOVF   00,F
0A16:  BTFSC  03.2
0A17:  GOTO   22B
....................     i2c_write(*s++); 
0A18:  MOVF   51,W
0A19:  MOVWF  7A
0A1A:  MOVF   50,W
0A1B:  INCF   50,F
0A1C:  BTFSC  03.2
0A1D:  INCF   51,F
0A1E:  MOVWF  04
0A1F:  MOVF   7A,W
0A20:  MOVWF  05
0A21:  MOVF   00,W
0A22:  MOVWF  54
0A23:  MOVWF  55
0A24:  MOVLP  00
0A25:  MOVLB  00
0A26:  CALL   6EC
0A27:  MOVLP  08
....................   } 
0A28:  MOVLB  01
0A29:  GOTO   20E
0A2A:  MOVLB  02
....................   i2c_write(0); // EOL 
0A2B:  CLRF   55
0A2C:  MOVLP  00
0A2D:  MOVLB  00
0A2E:  CALL   6EC
0A2F:  MOVLP  08
....................   i2c_stop(); 
0A30:  MOVLB  04
0A31:  BSF    16.2
0A32:  BTFSC  16.2
0A33:  GOTO   232
.................... #endif 
.................... } // }}} 
0A34:  MOVLB  00
0A35:  RETURN
....................  
.................... #ifdef BUTTON_STATES 
.................... void status_led(void) { // {{{ 
....................   char cnt_val; 
....................   STATUS_LED=0; 
*
0DE5:  MOVLB  01
0DE6:  BCF    5A.1
....................   cnt_val = rtcc_cnt>>3; 
0DE7:  RRF    2E,W
0DE8:  MOVWF  7A
0DE9:  RRF    2D,W
0DEA:  MOVWF  79
0DEB:  RRF    7A,F
0DEC:  RRF    79,F
0DED:  RRF    7A,F
0DEE:  RRF    79,F
0DEF:  MOVF   79,W
0DF0:  MOVWF  6B
....................   if ( button_state!=0 ) { 
0DF1:  MOVF   59,F
0DF2:  BTFSC  03.2
0DF3:  GOTO   602
....................     if ( (rtcc_cnt & 0x04) ) { 
0DF4:  MOVF   2D,W
0DF5:  ANDLW  04
0DF6:  MOVWF  77
0DF7:  CLRF   7A
0DF8:  MOVF   77,W
0DF9:  IORWF  7A,W
0DFA:  BTFSC  03.2
0DFB:  GOTO   602
....................       STATUS_LED = (cnt_val < (CurrentTrimPot+1));  
0DFC:  BCF    5A.1
0DFD:  MOVLW  01
0DFE:  ADDWF  74,W
0DFF:  SUBWF  6B,W
0E00:  BTFSS  03.0
0E01:  BSF    5A.1
....................     } 
....................   }  
....................   output_bit(STATUS_LED_PIN,STATUS_LED); 
0E02:  BTFSC  5A.1
0E03:  GOTO   608
0E04:  MOVLB  02
0E05:  BCF    0C.6
0E06:  GOTO   60A
0E07:  MOVLB  01
0E08:  MOVLB  02
0E09:  BSF    0C.6
0E0A:  MOVLB  01
0E0B:  BCF    0C.6
.................... } // }}} 
0E0C:  MOVLP  18
0E0D:  MOVLB  00
0E0E:  GOTO   69E (RETURN)
.................... #endif 
....................  
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
111C:  MOVF   70,F
111D:  BTFSC  03.2
111E:  GOTO   180
....................     printf("\n\rProcessing Command:"); 
111F:  MOVLW  FE
1120:  MOVLB  03
1121:  MOVWF  11
1122:  MOVLW  03
1123:  MOVWF  12
1124:  MOVLP  00
1125:  MOVLB  00
1126:  CALL   529
1127:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
1128:  MOVLW  09
1129:  MOVLB  03
112A:  MOVWF  11
112B:  MOVLW  04
112C:  MOVWF  12
112D:  BCF    03.0
112E:  MOVLW  0E
112F:  MOVLB  02
1130:  MOVWF  55
1131:  MOVLP  00
1132:  MOVLB  00
1133:  CALL   701
1134:  MOVLP  10
1135:  MOVF   63,W
1136:  MOVLB  02
1137:  MOVWF  55
1138:  MOVLW  1B
1139:  MOVWF  56
113A:  MOVLP  00
113B:  MOVLB  00
113C:  CALL   775
113D:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
113E:  MOVLW  12
113F:  MOVLB  03
1140:  MOVWF  11
1141:  MOVLW  04
1142:  MOVWF  12
1143:  BCF    03.0
1144:  MOVLW  0E
1145:  MOVLB  02
1146:  MOVWF  55
1147:  MOVLP  00
1148:  MOVLB  00
1149:  CALL   701
114A:  MOVLP  10
114B:  MOVF   70,W
114C:  MOVLB  02
114D:  MOVWF  55
114E:  MOVLW  1B
114F:  MOVWF  56
1150:  MOVLP  00
1151:  MOVLB  00
1152:  CALL   775
1153:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
1154:  MOVLW  1B
1155:  MOVLB  03
1156:  MOVWF  11
1157:  MOVLW  04
1158:  MOVWF  12
1159:  BCF    03.0
115A:  MOVLW  0E
115B:  MOVLB  02
115C:  MOVWF  55
115D:  MOVLP  00
115E:  MOVLB  00
115F:  CALL   701
1160:  MOVLP  10
1161:  MOVF   75,W
1162:  MOVLB  02
1163:  MOVWF  55
1164:  MOVLW  1B
1165:  MOVWF  56
1166:  MOVLP  00
1167:  MOVLB  00
1168:  CALL   775
1169:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
116A:  MOVLW  24
116B:  MOVLB  03
116C:  MOVWF  11
116D:  MOVLW  04
116E:  MOVWF  12
116F:  BCF    03.0
1170:  MOVLW  0E
1171:  MOVLB  02
1172:  MOVWF  55
1173:  MOVLP  00
1174:  MOVLB  00
1175:  CALL   701
1176:  MOVLP  10
1177:  MOVF   76,W
1178:  MOVLB  02
1179:  MOVWF  55
117A:  MOVLW  1B
117B:  MOVWF  56
117C:  MOVLP  00
117D:  MOVLB  00
117E:  CALL   775
117F:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
1180:  MOVLW  02
1181:  SUBWF  70,W
1182:  ADDLW  F5
1183:  BTFSC  03.0
1184:  GOTO   577
1185:  ADDLW  0B
1186:  GOTO   578
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
123E:  GOTO   577
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
123F:  RLF    75,W
1240:  MOVWF  77
1241:  RLF    77,F
1242:  MOVLW  FC
1243:  ANDWF  77,F
1244:  MOVF   77,W
1245:  MOVLB  02
1246:  MOVWF  31
1247:  INCF   31,W
1248:  MOVLP  00
1249:  MOVLB  00
124A:  CALL   043
124B:  MOVLP  10
124C:  MOVWF  7A
124D:  MOVLB  02
124E:  MOVF   31,W
124F:  MOVLP  00
1250:  MOVLB  00
1251:  CALL   043
1252:  MOVLP  10
1253:  MOVLB  02
1254:  MOVWF  25
1255:  MOVF   7A,W
1256:  MOVWF  26
....................       LastRegisterIndex = argument; 
1257:  MOVF   75,W
1258:  MOVWF  7C
....................       LastRegisterIndexValid=1; 
1259:  MOVLW  01
125A:  MOVWF  7D
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
125B:  MOVLW  01
125C:  MOVWF  7A
125D:  MOVLW  8B
125E:  MOVWF  31
125F:  MOVF   7A,W
1260:  MOVWF  32
1261:  CLRF   34
1262:  MOVF   75,W
1263:  MOVWF  33
1264:  MOVF   34,W
1265:  MOVWF  43
1266:  MOVF   33,W
1267:  MOVWF  42
1268:  CLRF   45
1269:  MOVLW  06
126A:  MOVWF  44
126B:  MOVLP  08
126C:  MOVLB  00
126D:  CALL   7E5
126E:  MOVLP  10
126F:  MOVF   78,W
1270:  MOVLB  02
1271:  ADDWF  31,W
1272:  MOVWF  29
1273:  MOVF   79,W
1274:  ADDWFC 32,W
1275:  MOVWF  2A
....................       romstrcpy(rname,cPtr); 
1276:  MOVLW  20
1277:  MOVWF  41
1278:  MOVLW  AB
1279:  MOVWF  40
127A:  MOVF   2A,W
127B:  MOVWF  43
127C:  MOVF   29,W
127D:  MOVWF  42
127E:  MOVLB  00
127F:  CALL   000
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
1280:  MOVLB  02
1281:  MOVF   26,W
1282:  MOVWF  7A
1283:  MOVF   25,W
1284:  MOVWF  04
1285:  MOVF   26,W
1286:  MOVWF  05
1287:  MOVF   00,W
1288:  MOVWF  31
1289:  MOVLW  20
128A:  MOVLB  01
128B:  MOVWF  61
128C:  MOVLW  73
128D:  MOVWF  60
128E:  MOVLW  5B
128F:  MOVLB  02
1290:  MOVWF  55
1291:  MOVLP  00
1292:  MOVLB  00
1293:  CALL   7F0
1294:  MOVLP  10
1295:  MOVF   75,W
1296:  MOVLB  02
1297:  MOVWF  32
1298:  MOVLW  01
1299:  MOVWF  33
129A:  MOVLB  00
129B:  CALL   079
129C:  MOVLW  5D
129D:  MOVLB  02
129E:  MOVWF  55
129F:  MOVLP  00
12A0:  MOVLB  00
12A1:  CALL   7F0
12A2:  MOVLP  10
12A3:  MOVLW  20
12A4:  MOVLB  02
12A5:  MOVWF  55
12A6:  MOVLP  00
12A7:  MOVLB  00
12A8:  CALL   7F0
12A9:  MOVLP  10
12AA:  MOVLW  20
12AB:  MOVWF  05
12AC:  MOVLW  AB
12AD:  MOVWF  04
12AE:  MOVLP  08
12AF:  CALL   1BB
12B0:  MOVLP  10
12B1:  MOVLW  20
12B2:  MOVLB  02
12B3:  MOVWF  55
12B4:  MOVLP  00
12B5:  MOVLB  00
12B6:  CALL   7F0
12B7:  MOVLP  10
12B8:  MOVLB  02
12B9:  MOVF   31,W
12BA:  MOVWF  32
12BB:  MOVLW  1B
12BC:  MOVWF  33
12BD:  MOVLB  00
12BE:  CALL   079
12BF:  MOVLW  0A
12C0:  MOVLB  02
12C1:  MOVWF  55
12C2:  MOVLP  00
12C3:  MOVLB  00
12C4:  CALL   7F0
12C5:  MOVLP  10
12C6:  MOVLW  0D
12C7:  MOVLB  02
12C8:  MOVWF  55
12C9:  MOVLP  00
12CA:  MOVLB  00
12CB:  CALL   7F0
12CC:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
12CD:  MOVLW  0A
12CE:  CLRWDT
12CF:  BTFSS  11.4
12D0:  GOTO   2CE
12D1:  MOVLB  03
12D2:  MOVWF  1A
12D3:  MOVLW  0D
12D4:  CLRWDT
12D5:  MOVLB  00
12D6:  BTFSC  11.4
12D7:  GOTO   2DA
12D8:  MOVLB  03
12D9:  GOTO   2D4
12DA:  MOVLB  03
12DB:  MOVWF  1A
12DC:  MOVLW  20
12DD:  MOVWF  05
12DE:  MOVLW  73
12DF:  MOVWF  04
12E0:  MOVLP  08
12E1:  MOVLB  00
12E2:  CALL   2A5
12E3:  MOVLP  10
....................       lcd_send(2,LCD_str); 
12E4:  MOVLW  02
12E5:  MOVLB  02
12E6:  MOVWF  4F
12E7:  MOVLW  20
12E8:  MOVWF  51
12E9:  MOVLW  73
12EA:  MOVWF  50
12EB:  MOVLP  08
12EC:  MOVLB  00
12ED:  CALL   1D2
12EE:  MOVLP  10
....................       prompt(); 
12EF:  CALL   0C2
....................       break; 
12F0:  GOTO   577
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
12F1:  CALL   027
12F2:  MOVF   78,F
12F3:  BTFSC  03.2
12F4:  GOTO   2F8
....................         store_variables(); 
12F5:  MOVLP  00
12F6:  CALL   61C
12F7:  MOVLP  10
....................       } 
....................       break; 
12F8:  GOTO   577
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
12F9:  DECFSZ 76,W
12FA:  GOTO   2FF
....................         init_src=USE_EEPROM_VARS; 
12FB:  MOVLB  02
12FC:  BSF    27.0
....................       } else { 
12FD:  GOTO   301
12FE:  MOVLB  00
....................         init_src=USE_DEFAULT_VARS; 
12FF:  MOVLB  02
1300:  BCF    27.0
....................       } 
....................       if ( in_admin_mode() ) { 
1301:  MOVLB  00
1302:  CALL   027
1303:  MOVF   78,F
1304:  BTFSC  03.2
1305:  GOTO   310
....................         init_variables(init_src); 
1306:  MOVLW  00
1307:  MOVLB  02
1308:  BTFSC  27.0
1309:  MOVLW  01
130A:  MOVWF  31
130B:  MOVWF  32
130C:  MOVLP  00
130D:  MOVLB  00
130E:  CALL   697
130F:  MOVLP  10
....................       } 
....................       break; 
1310:  GOTO   577
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1311:  MOVF   75,W
1312:  ANDLW  03
1313:  MOVWF  74
....................       increment(value); 
1314:  MOVF   76,W
1315:  MOVLB  02
1316:  MOVWF  34
1317:  MOVLB  00
1318:  CALL   036
....................       PROMPT_FLAG=1; 
1319:  MOVLB  01
131A:  BSF    5A.5
....................       break; 
131B:  MOVLB  00
131C:  GOTO   577
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
131D:  MOVF   75,W
131E:  ANDLW  03
131F:  MOVWF  74
....................       increment(-1*value); 
1320:  MOVLW  FF
1321:  MOVLB  02
1322:  MOVWF  48
1323:  MOVF   76,W
1324:  MOVWF  49
1325:  MOVLP  08
1326:  MOVLB  00
1327:  CALL   6EE
1328:  MOVLP  10
1329:  MOVF   78,W
132A:  MOVLB  02
132B:  MOVWF  31
132C:  MOVWF  34
132D:  MOVLB  00
132E:  CALL   036
....................       PROMPT_FLAG=1; 
132F:  MOVLB  01
1330:  BSF    5A.5
....................       break; 
1331:  MOVLB  00
1332:  GOTO   577
....................     case STATUS: 
....................       status(); 
....................       break; 
*
14F4:  MOVLB  00
14F5:  GOTO   577
....................     case ADMIN: 
....................       switch(argument) { 
14F6:  MOVF   75,W
14F7:  XORLW  02
14F8:  BTFSC  03.2
14F9:  GOTO   501
14FA:  XORLW  03
14FB:  BTFSC  03.2
14FC:  GOTO   506
14FD:  XORLW  02
14FE:  BTFSC  03.2
14FF:  GOTO   50E
1500:  GOTO   510
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
1501:  CALL   027
1502:  MOVF   78,F
1503:  BTFSS  03.2
....................             reset_cpu(); 
1504:  RESET
....................           } 
....................           break; 
1505:  GOTO   516
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
1506:  MOVLW  01
1507:  MOVLB  02
1508:  MOVWF  45
1509:  MOVLP  08
150A:  MOVLB  00
150B:  CALL   513
150C:  MOVLP  10
....................           break; 
150D:  GOTO   516
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
150E:  CALL   0DA
....................         break; 
150F:  GOTO   516
....................         default: 
....................           set_admin_mode(0); 
1510:  MOVLB  02
1511:  CLRF   45
1512:  MOVLP  08
1513:  MOVLB  00
1514:  CALL   513
1515:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
1516:  GOTO   577
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
....................       lcd_cmd=4+(value&0x03); 
1517:  MOVF   76,W
1518:  ANDLW  03
1519:  ADDLW  04
151A:  MOVLB  02
151B:  MOVWF  28
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
151C:  MOVLW  20
151D:  MOVLB  01
151E:  MOVWF  61
151F:  MOVLW  73
1520:  MOVWF  60
1521:  MOVLW  2D
1522:  MOVLB  03
1523:  MOVWF  11
1524:  MOVLW  04
1525:  MOVWF  12
1526:  BCF    03.0
1527:  MOVLW  04
1528:  MOVLB  02
1529:  MOVWF  4F
152A:  MOVLP  08
152B:  MOVLB  00
152C:  CALL   164
152D:  MOVLP  10
152E:  MOVLW  60
152F:  MOVLB  02
1530:  MOVWF  4F
1531:  MOVLW  18
1532:  MOVWF  50
1533:  MOVLP  08
1534:  MOVLB  00
1535:  CALL   236
1536:  MOVLP  10
1537:  MOVLW  30
1538:  MOVLB  03
1539:  MOVWF  11
153A:  MOVLW  04
153B:  MOVWF  12
153C:  BCF    03.0
153D:  MOVLW  08
153E:  MOVLB  02
153F:  MOVWF  4F
1540:  MOVLP  08
1541:  MOVLB  00
1542:  CALL   164
1543:  MOVLP  10
1544:  MOVLB  02
1545:  MOVF   28,W
1546:  MOVWF  4F
1547:  MOVLW  18
1548:  MOVWF  50
1549:  MOVLP  08
154A:  MOVLB  00
154B:  CALL   236
154C:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
154D:  MOVLW  0A
154E:  CLRWDT
154F:  BTFSS  11.4
1550:  GOTO   54E
1551:  MOVLB  03
1552:  MOVWF  1A
1553:  MOVLW  0D
1554:  CLRWDT
1555:  MOVLB  00
1556:  BTFSC  11.4
1557:  GOTO   55A
1558:  MOVLB  03
1559:  GOTO   554
155A:  MOVLB  03
155B:  MOVWF  1A
155C:  MOVLW  20
155D:  MOVWF  05
155E:  MOVLW  73
155F:  MOVWF  04
1560:  MOVLP  08
1561:  MOVLB  00
1562:  CALL   2A5
1563:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
1564:  MOVLB  02
1565:  MOVF   28,W
1566:  MOVWF  4F
1567:  MOVLW  20
1568:  MOVWF  51
1569:  MOVLW  73
156A:  MOVWF  50
156B:  MOVLP  08
156C:  MOVLB  00
156D:  CALL   1D2
156E:  MOVLP  10
....................       break; 
156F:  GOTO   577
....................     case MORSE_SEND: 
....................       morse(value); 
1570:  MOVF   76,W
1571:  MOVLB  02
1572:  MOVWF  44
1573:  MOVLP  08
1574:  MOVLB  00
1575:  CALL   0E9
1576:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
1577:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  4F
1803:  MOVLW  20
1804:  MOVWF  51
1805:  MOVLW  4D
1806:  MOVWF  50
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   1D2
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVWF  75
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B62:  MOVLB  01
1B63:  CLRF   6C
1B64:  CLRF   6B
1B65:  MOVF   6C,F
1B66:  BTFSS  03.2
1B67:  GOTO   3B6
1B68:  MOVF   6B,W
1B69:  SUBLW  37
1B6A:  BTFSS  03.0
1B6B:  GOTO   3B6
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B6C:  MOVLW  01
1B6D:  MOVWF  7A
1B6E:  MOVLW  8B
1B6F:  MOVLB  02
1B70:  MOVWF  25
1B71:  MOVF   7A,W
1B72:  MOVWF  26
1B73:  MOVLB  01
1B74:  MOVF   6C,W
1B75:  MOVLB  02
1B76:  MOVWF  43
1B77:  MOVLB  01
1B78:  MOVF   6B,W
1B79:  MOVLB  02
1B7A:  MOVWF  42
1B7B:  CLRF   45
1B7C:  MOVLW  06
1B7D:  MOVWF  44
1B7E:  MOVLP  08
1B7F:  MOVLB  00
1B80:  CALL   7E5
1B81:  MOVLP  18
1B82:  MOVF   78,W
1B83:  MOVLB  02
1B84:  ADDWF  25,W
1B85:  MOVLB  01
1B86:  MOVWF  6D
1B87:  MOVF   79,W
1B88:  MOVLB  02
1B89:  ADDWFC 26,W
1B8A:  MOVLB  01
1B8B:  MOVWF  6E
....................     romstrcpy(rname,cPtr); 
1B8C:  MOVLW  20
1B8D:  MOVLB  02
1B8E:  MOVWF  41
1B8F:  MOVLW  9F
1B90:  MOVWF  40
1B91:  MOVLB  01
1B92:  MOVF   6E,W
1B93:  MOVLB  02
1B94:  MOVWF  43
1B95:  MOVLB  01
1B96:  MOVF   6D,W
1B97:  MOVLB  02
1B98:  MOVWF  42
1B99:  MOVLP  10
1B9A:  MOVLB  00
1B9B:  CALL   000
1B9C:  MOVLP  18
....................     if(stricmp(argument_name,rname)==0) { 
1B9D:  MOVLW  20
1B9E:  MOVLB  02
1B9F:  MOVWF  45
1BA0:  MOVLW  6D
1BA1:  MOVWF  44
1BA2:  MOVLW  20
1BA3:  MOVWF  47
1BA4:  MOVLW  9F
1BA5:  MOVWF  46
1BA6:  MOVLP  08
1BA7:  MOVLB  00
1BA8:  CALL   74E
1BA9:  MOVLP  18
1BAA:  MOVF   78,F
1BAB:  BTFSS  03.2
1BAC:  GOTO   3B1
....................       argument=x; 
1BAD:  MOVLB  01
1BAE:  MOVF   6B,W
1BAF:  MOVWF  75
1BB0:  MOVLB  00
....................     } 
....................   } 
1BB1:  MOVLB  01
1BB2:  INCF   6B,F
1BB3:  BTFSC  03.2
1BB4:  INCF   6C,F
1BB5:  GOTO   365
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BB6:  MOVF   75,W
1BB7:  SUBLW  FF
1BB8:  BTFSS  03.2
1BB9:  GOTO   41A
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BBA:  MOVLW  20
1BBB:  MOVLB  02
1BBC:  MOVWF  45
1BBD:  MOVLW  6D
1BBE:  MOVWF  44
1BBF:  MOVLP  08
1BC0:  MOVLB  00
1BC1:  CALL   715
1BC2:  MOVLP  18
1BC3:  MOVF   78,W
1BC4:  MOVWF  76
....................     strcpy(rname,"eeprom"); 
1BC5:  MOVLB  02
1BC6:  CLRF   25
1BC7:  CLRF   26
1BC8:  MOVLW  20
1BC9:  MOVWF  05
1BCA:  MOVLW  9F
1BCB:  MOVWF  04
1BCC:  MOVF   25,W
1BCD:  ADDWF  04,F
1BCE:  MOVLW  00
1BCF:  ADDWFC 05,F
1BD0:  MOVF   26,W
1BD1:  MOVLP  00
1BD2:  MOVLB  00
1BD3:  CALL   124
1BD4:  MOVLP  18
1BD5:  MOVWF  00
1BD6:  IORLW  00
1BD7:  BTFSC  03.2
1BD8:  GOTO   3DE
1BD9:  MOVLB  02
1BDA:  INCF   26,F
1BDB:  INCF   25,F
1BDC:  GOTO   3C8
1BDD:  MOVLB  00
....................     if(stricmp(argument_name,rname)==0) { 
1BDE:  MOVLW  20
1BDF:  MOVLB  02
1BE0:  MOVWF  45
1BE1:  MOVLW  6D
1BE2:  MOVWF  44
1BE3:  MOVLW  20
1BE4:  MOVWF  47
1BE5:  MOVLW  9F
1BE6:  MOVWF  46
1BE7:  MOVLP  08
1BE8:  MOVLB  00
1BE9:  CALL   74E
1BEA:  MOVLP  18
1BEB:  MOVF   78,F
1BEC:  BTFSS  03.2
1BED:  GOTO   3F0
....................       value=USE_EEPROM_VARS; 
1BEE:  MOVLW  01
1BEF:  MOVWF  76
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BF0:  MOVLB  02
1BF1:  CLRF   25
1BF2:  CLRF   26
1BF3:  MOVLW  20
1BF4:  MOVWF  05
1BF5:  MOVLW  9F
1BF6:  MOVWF  04
1BF7:  MOVF   25,W
1BF8:  ADDWF  04,F
1BF9:  MOVLW  00
1BFA:  ADDWFC 05,F
1BFB:  MOVF   26,W
1BFC:  MOVLP  00
1BFD:  MOVLB  00
1BFE:  CALL   12C
1BFF:  MOVLP  18
1C00:  MOVWF  00
1C01:  IORLW  00
1C02:  BTFSC  03.2
1C03:  GOTO   409
1C04:  MOVLB  02
1C05:  INCF   26,F
1C06:  INCF   25,F
1C07:  GOTO   3F3
1C08:  MOVLB  00
....................     if(stricmp(argument_name,rname)==0) { 
1C09:  MOVLW  20
1C0A:  MOVLB  02
1C0B:  MOVWF  45
1C0C:  MOVLW  6D
1C0D:  MOVWF  44
1C0E:  MOVLW  20
1C0F:  MOVWF  47
1C10:  MOVLW  9F
1C11:  MOVWF  46
1C12:  MOVLP  08
1C13:  MOVLB  00
1C14:  CALL   74E
1C15:  MOVLP  18
1C16:  MOVF   78,F
1C17:  BTFSC  03.2
....................       value=USE_DEFAULT_VARS; 
1C18:  CLRF   76
1C19:  MOVLB  01
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C1A:  MOVF   70,W
1C1B:  SUBLW  06
1C1C:  BTFSC  03.2
1C1D:  GOTO   422
1C1E:  MOVF   70,W
1C1F:  SUBLW  07
1C20:  BTFSS  03.2
1C21:  GOTO   426
....................     value = 1; 
1C22:  MOVLW  01
1C23:  MOVWF  76
....................     argument = CurrentTrimPot; 
1C24:  MOVF   74,W
1C25:  MOVWF  75
....................   } 
....................   rs232_mode = 1; 
1C26:  BSF    5A.7
....................   execute_command(); 
1C27:  MOVLP  10
1C28:  MOVLB  00
1C29:  CALL   11C
1C2A:  MOVLP  18
....................   rs232_mode = 0; 
1C2B:  MOVLB  01
1C2C:  BCF    5A.7
.................... } // }}} 
1C2D:  MOVLP  18
1C2E:  MOVLB  00
1C2F:  GOTO   6A2 (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
1333:  MOVLW  1B
1334:  MOVLP  00
1335:  CALL   2DA
1336:  MOVLP  10
....................   printf("[2J"); 
1337:  MOVLW  5B
1338:  CLRWDT
1339:  BTFSS  11.4
133A:  GOTO   338
133B:  MOVLB  03
133C:  MOVWF  1A
133D:  MOVLW  32
133E:  CLRWDT
133F:  MOVLB  00
1340:  BTFSC  11.4
1341:  GOTO   344
1342:  MOVLB  03
1343:  GOTO   33E
1344:  MOVLB  03
1345:  MOVWF  1A
1346:  MOVLW  4A
1347:  CLRWDT
1348:  MOVLB  00
1349:  BTFSC  11.4
134A:  GOTO   34D
134B:  MOVLB  03
134C:  GOTO   347
134D:  MOVLB  03
134E:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
134F:  MOVLW  1B
1350:  MOVLP  00
1351:  MOVLB  00
1352:  CALL   2DA
1353:  MOVLP  10
....................   printf("[0;0H"); 
1354:  MOVLW  36
1355:  MOVLB  03
1356:  MOVWF  11
1357:  MOVLW  04
1358:  MOVWF  12
1359:  MOVLP  00
135A:  MOVLB  00
135B:  CALL   529
135C:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
0800:  MOVLB  02
0801:  SWAPF  44,W
0802:  MOVWF  46
0803:  RLF    46,F
0804:  RLF    46,F
0805:  MOVLW  C0
0806:  ANDWF  46,F
....................   tx_value=tx_value + (value & 0x3F); 
0807:  MOVF   45,W
0808:  ANDLW  3F
0809:  ADDWF  46,F
....................   i2c_start(); 
080A:  MOVLB  04
080B:  BSF    16.0
080C:  BTFSC  16.0
080D:  GOTO   00C
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
080E:  MOVLW  50
080F:  MOVLB  02
0810:  MOVWF  55
0811:  MOVLP  00
0812:  MOVLB  00
0813:  CALL   6EC
0814:  MOVLP  08
0815:  MOVF   78,W
0816:  MOVLB  02
0817:  BCF    47.0
0818:  BTFSC  78.0
0819:  BSF    47.0
....................   if ( ack != 0) { 
081A:  BTFSS  47.0
081B:  GOTO   037
....................     printf("\n\rI2C : No ACK : %u",ack); 
081C:  MOVLW  00
081D:  BTFSC  47.0
081E:  MOVLW  01
081F:  MOVWF  48
0820:  MOVLW  39
0821:  MOVLB  03
0822:  MOVWF  11
0823:  MOVLW  04
0824:  MOVWF  12
0825:  BCF    03.0
0826:  MOVLW  11
0827:  MOVLB  02
0828:  MOVWF  55
0829:  MOVLP  00
082A:  MOVLB  00
082B:  CALL   701
082C:  MOVLP  08
082D:  MOVLB  02
082E:  MOVF   48,W
082F:  MOVWF  55
0830:  MOVLW  1B
0831:  MOVWF  56
0832:  MOVLP  00
0833:  MOVLB  00
0834:  CALL   775
0835:  MOVLP  08
0836:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
0837:  MOVF   46,W
0838:  MOVWF  55
0839:  MOVLP  00
083A:  MOVLB  00
083B:  CALL   6EC
083C:  MOVLP  08
....................   i2c_stop();   
083D:  MOVLB  04
083E:  BSF    16.2
083F:  BTFSC  16.2
0840:  GOTO   03F
....................   printf("\n\rPot(%u)<=%u",pot,value); 
0841:  MOVLW  43
0842:  MOVLB  03
0843:  MOVWF  11
0844:  MOVLW  04
0845:  MOVWF  12
0846:  BCF    03.0
0847:  MOVLW  06
0848:  MOVLB  02
0849:  MOVWF  55
084A:  MOVLP  00
084B:  MOVLB  00
084C:  CALL   701
084D:  MOVLP  08
084E:  MOVLB  02
084F:  MOVF   44,W
0850:  MOVWF  55
0851:  MOVLW  1B
0852:  MOVWF  56
0853:  MOVLP  00
0854:  MOVLB  00
0855:  CALL   775
0856:  MOVLP  08
0857:  MOVLW  29
0858:  CLRWDT
0859:  BTFSS  11.4
085A:  GOTO   058
085B:  MOVLB  03
085C:  MOVWF  1A
085D:  MOVLW  3C
085E:  CLRWDT
085F:  MOVLB  00
0860:  BTFSC  11.4
0861:  GOTO   064
0862:  MOVLB  03
0863:  GOTO   05E
0864:  MOVLB  03
0865:  MOVWF  1A
0866:  MOVLW  3D
0867:  CLRWDT
0868:  MOVLB  00
0869:  BTFSC  11.4
086A:  GOTO   06D
086B:  MOVLB  03
086C:  GOTO   067
086D:  MOVLB  03
086E:  MOVWF  1A
086F:  MOVLB  02
0870:  MOVF   45,W
0871:  MOVWF  55
0872:  MOVLW  1B
0873:  MOVWF  56
0874:  MOVLP  00
0875:  MOVLB  00
0876:  CALL   775
0877:  MOVLP  08
....................  
.................... } // }}} 
0878:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
08E9:  MOVLW  DB
08EA:  MOVLB  02
08EB:  ADDWF  44,W
08EC:  MOVWF  48
08ED:  MOVLW  1F
08EE:  MOVWF  49
08EF:  BTFSC  03.0
08F0:  INCF   49,F
08F1:  MOVF   49,W
08F2:  MOVLB  03
08F3:  MOVWF  12
08F4:  MOVLB  02
08F5:  MOVF   48,W
08F6:  MOVLB  03
08F7:  MOVWF  11
08F8:  MOVLW  20
08F9:  MOVWF  05
08FA:  MOVLW  C5
08FB:  MOVWF  04
08FC:  MOVLW  01
08FD:  MOVLB  02
08FE:  MOVWF  4A
08FF:  MOVLP  00
0900:  MOVLB  00
0901:  CALL   7DD
0902:  MOVLP  08
....................    
....................   PROMPT_FLAG=1; 
0903:  MOVLB  01
0904:  BSF    5A.5
....................   for(x=0;x<4;x++) { 
0905:  MOVLB  02
0906:  CLRF   46
0907:  MOVF   46,W
0908:  SUBLW  03
0909:  BTFSS  03.0
090A:  GOTO   131
....................     do_delay=1; 
090B:  BSF    47.0
....................     switch(mc & 0xc0) { // Check two MSB's 
090C:  MOVF   45,W
090D:  ANDLW  C0
090E:  XORLW  40
090F:  MOVLB  00
0910:  BTFSC  03.2
0911:  GOTO   116
0912:  XORLW  C0
0913:  BTFSC  03.2
0914:  GOTO   118
0915:  GOTO   11A
....................       case(0x40): 
....................         dit(); 
0916:  CALL   079
....................         break; 
0917:  GOTO   11D
....................       case(0x80): 
....................         dah(); 
0918:  CALL   0B1
....................         break; 
0919:  GOTO   11D
....................       default: 
....................         do_delay=0; 
091A:  MOVLB  02
091B:  BCF    47.0
....................         break; 
091C:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
091D:  MOVLB  02
091E:  RLF    45,F
091F:  RLF    45,F
0920:  MOVLW  FC
0921:  ANDWF  45,F
....................     if ( do_delay ) { 
0922:  BTFSS  47.0
0923:  GOTO   12F
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
0924:  MOVLB  01
0925:  CLRF   30
0926:  MOVLW  02
0927:  MOVWF  2F
....................       while(aux_timer) { 
0928:  MOVF   2F,W
0929:  IORWF  30,W
092A:  BTFSC  03.2
092B:  GOTO   12E
....................         delay_cycles(1); 
092C:  NOP
....................       } 
092D:  GOTO   128
092E:  MOVLB  02
....................     } 
....................   } 
092F:  INCF   46,F
0930:  GOTO   107
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
0931:  MOVF   44,W
0932:  SUBLW  09
0933:  BTFSS  03.0
0934:  GOTO   140
....................     if ( c < 5 ) { 
0935:  MOVF   44,W
0936:  SUBLW  04
0937:  BTFSS  03.0
0938:  GOTO   13D
....................       dah(); 
0939:  MOVLB  00
093A:  CALL   0B1
....................     } 
....................     else { 
093B:  GOTO   13F
093C:  MOVLB  02
....................       dit(); 
093D:  MOVLB  00
093E:  CALL   079
093F:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
0940:  MOVLB  00
0941:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0BC1:  MOVLW  30
0BC2:  MOVLB  02
0BC3:  MOVWF  39
0BC4:  MOVWF  3A
0BC5:  MOVWF  3B
0BC6:  MOVWF  3C
0BC7:  CLRF   3D
....................   char PTT_s[5]={'0','0','0','0',0}; 
0BC8:  MOVWF  3E
0BC9:  MOVWF  3F
0BCA:  MOVWF  40
0BCB:  MOVWF  41
0BCC:  CLRF   42
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0BCD:  MOVF   33,W
0BCE:  MOVLB  00
0BCF:  MOVWF  6B
....................  
....................   if ( cor ) { 
0BD0:  MOVLB  02
0BD1:  MOVF   33,F
0BD2:  BTFSC  03.2
0BD3:  GOTO   3E5
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0BD4:  MOVLW  01
0BD5:  SUBWF  33,W
0BD6:  ADDLW  29
0BD7:  MOVWF  04
0BD8:  MOVLW  20
0BD9:  MOVWF  05
0BDA:  BTFSC  03.0
0BDB:  INCF   05,F
0BDC:  MOVF   00,W
0BDD:  MOVWF  44
0BDE:  MOVLB  00
0BDF:  MOVF   60,W
0BE0:  ANDWF  61,W
0BE1:  MOVLB  02
0BE2:  ANDWF  44,W
0BE3:  MOVWF  38
....................   } else { 
0BE4:  GOTO   42E
....................     ptt=0; 
0BE5:  CLRF   38
....................     if ( COR_DROP_FLAG ) { 
0BE6:  BTFSS  72.7
0BE7:  GOTO   42E
....................       COR_DROP_FLAG=0; 
0BE8:  BCF    72.7
....................       if ( ConfirmChar || TailChar ) { 
0BE9:  MOVLB  00
0BEA:  MOVF   69,F
0BEB:  BTFSS  03.2
0BEC:  GOTO   3F0
0BED:  MOVF   68,F
0BEE:  BTFSC  03.2
0BEF:  GOTO   42D
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0C2E:  MOVLW  01
0C2F:  MOVWF  37
....................   for(x=0;x<4;x++) { 
0C30:  CLRF   34
0C31:  MOVF   34,W
0C32:  SUBLW  03
0C33:  BTFSS  03.0
0C34:  GOTO   499
....................     if ( !cor ) { 
0C35:  MOVF   33,F
0C36:  BTFSS  03.2
0C37:  GOTO   43B
....................       rx_bit=0; 
0C38:  BCF    43.0
....................       ptt_bit=0; 
0C39:  BCF    43.1
....................     } else { 
0C3A:  GOTO   44E
....................       if ( cor == (x+1) ) { 
0C3B:  MOVLW  01
0C3C:  ADDWF  34,W
0C3D:  SUBWF  33,W
0C3E:  BTFSS  03.2
0C3F:  GOTO   446
....................         rx_bit=1; 
0C40:  BSF    43.0
....................         CurrentCorMask=mask; 
0C41:  MOVF   37,W
0C42:  MOVLB  00
0C43:  MOVWF  6A
....................       } else { 
0C44:  GOTO   448
0C45:  MOVLB  02
....................         rx_bit=0; 
0C46:  BCF    43.0
0C47:  MOVLB  00
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0C48:  MOVLB  02
0C49:  BCF    43.1
0C4A:  MOVF   38,W
0C4B:  ANDWF  37,W
0C4C:  BTFSS  03.2
0C4D:  BSF    43.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0C4E:  MOVF   34,W
0C4F:  MOVLP  00
0C50:  MOVLB  00
0C51:  CALL   031
0C52:  MOVLP  08
0C53:  MOVLB  02
0C54:  MOVWF  44
0C55:  MOVLW  00
0C56:  BTFSC  43.0
0C57:  MOVLW  01
0C58:  MOVWF  77
0C59:  MOVF   44,W
0C5A:  MOVWF  45
0C5B:  MOVF   77,W
0C5C:  MOVWF  46
0C5D:  MOVLW  01
0C5E:  MOVWF  48
0C5F:  CLRF   47
0C60:  MOVLB  00
0C61:  CALL   142
0C62:  MOVLB  02
0C63:  MOVF   44,W
0C64:  MOVWF  45
0C65:  CLRF   46
0C66:  CLRF   48
0C67:  MOVLW  80
0C68:  MOVWF  47
0C69:  MOVLB  00
0C6A:  CALL   142
....................     output_bit(PTT_PIN[x],ptt_bit); 
0C6B:  MOVLB  02
0C6C:  MOVF   34,W
0C6D:  MOVLP  00
0C6E:  MOVLB  00
0C6F:  CALL   036
0C70:  MOVLP  08
0C71:  MOVLB  02
0C72:  MOVWF  44
0C73:  MOVLW  00
0C74:  BTFSC  43.1
0C75:  MOVLW  01
0C76:  MOVWF  77
0C77:  MOVF   44,W
0C78:  MOVWF  45
0C79:  MOVF   77,W
0C7A:  MOVWF  46
0C7B:  MOVLW  01
0C7C:  MOVWF  48
0C7D:  CLRF   47
0C7E:  MOVLB  00
0C7F:  CALL   142
0C80:  MOVLB  02
0C81:  MOVF   44,W
0C82:  MOVWF  45
0C83:  CLRF   46
0C84:  CLRF   48
0C85:  MOVLW  80
0C86:  MOVWF  47
0C87:  MOVLB  00
0C88:  CALL   142
....................     if(ptt_bit) { 
0C89:  MOVLB  02
0C8A:  BTFSS  43.1
0C8B:  GOTO   495
....................       PTT_s[x]='1'; 
0C8C:  MOVLW  BE
0C8D:  ADDWF  34,W
0C8E:  MOVWF  04
0C8F:  MOVLW  20
0C90:  MOVWF  05
0C91:  BTFSC  03.0
0C92:  INCF   05,F
0C93:  MOVLW  31
0C94:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C95:  BCF    03.0
0C96:  RLF    37,F
....................   }  
0C97:  INCF   34,F
0C98:  GOTO   431
....................   if(!cor) { 
0C99:  MOVF   33,F
0C9A:  BTFSS  03.2
0C9B:  GOTO   4A0
....................     CurrentCorPriority=0; 
0C9C:  MOVLB  00
0C9D:  CLRF   6C
....................   } else { 
0C9E:  GOTO   4CE
0C9F:  MOVLB  02
....................     CurrentCorPriority=RXPriority[cor-1]; 
0CA0:  MOVLW  01
0CA1:  SUBWF  33,W
0CA2:  ADDLW  25
0CA3:  MOVWF  04
0CA4:  MOVLW  20
0CA5:  MOVWF  05
0CA6:  BTFSC  03.0
0CA7:  INCF   05,F
0CA8:  MOVF   00,W
0CA9:  MOVLB  00
0CAA:  MOVWF  6C
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0CAB:  MOVLB  02
0CAC:  CLRF   35
0CAD:  MOVF   35,W
0CAE:  SUBLW  03
0CAF:  BTFSS  03.0
0CB0:  GOTO   4CB
....................       pot_val=RX_GAIN[cor-1][pot]; 
0CB1:  MOVLW  01
0CB2:  SUBWF  33,W
0CB3:  MOVWF  77
0CB4:  RLF    77,F
0CB5:  RLF    77,F
0CB6:  MOVLW  FC
0CB7:  ANDWF  77,F
0CB8:  MOVF   77,W
0CB9:  ADDWF  35,W
0CBA:  ADDLW  0C
0CBB:  MOVWF  04
0CBC:  MOVLW  20
0CBD:  MOVWF  05
0CBE:  BTFSC  03.0
0CBF:  INCF   05,F
0CC0:  MOVF   00,W
0CC1:  MOVWF  36
....................       set_trimpot(pot,pot_val); 
0CC2:  MOVF   35,W
0CC3:  MOVWF  44
0CC4:  MOVF   36,W
0CC5:  MOVWF  45
0CC6:  MOVLB  00
0CC7:  CALL   000
....................     } 
0CC8:  MOVLB  02
0CC9:  INCF   35,F
0CCA:  GOTO   4AD
....................     PROMPT_FLAG=1; 
0CCB:  MOVLB  01
0CCC:  BSF    5A.5
0CCD:  MOVLB  00
....................   } 
....................   if(cor>0) { 
0CCE:  MOVLB  02
0CCF:  MOVF   33,F
0CD0:  BTFSC  03.2
0CD1:  GOTO   4DC
....................     COR_s[cor-1]='1'; 
0CD2:  MOVLW  01
0CD3:  SUBWF  33,W
0CD4:  ADDLW  B9
0CD5:  MOVWF  04
0CD6:  MOVLW  20
0CD7:  MOVWF  05
0CD8:  BTFSC  03.0
0CD9:  INCF   05,F
0CDA:  MOVLW  31
0CDB:  MOVWF  00
....................   } 
....................   sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0CDC:  MOVLW  20
0CDD:  MOVLB  01
0CDE:  MOVWF  61
0CDF:  MOVLW  73
0CE0:  MOVWF  60
0CE1:  MOVLW  4A
0CE2:  MOVLB  03
0CE3:  MOVWF  11
0CE4:  MOVLW  04
0CE5:  MOVWF  12
0CE6:  BCF    03.0
0CE7:  MOVLW  04
0CE8:  MOVLB  02
0CE9:  MOVWF  4F
0CEA:  MOVLB  00
0CEB:  CALL   164
0CEC:  MOVLW  20
0CED:  MOVWF  05
0CEE:  MOVLW  B9
0CEF:  MOVWF  04
0CF0:  CALL   1BB
0CF1:  MOVLW  4D
0CF2:  MOVLB  03
0CF3:  MOVWF  11
0CF4:  MOVLW  04
0CF5:  MOVWF  12
0CF6:  BCF    03.0
0CF7:  MOVLW  05
0CF8:  MOVLB  02
0CF9:  MOVWF  4F
0CFA:  MOVLB  00
0CFB:  CALL   164
0CFC:  MOVLW  20
0CFD:  MOVWF  05
0CFE:  MOVLW  BE
0CFF:  MOVWF  04
0D00:  CALL   1BB
....................   lcd_send(1,LCD_str); // COR/PTT on line 1 
0D01:  MOVLW  01
0D02:  MOVLB  02
0D03:  MOVWF  4F
0D04:  MOVLW  20
0D05:  MOVWF  51
0D06:  MOVLW  73
0D07:  MOVWF  50
0D08:  MOVLB  00
0D09:  CALL   1D2
....................   delay_ms(50); 
0D0A:  MOVLW  32
0D0B:  MOVLB  02
0D0C:  MOVWF  4F
0D0D:  MOVLP  00
0D0E:  MOVLB  00
0D0F:  CALL   7C4
0D10:  MOVLP  08
....................   pot_values_to_lcd(); 
0D11:  CALL   2BF
.................... }// }}} 
0D12:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1D3A:  MOVF   6D,W
1D3B:  SUBLW  0A
1D3C:  BTFSS  03.0
1D3D:  GOTO   558
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1D3E:  MOVLW  61
1D3F:  ADDWF  6D,W
1D40:  MOVWF  04
1D41:  MOVLW  20
1D42:  MOVWF  05
1D43:  BTFSC  03.0
1D44:  INCF   05,F
1D45:  BTFSS  00.4
1D46:  GOTO   556
1D47:  MOVLW  61
1D48:  ADDWF  6D,W
1D49:  MOVWF  04
1D4A:  MOVLW  20
1D4B:  MOVWF  05
1D4C:  BTFSC  03.0
1D4D:  INCF   05,F
1D4E:  MOVF   00,W
1D4F:  ANDLW  0F
1D50:  SUBLW  0C
1D51:  BTFSC  03.2
1D52:  GOTO   556
....................       strobe=1; 
1D53:  MOVLW  01
1D54:  MOVWF  6E
....................      } else { 
1D55:  GOTO   557
....................       strobe = 0; 
1D56:  CLRF   6E
....................     }  
....................   } else { 
1D57:  GOTO   559
....................     strobe=0; 
1D58:  CLRF   6E
....................   } 
....................   return(strobe); 
1D59:  MOVF   6E,W
1D5A:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
1CB3:  MOVLB  01
1CB4:  MOVF   6D,W
1CB5:  SUBWF  6E,W
1CB6:  BTFSS  03.0
1CB7:  GOTO   4EA
1CB8:  MOVF   6D,W
1CB9:  SUBLW  09
1CBA:  BTFSS  03.0
1CBB:  GOTO   4EA
....................     valid=1; 
1CBC:  MOVLB  02
1CBD:  BSF    21.0
....................     for(x=a;x<=b;x++) { 
1CBE:  MOVLB  01
1CBF:  MOVF   6D,W
1CC0:  MOVLB  02
1CC1:  MOVWF  20
1CC2:  MOVF   20,W
1CC3:  MOVLB  01
1CC4:  SUBWF  6E,W
1CC5:  BTFSS  03.0
1CC6:  GOTO   4E9
....................       key=(int)DTMF_ARRAY[x].Key; 
1CC7:  MOVLW  61
1CC8:  MOVLB  02
1CC9:  ADDWF  20,W
1CCA:  MOVWF  04
1CCB:  MOVLW  20
1CCC:  MOVWF  05
1CCD:  BTFSC  03.0
1CCE:  INCF   05,F
1CCF:  MOVF   00,W
1CD0:  ANDLW  0F
1CD1:  MOVLB  01
1CD2:  MOVWF  6F
....................       if(! DTMF_ARRAY[x].Strobe ) { 
1CD3:  MOVLW  61
1CD4:  MOVLB  02
1CD5:  ADDWF  20,W
1CD6:  MOVWF  04
1CD7:  MOVLW  20
1CD8:  MOVWF  05
1CD9:  BTFSC  03.0
1CDA:  INCF   05,F
1CDB:  BTFSS  00.4
....................         valid=0; 
1CDC:  BCF    21.0
....................       } 
....................      if(key==dp) { 
1CDD:  MOVLB  01
1CDE:  MOVF   6F,W
1CDF:  SUBLW  0C
1CE0:  BTFSS  03.2
1CE1:  GOTO   4E5
....................         valid=0; 
1CE2:  MOVLB  02
1CE3:  BCF    21.0
1CE4:  MOVLB  01
....................       } 
....................     } 
1CE5:  MOVLB  02
1CE6:  INCF   20,F
1CE7:  GOTO   4C2
1CE8:  MOVLB  01
....................   } else { 
1CE9:  GOTO   4ED
....................     valid=0; 
1CEA:  MOVLB  02
1CEB:  BCF    21.0
1CEC:  MOVLB  01
....................   } 
....................   return(valid); 
1CED:  MOVLW  00
1CEE:  MOVLB  02
1CEF:  BTFSC  21.0
1CF0:  MOVLW  01
1CF1:  MOVWF  78
.................... } // }}} 
1CF2:  MOVLB  00
1CF3:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   int site_id; 
....................   int digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : DTMF send 
....................   // 11 : Morse send 
....................   // 12 : Send to I2C 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   value = 0; 
1CF4:  CLRF   76
....................   command=0; 
1CF5:  CLRF   70
....................   if ( ValidKeyRange(0,5)) { 
1CF6:  MOVLB  01
1CF7:  CLRF   6D
1CF8:  MOVLW  05
1CF9:  MOVWF  6E
1CFA:  MOVLB  00
1CFB:  CALL   4B3
1CFC:  MOVF   78,F
1CFD:  BTFSC  03.2
1CFE:  GOTO   58A
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1CFF:  MOVLB  01
1D00:  MOVF   31,W
1D01:  ANDLW  0F
1D02:  MOVWF  6E
1D03:  MOVLB  02
1D04:  MOVWF  48
1D05:  MOVLW  0A
1D06:  MOVWF  49
1D07:  MOVLP  08
1D08:  MOVLB  00
1D09:  CALL   6EE
1D0A:  MOVLP  18
1D0B:  MOVF   78,W
1D0C:  MOVLB  01
1D0D:  MOVWF  6D
1D0E:  MOVF   32,W
1D0F:  ANDLW  0F
1D10:  ADDWF  6D,W
1D11:  MOVWF  6B
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1D12:  MOVF   33,W
1D13:  ANDLW  0F
1D14:  MOVWF  6E
1D15:  MOVLB  02
1D16:  MOVWF  48
1D17:  MOVLW  0A
1D18:  MOVWF  49
1D19:  MOVLP  08
1D1A:  MOVLB  00
1D1B:  CALL   6EE
1D1C:  MOVLP  18
1D1D:  MOVF   78,W
1D1E:  MOVLB  01
1D1F:  MOVWF  6D
1D20:  MOVF   34,W
1D21:  ANDLW  0F
1D22:  ADDWF  6D,W
1D23:  MOVWF  70
....................     argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1D24:  MOVF   35,W
1D25:  ANDLW  0F
1D26:  MOVWF  6E
1D27:  MOVLB  02
1D28:  MOVWF  48
1D29:  MOVLW  0A
1D2A:  MOVWF  49
1D2B:  MOVLP  08
1D2C:  MOVLB  00
1D2D:  CALL   6EE
1D2E:  MOVLP  18
1D2F:  MOVF   78,W
1D30:  MOVLB  01
1D31:  MOVWF  6D
1D32:  MOVF   36,W
1D33:  ANDLW  0F
1D34:  ADDWF  6D,W
1D35:  MOVWF  75
....................     digit=6; 
1D36:  MOVLW  06
1D37:  MOVWF  6C
....................     while(ValidKey(digit)) { 
1D38:  MOVF   6C,W
1D39:  MOVWF  6D
*
1D5B:  MOVF   78,F
1D5C:  BTFSC  03.2
1D5D:  GOTO   577
....................      value = value * 10 + DTMF_ARRAY[digit].Key; 
1D5E:  MOVF   76,W
1D5F:  MOVLB  02
1D60:  MOVWF  48
1D61:  MOVLW  0A
1D62:  MOVWF  49
1D63:  MOVLP  08
1D64:  MOVLB  00
1D65:  CALL   6EE
1D66:  MOVLP  18
1D67:  MOVF   78,W
1D68:  MOVLB  01
1D69:  MOVWF  6D
1D6A:  MOVLW  61
1D6B:  ADDWF  6C,W
1D6C:  MOVWF  04
1D6D:  MOVLW  20
1D6E:  MOVWF  05
1D6F:  BTFSC  03.0
1D70:  INCF   05,F
1D71:  MOVF   00,W
1D72:  ANDLW  0F
1D73:  ADDWF  6D,W
1D74:  MOVWF  76
....................      digit++; 
1D75:  INCF   6C,F
....................     } 
1D76:  GOTO   538
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1D77:  MOVF   70,W
1D78:  XORLW  04
1D79:  MOVLB  00
1D7A:  BTFSC  03.2
1D7B:  GOTO   57F
1D7C:  XORLW  01
1D7D:  BTFSS  03.2
1D7E:  GOTO   581
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1D7F:  MOVF   75,W
1D80:  MOVWF  76
....................         break; 
....................     } 
....................     if ( site_id == SiteID ) { 
1D81:  MOVF   63,W
1D82:  MOVLB  01
1D83:  SUBWF  6B,W
1D84:  BTFSS  03.2
1D85:  GOTO   58B
....................       execute_command(); 
1D86:  MOVLP  10
1D87:  MOVLB  00
1D88:  CALL   11C
1D89:  MOVLP  18
1D8A:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1D8B:  MOVF   31,W
1D8C:  ANDLW  0F
1D8D:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1D8E:  BTFSS  5A.6
1D8F:  GOTO   5C0
1D90:  CLRF   6D
1D91:  CLRF   6E
1D92:  MOVLB  00
1D93:  CALL   4B3
1D94:  MOVF   78,F
1D95:  BTFSS  03.2
1D96:  GOTO   599
1D97:  MOVLB  01
1D98:  GOTO   5C0
....................     restart_wdt(); 
1D99:  CLRWDT
....................     switch(command) { 
1D9A:  MOVF   70,W
1D9B:  XORLW  0E
1D9C:  BTFSC  03.2
1D9D:  GOTO   5A5
1D9E:  XORLW  01
1D9F:  BTFSC  03.2
1DA0:  GOTO   5AD
1DA1:  XORLW  05
1DA2:  BTFSC  03.2
1DA3:  GOTO   5B5
1DA4:  GOTO   5BC
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1DA5:  MOVLW  01
1DA6:  ADDWF  74,W
1DA7:  ANDLW  03
1DA8:  MOVWF  74
....................         pot_values_to_lcd(); 
1DA9:  MOVLP  08
1DAA:  CALL   2BF
1DAB:  MOVLP  18
....................         break; 
1DAC:  GOTO   5BC
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1DAD:  MOVLW  FF
1DAE:  MOVLB  02
1DAF:  MOVWF  34
1DB0:  MOVLP  10
1DB1:  MOVLB  00
1DB2:  CALL   036
1DB3:  MOVLP  18
....................         break; 
1DB4:  GOTO   5BC
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1DB5:  MOVLW  01
1DB6:  MOVLB  02
1DB7:  MOVWF  34
1DB8:  MOVLP  10
1DB9:  MOVLB  00
1DBA:  CALL   036
1DBB:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1DBC:  MOVLP  10
1DBD:  CALL   027
1DBE:  MOVLP  18
1DBF:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1DC0:  BSF    5A.4
.................... } // }}} 
1DC1:  MOVLP  18
1DC2:  MOVLB  00
1DC3:  GOTO   7BA (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask,cor_index; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
1C30:  MOVLW  01
1C31:  MOVLB  01
1C32:  MOVWF  6B
....................   do_update_ptt=0; 
1C33:  CLRF   6F
....................   cor_in = COR_IN | (COR_EMUL&0x0F); 
1C34:  MOVLB  00
1C35:  MOVF   67,W
1C36:  ANDLW  0F
1C37:  IORWF  5F,W
1C38:  MOVLB  01
1C39:  MOVWF  6E
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in&CurrentCorMask) ) { 
1C3A:  MOVLB  00
1C3B:  MOVF   6C,F
1C3C:  BTFSC  03.2
1C3D:  GOTO   455
1C3E:  MOVLB  01
1C3F:  MOVF   6E,W
1C40:  MOVLB  00
1C41:  ANDWF  6A,W
1C42:  BTFSS  03.2
1C43:  GOTO   455
....................     CurrentCorPriority=0; 
1C44:  CLRF   6C
....................     CurrentCorMask=0; 
1C45:  CLRF   6A
....................     do_update_ptt=1; 
1C46:  MOVLW  01
1C47:  MOVLB  01
1C48:  MOVWF  6F
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
1C49:  MOVF   6E,W
1C4A:  MOVLB  00
1C4B:  ANDWF  60,W
1C4C:  ANDWF  61,W
1C4D:  BTFSS  03.2
1C4E:  GOTO   455
....................       COR_DROP_FLAG=1; 
1C4F:  BSF    72.7
....................       if ( Tail ) { 
1C50:  MOVF   65,F
1C51:  BTFSC  03.2
1C52:  GOTO   455
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
1C53:  MOVF   65,W
1C54:  MOVWF  68
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
1C55:  MOVLB  01
1C56:  CLRF   6C
....................   for(x=0;x<4;x++) { 
1C57:  MOVLB  02
1C58:  CLRF   20
1C59:  MOVF   20,W
1C5A:  SUBLW  03
1C5B:  BTFSS  03.0
1C5C:  GOTO   4A0
....................     if ( cor_in & cor_mask ) { 
1C5D:  MOVLB  01
1C5E:  MOVF   6E,W
1C5F:  ANDWF  6B,W
1C60:  BTFSC  03.2
1C61:  GOTO   499
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
1C62:  MOVLB  00
1C63:  MOVF   60,W
1C64:  ANDWF  61,W
1C65:  MOVLB  01
1C66:  ANDWF  6B,W
1C67:  BTFSC  03.2
1C68:  GOTO   475
....................         rx_priority=RXPriority[x]; 
1C69:  MOVLW  25
1C6A:  MOVLB  02
1C6B:  ADDWF  20,W
1C6C:  MOVWF  04
1C6D:  MOVLW  20
1C6E:  MOVWF  05
1C6F:  BTFSC  03.0
1C70:  INCF   05,F
1C71:  MOVF   00,W
1C72:  MOVLB  01
1C73:  MOVWF  6D
....................       } else { 
1C74:  GOTO   477
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
1C75:  MOVLW  01
1C76:  MOVWF  6D
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
1C77:  MOVF   6D,W
1C78:  MOVLB  00
1C79:  SUBWF  6C,W
1C7A:  BTFSC  03.0
1C7B:  GOTO   49A
....................         if ( ! CurrentCorPriority ) { 
1C7C:  MOVF   6C,F
1C7D:  BTFSS  03.2
1C7E:  GOTO   483
....................           CurrentCorPriority = rx_priority; 
1C7F:  MOVLB  01
1C80:  MOVF   6D,W
1C81:  MOVLB  00
1C82:  MOVWF  6C
....................         } 
....................         cor_index=x+1; 
1C83:  MOVLW  01
1C84:  MOVLB  02
1C85:  ADDWF  20,W
1C86:  MOVLB  01
1C87:  MOVWF  6C
....................         do_update_ptt=1; 
1C88:  MOVLW  01
1C89:  MOVWF  6F
....................         TOT_SecondCounter= 60 * TOT_Min; 
1C8A:  MOVLW  3C
1C8B:  MOVLB  02
1C8C:  MOVWF  48
1C8D:  MOVLB  00
1C8E:  MOVF   66,W
1C8F:  MOVLB  02
1C90:  MOVWF  49
1C91:  MOVLP  08
1C92:  MOVLB  00
1C93:  CALL   6EE
1C94:  MOVLP  18
1C95:  MOVLB  01
1C96:  CLRF   5E
1C97:  MOVF   78,W
1C98:  MOVWF  5D
1C99:  MOVLB  00
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
1C9A:  BCF    03.0
1C9B:  MOVLB  01
1C9C:  RLF    6B,F
....................   } 
1C9D:  MOVLB  02
1C9E:  INCF   20,F
1C9F:  GOTO   459
....................   if ( do_update_ptt ) { 
1CA0:  MOVLB  01
1CA1:  MOVF   6F,F
1CA2:  BTFSC  03.2
1CA3:  GOTO   4AD
....................     update_ptt(cor_index); 
1CA4:  MOVF   6C,W
1CA5:  MOVLB  02
1CA6:  MOVWF  33
1CA7:  MOVLP  08
1CA8:  MOVLB  00
1CA9:  CALL   3C1
1CAA:  MOVLP  18
....................     PROMPT_FLAG=1; 
1CAB:  MOVLB  01
1CAC:  BSF    5A.5
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
1CAD:  MOVF   6E,F
1CAE:  BTFSC  03.2
....................     CLEAR_DTMF_FLAG=1; 
1CAF:  BSF    5A.4
....................   } 
.................... } // }}} 
1CB0:  MOVLP  18
1CB1:  MOVLB  00
1CB2:  GOTO   71D (RETURN)
....................  
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
17D8:  MOVLB  01
17D9:  CLRF   6B
17DA:  MOVF   6B,W
17DB:  SUBLW  09
17DC:  BTFSS  03.0
17DD:  GOTO   7E8
....................     DTMF_ARRAY[x]=(sDTMF)0; 
17DE:  MOVLW  61
17DF:  ADDWF  6B,W
17E0:  MOVWF  04
17E1:  MOVLW  20
17E2:  MOVWF  05
17E3:  BTFSC  03.0
17E4:  INCF   05,F
17E5:  CLRF   00
....................   } 
17E6:  INCF   6B,F
17E7:  GOTO   7DA
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
17E8:  MOVLW  20
17E9:  MOVWF  3C
17EA:  MOVLW  61
17EB:  MOVWF  3B
.................... } // }}} 
17EC:  MOVLP  18
17ED:  MOVLB  00
17EE:  GOTO   7C2 (RETURN)
....................  
.................... void header (void) { // {{{ 
.................... //  putc(ESC); 
.................... //  printf("[47;34m\n\rRadio Repeater Controller - "); 
.................... //  putc(ESC); 
.................... //  printf("[47;31mVE2LRS"); 
.................... //  putc(ESC); 
.................... //  printf("[47;34m (C) 2013\n\n\r"); 
.................... //  putc(ESC); 
.................... //  printf("[40;37m"); 
.................... } // }}} 
*
0003:  RETURN
....................  
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   header(); 
*
135D:  MOVLP  00
135E:  CALL   003
135F:  MOVLP  10
1360:  CLRF   25
1361:  BTFSC  0B.7
1362:  BSF    25.7
1363:  BCF    0B.7
....................   dtmf_in=dtmf_read(CONTROL_REG); 
1364:  MOVLW  01
1365:  MOVLB  02
1366:  MOVWF  5D
1367:  MOVLP  00
1368:  MOVLB  00
1369:  CALL   33E
136A:  MOVLP  10
136B:  BTFSC  25.7
136C:  BSF    0B.7
136D:  MOVF   78,W
136E:  MOVLB  02
136F:  MOVWF  38
....................   aux_in = 0; 
1370:  CLRF   39
....................   for(x=0;x<RegMapNum;x++) { 
1371:  CLRF   32
1372:  CLRF   31
1373:  MOVF   32,F
1374:  BTFSS  03.2
1375:  GOTO   46C
1376:  MOVF   31,W
1377:  SUBLW  37
1378:  BTFSS  03.0
1379:  GOTO   46C
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
137A:  MOVLW  01
137B:  MOVWF  7A
137C:  MOVLW  8B
137D:  MOVWF  40
137E:  MOVF   7A,W
137F:  MOVWF  41
1380:  MOVF   32,W
1381:  MOVWF  43
1382:  MOVF   31,W
1383:  MOVWF  42
1384:  CLRF   45
1385:  MOVLW  06
1386:  MOVWF  44
1387:  MOVLP  08
1388:  MOVLB  00
1389:  CALL   7E5
138A:  MOVLP  10
138B:  MOVF   78,W
138C:  MOVLB  02
138D:  ADDWF  40,W
138E:  MOVWF  34
138F:  MOVF   79,W
1390:  ADDWFC 41,W
1391:  MOVWF  35
....................     romstrcpy(rname,cPtr); 
1392:  MOVLW  20
1393:  MOVWF  41
1394:  MOVLW  BA
1395:  MOVWF  40
1396:  MOVF   35,W
1397:  MOVWF  43
1398:  MOVF   34,W
1399:  MOVWF  42
139A:  MOVLB  00
139B:  CALL   000
....................   regPtr=RegMap[x].reg_ptr; 
139C:  MOVLB  02
139D:  RLF    31,W
139E:  MOVWF  40
139F:  RLF    32,W
13A0:  MOVWF  41
13A1:  RLF    40,F
13A2:  RLF    41,F
13A3:  MOVLW  FC
13A4:  ANDWF  40,F
13A5:  MOVF   41,W
13A6:  MOVWF  7A
13A7:  MOVF   40,W
13A8:  MOVWF  42
13A9:  INCF   40,W
13AA:  MOVLP  00
13AB:  MOVLB  00
13AC:  CALL   043
13AD:  MOVLP  10
13AE:  MOVWF  7A
13AF:  MOVLB  02
13B0:  MOVF   42,W
13B1:  MOVLP  00
13B2:  MOVLB  00
13B3:  CALL   043
13B4:  MOVLP  10
13B5:  MOVLB  02
13B6:  MOVWF  36
13B7:  MOVF   7A,W
13B8:  MOVWF  37
....................     printf("[%02Lu] %s %u\n\r",x,rname,*regPtr); 
13B9:  MOVF   37,W
13BA:  MOVWF  7A
13BB:  MOVF   36,W
13BC:  MOVWF  04
13BD:  MOVF   7A,W
13BE:  MOVWF  05
13BF:  MOVF   00,W
13C0:  MOVWF  40
13C1:  MOVLW  5B
13C2:  CLRWDT
13C3:  MOVLB  00
13C4:  BTFSC  11.4
13C5:  GOTO   3C8
13C6:  MOVLB  02
13C7:  GOTO   3C2
13C8:  MOVLB  03
13C9:  MOVWF  1A
13CA:  MOVLW  0B
13CB:  MOVWF  04
13CC:  MOVLB  02
13CD:  MOVF   32,W
13CE:  MOVWF  42
13CF:  MOVF   31,W
13D0:  MOVWF  41
*
142E:  MOVLW  5D
142F:  CLRWDT
1430:  MOVLB  00
1431:  BTFSC  11.4
1432:  GOTO   435
1433:  MOVLB  02
1434:  GOTO   42F
1435:  MOVLB  03
1436:  MOVWF  1A
1437:  MOVLW  20
1438:  CLRWDT
1439:  MOVLB  00
143A:  BTFSC  11.4
143B:  GOTO   43E
143C:  MOVLB  03
143D:  GOTO   438
143E:  MOVLB  03
143F:  MOVWF  1A
1440:  MOVLW  20
1441:  MOVWF  05
1442:  MOVLW  BA
1443:  MOVWF  04
1444:  MOVLP  08
1445:  MOVLB  00
1446:  CALL   2A5
1447:  MOVLP  10
1448:  MOVLW  20
1449:  CLRWDT
144A:  BTFSS  11.4
144B:  GOTO   449
144C:  MOVLB  03
144D:  MOVWF  1A
144E:  MOVLB  02
144F:  MOVF   40,W
1450:  MOVWF  55
1451:  MOVLW  1B
1452:  MOVWF  56
1453:  MOVLP  00
1454:  MOVLB  00
1455:  CALL   775
1456:  MOVLP  10
1457:  MOVLW  0A
1458:  CLRWDT
1459:  BTFSS  11.4
145A:  GOTO   458
145B:  MOVLB  03
145C:  MOVWF  1A
145D:  MOVLW  0D
145E:  CLRWDT
145F:  MOVLB  00
1460:  BTFSC  11.4
1461:  GOTO   464
1462:  MOVLB  03
1463:  GOTO   45E
1464:  MOVLB  03
1465:  MOVWF  1A
....................     restart_wdt(); 
1466:  CLRWDT
....................   } 
1467:  MOVLB  02
1468:  INCF   31,F
1469:  BTFSC  03.2
146A:  INCF   32,F
146B:  GOTO   373
....................   for(y=0;y<3;y++) { 
146C:  CLRF   33
146D:  MOVF   33,W
146E:  SUBLW  02
146F:  BTFSS  03.0
1470:  GOTO   487
....................     if(AuxInSW[y]==1) { 
1471:  MOVLW  1F
1472:  ADDWF  33,W
1473:  MOVWF  04
1474:  MOVLW  20
1475:  MOVWF  05
1476:  BTFSC  03.0
1477:  INCF   05,F
1478:  DECFSZ 00,W
1479:  GOTO   485
....................       aux_in += 2<<y; 
147A:  MOVLW  02
147B:  MOVWF  77
147C:  MOVF   33,W
147D:  MOVWF  78
147E:  BTFSC  03.2
147F:  GOTO   483
1480:  LSLF   77,F
1481:  DECFSZ 78,F
1482:  GOTO   480
1483:  MOVF   77,W
1484:  ADDWF  39,F
....................     } 
....................   } 
1485:  INCF   33,F
1486:  GOTO   46D
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u",COR_IN,COR_EMUL,aux_in); 
1487:  MOVLW  51
1488:  MOVLB  03
1489:  MOVWF  11
148A:  MOVLW  04
148B:  MOVWF  12
148C:  BCF    03.0
148D:  MOVLW  07
148E:  MOVLB  02
148F:  MOVWF  55
1490:  MOVLP  00
1491:  MOVLB  00
1492:  CALL   701
1493:  MOVLP  10
1494:  MOVF   5F,W
1495:  MOVLB  02
1496:  MOVWF  55
1497:  MOVLW  1B
1498:  MOVWF  56
1499:  MOVLP  00
149A:  MOVLB  00
149B:  CALL   775
149C:  MOVLP  10
149D:  MOVLW  55
149E:  MOVLB  03
149F:  MOVWF  11
14A0:  MOVLW  04
14A1:  MOVWF  12
14A2:  BSF    03.0
14A3:  MOVLW  07
14A4:  MOVLB  02
14A5:  MOVWF  55
14A6:  MOVLP  00
14A7:  MOVLB  00
14A8:  CALL   701
14A9:  MOVLP  10
14AA:  MOVF   67,W
14AB:  MOVLB  02
14AC:  MOVWF  55
14AD:  MOVLW  1B
14AE:  MOVWF  56
14AF:  MOVLP  00
14B0:  MOVLB  00
14B1:  CALL   775
14B2:  MOVLP  10
14B3:  MOVLW  5A
14B4:  MOVLB  03
14B5:  MOVWF  11
14B6:  MOVLW  04
14B7:  MOVWF  12
14B8:  BCF    03.0
14B9:  MOVLW  09
14BA:  MOVLB  02
14BB:  MOVWF  55
14BC:  MOVLP  00
14BD:  MOVLB  00
14BE:  CALL   701
14BF:  MOVLP  10
14C0:  MOVLB  02
14C1:  MOVF   39,W
14C2:  MOVWF  55
14C3:  MOVLW  1B
14C4:  MOVWF  56
14C5:  MOVLP  00
14C6:  MOVLB  00
14C7:  CALL   775
14C8:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
14C9:  MOVLW  60
14CA:  MOVLB  03
14CB:  MOVWF  11
14CC:  MOVLW  04
14CD:  MOVWF  12
14CE:  BCF    03.0
14CF:  MOVLW  10
14D0:  MOVLB  02
14D1:  MOVWF  55
14D2:  MOVLP  00
14D3:  MOVLB  00
14D4:  CALL   701
14D5:  MOVLP  10
14D6:  MOVLB  02
14D7:  MOVF   38,W
14D8:  MOVWF  55
14D9:  MOVLW  1B
14DA:  MOVWF  56
14DB:  MOVLP  00
14DC:  MOVLB  00
14DD:  CALL   775
14DE:  MOVLP  10
14DF:  MOVLW  0A
14E0:  CLRWDT
14E1:  BTFSS  11.4
14E2:  GOTO   4E0
14E3:  MOVLB  03
14E4:  MOVWF  1A
14E5:  MOVLW  0D
14E6:  CLRWDT
14E7:  MOVLB  00
14E8:  BTFSC  11.4
14E9:  GOTO   4EC
14EA:  MOVLB  03
14EB:  GOTO   4E6
14EC:  MOVLB  03
14ED:  MOVWF  1A
....................   pot_values_to_lcd(); 
14EE:  MOVLP  08
14EF:  MOVLB  00
14F0:  CALL   2BF
14F1:  MOVLP  10
....................   PROMPT_FLAG=1; 
14F2:  MOVLB  01
14F3:  BSF    5A.5
.................... } // }}} 
....................  
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0ABF:  MOVLW  20
0AC0:  MOVLB  02
0AC1:  MOVWF  47
0AC2:  MOVWF  48
0AC3:  MOVWF  49
0AC4:  MOVWF  4A
....................   unsigned pval[4]={0,0,0,0}; 
0AC5:  CLRF   4B
0AC6:  CLRF   4C
0AC7:  CLRF   4D
0AC8:  CLRF   4E
....................   delay_ms(40); 
0AC9:  MOVLW  28
0ACA:  MOVWF  4F
0ACB:  MOVLP  00
0ACC:  MOVLB  00
0ACD:  CALL   7C4
0ACE:  MOVLP  08
....................   i2c_start(); 
0ACF:  MOVLB  04
0AD0:  BSF    16.0
0AD1:  BTFSC  16.0
0AD2:  GOTO   2D1
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0AD3:  MOVLW  51
0AD4:  MOVLB  02
0AD5:  MOVWF  55
0AD6:  MOVLP  00
0AD7:  MOVLB  00
0AD8:  CALL   6EC
0AD9:  MOVLP  08
0ADA:  MOVF   78,W
0ADB:  MOVLB  02
0ADC:  BCF    46.1
0ADD:  BTFSC  78.0
0ADE:  BSF    46.1
....................   for(x=0;x<4;x++) { 
0ADF:  CLRF   44
0AE0:  MOVF   44,W
0AE1:  SUBLW  03
0AE2:  BTFSS  03.0
0AE3:  GOTO   31D
....................     if(x==3) { 
0AE4:  MOVF   44,W
0AE5:  SUBLW  03
0AE6:  BTFSS  03.2
0AE7:  GOTO   2EA
....................       ack=0; 
0AE8:  BCF    46.0
....................     } else { 
0AE9:  GOTO   2EB
....................       ack=1; 
0AEA:  BSF    46.0
....................     } 
....................     pot_val=i2c_read(ack); 
0AEB:  MOVLW  00
0AEC:  BTFSC  46.0
0AED:  MOVLW  01
0AEE:  MOVWF  4F
0AEF:  MOVF   4F,W
0AF0:  MOVWF  77
*
0AFF:  MOVF   78,W
0B00:  MOVLB  02
0B01:  MOVWF  45
....................     pot_val=pot_val&0x3F; 
0B02:  MOVLW  3F
0B03:  ANDWF  45,F
....................     pval[x]=pot_val; 
0B04:  MOVLW  CB
0B05:  ADDWF  44,W
0B06:  MOVWF  04
0B07:  MOVLW  20
0B08:  MOVWF  05
0B09:  BTFSC  03.0
0B0A:  INCF   05,F
0B0B:  MOVF   45,W
0B0C:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0B0D:  MOVF   74,W
0B0E:  ANDLW  03
0B0F:  SUBWF  44,W
0B10:  BTFSS  03.2
0B11:  GOTO   31B
....................       c[x] = '*'; 
0B12:  MOVLW  C7
0B13:  ADDWF  44,W
0B14:  MOVWF  04
0B15:  MOVLW  20
0B16:  MOVWF  05
0B17:  BTFSC  03.0
0B18:  INCF   05,F
0B19:  MOVLW  2A
0B1A:  MOVWF  00
....................     } 
....................   } 
0B1B:  INCF   44,F
0B1C:  GOTO   2E0
....................   i2c_stop(); 
0B1D:  MOVLB  04
0B1E:  BSF    16.2
0B1F:  BTFSC  16.2
0B20:  GOTO   31F
....................   delay_ms(50); 
0B21:  MOVLW  32
0B22:  MOVLB  02
0B23:  MOVWF  4F
0B24:  MOVLP  00
0B25:  MOVLB  00
0B26:  CALL   7C4
0B27:  MOVLP  08
....................   if ( ack_in!=0 ) { 
0B28:  MOVLB  02
0B29:  BTFSS  46.1
0B2A:  GOTO   346
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0B2B:  MOVLW  00
0B2C:  BTFSC  46.0
0B2D:  MOVLW  01
0B2E:  MOVWF  4F
0B2F:  MOVLW  6B
0B30:  MOVLB  03
0B31:  MOVWF  11
0B32:  MOVLW  04
0B33:  MOVWF  12
0B34:  BCF    03.0
0B35:  MOVLW  25
0B36:  MOVLB  02
0B37:  MOVWF  55
0B38:  MOVLP  00
0B39:  MOVLB  00
0B3A:  CALL   701
0B3B:  MOVLP  08
0B3C:  MOVLB  02
0B3D:  MOVF   4F,W
0B3E:  MOVWF  55
0B3F:  MOVLW  1B
0B40:  MOVWF  56
0B41:  MOVLP  00
0B42:  MOVLB  00
0B43:  CALL   775
0B44:  MOVLP  08
0B45:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0B46:  MOVLW  20
0B47:  MOVLB  01
0B48:  MOVWF  61
0B49:  MOVLW  73
0B4A:  MOVWF  60
0B4B:  MOVLW  7F
0B4C:  MOVLB  03
0B4D:  MOVWF  11
0B4E:  MOVLW  04
0B4F:  MOVWF  12
0B50:  BCF    03.0
0B51:  MOVLW  04
0B52:  MOVLB  02
0B53:  MOVWF  4F
0B54:  MOVLB  00
0B55:  CALL   164
0B56:  MOVLB  02
0B57:  MOVF   47,W
0B58:  MOVWF  55
0B59:  MOVLP  00
0B5A:  MOVLB  00
0B5B:  CALL   7F0
0B5C:  MOVLP  08
0B5D:  MOVLB  02
0B5E:  MOVF   4B,W
0B5F:  MOVWF  4F
0B60:  MOVLW  18
0B61:  MOVWF  50
0B62:  MOVLB  00
0B63:  CALL   236
0B64:  MOVLW  20
0B65:  MOVLB  02
0B66:  MOVWF  55
0B67:  MOVLP  00
0B68:  MOVLB  00
0B69:  CALL   7F0
0B6A:  MOVLP  08
0B6B:  MOVLB  02
0B6C:  MOVF   48,W
0B6D:  MOVWF  55
0B6E:  MOVLP  00
0B6F:  MOVLB  00
0B70:  CALL   7F0
0B71:  MOVLP  08
0B72:  MOVLB  02
0B73:  MOVF   4C,W
0B74:  MOVWF  4F
0B75:  MOVLW  18
0B76:  MOVWF  50
0B77:  MOVLB  00
0B78:  CALL   236
0B79:  MOVLW  20
0B7A:  MOVLB  02
0B7B:  MOVWF  55
0B7C:  MOVLP  00
0B7D:  MOVLB  00
0B7E:  CALL   7F0
0B7F:  MOVLP  08
0B80:  MOVLB  02
0B81:  MOVF   49,W
0B82:  MOVWF  55
0B83:  MOVLP  00
0B84:  MOVLB  00
0B85:  CALL   7F0
0B86:  MOVLP  08
0B87:  MOVLB  02
0B88:  MOVF   4D,W
0B89:  MOVWF  4F
0B8A:  MOVLW  18
0B8B:  MOVWF  50
0B8C:  MOVLB  00
0B8D:  CALL   236
0B8E:  MOVLW  20
0B8F:  MOVLB  02
0B90:  MOVWF  55
0B91:  MOVLP  00
0B92:  MOVLB  00
0B93:  CALL   7F0
0B94:  MOVLP  08
0B95:  MOVLB  02
0B96:  MOVF   4A,W
0B97:  MOVWF  55
0B98:  MOVLP  00
0B99:  MOVLB  00
0B9A:  CALL   7F0
0B9B:  MOVLP  08
0B9C:  MOVLB  02
0B9D:  MOVF   4E,W
0B9E:  MOVWF  4F
0B9F:  MOVLW  18
0BA0:  MOVWF  50
0BA1:  MOVLB  00
0BA2:  CALL   236
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0BA3:  MOVLB  02
0BA4:  CLRF   4F
0BA5:  MOVLW  20
0BA6:  MOVWF  51
0BA7:  MOVLW  73
0BA8:  MOVWF  50
0BA9:  MOVLB  00
0BAA:  CALL   1D2
....................   printf("\n\r%s",LCD_str); 
0BAB:  MOVLW  0A
0BAC:  CLRWDT
0BAD:  BTFSS  11.4
0BAE:  GOTO   3AC
0BAF:  MOVLB  03
0BB0:  MOVWF  1A
0BB1:  MOVLW  0D
0BB2:  CLRWDT
0BB3:  MOVLB  00
0BB4:  BTFSC  11.4
0BB5:  GOTO   3B8
0BB6:  MOVLB  03
0BB7:  GOTO   3B2
0BB8:  MOVLB  03
0BB9:  MOVWF  1A
0BBA:  MOVLW  20
0BBB:  MOVWF  05
0BBC:  MOVLW  73
0BBD:  MOVWF  04
0BBE:  MOVLB  00
0BBF:  CALL   2A5
....................  
.................... } // }}} 
0BC0:  RETURN
....................  
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
10C2:  MOVLB  01
10C3:  BTFSS  5A.6
10C4:  GOTO   0D0
....................     printf("\n\n\rADMIN> "); 
10C5:  MOVLW  8B
10C6:  MOVLB  03
10C7:  MOVWF  11
10C8:  MOVLW  04
10C9:  MOVWF  12
10CA:  MOVLP  00
10CB:  MOVLB  00
10CC:  CALL   529
10CD:  MOVLP  10
....................   } else { 
10CE:  GOTO   0D9
10CF:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
10D0:  MOVLW  91
10D1:  MOVLB  03
10D2:  MOVWF  11
10D3:  MOVLW  04
10D4:  MOVWF  12
10D5:  MOVLP  00
10D6:  MOVLB  00
10D7:  CALL   529
10D8:  MOVLP  10
....................   } 
.................... } // }}} 
10D9:  RETURN
....................  
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
050F:  MOVLW  10
0510:  MOVLB  01
0511:  MOVWF  6C
....................   for (x=0;x<char_num;x++) { 
0512:  CLRF   6B
0513:  MOVF   6C,W
0514:  SUBWF  6B,W
0515:  BTFSC  03.0
0516:  GOTO   521
....................     sBuffer[x]='\0'; 
0517:  MOVLW  4D
0518:  ADDWF  6B,W
0519:  MOVWF  04
051A:  MOVLW  20
051B:  MOVWF  05
051C:  BTFSC  03.0
051D:  INCF   05,F
051E:  CLRF   00
....................   } 
051F:  INCF   6B,F
0520:  GOTO   513
....................   sBufferIndex=0; 
0521:  CLRF   71
....................   sBufferFlag=0;   
0522:  BCF    72.0
....................   argument=-1; 
0523:  MOVLW  FF
0524:  MOVWF  75
....................   argument_name[0]='\0'; 
0525:  CLRF   3D
....................   command=0; 
0526:  CLRF   70
.................... } // }}} 
0527:  MOVLB  00
0528:  RETURN
....................  
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
06AC:  MOVLW  00
06AD:  MOVLB  01
06AE:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
06AF:  MOVLB  02
06B0:  BCF    4A.0
06B1:  MOVF   48,W
06B2:  ANDLW  0F
06B3:  ANDLW  01
06B4:  BTFSS  03.2
06B5:  BSF    4A.0
....................   output_bit(DTMF_D0,dbit); 
06B6:  BTFSC  4A.0
06B7:  GOTO   6BA
06B8:  BCF    0F.0
06B9:  GOTO   6BB
06BA:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
06BB:  BCF    4A.0
06BC:  MOVF   48,W
06BD:  ANDLW  0F
06BE:  ANDLW  02
06BF:  BTFSS  03.2
06C0:  BSF    4A.0
....................   output_bit(DTMF_D1,dbit); 
06C1:  BTFSC  4A.0
06C2:  GOTO   6C5
06C3:  BCF    0F.1
06C4:  GOTO   6C6
06C5:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
06C6:  BCF    4A.0
06C7:  MOVF   48,W
06C8:  ANDLW  0F
06C9:  ANDLW  04
06CA:  BTFSS  03.2
06CB:  BSF    4A.0
....................   output_bit(DTMF_D2,dbit); 
06CC:  BTFSC  4A.0
06CD:  GOTO   6D0
06CE:  BCF    0F.2
06CF:  GOTO   6D1
06D0:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
06D1:  BCF    4A.0
06D2:  MOVF   48,W
06D3:  ANDLW  0F
06D4:  ANDLW  08
06D5:  BTFSS  03.2
06D6:  BSF    4A.0
....................   output_bit(DTMF_D3,dbit); 
06D7:  BTFSC  4A.0
06D8:  GOTO   6DB
06D9:  BCF    0F.3
06DA:  GOTO   6DC
06DB:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
06DC:  MOVF   49,F
06DD:  BTFSS  03.2
06DE:  GOTO   6E1
06DF:  BCF    0F.6
06E0:  GOTO   6E2
06E1:  BSF    0F.6
....................   delay_cycles(2); 
06E2:  GOTO   6E3
....................   output_bit(DTMF_WEB,0); 
06E3:  BCF    0F.5
....................   delay_cycles(2); 
06E4:  GOTO   6E5
....................   output_bit(DTMF_WEB,1);   
06E5:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
06E6:  GOTO   6E7
....................   set_tris_d(0x0F); 
06E7:  MOVLW  0F
06E8:  MOVLB  01
06E9:  MOVWF  0F
.................... } // }}} 
06EA:  MOVLB  00
06EB:  RETURN
....................  
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
*
033E:  MOVLW  0F
033F:  MOVLB  01
0340:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
0341:  MOVLB  02
0342:  MOVF   5D,F
0343:  BTFSS  03.2
0344:  GOTO   347
0345:  BCF    0F.6
0346:  GOTO   348
0347:  BSF    0F.6
....................   delay_cycles(1); 
0348:  NOP
....................   output_bit(DTMF_REB,0); 
0349:  BCF    0F.4
....................   delay_cycles(1); 
034A:  NOP
....................   value=input_d(); 
034B:  MOVLB  00
034C:  MOVF   0F,W
034D:  MOVLB  02
034E:  MOVWF  5E
....................   value&=0x0F; 
034F:  MOVLW  0F
0350:  ANDWF  5E,F
....................   output_bit(DTMF_REB,1); 
0351:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
0352:  NOP
....................   return(value); 
0353:  MOVF   5E,W
0354:  MOVWF  78
.................... } // }}} 
0355:  MOVLB  00
0356:  RETURN
....................  
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0D5D:  MOVLB  02
0D5E:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0D5F:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0D60:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0D61:  CLRF   48
0D62:  MOVLW  01
0D63:  MOVWF  49
0D64:  MOVLP  00
0D65:  MOVLB  00
0D66:  CALL   6AC
0D67:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0D68:  MOVLB  02
0D69:  CLRF   48
0D6A:  MOVLW  01
0D6B:  MOVWF  49
0D6C:  MOVLP  00
0D6D:  MOVLB  00
0D6E:  CALL   6AC
0D6F:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0D70:  MOVLW  0C
0D71:  MOVLB  02
0D72:  MOVWF  48
0D73:  MOVLW  01
0D74:  MOVWF  49
0D75:  MOVLP  00
0D76:  MOVLB  00
0D77:  CALL   6AC
0D78:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0D79:  MOVLW  01
0D7A:  MOVLB  02
0D7B:  MOVWF  48
0D7C:  MOVWF  49
0D7D:  MOVLP  00
0D7E:  MOVLB  00
0D7F:  CALL   6AC
0D80:  MOVLP  08
0D81:  CLRF   25
0D82:  BTFSC  0B.7
0D83:  BSF    25.7
0D84:  BCF    0B.7
....................     dtmf_read(CONTROL_REG); 
0D85:  MOVLW  01
0D86:  MOVLB  02
0D87:  MOVWF  5D
0D88:  MOVLP  00
0D89:  MOVLB  00
0D8A:  CALL   33E
0D8B:  MOVLP  08
0D8C:  BTFSC  25.7
0D8D:  BSF    0B.7
.................... } // }}} 
....................  
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19EC:  MOVF   45,W
19ED:  MOVWF  48
19EE:  CLRF   49
19EF:  MOVLP  00
19F0:  MOVLB  00
19F1:  CALL   6AC
19F2:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19F3:  MOVLW  0C
19F4:  MOVLB  02
19F5:  MOVWF  48
19F6:  MOVLW  01
19F7:  MOVWF  49
19F8:  MOVLP  00
19F9:  MOVLB  00
19FA:  CALL   6AC
19FB:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
19FC:  MOVLW  01
19FD:  MOVLB  02
19FE:  MOVWF  48
19FF:  MOVWF  49
1A00:  MOVLP  00
1A01:  MOVLB  00
1A02:  CALL   6AC
1A03:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A04:  MOVLW  05
1A05:  MOVLB  02
1A06:  MOVWF  48
1A07:  MOVLW  01
1A08:  MOVWF  49
1A09:  MOVLP  00
1A0A:  MOVLB  00
1A0B:  CALL   6AC
1A0C:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A0D:  MOVLB  01
1A0E:  CLRF   30
1A0F:  MOVLW  10
1A10:  MOVWF  2F
....................   while(aux_timer) { 
1A11:  MOVF   2F,W
1A12:  IORWF  30,W
1A13:  BTFSC  03.2
1A14:  GOTO   217
....................     delay_cycles(1); 
1A15:  NOP
....................   } 
1A16:  GOTO   211
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A17:  MOVLW  04
1A18:  MOVLB  02
1A19:  MOVWF  48
1A1A:  MOVLW  01
1A1B:  MOVWF  49
1A1C:  MOVLP  00
1A1D:  MOVLB  00
1A1E:  CALL   6AC
1A1F:  MOVLP  18
.................... } // }}} 
....................  
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
0879:  MOVLW  01
087A:  MOVLB  02
087B:  MOVWF  48
087C:  CLRF   49
087D:  MOVLP  00
087E:  MOVLB  00
087F:  CALL   6AC
0880:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0881:  MOVLW  0C
0882:  MOVLB  02
0883:  MOVWF  48
0884:  MOVLW  01
0885:  MOVWF  49
0886:  MOVLP  00
0887:  MOVLB  00
0888:  CALL   6AC
0889:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
088A:  MOVLW  05
088B:  MOVLB  02
088C:  MOVWF  48
088D:  MOVLW  01
088E:  MOVWF  49
088F:  MOVLP  00
0890:  MOVLB  00
0891:  CALL   6AC
0892:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0893:  MOVLW  05
0894:  MOVLB  02
0895:  MOVWF  48
0896:  MOVLW  01
0897:  MOVWF  49
0898:  MOVLP  00
0899:  MOVLB  00
089A:  CALL   6AC
089B:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
089C:  MOVLB  01
089D:  CLRF   30
089E:  MOVLW  02
089F:  MOVWF  2F
....................   while(aux_timer) { 
08A0:  MOVF   2F,W
08A1:  IORWF  30,W
08A2:  BTFSC  03.2
08A3:  GOTO   0A6
....................     delay_cycles(1); 
08A4:  NOP
....................   } 
08A5:  GOTO   0A0
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
08A6:  MOVLW  04
08A7:  MOVLB  02
08A8:  MOVWF  48
08A9:  MOVLW  01
08AA:  MOVWF  49
08AB:  MOVLP  00
08AC:  MOVLB  00
08AD:  CALL   6AC
08AE:  MOVLP  08
....................   restart_wdt(); 
08AF:  CLRWDT
.................... } // }}} 
08B0:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
08B1:  MOVLW  01
08B2:  MOVLB  02
08B3:  MOVWF  48
08B4:  CLRF   49
08B5:  MOVLP  00
08B6:  MOVLB  00
08B7:  CALL   6AC
08B8:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
08B9:  MOVLW  0C
08BA:  MOVLB  02
08BB:  MOVWF  48
08BC:  MOVLW  01
08BD:  MOVWF  49
08BE:  MOVLP  00
08BF:  MOVLB  00
08C0:  CALL   6AC
08C1:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
08C2:  MOVLW  05
08C3:  MOVLB  02
08C4:  MOVWF  48
08C5:  MOVLW  01
08C6:  MOVWF  49
08C7:  MOVLP  00
08C8:  MOVLB  00
08C9:  CALL   6AC
08CA:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
08CB:  MOVLW  05
08CC:  MOVLB  02
08CD:  MOVWF  48
08CE:  MOVLW  01
08CF:  MOVWF  49
08D0:  MOVLP  00
08D1:  MOVLB  00
08D2:  CALL   6AC
08D3:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
08D4:  MOVLB  01
08D5:  CLRF   30
08D6:  MOVLW  06
08D7:  MOVWF  2F
....................   while(aux_timer) { 
08D8:  MOVF   2F,W
08D9:  IORWF  30,W
08DA:  BTFSC  03.2
08DB:  GOTO   0DE
....................     delay_cycles(1); 
08DC:  NOP
....................   } 
08DD:  GOTO   0D8
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
08DE:  MOVLW  04
08DF:  MOVLB  02
08E0:  MOVWF  48
08E1:  MOVLW  01
08E2:  MOVWF  49
08E3:  MOVLP  00
08E4:  MOVLB  00
08E5:  CALL   6AC
08E6:  MOVLP  08
....................   restart_wdt(); 
08E7:  CLRWDT
.................... } // }}} 
08E8:  RETURN
....................  
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
057E:  MOVLB  02
057F:  MOVF   3D,W
0580:  MOVWF  04
0581:  MOVF   3E,W
0582:  MOVWF  05
0583:  MOVF   00,W
0584:  MOVWF  40
....................   if ( tmp > 127 ) { 
0585:  MOVF   40,W
0586:  SUBLW  7F
0587:  BTFSS  03.0
....................     tmp++; 
0588:  INCF   40,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
0589:  BCF    03.0
058A:  RLF    40,W
058B:  XORLW  09
058C:  ADDWF  3F,W
058D:  MOVWF  40
....................   *cksum=tmp; 
058E:  MOVF   3D,W
058F:  MOVWF  04
0590:  MOVF   3E,W
0591:  MOVWF  05
0592:  MOVF   40,W
0593:  MOVWF  00
.................... } // }}} 
0594:  MOVLB  00
0595:  RETURN
....................  
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
0596:  MOVLW  01
0597:  MOVLB  02
0598:  MOVWF  37
....................   eeprom_index=0; 
0599:  CLRF   38
....................   retVal = 1; 
059A:  MOVWF  3A
....................   if ( source == USE_EEPROM_VARS ) { 
059B:  DECFSZ 33,W
059C:  GOTO   5A6
....................     printf("\n\rInitializing RAM variables from EEPROM"); 
059D:  MOVLW  98
059E:  MOVLB  03
059F:  MOVWF  11
05A0:  MOVLW  04
05A1:  MOVWF  12
05A2:  MOVLB  00
05A3:  CALL   529
....................   } else { 
05A4:  GOTO   5AD
05A5:  MOVLB  02
....................     printf("\n\rInitializing RAM variables with firmware default values"); 
05A6:  MOVLW  AD
05A7:  MOVLB  03
05A8:  MOVWF  11
05A9:  MOVLW  04
05AA:  MOVWF  12
05AB:  MOVLB  00
05AC:  CALL   529
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
05AD:  MOVLB  02
05AE:  CLRF   34
05AF:  MOVF   34,W
05B0:  SUBLW  37
05B1:  BTFSS  03.0
05B2:  GOTO   60C
....................     regPtr=RegMap[x].reg_ptr; 
05B3:  RLF    34,W
05B4:  MOVWF  77
05B5:  RLF    77,F
05B6:  MOVLW  FC
05B7:  ANDWF  77,F
05B8:  MOVF   77,W
05B9:  MOVWF  3C
05BA:  INCF   3C,W
05BB:  MOVLB  00
05BC:  CALL   043
05BD:  MOVWF  7A
05BE:  MOVLB  02
05BF:  MOVF   3C,W
05C0:  MOVLB  00
05C1:  CALL   043
05C2:  MOVLB  02
05C3:  MOVWF  35
05C4:  MOVF   7A,W
05C5:  MOVWF  36
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
05C6:  DECFSZ 33,W
05C7:  GOTO   5F8
05C8:  RLF    34,W
05C9:  MOVWF  77
05CA:  RLF    77,F
05CB:  MOVLW  FC
05CC:  ANDWF  77,F
05CD:  MOVF   77,W
05CE:  ADDLW  03
05CF:  MOVLB  00
05D0:  CALL   043
05D1:  MOVWF  78
05D2:  BTFSC  78.0
05D3:  GOTO   5D6
05D4:  MOVLB  02
05D5:  GOTO   5F8
....................     eeprom_val=read_eeprom(eeprom_index); 
05D6:  MOVLB  02
05D7:  MOVF   38,W
05D8:  MOVLB  03
05D9:  MOVWF  11
05DA:  BCF    15.7
05DB:  BSF    15.0
05DC:  MOVF   13,W
05DD:  MOVLB  02
05DE:  MOVWF  3B
....................     *regPtr=eeprom_val; 
05DF:  MOVF   35,W
05E0:  MOVWF  04
05E1:  MOVF   36,W
05E2:  MOVWF  05
05E3:  MOVF   3B,W
05E4:  MOVWF  00
....................     update_checksum(&cksum,*regPtr);     
05E5:  MOVF   36,W
05E6:  MOVWF  7A
05E7:  MOVF   35,W
05E8:  MOVWF  04
05E9:  MOVF   36,W
05EA:  MOVWF  05
05EB:  MOVF   00,W
05EC:  MOVWF  3C
05ED:  MOVLW  20
05EE:  MOVWF  3E
05EF:  MOVLW  B7
05F0:  MOVWF  3D
05F1:  MOVF   3C,W
05F2:  MOVWF  3F
05F3:  MOVLB  00
05F4:  CALL   57E
....................       eeprom_index++; 
05F5:  MOVLB  02
05F6:  INCF   38,F
....................     } else { 
05F7:  GOTO   60A
....................       default_value=(int8)RegMap[x].default_value; 
05F8:  RLF    34,W
05F9:  MOVWF  77
05FA:  RLF    77,F
05FB:  MOVLW  FC
05FC:  ANDWF  77,F
05FD:  MOVF   77,W
05FE:  ADDLW  02
05FF:  MOVLB  00
0600:  CALL   043
0601:  MOVWF  78
0602:  MOVLB  02
0603:  MOVWF  39
....................       *regPtr=default_value; 
0604:  MOVF   35,W
0605:  MOVWF  04
0606:  MOVF   36,W
0607:  MOVWF  05
0608:  MOVF   39,W
0609:  MOVWF  00
....................     } 
....................   } 
060A:  INCF   34,F
060B:  GOTO   5AF
....................   if ( source == USE_EEPROM_VARS ) { 
060C:  DECFSZ 33,W
060D:  GOTO   618
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
060E:  MOVF   38,W
060F:  MOVLB  03
0610:  MOVWF  11
0611:  BCF    15.7
0612:  BSF    15.0
0613:  MOVF   13,W
0614:  MOVLB  02
0615:  SUBWF  37,W
0616:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
0617:  CLRF   3A
....................     } 
....................   } 
....................   return (retVal); 
0618:  MOVF   3A,W
0619:  MOVWF  78
.................... } // }}} 
061A:  MOVLB  00
061B:  RETURN
....................  
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
061C:  MOVLW  01
061D:  MOVLB  02
061E:  MOVWF  37
....................  
....................   eeprom_index=0; 
061F:  CLRF   34
....................   for(x=0;x<RegMapNum;x++) { 
0620:  CLRF   33
0621:  MOVF   33,W
0622:  SUBLW  37
0623:  BTFSS  03.0
0624:  GOTO   67A
....................     regPtr=RegMap[x].reg_ptr; 
0625:  RLF    33,W
0626:  MOVWF  77
0627:  RLF    77,F
0628:  MOVLW  FC
0629:  ANDWF  77,F
062A:  MOVF   77,W
062B:  MOVWF  39
062C:  INCF   39,W
062D:  MOVLB  00
062E:  CALL   043
062F:  MOVWF  7A
0630:  MOVLB  02
0631:  MOVF   39,W
0632:  MOVLB  00
0633:  CALL   043
0634:  MOVLB  02
0635:  MOVWF  35
0636:  MOVF   7A,W
0637:  MOVWF  36
....................     if ( RegMap[x].non_volatile ) { 
0638:  RLF    33,W
0639:  MOVWF  77
063A:  RLF    77,F
063B:  MOVLW  FC
063C:  ANDWF  77,F
063D:  MOVF   77,W
063E:  ADDLW  03
063F:  MOVLB  00
0640:  CALL   043
0641:  MOVWF  78
0642:  BTFSS  78.0
0643:  GOTO   677
....................      value=*regPtr; 
0644:  MOVLB  02
0645:  MOVF   35,W
0646:  MOVWF  04
0647:  MOVF   36,W
0648:  MOVWF  05
0649:  MOVF   00,W
064A:  MOVWF  38
....................      if ( read_eeprom(eeprom_index) != value ) { 
064B:  MOVF   34,W
064C:  MOVLB  03
064D:  MOVWF  11
064E:  BCF    15.7
064F:  BSF    15.0
0650:  MOVF   13,W
0651:  MOVLB  02
0652:  SUBWF  38,W
0653:  BTFSC  03.2
0654:  GOTO   66C
....................        write_eeprom(eeprom_index,value); 
0655:  MOVF   0B,W
0656:  MOVWF  77
0657:  BCF    0B.7
0658:  MOVF   34,W
0659:  MOVLB  03
065A:  MOVWF  11
065B:  MOVLB  02
065C:  MOVF   38,W
065D:  MOVLB  03
065E:  MOVWF  13
065F:  BCF    15.7
0660:  BSF    15.2
0661:  MOVLW  55
0662:  MOVWF  16
0663:  MOVLW  AA
0664:  MOVWF  16
0665:  BSF    15.1
0666:  BTFSC  15.1
0667:  GOTO   666
0668:  BCF    15.2
0669:  MOVF   77,W
066A:  IORWF  0B,F
066B:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
066C:  MOVLW  20
066D:  MOVWF  3E
066E:  MOVLW  B7
066F:  MOVWF  3D
0670:  MOVF   38,W
0671:  MOVWF  3F
0672:  MOVLB  00
0673:  CALL   57E
....................      eeprom_index++; 
0674:  MOVLB  02
0675:  INCF   34,F
0676:  MOVLB  00
....................     } 
....................   } 
0677:  MOVLB  02
0678:  INCF   33,F
0679:  GOTO   621
....................   write_eeprom(eeprom_index,cksum); 
067A:  MOVF   0B,W
067B:  MOVWF  77
067C:  BCF    0B.7
067D:  MOVF   34,W
067E:  MOVLB  03
067F:  MOVWF  11
0680:  MOVLB  02
0681:  MOVF   37,W
0682:  MOVLB  03
0683:  MOVWF  13
0684:  BCF    15.7
0685:  BSF    15.2
0686:  MOVLW  55
0687:  MOVWF  16
0688:  MOVLW  AA
0689:  MOVWF  16
068A:  BSF    15.1
068B:  BTFSC  15.1
068C:  GOTO   68B
068D:  BCF    15.2
068E:  MOVF   77,W
068F:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
0690:  MOVLW  CA
0691:  MOVWF  11
0692:  MOVLW  04
0693:  MOVWF  12
0694:  MOVLB  00
0695:  CALL   529
.................... } // }}} 
0696:  RETURN
....................  
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
0697:  MOVLB  02
0698:  MOVF   32,W
0699:  MOVWF  33
069A:  MOVLB  00
069B:  CALL   596
069C:  MOVF   78,F
069D:  BTFSS  03.2
069E:  GOTO   6AB
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
069F:  MOVLW  DD
06A0:  MOVLB  03
06A1:  MOVWF  11
06A2:  MOVLW  04
06A3:  MOVWF  12
06A4:  MOVLB  00
06A5:  CALL   529
....................         _init_variables(USE_DEFAULT_VARS); 
06A6:  MOVLB  02
06A7:  CLRF   33
06A8:  MOVLB  00
06A9:  CALL   596
....................     store_variables(); 
06AA:  CALL   61C
....................     } 
.................... } // }}} 
06AB:  RETURN
....................  
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0DA2:  MOVLB  02
0DA3:  CLRF   44
0DA4:  CLRF   45
0DA5:  MOVLB  00
0DA6:  CALL   000
....................   set_trimpot(1,0); 
0DA7:  MOVLW  01
0DA8:  MOVLB  02
0DA9:  MOVWF  44
0DAA:  CLRF   45
0DAB:  MOVLB  00
0DAC:  CALL   000
....................   set_trimpot(2,0); 
0DAD:  MOVLW  02
0DAE:  MOVLB  02
0DAF:  MOVWF  44
0DB0:  CLRF   45
0DB1:  MOVLB  00
0DB2:  CALL   000
....................   set_trimpot(3,0); 
0DB3:  MOVLW  03
0DB4:  MOVLB  02
0DB5:  MOVWF  44
0DB6:  CLRF   45
0DB7:  MOVLB  00
0DB8:  CALL   000
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0D2A:  MOVLP  00
0D2B:  CALL   50F
0D2C:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0D2D:  MOVLB  02
0D2E:  CLRF   12
0D2F:  CLRF   11
0D30:  CLRF   14
0D31:  CLRF   13
....................   setup_wdt(WDT_2S); 
0D32:  MOVLW  17
0D33:  MOVLB  01
0D34:  MOVWF  17
....................   COR_IN=0; 
0D35:  MOVLB  00
0D36:  CLRF   5F
....................   COR_DROP_FLAG=0; 
0D37:  BCF    72.7
....................   LastRegisterIndexValid=0; 
0D38:  CLRF   7D
....................   LastRegisterIndex=0; 
0D39:  CLRF   7C
....................   CurrentCorMask=0; 
0D3A:  CLRF   6A
....................   CurrentCorPriority=0; 
0D3B:  CLRF   6C
....................   CurrentCorIndex=0; 
0D3C:  CLRF   6B
....................   CurrentTrimPot=0; 
0D3D:  CLRF   74
....................   set_tris_b(0xFF); 
0D3E:  MOVLW  FF
0D3F:  TRIS   6
....................   set_tris_d(0x00); 
0D40:  MOVLW  00
0D41:  MOVLB  01
0D42:  MOVWF  0F
....................   // 0b11111000 
....................   set_tris_e(0xF8); 
0D43:  BCF    10.0
0D44:  BCF    10.1
0D45:  BCF    10.2
0D46:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0D47:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0D48:  BSF    0B.3
0D49:  MOVLW  CF
0D4A:  MOVLB  07
0D4B:  IORWF  14,F
0D4C:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0D4D:  BSF    0B.3
0D4E:  BSF    15.4
0D4F:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0D50:  MOVLW  C0
0D51:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0D52:  MOVLB  02
0D53:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0D54:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0D55:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0D56:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0D57:  MOVLW  01
0D58:  MOVWF  32
0D59:  MOVLP  00
0D5A:  MOVLB  00
0D5B:  CALL   697
0D5C:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D8E:  MOVLB  01
0D8F:  BSF    5A.4
....................   Enable_Mask = 0x0F; 
0D90:  MOVLW  0F
0D91:  MOVLB  00
0D92:  MOVWF  61
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D93:  MOVF   62,W
0D94:  ANDLW  0F
0D95:  IORLW  C0
0D96:  MOVLB  04
0D97:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D98:  MOVLB  01
0D99:  BCF    15.7
....................   // }}} 
....................   header(); 
0D9A:  MOVLP  00
0D9B:  MOVLB  00
0D9C:  CALL   003
0D9D:  MOVLP  08
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D9E:  MOVLW  9D
0D9F:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0DA0:  MOVLW  80
0DA1:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0DB9:  MOVLB  01
0DBA:  CLRF   2E
0DBB:  MOVLW  1E
0DBC:  MOVWF  2D
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0DBD:  MOVF   15,W
0DBE:  ANDLW  C0
0DBF:  IORLW  07
0DC0:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0DC1:  BSF    0B.5
....................   update_ptt(0); 
0DC2:  MOVLB  02
0DC3:  CLRF   33
0DC4:  MOVLB  00
0DC5:  CALL   3C1
....................   MinuteCounter=MIN_COUNTER; 
0DC6:  MOVLW  1D
0DC7:  MOVLB  01
0DC8:  MOVWF  5C
....................   SecondCounter=SEC_COUNTER; 
0DC9:  MOVLW  3B
0DCA:  MOVWF  5B
....................   THIRTY_MIN_FLAG=0; 
0DCB:  BCF    72.6
....................   MINUTE_FLAG=0; 
0DCC:  BCF    72.5
....................   PROMPT_FLAG=1; 
0DCD:  BSF    5A.5
....................   TailChar=Tail; 
0DCE:  MOVLB  00
0DCF:  MOVF   65,W
0DD0:  MOVWF  68
....................   ConfirmChar=0; 
0DD1:  CLRF   69
....................   AuxOut[0] = PO_AUX_OUT0; 
0DD2:  MOVLW  01
0DD3:  MOVWF  42
....................   AuxOut[1] = PO_AUX_OUT1; 
0DD4:  MOVWF  43
....................   AuxOut[2] = PO_AUX_OUT2; 
0DD5:  MOVWF  44
....................   AuxInSW[0] = 0; 
0DD6:  CLRF   3F
....................   AuxInSW[1] = 0; 
0DD7:  CLRF   40
....................   AuxInSW[2] = 0; 
0DD8:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0DD9:  MOVLB  01
0DDA:  BCF    5A.0
....................   set_admin_mode(0); 
0DDB:  MOVLB  02
0DDC:  CLRF   45
0DDD:  MOVLB  00
0DDE:  CALL   513
....................   rs232_mode=0; 
0DDF:  MOVLB  01
0DE0:  BCF    5A.7
....................   button_state=0; 
0DE1:  CLRF   59
.................... //  setup_adc_ports(ADJ_POT); 
.................... //  set_adc_channel(13); 
.................... //  printf("\n\rInitialization complete"); 
.................... } // }}} 
0DE2:  MOVLP  18
0DE3:  MOVLB  00
0DE4:  GOTO   5F7 (RETURN)
....................  
.................... void tokenize_sBuffer() { // {{{ 
*
180D:  MOVLB  02
180E:  BCF    2D.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
180F:  CLRF   44
1810:  CLRF   45
1811:  MOVLW  20
1812:  MOVWF  05
1813:  MOVLW  B0
1814:  MOVWF  04
1815:  MOVF   44,W
1816:  ADDWF  04,F
1817:  MOVLW  00
1818:  ADDWFC 05,F
1819:  MOVF   45,W
181A:  MOVLP  00
181B:  MOVLB  00
181C:  CALL   135
181D:  MOVLP  18
181E:  MOVWF  00
181F:  IORLW  00
1820:  BTFSC  03.2
1821:  GOTO   027
1822:  MOVLB  02
1823:  INCF   45,F
1824:  INCF   44,F
1825:  GOTO   011
1826:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1827:  MOVLW  20
1828:  MOVLB  02
1829:  MOVWF  45
182A:  MOVLW  4D
182B:  MOVWF  44
182C:  MOVLW  20
182D:  MOVWF  47
182E:  MOVLW  B0
182F:  MOVWF  46
1830:  MOVLP  08
1831:  MOVLB  00
1832:  CALL   60F
1833:  MOVLP  18
1834:  MOVF   79,W
1835:  MOVLB  02
1836:  MOVWF  2F
1837:  MOVF   78,W
1838:  MOVWF  2E
....................   if (sptr!=0) {; 
1839:  MOVF   2E,F
183A:  BTFSS  03.2
183B:  GOTO   03F
183C:  MOVF   2F,F
183D:  BTFSC  03.2
183E:  GOTO   059
....................     strcpy(verb,sptr); 
183F:  MOVF   2F,W
1840:  MOVWF  47
1841:  MOVF   2E,W
1842:  MOVWF  46
1843:  MOVLW  20
1844:  MOVWF  45
1845:  MOVLW  A5
1846:  MOVWF  44
1847:  MOVF   47,W
1848:  MOVWF  05
1849:  MOVF   46,W
184A:  MOVWF  04
184B:  MOVF   00,W
184C:  MOVWF  48
184D:  MOVF   45,W
184E:  MOVWF  05
184F:  MOVF   44,W
1850:  MOVWF  04
1851:  MOVF   48,W
1852:  MOVWF  00
1853:  MOVF   00,F
1854:  BTFSC  03.2
1855:  GOTO   059
1856:  INCF   44,F
1857:  INCF   46,F
1858:  GOTO   047
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
1859:  CLRF   45
185A:  CLRF   44
185B:  MOVLW  20
185C:  MOVWF  47
185D:  MOVLW  B0
185E:  MOVWF  46
185F:  MOVLP  08
1860:  MOVLB  00
1861:  CALL   60F
1862:  MOVLP  18
1863:  MOVF   79,W
1864:  MOVLB  02
1865:  MOVWF  2F
1866:  MOVF   78,W
1867:  MOVWF  2E
....................   if (sptr!=0) {; 
1868:  MOVF   2E,F
1869:  BTFSS  03.2
186A:  GOTO   06E
186B:  MOVF   2F,F
186C:  BTFSC  03.2
186D:  GOTO   088
....................     strcpy(argument_name,sptr); 
186E:  MOVF   2F,W
186F:  MOVWF  47
1870:  MOVF   2E,W
1871:  MOVWF  46
1872:  MOVLW  20
1873:  MOVWF  45
1874:  MOVLW  6D
1875:  MOVWF  44
1876:  MOVF   47,W
1877:  MOVWF  05
1878:  MOVF   46,W
1879:  MOVWF  04
187A:  MOVF   00,W
187B:  MOVWF  48
187C:  MOVF   45,W
187D:  MOVWF  05
187E:  MOVF   44,W
187F:  MOVWF  04
1880:  MOVF   48,W
1881:  MOVWF  00
1882:  MOVF   00,F
1883:  BTFSC  03.2
1884:  GOTO   088
1885:  INCF   44,F
1886:  INCF   46,F
1887:  GOTO   076
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1888:  CLRF   45
1889:  CLRF   44
188A:  MOVLW  20
188B:  MOVWF  47
188C:  MOVLW  B0
188D:  MOVWF  46
188E:  MOVLP  08
188F:  MOVLB  00
1890:  CALL   60F
1891:  MOVLP  18
1892:  MOVF   79,W
1893:  MOVLB  02
1894:  MOVWF  2F
1895:  MOVF   78,W
1896:  MOVWF  2E
....................   if (sptr!=0) {; 
1897:  MOVF   2E,F
1898:  BTFSS  03.2
1899:  GOTO   09D
189A:  MOVF   2F,F
189B:  BTFSC  03.2
189C:  GOTO   0C3
....................     strcpy(match_val,sptr); 
189D:  MOVF   2F,W
189E:  MOVWF  47
189F:  MOVF   2E,W
18A0:  MOVWF  46
18A1:  MOVLW  20
18A2:  MOVWF  45
18A3:  MOVLW  B8
18A4:  MOVWF  44
18A5:  MOVF   47,W
18A6:  MOVWF  05
18A7:  MOVF   46,W
18A8:  MOVWF  04
18A9:  MOVF   00,W
18AA:  MOVWF  48
18AB:  MOVF   45,W
18AC:  MOVWF  05
18AD:  MOVF   44,W
18AE:  MOVWF  04
18AF:  MOVF   48,W
18B0:  MOVWF  00
18B1:  MOVF   00,F
18B2:  BTFSC  03.2
18B3:  GOTO   0B7
18B4:  INCF   44,F
18B5:  INCF   46,F
18B6:  GOTO   0A5
....................     value = str_to_decimal(match_val); 
18B7:  MOVLW  20
18B8:  MOVWF  45
18B9:  MOVLW  B8
18BA:  MOVWF  44
18BB:  MOVLP  08
18BC:  MOVLB  00
18BD:  CALL   715
18BE:  MOVLP  18
18BF:  MOVF   78,W
18C0:  MOVWF  76
....................   } else { 
18C1:  GOTO   0C6
18C2:  MOVLB  02
....................     value = 0; 
18C3:  CLRF   76
....................     do_get_var = 1; 
18C4:  BSF    2D.0
18C5:  MOVLB  00
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18C6:  MOVLB  02
18C7:  CLRF   44
18C8:  CLRF   45
18C9:  MOVLW  20
18CA:  MOVWF  05
18CB:  MOVLW  BC
18CC:  MOVWF  04
18CD:  MOVF   44,W
18CE:  ADDWF  04,F
18CF:  MOVLW  00
18D0:  ADDWFC 05,F
18D1:  MOVF   45,W
18D2:  MOVLP  00
18D3:  MOVLB  00
18D4:  CALL   13B
18D5:  MOVLP  18
18D6:  MOVWF  00
18D7:  IORLW  00
18D8:  BTFSC  03.2
18D9:  GOTO   0DF
18DA:  MOVLB  02
18DB:  INCF   45,F
18DC:  INCF   44,F
18DD:  GOTO   0C9
18DE:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
18DF:  MOVLW  20
18E0:  MOVLB  02
18E1:  MOVWF  45
18E2:  MOVLW  BC
18E3:  MOVWF  44
18E4:  MOVLW  20
18E5:  MOVWF  47
18E6:  MOVLW  A5
18E7:  MOVWF  46
18E8:  MOVLP  08
18E9:  MOVLB  00
18EA:  CALL   74E
18EB:  MOVLP  18
18EC:  MOVF   78,F
18ED:  BTFSS  03.2
18EE:  GOTO   0F8
....................     if ( do_get_var ) { 
18EF:  MOVLB  02
18F0:  BTFSS  2D.0
18F1:  GOTO   0F5
....................       command=GET_REG; 
18F2:  MOVLW  03
18F3:  MOVWF  70
....................     } else { 
18F4:  GOTO   0F7
....................       command=SET_REG; 
18F5:  MOVLW  02
18F6:  MOVWF  70
18F7:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18F8:  MOVLB  02
18F9:  CLRF   44
18FA:  CLRF   45
18FB:  MOVLW  20
18FC:  MOVWF  05
18FD:  MOVLW  BC
18FE:  MOVWF  04
18FF:  MOVF   44,W
1900:  ADDWF  04,F
1901:  MOVLW  00
1902:  ADDWFC 05,F
1903:  MOVF   45,W
1904:  MOVLP  00
1905:  MOVLB  00
1906:  CALL   140
1907:  MOVLP  18
1908:  MOVWF  00
1909:  IORLW  00
190A:  BTFSC  03.2
190B:  GOTO   111
190C:  MOVLB  02
190D:  INCF   45,F
190E:  INCF   44,F
190F:  GOTO   0FB
1910:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1911:  MOVLW  20
1912:  MOVLB  02
1913:  MOVWF  45
1914:  MOVLW  BC
1915:  MOVWF  44
1916:  MOVLW  20
1917:  MOVWF  47
1918:  MOVLW  A5
1919:  MOVWF  46
191A:  MOVLP  08
191B:  MOVLB  00
191C:  CALL   74E
191D:  MOVLP  18
191E:  MOVF   78,F
191F:  BTFSS  03.2
1920:  GOTO   123
....................       command=SAVE_SETTINGS; 
1921:  MOVLW  04
1922:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1923:  MOVLB  02
1924:  CLRF   44
1925:  CLRF   45
1926:  MOVLW  20
1927:  MOVWF  05
1928:  MOVLW  BC
1929:  MOVWF  04
192A:  MOVF   44,W
192B:  ADDWF  04,F
192C:  MOVLW  00
192D:  ADDWFC 05,F
192E:  MOVF   45,W
192F:  MOVLP  00
1930:  MOVLB  00
1931:  CALL   146
1932:  MOVLP  18
1933:  MOVWF  00
1934:  IORLW  00
1935:  BTFSC  03.2
1936:  GOTO   13C
1937:  MOVLB  02
1938:  INCF   45,F
1939:  INCF   44,F
193A:  GOTO   126
193B:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
193C:  MOVLW  20
193D:  MOVLB  02
193E:  MOVWF  45
193F:  MOVLW  BC
1940:  MOVWF  44
1941:  MOVLW  20
1942:  MOVWF  47
1943:  MOVLW  A5
1944:  MOVWF  46
1945:  MOVLP  08
1946:  MOVLB  00
1947:  CALL   74E
1948:  MOVLP  18
1949:  MOVF   78,F
194A:  BTFSS  03.2
194B:  GOTO   14E
....................       command=RESTORE_SETTINGS; 
194C:  MOVLW  05
194D:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
194E:  MOVLB  02
194F:  CLRF   44
1950:  CLRF   45
1951:  MOVLW  20
1952:  MOVWF  05
1953:  MOVLW  BC
1954:  MOVWF  04
1955:  MOVF   44,W
1956:  ADDWF  04,F
1957:  MOVLW  00
1958:  ADDWFC 05,F
1959:  MOVF   45,W
195A:  MOVLP  00
195B:  MOVLB  00
195C:  CALL   14F
195D:  MOVLP  18
195E:  MOVWF  00
195F:  IORLW  00
1960:  BTFSC  03.2
1961:  GOTO   167
1962:  MOVLB  02
1963:  INCF   45,F
1964:  INCF   44,F
1965:  GOTO   151
1966:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1967:  MOVLW  20
1968:  MOVLB  02
1969:  MOVWF  45
196A:  MOVLW  BC
196B:  MOVWF  44
196C:  MOVLW  20
196D:  MOVWF  47
196E:  MOVLW  A5
196F:  MOVWF  46
1970:  MOVLP  08
1971:  MOVLB  00
1972:  CALL   74E
1973:  MOVLP  18
1974:  MOVF   78,F
1975:  BTFSS  03.2
1976:  GOTO   179
....................     command=STATUS; 
1977:  MOVLW  08
1978:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
1979:  MOVLB  02
197A:  CLRF   44
197B:  CLRF   45
197C:  MOVLW  20
197D:  MOVWF  05
197E:  MOVLW  BC
197F:  MOVWF  04
1980:  MOVF   44,W
1981:  ADDWF  04,F
1982:  MOVLW  00
1983:  ADDWFC 05,F
1984:  MOVF   45,W
1985:  MOVLP  00
1986:  MOVLB  00
1987:  CALL   157
1988:  MOVLP  18
1989:  MOVWF  00
198A:  IORLW  00
198B:  BTFSC  03.2
198C:  GOTO   192
198D:  MOVLB  02
198E:  INCF   45,F
198F:  INCF   44,F
1990:  GOTO   17C
1991:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1992:  MOVLW  20
1993:  MOVLB  02
1994:  MOVWF  45
1995:  MOVLW  BC
1996:  MOVWF  44
1997:  MOVLW  20
1998:  MOVWF  47
1999:  MOVLW  A5
199A:  MOVWF  46
199B:  MOVLP  08
199C:  MOVLB  00
199D:  CALL   74E
199E:  MOVLP  18
199F:  MOVF   78,F
19A0:  BTFSS  03.2
19A1:  GOTO   1A6
....................     command=ADMIN; 
19A2:  MOVLW  09
19A3:  MOVWF  70
....................     argument=REBOOT; 
19A4:  MOVLW  02
19A5:  MOVWF  75
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19A6:  MOVLB  02
19A7:  CLRF   44
19A8:  CLRF   45
19A9:  MOVLW  20
19AA:  MOVWF  05
19AB:  MOVLW  BC
19AC:  MOVWF  04
19AD:  MOVF   44,W
19AE:  ADDWF  04,F
19AF:  MOVLW  00
19B0:  ADDWFC 05,F
19B1:  MOVF   45,W
19B2:  MOVLP  00
19B3:  MOVLB  00
19B4:  CALL   15F
19B5:  MOVLP  18
19B6:  MOVWF  00
19B7:  IORLW  00
19B8:  BTFSC  03.2
19B9:  GOTO   1BF
19BA:  MOVLB  02
19BB:  INCF   45,F
19BC:  INCF   44,F
19BD:  GOTO   1A9
19BE:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
19BF:  MOVLW  20
19C0:  MOVLB  02
19C1:  MOVWF  45
19C2:  MOVLW  BC
19C3:  MOVWF  44
19C4:  MOVLW  20
19C5:  MOVWF  47
19C6:  MOVLW  A5
19C7:  MOVWF  46
19C8:  MOVLP  08
19C9:  MOVLB  00
19CA:  CALL   74E
19CB:  MOVLP  18
19CC:  MOVF   78,F
19CD:  BTFSS  03.2
19CE:  GOTO   220
....................     //command=DTMF_SEND; 
....................     command=0; 
19CF:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D0:  MOVLW  20
19D1:  MOVLB  02
19D2:  MOVWF  45
19D3:  MOVLW  6D
19D4:  MOVWF  44
19D5:  MOVLP  08
19D6:  MOVLB  00
19D7:  CALL   715
19D8:  MOVLP  18
19D9:  MOVF   78,W
19DA:  MOVWF  76
....................     if ( value == d0 ) { 
19DB:  MOVF   76,W
19DC:  SUBLW  0A
19DD:  BTFSS  03.2
19DE:  GOTO   1E1
....................       value = dd; 
19DF:  CLRF   76
....................     } else if (value == dd) { 
19E0:  GOTO   1E6
19E1:  MOVF   76,F
19E2:  BTFSS  03.2
19E3:  GOTO   1E6
....................       value = d0; 
19E4:  MOVLW  0A
19E5:  MOVWF  76
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19E6:  MOVF   76,W
19E7:  ANDLW  0F
19E8:  MOVLB  02
19E9:  MOVWF  44
19EA:  MOVF   44,W
19EB:  MOVWF  45
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A20:  MOVLB  02
1A21:  CLRF   44
1A22:  CLRF   45
1A23:  MOVLW  20
1A24:  MOVWF  05
1A25:  MOVLW  BC
1A26:  MOVWF  04
1A27:  MOVF   44,W
1A28:  ADDWF  04,F
1A29:  MOVLW  00
1A2A:  ADDWFC 05,F
1A2B:  MOVF   45,W
1A2C:  MOVLP  00
1A2D:  MOVLB  00
1A2E:  CALL   162
1A2F:  MOVLP  18
1A30:  MOVWF  00
1A31:  IORLW  00
1A32:  BTFSC  03.2
1A33:  GOTO   239
1A34:  MOVLB  02
1A35:  INCF   45,F
1A36:  INCF   44,F
1A37:  GOTO   223
1A38:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1A39:  MOVLW  20
1A3A:  MOVLB  02
1A3B:  MOVWF  45
1A3C:  MOVLW  BC
1A3D:  MOVWF  44
1A3E:  MOVLW  20
1A3F:  MOVWF  47
1A40:  MOVLW  A5
1A41:  MOVWF  46
1A42:  MOVLP  08
1A43:  MOVLB  00
1A44:  CALL   74E
1A45:  MOVLP  18
1A46:  MOVF   78,F
1A47:  BTFSS  03.2
1A48:  GOTO   24B
....................     command=I2C_SEND; 
1A49:  MOVLW  0C
1A4A:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A4B:  MOVLB  02
1A4C:  CLRF   44
1A4D:  CLRF   45
1A4E:  MOVLW  20
1A4F:  MOVWF  05
1A50:  MOVLW  BC
1A51:  MOVWF  04
1A52:  MOVF   44,W
1A53:  ADDWF  04,F
1A54:  MOVLW  00
1A55:  ADDWFC 05,F
1A56:  MOVF   45,W
1A57:  MOVLP  00
1A58:  MOVLB  00
1A59:  CALL   167
1A5A:  MOVLP  18
1A5B:  MOVWF  00
1A5C:  IORLW  00
1A5D:  BTFSC  03.2
1A5E:  GOTO   264
1A5F:  MOVLB  02
1A60:  INCF   45,F
1A61:  INCF   44,F
1A62:  GOTO   24E
1A63:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1A64:  MOVLW  20
1A65:  MOVLB  02
1A66:  MOVWF  45
1A67:  MOVLW  BC
1A68:  MOVWF  44
1A69:  MOVLW  20
1A6A:  MOVWF  47
1A6B:  MOVLW  A5
1A6C:  MOVWF  46
1A6D:  MOVLP  08
1A6E:  MOVLB  00
1A6F:  CALL   74E
1A70:  MOVLP  18
1A71:  MOVF   78,F
1A72:  BTFSS  03.2
1A73:  GOTO   28B
....................     value = str_to_decimal(argument_name); 
1A74:  MOVLW  20
1A75:  MOVLB  02
1A76:  MOVWF  45
1A77:  MOVLW  6D
1A78:  MOVWF  44
1A79:  MOVLP  08
1A7A:  MOVLB  00
1A7B:  CALL   715
1A7C:  MOVLP  18
1A7D:  MOVF   78,W
1A7E:  MOVWF  76
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A7F:  MOVF   76,W
1A80:  SUBLW  24
1A81:  BTFSS  03.0
1A82:  GOTO   287
....................       argument = 0; 
1A83:  CLRF   75
....................       command  = MORSE_SEND; 
1A84:  MOVLW  0B
1A85:  MOVWF  70
....................     } else { 
1A86:  GOTO   28B
....................       command  = ADMIN; 
1A87:  MOVLW  09
1A88:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A89:  MOVLW  03
1A8A:  MOVWF  75
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A8B:  MOVLB  02
1A8C:  CLRF   44
1A8D:  CLRF   45
1A8E:  MOVLW  20
1A8F:  MOVWF  05
1A90:  MOVLW  BC
1A91:  MOVWF  04
1A92:  MOVF   44,W
1A93:  ADDWF  04,F
1A94:  MOVLW  00
1A95:  ADDWFC 05,F
1A96:  MOVF   45,W
1A97:  MOVLP  00
1A98:  MOVLB  00
1A99:  CALL   16E
1A9A:  MOVLP  18
1A9B:  MOVWF  00
1A9C:  IORLW  00
1A9D:  BTFSC  03.2
1A9E:  GOTO   2A4
1A9F:  MOVLB  02
1AA0:  INCF   45,F
1AA1:  INCF   44,F
1AA2:  GOTO   28E
1AA3:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1AA4:  MOVLW  20
1AA5:  MOVLB  02
1AA6:  MOVWF  45
1AA7:  MOVLW  BC
1AA8:  MOVWF  44
1AA9:  MOVLW  20
1AAA:  MOVWF  47
1AAB:  MOVLW  A5
1AAC:  MOVWF  46
1AAD:  MOVLP  08
1AAE:  MOVLB  00
1AAF:  CALL   74E
1AB0:  MOVLP  18
1AB1:  MOVF   78,F
1AB2:  BTFSS  03.2
1AB3:  GOTO   2B6
....................     command=INCREMENT_REG; 
1AB4:  MOVLW  06
1AB5:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1AB6:  MOVLB  02
1AB7:  CLRF   44
1AB8:  CLRF   45
1AB9:  MOVLW  20
1ABA:  MOVWF  05
1ABB:  MOVLW  BC
1ABC:  MOVWF  04
1ABD:  MOVF   44,W
1ABE:  ADDWF  04,F
1ABF:  MOVLW  00
1AC0:  ADDWFC 05,F
1AC1:  MOVF   45,W
1AC2:  MOVLP  00
1AC3:  MOVLB  00
1AC4:  CALL   171
1AC5:  MOVLP  18
1AC6:  MOVWF  00
1AC7:  IORLW  00
1AC8:  BTFSC  03.2
1AC9:  GOTO   2CF
1ACA:  MOVLB  02
1ACB:  INCF   45,F
1ACC:  INCF   44,F
1ACD:  GOTO   2B9
1ACE:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1ACF:  MOVLW  20
1AD0:  MOVLB  02
1AD1:  MOVWF  45
1AD2:  MOVLW  BC
1AD3:  MOVWF  44
1AD4:  MOVLW  20
1AD5:  MOVWF  47
1AD6:  MOVLW  A5
1AD7:  MOVWF  46
1AD8:  MOVLP  08
1AD9:  MOVLB  00
1ADA:  CALL   74E
1ADB:  MOVLP  18
1ADC:  MOVF   78,F
1ADD:  BTFSS  03.2
1ADE:  GOTO   2E1
....................     command=DECREMENT_REG; 
1ADF:  MOVLW  07
1AE0:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AE1:  MOVLB  02
1AE2:  CLRF   44
1AE3:  CLRF   45
1AE4:  MOVLW  20
1AE5:  MOVWF  05
1AE6:  MOVLW  BC
1AE7:  MOVWF  04
1AE8:  MOVF   44,W
1AE9:  ADDWF  04,F
1AEA:  MOVLW  00
1AEB:  ADDWFC 05,F
1AEC:  MOVF   45,W
1AED:  MOVLP  00
1AEE:  MOVLB  00
1AEF:  CALL   174
1AF0:  MOVLP  18
1AF1:  MOVWF  00
1AF2:  IORLW  00
1AF3:  BTFSC  03.2
1AF4:  GOTO   2FA
1AF5:  MOVLB  02
1AF6:  INCF   45,F
1AF7:  INCF   44,F
1AF8:  GOTO   2E4
1AF9:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1AFA:  MOVLW  20
1AFB:  MOVLB  02
1AFC:  MOVWF  45
1AFD:  MOVLW  BC
1AFE:  MOVWF  44
1AFF:  MOVLW  20
1B00:  MOVWF  47
1B01:  MOVLW  A5
1B02:  MOVWF  46
1B03:  MOVLP  08
1B04:  MOVLB  00
1B05:  CALL   74E
1B06:  MOVLP  18
1B07:  MOVF   78,F
1B08:  BTFSS  03.2
1B09:  GOTO   329
....................     command=SET_REG; 
1B0A:  MOVLW  02
1B0B:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B0C:  MOVLW  01
1B0D:  ADDWF  74,W
1B0E:  ANDLW  03
1B0F:  MOVWF  76
....................     strcpy(argument_name,"CPOT"); 
1B10:  MOVLB  02
1B11:  CLRF   44
1B12:  CLRF   45
1B13:  MOVLW  20
1B14:  MOVWF  05
1B15:  MOVLW  6D
1B16:  MOVWF  04
1B17:  MOVF   44,W
1B18:  ADDWF  04,F
1B19:  MOVLW  00
1B1A:  ADDWFC 05,F
1B1B:  MOVF   45,W
1B1C:  MOVLP  00
1B1D:  MOVLB  00
1B1E:  CALL   177
1B1F:  MOVLP  18
1B20:  MOVWF  00
1B21:  IORLW  00
1B22:  BTFSC  03.2
1B23:  GOTO   329
1B24:  MOVLB  02
1B25:  INCF   45,F
1B26:  INCF   44,F
1B27:  GOTO   313
1B28:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B29:  MOVLB  02
1B2A:  CLRF   44
1B2B:  CLRF   45
1B2C:  MOVLW  20
1B2D:  MOVWF  05
1B2E:  MOVLW  BC
1B2F:  MOVWF  04
1B30:  MOVF   44,W
1B31:  ADDWF  04,F
1B32:  MOVLW  00
1B33:  ADDWFC 05,F
1B34:  MOVF   45,W
1B35:  MOVLP  00
1B36:  MOVLB  00
1B37:  CALL   17D
1B38:  MOVLP  18
1B39:  MOVWF  00
1B3A:  IORLW  00
1B3B:  BTFSC  03.2
1B3C:  GOTO   342
1B3D:  MOVLB  02
1B3E:  INCF   45,F
1B3F:  INCF   44,F
1B40:  GOTO   32C
1B41:  MOVLB  00
....................   if ( stricmp(smatch_reg,verb) == 0 ) { 
1B42:  MOVLW  20
1B43:  MOVLB  02
1B44:  MOVWF  45
1B45:  MOVLW  BC
1B46:  MOVWF  44
1B47:  MOVLW  20
1B48:  MOVWF  47
1B49:  MOVLW  A5
1B4A:  MOVWF  46
1B4B:  MOVLP  08
1B4C:  MOVLB  00
1B4D:  CALL   74E
1B4E:  MOVLP  18
1B4F:  MOVF   78,F
1B50:  BTFSS  03.2
1B51:  GOTO   362
....................     AdminMode = ~AdminMode; 
1B52:  MOVLW  40
1B53:  MOVLB  01
1B54:  XORWF  5A,F
....................     set_admin_mode(AdminMode); 
1B55:  MOVLW  00
1B56:  BTFSC  5A.6
1B57:  MOVLW  01
1B58:  MOVLB  02
1B59:  MOVWF  44
1B5A:  MOVWF  45
1B5B:  MOVLP  08
1B5C:  MOVLB  00
1B5D:  CALL   513
1B5E:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B5F:  MOVLB  01
1B60:  BSF    5A.5
1B61:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
1187:  MOVF   76,W
1188:  SUBLW  FF
1189:  BTFSS  03.2
118A:  GOTO   1B1
....................     printf ("\n\r%s %u",argument,value); 
118B:  MOVLW  0A
118C:  CLRWDT
118D:  BTFSS  11.4
118E:  GOTO   18C
118F:  MOVLB  03
1190:  MOVWF  1A
1191:  MOVLW  0D
1192:  CLRWDT
1193:  MOVLB  00
1194:  BTFSC  11.4
1195:  GOTO   198
1196:  MOVLB  03
1197:  GOTO   192
1198:  MOVLB  03
1199:  MOVWF  1A
119A:  CLRF   05
119B:  MOVF   75,W
119C:  MOVWF  04
119D:  MOVLP  08
119E:  MOVLB  00
119F:  CALL   2A5
11A0:  MOVLP  10
11A1:  MOVLW  20
11A2:  CLRWDT
11A3:  BTFSS  11.4
11A4:  GOTO   1A2
11A5:  MOVLB  03
11A6:  MOVWF  1A
11A7:  MOVF   76,W
11A8:  MOVLB  02
11A9:  MOVWF  55
11AA:  MOVLW  1B
11AB:  MOVWF  56
11AC:  MOVLP  00
11AD:  MOVLB  00
11AE:  CALL   775
11AF:  MOVLP  10
....................   } else { 
11B0:  GOTO   23E
....................     pObj=RegMap[argument].reg_ptr; 
11B1:  RLF    75,W
11B2:  MOVWF  77
11B3:  RLF    77,F
11B4:  MOVLW  FC
11B5:  ANDWF  77,F
11B6:  MOVF   77,W
11B7:  MOVLB  02
11B8:  MOVWF  34
11B9:  INCF   34,W
11BA:  MOVLP  00
11BB:  MOVLB  00
11BC:  CALL   043
11BD:  MOVLP  10
11BE:  MOVWF  7A
11BF:  MOVLB  02
11C0:  MOVF   34,W
11C1:  MOVLP  00
11C2:  MOVLB  00
11C3:  CALL   043
11C4:  MOVLP  10
11C5:  MOVLB  02
11C6:  MOVWF  31
11C7:  MOVF   7A,W
11C8:  MOVWF  32
....................     if ( in_admin_mode() ) { 
11C9:  MOVLB  00
11CA:  CALL   027
11CB:  MOVF   78,F
11CC:  BTFSC  03.2
11CD:  GOTO   1D6
....................       *pObj=value; 
11CE:  MOVLB  02
11CF:  MOVF   31,W
11D0:  MOVWF  04
11D1:  MOVF   32,W
11D2:  MOVWF  05
11D3:  MOVF   76,W
11D4:  MOVWF  00
11D5:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
11D6:  MOVLB  02
11D7:  MOVF   31,W
11D8:  MOVWF  04
11D9:  MOVF   32,W
11DA:  MOVWF  05
11DB:  MOVF   00,W
11DC:  MOVWF  33
....................     LastRegisterIndex = argument; 
11DD:  MOVF   75,W
11DE:  MOVWF  7C
....................     LastRegisterIndexValid=1; 
11DF:  MOVLW  01
11E0:  MOVWF  7D
....................     printf ("\n\rSetting %s(%u) to %u",argument_name,argument,lVar); 
11E1:  MOVLW  F6
11E2:  MOVLB  03
11E3:  MOVWF  11
11E4:  MOVLW  04
11E5:  MOVWF  12
11E6:  BCF    03.0
11E7:  MOVLW  0A
11E8:  MOVLB  02
11E9:  MOVWF  55
11EA:  MOVLP  00
11EB:  MOVLB  00
11EC:  CALL   701
11ED:  MOVLP  10
11EE:  MOVLW  20
11EF:  MOVWF  05
11F0:  MOVLW  6D
11F1:  MOVWF  04
11F2:  MOVLP  08
11F3:  CALL   2A5
11F4:  MOVLP  10
11F5:  MOVLW  28
11F6:  CLRWDT
11F7:  BTFSS  11.4
11F8:  GOTO   1F6
11F9:  MOVLB  03
11FA:  MOVWF  1A
11FB:  MOVF   75,W
11FC:  MOVLB  02
11FD:  MOVWF  55
11FE:  MOVLW  1B
11FF:  MOVWF  56
1200:  MOVLP  00
1201:  MOVLB  00
1202:  CALL   775
1203:  MOVLP  10
1204:  MOVLW  FD
1205:  MOVLB  03
1206:  MOVWF  11
1207:  MOVLW  04
1208:  MOVWF  12
1209:  BSF    03.0
120A:  MOVLW  05
120B:  MOVLB  02
120C:  MOVWF  55
120D:  MOVLP  00
120E:  MOVLB  00
120F:  CALL   701
1210:  MOVLP  10
1211:  MOVLB  02
1212:  MOVF   33,W
1213:  MOVWF  55
1214:  MOVLW  1B
1215:  MOVWF  56
1216:  MOVLP  00
1217:  MOVLB  00
1218:  CALL   775
1219:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
121A:  MOVLB  02
121B:  MOVF   32,W
121C:  SUBLW  1F
121D:  BTFSC  03.0
121E:  GOTO   230
121F:  XORLW  FF
1220:  BTFSS  03.2
1221:  GOTO   226
1222:  MOVF   31,W
1223:  SUBLW  0B
1224:  BTFSC  03.0
1225:  GOTO   230
1226:  MOVF   32,W
1227:  SUBLW  20
1228:  BTFSS  03.0
1229:  GOTO   230
122A:  BTFSS  03.2
122B:  GOTO   237
122C:  MOVF   31,W
122D:  SUBLW  1B
122E:  BTFSC  03.0
122F:  GOTO   237
1230:  MOVF   31,W
1231:  SUBLW  74
1232:  BTFSS  03.2
1233:  GOTO   23B
1234:  MOVF   32,F
1235:  BTFSS  03.2
1236:  GOTO   23B
....................       increment(0); // Increment is done in this function. Only update trim pot. 
1237:  CLRF   34
1238:  MOVLB  00
1239:  CALL   036
123A:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
123B:  MOVLB  01
123C:  BSF    5A.5
123D:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
1036:  MOVF   74,W
1037:  ANDLW  03
1038:  MOVLB  02
1039:  MOVWF  38
....................   if ( CurrentCorIndex ) { 
103A:  MOVLB  00
103B:  MOVF   6B,F
103C:  BTFSC  03.2
103D:  GOTO   075
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
103E:  MOVLW  01
103F:  SUBWF  6B,W
1040:  MOVWF  77
1041:  RLF    77,F
1042:  RLF    77,F
1043:  MOVLW  FC
1044:  ANDWF  77,F
1045:  MOVF   77,W
1046:  MOVLB  02
1047:  ADDWF  38,W
1048:  ADDLW  0C
1049:  MOVWF  78
104A:  MOVLW  20
104B:  MOVWF  7A
104C:  BTFSC  03.0
104D:  INCF   7A,F
104E:  MOVF   78,W
104F:  MOVWF  35
1050:  MOVF   7A,W
1051:  MOVWF  36
....................     value = *pot_ptr; 
1052:  MOVF   35,W
1053:  MOVWF  04
1054:  MOVF   36,W
1055:  MOVWF  05
1056:  MOVF   00,W
1057:  MOVWF  37
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
1058:  MOVF   35,W
1059:  MOVWF  04
105A:  MOVF   36,W
105B:  MOVWF  05
105C:  MOVF   34,W
105D:  ADDWF  37,W
105E:  MOVWF  00
....................     if ( in_admin_mode() ) { 
105F:  MOVLB  00
1060:  CALL   027
1061:  MOVF   78,F
1062:  BTFSC  03.2
1063:  GOTO   075
....................       set_trimpot(CPotPtr,*pot_ptr); 
1064:  MOVLB  02
1065:  MOVF   36,W
1066:  MOVWF  7A
1067:  MOVF   35,W
1068:  MOVWF  04
1069:  MOVF   36,W
106A:  MOVWF  05
106B:  MOVF   00,W
106C:  MOVWF  39
106D:  MOVF   38,W
106E:  MOVWF  44
106F:  MOVF   39,W
1070:  MOVWF  45
1071:  MOVLP  08
1072:  MOVLB  00
1073:  CALL   000
1074:  MOVLP  10
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
1075:  MOVLP  08
1076:  CALL   2BF
1077:  MOVLP  10
.................... } // }}} 
1078:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
1000:  MOVLB  02
1001:  CLRF   44
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
1002:  MOVF   44,W
1003:  SUBLW  05
1004:  BTFSS  03.0
1005:  GOTO   025
....................     dest[c]=src[c]; 
1006:  MOVF   44,W
1007:  ADDWF  40,W
1008:  MOVWF  45
1009:  MOVLW  00
100A:  ADDWFC 41,W
100B:  MOVWF  46
100C:  MOVF   44,W
100D:  ADDWF  42,W
100E:  MOVWF  78
100F:  MOVLW  00
1010:  ADDWFC 43,W
1011:  MOVWF  7A
1012:  MOVF   78,W
1013:  MOVLB  03
1014:  MOVWF  11
1015:  MOVF   7A,W
1016:  MOVWF  12
1017:  MOVLB  02
1018:  MOVF   46,W
1019:  MOVWF  05
101A:  MOVF   45,W
101B:  MOVWF  04
101C:  MOVLW  01
101D:  MOVWF  4A
101E:  MOVLP  00
101F:  MOVLB  00
1020:  CALL   7DD
1021:  MOVLP  10
....................   c++; 
1022:  MOVLB  02
1023:  INCF   44,F
....................   } 
1024:  GOTO   002
.................... } // }}} 
1025:  MOVLB  00
1026:  RETURN
.................... void ExecAuxOutOp(int op,int arg,int ID) { // {{{ 
....................   int cor_in_local; 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
16CD:  MOVF   2F,W
16CE:  ANDLW  0F
16CF:  MOVWF  32
....................   uarg = (arg & 0xF0) >> 4; 
16D0:  MOVF   2F,W
16D1:  ANDLW  F0
16D2:  MOVWF  77
16D3:  SWAPF  77,W
16D4:  MOVWF  33
16D5:  MOVLW  0F
16D6:  ANDWF  33,F
....................   cor_in_local = COR_IN | (COR_EMUL&0x0F); 
16D7:  MOVLB  00
16D8:  MOVF   67,W
16D9:  ANDLW  0F
16DA:  IORWF  5F,W
16DB:  MOVLB  02
16DC:  MOVWF  31
....................   switch(op) { 
16DD:  MOVF   2E,W
16DE:  XORLW  01
16DF:  MOVLB  00
16E0:  BTFSC  03.2
16E1:  GOTO   6E6
16E2:  XORLW  03
16E3:  BTFSC  03.2
16E4:  GOTO   6FB
16E5:  GOTO   714
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Use COR_IN from HW ports here 
....................       AuxOut[ID] = ((COR_IN ^ uarg) & larg) != 0; 
16E6:  MOVLW  22
16E7:  MOVLB  02
16E8:  ADDWF  30,W
16E9:  MOVWF  04
16EA:  MOVLW  20
16EB:  MOVWF  05
16EC:  BTFSC  03.0
16ED:  INCF   05,F
16EE:  MOVLB  00
16EF:  MOVF   5F,W
16F0:  MOVLB  02
16F1:  XORWF  33,W
16F2:  ANDWF  32,W
16F3:  BTFSS  03.2
16F4:  GOTO   6F7
16F5:  MOVLW  00
16F6:  GOTO   6F8
16F7:  MOVLW  01
16F8:  MOVWF  00
....................     break; 
16F9:  MOVLB  00
16FA:  GOTO   714
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
16FB:  MOVLW  22
16FC:  MOVLB  02
16FD:  ADDWF  30,W
16FE:  MOVWF  04
16FF:  MOVLW  20
1700:  MOVWF  05
1701:  BTFSC  03.0
1702:  INCF   05,F
1703:  MOVF   32,W
1704:  ANDLW  1F
1705:  MOVWF  36
1706:  MOVF   7A,W
1707:  MOVWF  37
1708:  MOVF   33,W
1709:  XORWF  36,F
170A:  BTFSS  03.2
170B:  GOTO   711
170C:  MOVF   37,F
170D:  BTFSS  03.2
170E:  GOTO   711
170F:  MOVLW  00
1710:  GOTO   712
1711:  MOVLW  01
1712:  MOVWF  00
....................     break; 
1713:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0F15:  MOVLB  02
0F16:  CLRF   46
0F17:  CLRF   47
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0F18:  MOVF   46,W
0F19:  ADDWF  44,W
0F1A:  MOVWF  04
0F1B:  MOVLW  00
0F1C:  ADDWFC 45,W
0F1D:  MOVWF  05
0F1E:  MOVF   00,F
0F1F:  BTFSC  03.2
0F20:  GOTO   74A
0F21:  MOVF   46,W
0F22:  ADDWF  44,W
0F23:  MOVWF  04
0F24:  MOVLW  00
0F25:  ADDWFC 45,W
0F26:  MOVWF  05
0F27:  MOVF   00,W
0F28:  SUBLW  2F
0F29:  BTFSC  03.0
0F2A:  GOTO   74A
0F2B:  MOVF   46,W
0F2C:  ADDWF  44,W
0F2D:  MOVWF  04
0F2E:  MOVLW  00
0F2F:  ADDWFC 45,W
0F30:  MOVWF  05
0F31:  MOVF   00,W
0F32:  SUBLW  39
0F33:  BTFSS  03.0
0F34:  GOTO   74A
....................     value = (value * 10) + (str[x]-'0'); 
0F35:  MOVF   47,W
0F36:  MOVWF  48
0F37:  MOVLW  0A
0F38:  MOVWF  49
0F39:  MOVLB  00
0F3A:  CALL   6EE
0F3B:  MOVF   78,W
0F3C:  MOVLB  02
0F3D:  MOVWF  48
0F3E:  MOVF   46,W
0F3F:  ADDWF  44,W
0F40:  MOVWF  04
0F41:  MOVLW  00
0F42:  ADDWFC 45,W
0F43:  MOVWF  05
0F44:  MOVLW  30
0F45:  SUBWF  00,W
0F46:  ADDWF  48,W
0F47:  MOVWF  47
....................     x++; 
0F48:  INCF   46,F
....................   } 
0F49:  GOTO   718
....................   return(value); 
0F4A:  MOVF   47,W
0F4B:  MOVWF  78
.................... } // }}} 
0F4C:  MOVLB  00
0F4D:  RETURN
....................  
.................... void ExecAuxInOp(int op,int arg,int ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
15ED:  MOVLB  02
15EE:  BCF    31.0
15EF:  MOVLW  1F
15F0:  ADDWF  30,W
15F1:  MOVWF  04
15F2:  MOVLW  20
15F3:  MOVWF  05
15F4:  BTFSC  03.0
15F5:  INCF   05,F
15F6:  MOVF   00,F
15F7:  BTFSS  03.2
15F8:  BSF    31.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
15F9:  MOVF   2F,W
15FA:  ANDLW  0F
15FB:  MOVWF  32
....................   uarg = (arg & 0xF0) >> 4; 
15FC:  MOVF   2F,W
15FD:  ANDLW  F0
15FE:  MOVWF  77
15FF:  SWAPF  77,W
1600:  MOVWF  33
1601:  MOVLW  0F
1602:  ANDWF  33,F
....................   switch(op) { 
1603:  MOVLW  01
1604:  SUBWF  2E,W
1605:  ADDLW  FC
1606:  BTFSC  03.0
1607:  GOTO   64E
1608:  ADDLW  04
1609:  MOVLB  00
160A:  GOTO   651
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
160B:  MOVLB  02
160C:  BTFSS  31.0
160D:  GOTO   613
....................         Enable_Mask &= arg; 
160E:  MOVF   2F,W
160F:  MOVLB  00
1610:  ANDWF  61,F
....................       } else { // AuxIn is not enabled 
1611:  GOTO   618
1612:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
1613:  MOVF   2F,W
1614:  XORLW  FF
1615:  ANDLW  0F
1616:  MOVLB  00
1617:  IORWF  61,F
....................       } 
....................       break; 
1618:  MOVLB  02
1619:  GOTO   64E
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
161A:  MOVLB  02
161B:  BTFSS  31.0
161C:  GOTO   623
....................         COR_DROP_FLAG=1; 
161D:  BSF    72.7
....................         TailChar=arg; 
161E:  MOVF   2F,W
161F:  MOVLB  00
1620:  MOVWF  68
....................       } else { 
1621:  GOTO   625
1622:  MOVLB  02
....................         TailChar=0; 
1623:  MOVLB  00
1624:  CLRF   68
....................       } 
....................     break; 
1625:  MOVLB  02
1626:  GOTO   64E
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
1627:  MOVLB  02
1628:  BTFSC  31.0
1629:  GOTO   630
....................         COR_DROP_FLAG=1; 
162A:  BSF    72.7
....................         TailChar=arg; 
162B:  MOVF   2F,W
162C:  MOVLB  00
162D:  MOVWF  68
....................       } else { 
162E:  GOTO   632
162F:  MOVLB  02
....................         TailChar=0; 
1630:  MOVLB  00
1631:  CLRF   68
....................       } 
....................     break; 
1632:  MOVLB  02
1633:  GOTO   64E
....................     case AUXI_EMULATE_COR: 
....................       if ( (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0 ) { 
1634:  MOVLB  02
1635:  MOVF   2F,W
1636:  ANDLW  10
1637:  BTFSC  03.2
1638:  GOTO   63D
....................         tmp_bit = ~in_bit; 
1639:  BCF    31.1
163A:  BTFSS  31.0
163B:  BSF    31.1
....................       } else { 
163C:  GOTO   640
....................         tmp_bit = in_bit; 
163D:  BCF    31.1
163E:  BTFSC  31.0
163F:  BSF    31.1
....................       } 
....................       if ( tmp_bit ) { 
1640:  BTFSS  31.1
1641:  GOTO   647
....................         COR_EMUL |= larg; 
1642:  MOVF   32,W
1643:  MOVLB  00
1644:  IORWF  67,F
....................       } else { 
1645:  GOTO   64B
1646:  MOVLB  02
....................         COR_EMUL &= ~larg; 
1647:  MOVF   32,W
1648:  XORLW  FF
1649:  MOVLB  00
164A:  ANDWF  67,F
....................       } 
....................     break; 
164B:  MOVLB  02
164C:  GOTO   64E
164D:  MOVLB  02
....................   } 
.................... } // }}} 
164E:  MOVLP  10
164F:  MOVLB  00
1650:  GOTO   785 (RETURN)
....................  
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
15A2:  MOVLB  01
15A3:  CLRF   6B
15A4:  MOVF   6B,W
15A5:  SUBLW  02
15A6:  BTFSS  03.0
15A7:  GOTO   5EA
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = (input(AUX_IN_PIN[x])!=0) || (AuxIn[x]!=0); 
15A8:  MOVLW  1F
15A9:  ADDWF  6B,W
15AA:  MOVWF  78
15AB:  MOVLW  20
15AC:  MOVWF  7A
15AD:  BTFSC  03.0
15AE:  INCF   7A,F
15AF:  MOVF   78,W
15B0:  MOVWF  6C
15B1:  MOVF   7A,W
15B2:  MOVWF  6D
15B3:  MOVF   6B,W
15B4:  MOVLP  00
15B5:  MOVLB  00
15B6:  CALL   03F
15B7:  MOVLP  10
15B8:  MOVLB  01
15B9:  MOVWF  6E
15BA:  MOVLB  02
15BB:  MOVWF  45
15BC:  MOVLW  01
15BD:  MOVWF  46
15BE:  CLRF   48
15BF:  MOVLW  80
15C0:  MOVWF  47
15C1:  MOVLP  08
15C2:  MOVLB  00
15C3:  CALL   142
15C4:  MOVLP  10
15C5:  MOVLB  01
15C6:  MOVF   6E,W
15C7:  MOVWF  6F
15C8:  MOVLB  02
15C9:  CLRF   21
15CA:  CLRF   20
15CB:  MOVLB  00
15CC:  GOTO   587
15CD:  BTFSC  78.0
15CE:  GOTO   5DF
15CF:  MOVLW  1C
15D0:  MOVLB  01
15D1:  ADDWF  6B,W
15D2:  MOVWF  04
15D3:  MOVLW  20
15D4:  MOVWF  05
15D5:  BTFSC  03.0
15D6:  INCF   05,F
15D7:  MOVF   00,F
15D8:  BTFSC  03.2
15D9:  GOTO   5DC
15DA:  MOVLB  00
15DB:  GOTO   5DF
15DC:  MOVLW  00
15DD:  GOTO   5E1
15DE:  MOVLB  00
15DF:  MOVLW  01
15E0:  MOVLB  01
15E1:  MOVWF  6F
15E2:  MOVF   6D,W
15E3:  MOVWF  05
15E4:  MOVF   6C,W
15E5:  MOVWF  04
15E6:  MOVF   6F,W
15E7:  MOVWF  00
....................   } 
15E8:  INCF   6B,F
15E9:  GOTO   5A4
.................... } // }}} 
15EA:  MOVLP  18
15EB:  MOVLB  00
15EC:  GOTO   6AD (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
1692:  MOVLW  30
1693:  MOVLB  01
1694:  MOVWF  6E
1695:  MOVWF  6F
1696:  MOVLB  02
1697:  MOVWF  20
1698:  CLRF   21
....................   char AuxOut_s[4]={'0','0','0',0}; 
1699:  MOVWF  22
169A:  MOVWF  23
169B:  MOVWF  24
169C:  CLRF   25
....................   char ADM[]=" ADMIN"; 
169D:  MOVLW  20
169E:  MOVWF  26
169F:  MOVLW  41
16A0:  MOVWF  27
16A1:  MOVLW  44
16A2:  MOVWF  28
16A3:  MOVLW  4D
16A4:  MOVWF  29
16A5:  MOVLW  49
16A6:  MOVWF  2A
16A7:  MOVLW  4E
16A8:  MOVWF  2B
16A9:  CLRF   2C
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
16AA:  MOVLB  01
16AB:  CLRF   6B
16AC:  MOVF   6B,W
16AD:  SUBLW  02
16AE:  BTFSS  03.0
16AF:  GOTO   788
....................     AuxOp = AuxOutOp[x]; 
16B0:  MOVLW  33
16B1:  ADDWF  6B,W
16B2:  MOVWF  04
16B3:  MOVLW  20
16B4:  MOVWF  05
16B5:  BTFSC  03.0
16B6:  INCF   05,F
16B7:  MOVF   00,W
16B8:  MOVWF  6C
....................     AuxArg = AuxOutArg[x]; 
16B9:  MOVLW  36
16BA:  ADDWF  6B,W
16BB:  MOVWF  04
16BC:  MOVLW  20
16BD:  MOVWF  05
16BE:  BTFSC  03.0
16BF:  INCF   05,F
16C0:  MOVF   00,W
16C1:  MOVWF  6D
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
16C2:  MOVF   6C,W
16C3:  MOVLB  02
16C4:  MOVWF  2E
16C5:  MOVLB  01
16C6:  MOVF   6D,W
16C7:  MOVLB  02
16C8:  MOVWF  2F
16C9:  MOVLB  01
16CA:  MOVF   6B,W
16CB:  MOVLB  02
16CC:  MOVWF  30
....................     out_bit = (AuxOut[x])==0; 
*
1714:  MOVLB  02
1715:  BCF    2D.0
1716:  MOVLW  22
1717:  MOVLB  01
1718:  ADDWF  6B,W
1719:  MOVWF  04
171A:  MOVLW  20
171B:  MOVWF  05
171C:  BTFSC  03.0
171D:  INCF   05,F
171E:  MOVF   00,F
171F:  BTFSS  03.2
1720:  GOTO   724
1721:  MOVLB  02
1722:  BSF    2D.0
1723:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
1724:  MOVF   6B,W
1725:  MOVLP  00
1726:  MOVLB  00
1727:  CALL   03B
1728:  MOVLP  10
1729:  MOVLB  02
172A:  MOVWF  2E
172B:  MOVLW  00
172C:  BTFSC  2D.0
172D:  MOVLW  01
172E:  MOVWF  77
172F:  MOVF   2E,W
1730:  MOVWF  45
1731:  MOVF   77,W
1732:  MOVWF  46
1733:  MOVLW  01
1734:  MOVWF  48
1735:  CLRF   47
1736:  MOVLP  08
1737:  MOVLB  00
1738:  CALL   142
1739:  MOVLP  10
173A:  MOVLB  02
173B:  MOVF   2E,W
173C:  MOVWF  45
173D:  CLRF   46
173E:  CLRF   48
173F:  MOVLW  80
1740:  MOVWF  47
1741:  MOVLP  08
1742:  MOVLB  00
1743:  CALL   142
1744:  MOVLP  10
....................     if(out_bit==0) { 
1745:  MOVLB  02
1746:  BTFSC  2D.0
1747:  GOTO   753
....................       AuxOut_s[x]='1'; 
1748:  MOVLW  A2
1749:  MOVLB  01
174A:  ADDWF  6B,W
174B:  MOVWF  04
174C:  MOVLW  20
174D:  MOVWF  05
174E:  BTFSC  03.0
174F:  INCF   05,F
1750:  MOVLW  31
1751:  MOVWF  00
1752:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
1753:  MOVLW  39
1754:  MOVLB  01
1755:  ADDWF  6B,W
1756:  MOVWF  04
1757:  MOVLW  20
1758:  MOVWF  05
1759:  BTFSC  03.0
175A:  INCF   05,F
175B:  MOVF   00,W
175C:  MOVWF  6C
....................     AuxArg = AuxInArg[x]; 
175D:  MOVLW  3C
175E:  ADDWF  6B,W
175F:  MOVWF  04
1760:  MOVLW  20
1761:  MOVWF  05
1762:  BTFSC  03.0
1763:  INCF   05,F
1764:  MOVF   00,W
1765:  MOVWF  6D
....................     if(AuxInSW[x]==1) { 
1766:  MOVLW  1F
1767:  ADDWF  6B,W
1768:  MOVWF  04
1769:  MOVLW  20
176A:  MOVWF  05
176B:  BTFSC  03.0
176C:  INCF   05,F
176D:  DECFSZ 00,W
176E:  GOTO   778
....................       AuxIn_s[x]='1'; 
176F:  MOVLW  9E
1770:  ADDWF  6B,W
1771:  MOVWF  04
1772:  MOVLW  20
1773:  MOVWF  05
1774:  BTFSC  03.0
1775:  INCF   05,F
1776:  MOVLW  31
1777:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
1778:  MOVF   6C,W
1779:  MOVLB  02
177A:  MOVWF  2E
177B:  MOVLB  01
177C:  MOVF   6D,W
177D:  MOVLB  02
177E:  MOVWF  2F
177F:  MOVLB  01
1780:  MOVF   6B,W
1781:  MOVLB  02
1782:  MOVWF  30
1783:  MOVLB  00
1784:  GOTO   5ED
....................     // }}} 
....................   } 
1785:  MOVLB  01
1786:  INCF   6B,F
1787:  GOTO   6AC
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
1788:  MOVLW  20
1789:  MOVWF  61
178A:  MOVLW  73
178B:  MOVWF  60
178C:  MOVLW  49
178D:  MOVLB  02
178E:  MOVWF  55
178F:  MOVLP  00
1790:  MOVLB  00
1791:  CALL   7F0
1792:  MOVLP  10
1793:  MOVLW  3A
1794:  MOVLB  02
1795:  MOVWF  55
1796:  MOVLP  00
1797:  MOVLB  00
1798:  CALL   7F0
1799:  MOVLP  10
179A:  MOVLW  20
179B:  MOVWF  05
179C:  MOVLW  9E
179D:  MOVWF  04
179E:  MOVLP  08
179F:  CALL   1BB
17A0:  MOVLP  10
17A1:  MOVLW  20
17A2:  MOVLB  02
17A3:  MOVWF  55
17A4:  MOVLP  00
17A5:  MOVLB  00
17A6:  CALL   7F0
17A7:  MOVLP  10
17A8:  MOVLW  4F
17A9:  MOVLB  02
17AA:  MOVWF  55
17AB:  MOVLP  00
17AC:  MOVLB  00
17AD:  CALL   7F0
17AE:  MOVLP  10
17AF:  MOVLW  3A
17B0:  MOVLB  02
17B1:  MOVWF  55
17B2:  MOVLP  00
17B3:  MOVLB  00
17B4:  CALL   7F0
17B5:  MOVLP  10
17B6:  MOVLW  20
17B7:  MOVWF  05
17B8:  MOVLW  A2
17B9:  MOVWF  04
17BA:  MOVLP  08
17BB:  CALL   1BB
17BC:  MOVLP  10
....................   if ( AdminMode ) { 
17BD:  MOVLB  01
17BE:  BTFSS  5A.6
17BF:  GOTO   7CC
....................     strcat(LCD_str,ADM); 
17C0:  MOVLW  20
17C1:  MOVLB  02
17C2:  MOVWF  2F
17C3:  MOVLW  73
17C4:  MOVWF  2E
17C5:  MOVLW  20
17C6:  MOVWF  31
17C7:  MOVLW  A6
17C8:  MOVWF  30
17C9:  MOVLB  00
17CA:  CALL   659
17CB:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
17CC:  MOVLW  03
17CD:  MOVLB  02
17CE:  MOVWF  4F
17CF:  MOVLW  20
17D0:  MOVWF  51
17D1:  MOVLW  73
17D2:  MOVWF  50
17D3:  MOVLP  08
17D4:  MOVLB  00
17D5:  CALL   1D2
17D6:  MOVLP  10
.................... } // }}} 
17D7:  RETURN
....................  
....................  
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
10DA:  MOVLW  01
10DB:  MOVLB  02
10DC:  MOVWF  33
10DD:  MOVLP  08
10DE:  MOVLB  00
10DF:  CALL   3C1
10E0:  MOVLP  10
....................   delay_ms(1000); 
10E1:  MOVLW  04
10E2:  MOVLB  02
10E3:  MOVWF  33
10E4:  MOVLW  FA
10E5:  MOVWF  4F
10E6:  MOVLP  00
10E7:  MOVLB  00
10E8:  CALL   7C4
10E9:  MOVLP  10
10EA:  MOVLB  02
10EB:  DECFSZ 33,F
10EC:  GOTO   0E4
....................   for(x=0;x<6;x++) { 
10ED:  CLRF   31
10EE:  MOVF   31,W
10EF:  SUBLW  05
10F0:  BTFSS  03.0
10F1:  GOTO   10E
....................     mchar=Morse[x]; 
10F2:  MOVLW  2D
10F3:  ADDWF  31,W
10F4:  MOVWF  04
10F5:  MOVLW  20
10F6:  MOVWF  05
10F7:  BTFSC  03.0
10F8:  INCF   05,F
10F9:  MOVF   00,W
10FA:  MOVWF  32
....................     morse(mchar); 
10FB:  MOVF   32,W
10FC:  MOVWF  44
10FD:  MOVLP  08
10FE:  MOVLB  00
10FF:  CALL   0E9
1100:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
1101:  MOVLB  01
1102:  CLRF   30
1103:  MOVLW  06
1104:  MOVWF  2F
....................     while(aux_timer) { 
1105:  MOVF   2F,W
1106:  IORWF  30,W
1107:  BTFSC  03.2
1108:  GOTO   10B
....................       delay_cycles(1); 
1109:  NOP
....................     } 
110A:  GOTO   105
....................   } 
110B:  MOVLB  02
110C:  INCF   31,F
110D:  GOTO   0EE
....................   delay_ms(1000); 
110E:  MOVLW  04
110F:  MOVWF  33
1110:  MOVLW  FA
1111:  MOVWF  4F
1112:  MOVLP  00
1113:  MOVLB  00
1114:  CALL   7C4
1115:  MOVLP  10
1116:  MOVLB  02
1117:  DECFSZ 33,F
1118:  GOTO   110
....................   COR_FLAG=1; 
1119:  BSF    72.3
.................... } // }}} 
111A:  MOVLB  00
111B:  RETURN
....................  
.................... void main (void) { // {{{ 
*
1DC4:  CLRF   05
1DC5:  CLRF   04
1DC6:  MOVLW  1F
1DC7:  ANDWF  03,F
1DC8:  MOVLW  72
1DC9:  MOVLB  01
1DCA:  MOVWF  19
1DCB:  BSF    0E.3
1DCC:  BSF    0E.4
1DCD:  MOVLB  04
1DCE:  BCF    17.0
1DCF:  BCF    17.1
1DD0:  BCF    17.3
1DD1:  MOVLW  13
1DD2:  MOVWF  12
1DD3:  MOVLW  28
1DD4:  MOVWF  15
1DD5:  BSF    14.7
1DD6:  BCF    14.6
1DD7:  MOVLW  0C
1DD8:  MOVLB  03
1DD9:  MOVWF  1B
1DDA:  MOVLW  A2
1DDB:  MOVWF  1E
1DDC:  MOVLW  90
1DDD:  MOVWF  1D
1DDE:  MOVLB  01
1DDF:  BSF    5F.0
1DE0:  CLRF   61
1DE1:  CLRF   60
1DE2:  MOVLB  0F
1DE3:  CLRF   11
1DE4:  CLRF   12
1DE5:  CLRF   18
1DE6:  CLRF   19
1DE7:  CLRF   1A
1DE8:  MOVLB  03
1DE9:  CLRF   0C
1DEA:  CLRF   0D
1DEB:  CLRF   0F
1DEC:  CLRF   10
1DED:  MOVLB  02
1DEE:  CLRF   12
1DEF:  CLRF   11
1DF0:  CLRF   14
1DF1:  CLRF   13
....................   int x,dtmf; 
....................   char tmp[5]; 
....................   initialize(); 
*
1DF5:  MOVLP  08
1DF6:  GOTO   52A
1DF7:  MOVLP  18
....................   char enter_b,select_b; 
....................  
....................   setup_adc(ADC_CLOCK_INTERNAL); 
1DF8:  MOVLB  01
1DF9:  BSF    1E.4
1DFA:  BSF    1E.5
1DFB:  BCF    1E.6
1DFC:  BCF    1E.7
1DFD:  BSF    1D.0
....................   setup_adc_ports(ADJ_POT|VSS_VDD); 
1DFE:  BCF    1E.0
1DFF:  BCF    1E.1
1E00:  BCF    1E.2
1E01:  MOVLW  00
1E02:  MOVLB  03
1E03:  MOVWF  0C
1E04:  MOVWF  10
1E05:  MOVLW  20
1E06:  MOVWF  0D
1E07:  MOVLW  00
1E08:  MOVWF  0F
....................   set_adc_channel(13); 
1E09:  MOVLW  34
1E0A:  MOVWF  78
1E0B:  MOVLB  01
1E0C:  MOVF   1D,W
1E0D:  ANDLW  83
1E0E:  IORWF  78,W
1E0F:  MOVWF  1D
....................  
....................   while(1) { // {{{ 
....................     restart_wdt(); 
1E10:  CLRWDT
.................... #ifdef BUTTON_STATES 
....................   // Process Enter / select buttons {{{ 
....................   if ( input(ENTER_BUTTON)==0 ) { 
1E11:  BSF    0C.7
1E12:  MOVLB  00
1E13:  BTFSC  0C.7
1E14:  GOTO   621
....................     ENTER_PRESSED = (enter_b == DEBOUNCE_COUNT); 
1E15:  BCF    72.1
1E16:  MOVLB  01
1E17:  MOVF   69,W
1E18:  SUBLW  08
1E19:  BTFSC  03.2
1E1A:  BSF    72.1
....................     if ( enter_b < DEBOUNCE_COUNT+ 1 ) { 
1E1B:  MOVF   69,W
1E1C:  SUBLW  08
1E1D:  BTFSC  03.0
....................       enter_b++;  
1E1E:  INCF   69,F
....................     } 
....................   } else { 
1E1F:  GOTO   624
1E20:  MOVLB  00
....................     enter_b = 0; 
1E21:  MOVLB  01
1E22:  CLRF   69
....................     ENTER_PRESSED = 0; 
1E23:  BCF    72.1
....................   } 
....................   if ( input(SELECT_BUTTON)==0 ) { 
1E24:  MOVLB  00
1E25:  BTFSC  10.3
1E26:  GOTO   633
....................     SELECT_PRESSED = (select_b == DEBOUNCE_COUNT); 
1E27:  BCF    72.2
1E28:  MOVLB  01
1E29:  MOVF   6A,W
1E2A:  SUBLW  08
1E2B:  BTFSC  03.2
1E2C:  BSF    72.2
....................     if ( select_b < DEBOUNCE_COUNT + 1 ) { 
1E2D:  MOVF   6A,W
1E2E:  SUBLW  08
1E2F:  BTFSC  03.0
....................       select_b++; 
1E30:  INCF   6A,F
....................     } 
....................   } else { 
1E31:  GOTO   636
1E32:  MOVLB  00
....................     select_b = 0; 
1E33:  MOVLB  01
1E34:  CLRF   6A
....................     SELECT_PRESSED = 0; 
1E35:  BCF    72.2
....................   } 
....................   // Define Button States 
....................   // IDLE + ENTER --> TRIM 
....................   // TRIM + ENTER --> Exit 
....................   // TRIM + SELECT --> NextPot 
....................   #define IDLE 0 
....................   #define CALIB 16 
....................   #define TRIM 15  
....................   switch (button_state) { 
1E36:  MOVF   59,W
1E37:  XORLW  00
1E38:  MOVLB  00
1E39:  BTFSC  03.2
1E3A:  GOTO   642
1E3B:  XORLW  10
1E3C:  BTFSC  03.2
1E3D:  GOTO   649
1E3E:  XORLW  1F
1E3F:  BTFSC  03.2
1E40:  GOTO   65B
1E41:  GOTO   69B
....................     case IDLE:   
....................       if ( ENTER_PRESSED == 1 ) { 
1E42:  BTFSS  72.1
1E43:  GOTO   648
....................         button_state=CALIB; 
1E44:  MOVLW  10
1E45:  MOVLB  01
1E46:  MOVWF  59
1E47:  MOVLB  00
....................       } 
....................     break; 
1E48:  GOTO   69E
....................     case CALIB: 
....................       adj_value_a = read_adc() >> 2; 
1E49:  MOVLB  01
1E4A:  BSF    1D.1
1E4B:  BTFSC  1D.1
1E4C:  GOTO   64B
1E4D:  RRF    1C,W
1E4E:  MOVWF  7E
1E4F:  RRF    7E,F
1E50:  MOVLW  3F
1E51:  ANDWF  7E,F
....................       adj_value_b = adj_value_a; 
1E52:  MOVF   7E,W
1E53:  MOVWF  58
....................       button_state=TRIM; 
1E54:  MOVLW  0F
1E55:  MOVWF  59
....................       pot_values_to_lcd(); 
1E56:  MOVLP  08
1E57:  MOVLB  00
1E58:  CALL   2BF
1E59:  MOVLP  18
....................       break; 
1E5A:  GOTO   69E
....................     case TRIM: 
....................        if ( ((COR_IN|COR_EMUL)&0x0F) != 0 ) { 
1E5B:  MOVF   5F,W
1E5C:  IORWF  67,W
1E5D:  ANDLW  0F
1E5E:  BTFSC  03.2
1E5F:  GOTO   684
....................          adj_value_a = read_adc() >> 2; 
1E60:  MOVLB  01
1E61:  BSF    1D.1
1E62:  BTFSC  1D.1
1E63:  GOTO   662
1E64:  RRF    1C,W
1E65:  MOVWF  7E
1E66:  RRF    7E,F
1E67:  MOVLW  3F
1E68:  ANDWF  7E,F
....................          if ( adj_value_a != adj_value_b ) { 
1E69:  MOVF   58,W
1E6A:  SUBWF  7E,W
1E6B:  BTFSC  03.2
1E6C:  GOTO   681
....................            rs232_mode = 1; 
1E6D:  BSF    5A.7
....................            set_trimpot(CurrentTrimPot, 63-adj_value_a); 
1E6E:  MOVF   7E,W
1E6F:  SUBLW  3F
1E70:  MOVWF  6B
1E71:  MOVF   74,W
1E72:  MOVLB  02
1E73:  MOVWF  44
1E74:  MOVLB  01
1E75:  MOVF   6B,W
1E76:  MOVLB  02
1E77:  MOVWF  45
1E78:  MOVLP  08
1E79:  MOVLB  00
1E7A:  CALL   000
1E7B:  MOVLP  18
....................            pot_values_to_lcd(); 
1E7C:  MOVLP  08
1E7D:  CALL   2BF
1E7E:  MOVLP  18
....................            rs232_mode = 0; 
1E7F:  MOVLB  01
1E80:  BCF    5A.7
....................          } 
....................          adj_value_b = adj_value_a; 
1E81:  MOVF   7E,W
1E82:  MOVWF  58
1E83:  MOVLB  00
.................... 	     } 
....................        if ( SELECT_PRESSED == 1 ) { 
1E84:  BTFSS  72.2
1E85:  GOTO   68D
....................          CurrentTrimPot = (CurrentTrimPot + 1 ) & 0x03; 
1E86:  MOVLW  01
1E87:  ADDWF  74,W
1E88:  ANDLW  03
1E89:  MOVWF  74
....................          pot_values_to_lcd(); 
1E8A:  MOVLP  08
1E8B:  CALL   2BF
1E8C:  MOVLP  18
....................        } 
....................        if ( ENTER_PRESSED == 1 ) { 
1E8D:  BTFSS  72.1
1E8E:  GOTO   697
....................          // Hold SELECT and press ENTER to store settings in EEPROM 
....................          if ( input(SELECT_BUTTON)==0 ) { 
1E8F:  BTFSC  10.3
1E90:  GOTO   694
....................            store_variables(); 
1E91:  MOVLP  00
1E92:  CALL   61C
1E93:  MOVLP  18
....................          } 
....................          button_state = IDLE; 
1E94:  MOVLB  01
1E95:  CLRF   59
1E96:  MOVLB  00
.................... 	     }  
....................        status_led(); 
1E97:  MOVLP  08
1E98:  GOTO   5E5
1E99:  MOVLP  18
....................     break; 
1E9A:  GOTO   69E
....................     default: 
....................   		button_state = IDLE; 
1E9B:  MOVLB  01
1E9C:  CLRF   59
....................     break; 
1E9D:  MOVLB  00
....................   } 
....................   restart_wdt(); 
1E9E:  CLRWDT
....................   // }}} 
.................... #endif 
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "#" or a "\r" is received. 
....................     if ( sBufferFlag ) { 
1E9F:  BTFSS  72.0
1EA0:  GOTO   6A6
....................       process_sBuffer(); 
1EA1:  GOTO   000
....................       clear_sBuffer(); 
1EA2:  MOVLP  00
1EA3:  CALL   50F
1EA4:  MOVLP  18
....................       sBufferFlag=0; 
1EA5:  BCF    72.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1EA6:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1EA7:  MOVLB  01
1EA8:  BTFSS  5A.0
1EA9:  GOTO   6B0
....................       update_aux_in(); 
1EAA:  MOVLP  10
1EAB:  MOVLB  00
1EAC:  GOTO   5A2
1EAD:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1EAE:  MOVLB  01
1EAF:  BCF    5A.0
....................     } 
....................     if ( SECOND_FLAG ) { 
1EB0:  BTFSS  72.4
1EB1:  GOTO   6FB
....................       update_aux_out(); 
1EB2:  MOVLP  10
1EB3:  MOVLB  00
1EB4:  CALL   692
1EB5:  MOVLP  18
....................       // Time Out PTT {{{ 
....................       if ( TOT_SecondCounter || TOT_Min == 0) { 
1EB6:  MOVLB  01
1EB7:  MOVF   5D,W
1EB8:  IORWF  5E,W
1EB9:  BTFSS  03.2
1EBA:  GOTO   6C0
1EBB:  MOVLB  00
1EBC:  MOVF   66,F
1EBD:  BTFSS  03.2
1EBE:  GOTO   6C6
1EBF:  MOVLB  01
....................         TOT_SecondCounter--; 
1EC0:  MOVF   5D,W
1EC1:  BTFSC  03.2
1EC2:  DECF   5E,F
1EC3:  DECF   5D,F
....................       } else if ( COR_IN != 0x00 ) { 
1EC4:  GOTO   6DA
1EC5:  MOVLB  00
1EC6:  MOVF   5F,F
1EC7:  BTFSC  03.2
1EC8:  GOTO   6DB
....................         update_ptt(0); 
1EC9:  MOVLB  02
1ECA:  CLRF   33
1ECB:  MOVLP  08
1ECC:  MOVLB  00
1ECD:  CALL   3C1
1ECE:  MOVLP  18
....................         printf("\n\r# PTT Timeout!\n"); 
1ECF:  MOVLW  02
1ED0:  MOVLB  03
1ED1:  MOVWF  11
1ED2:  MOVLW  05
1ED3:  MOVWF  12
1ED4:  MOVLP  00
1ED5:  MOVLB  00
1ED6:  CALL   529
1ED7:  MOVLP  18
....................         PROMPT_FLAG=1; 
1ED8:  MOVLB  01
1ED9:  BSF    5A.5
1EDA:  MOVLB  00
....................       } 
....................       // }}} 
....................       // Admin mode timeout {{{ 
....................       if ( admin_timer ) { 
1EDB:  MOVF   73,F
1EDC:  BTFSC  03.2
1EDD:  GOTO   6E0
....................         admin_timer--; 
1EDE:  DECF   73,F
....................       } else { 
1EDF:  GOTO   6E9
....................         // Exit admin mode. 
....................         if ( AdminMode ) { 
1EE0:  MOVLB  01
1EE1:  BTFSS  5A.6
1EE2:  GOTO   6EA
....................           set_admin_mode(0); 
1EE3:  MOVLB  02
1EE4:  CLRF   45
1EE5:  MOVLP  08
1EE6:  MOVLB  00
1EE7:  CALL   513
1EE8:  MOVLP  18
1EE9:  MOVLB  01
....................         } 
....................       } 
....................       // }}} 
....................       restart_wdt(); 
1EEA:  CLRWDT
....................       if ( SecondCounter ) { 
1EEB:  MOVF   5B,F
1EEC:  BTFSC  03.2
1EED:  GOTO   6F0
....................         SecondCounter--; 
1EEE:  DECF   5B,F
....................       } else { 
1EEF:  GOTO   6FA
....................         SecondCounter=SEC_COUNTER; 
1EF0:  MOVLW  3B
1EF1:  MOVWF  5B
....................         if ( MinuteCounter ) { 
1EF2:  MOVF   5C,F
1EF3:  BTFSC  03.2
1EF4:  GOTO   6F7
....................           MinuteCounter--; 
1EF5:  DECF   5C,F
....................         } else { 
1EF6:  GOTO   6FA
....................           THIRTY_MIN_FLAG=1; 
1EF7:  BSF    72.6
....................           MinuteCounter = MIN_COUNTER; 
1EF8:  MOVLW  1D
1EF9:  MOVWF  5C
....................         } 
....................       } 
....................       SECOND_FLAG=0; 
1EFA:  BCF    72.4
....................     } 
....................     if ( THIRTY_MIN_FLAG ) { 
1EFB:  BTFSS  72.6
1EFC:  GOTO   719
....................       if ( (TXSiteID&0x03) !=0 ) { 
1EFD:  MOVLB  00
1EFE:  MOVF   64,W
1EFF:  ANDLW  03
1F00:  BTFSC  03.2
1F01:  GOTO   716
....................         // Transmit Site ID every 30 mins when: 
....................         // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................         // E = Transmit every 30 mins 
....................         // M = Transmit only if EnableMask is off 
....................         if ( (TXSiteID & 0x01)!=0 || ( (TXSiteID & 0x02)!=0 && ( ((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
1F02:  MOVF   64,W
1F03:  ANDLW  01
1F04:  BTFSS  03.2
1F05:  GOTO   713
1F06:  MOVF   64,W
1F07:  ANDLW  02
1F08:  BTFSC  03.2
1F09:  GOTO   716
1F0A:  SWAPF  64,W
1F0B:  MOVWF  77
1F0C:  MOVLW  0F
1F0D:  ANDWF  77,F
1F0E:  MOVF   77,W
1F0F:  ANDLW  0F
1F10:  ANDWF  60,W
1F11:  BTFSS  03.2
1F12:  GOTO   716
....................           send_morse_id(); 
1F13:  MOVLP  10
1F14:  CALL   0DA
1F15:  MOVLP  18
....................         } 
....................       } 
....................       THIRTY_MIN_FLAG=0; 
1F16:  BCF    72.6
....................       restart_wdt(); 
1F17:  CLRWDT
1F18:  MOVLB  01
....................     } 
....................     if ( COR_FLAG ) { 
1F19:  BTFSS  72.3
1F1A:  GOTO   723
....................       process_cor(); 
1F1B:  MOVLB  00
1F1C:  GOTO   430
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       update_aux_out();  
1F1D:  MOVLP  10
1F1E:  CALL   692
1F1F:  MOVLP  18
....................       COR_FLAG=0; 
1F20:  BCF    72.3
....................       restart_wdt(); 
1F21:  CLRWDT
1F22:  MOVLB  01
....................      } 
....................     if ( DTMF_IN_FLAG ) { 
1F23:  BTFSS  5A.3
1F24:  GOTO   7B6
....................       strcpy(LCD_str,"DTMF:"); 
1F25:  CLRF   6B
1F26:  CLRF   6C
1F27:  MOVLW  20
1F28:  MOVWF  05
1F29:  MOVLW  73
1F2A:  MOVWF  04
1F2B:  MOVF   6B,W
1F2C:  ADDWF  04,F
1F2D:  MOVLW  00
1F2E:  ADDWFC 05,F
1F2F:  MOVF   6C,W
1F30:  MOVLP  00
1F31:  MOVLB  00
1F32:  CALL   184
1F33:  MOVLP  18
1F34:  MOVWF  00
1F35:  IORLW  00
1F36:  BTFSC  03.2
1F37:  GOTO   73D
1F38:  MOVLB  01
1F39:  INCF   6C,F
1F3A:  INCF   6B,F
1F3B:  GOTO   727
1F3C:  MOVLB  00
....................       printf("\n\rDTMF="); 
1F3D:  MOVLW  0B
1F3E:  MOVLB  03
1F3F:  MOVWF  11
1F40:  MOVLW  05
1F41:  MOVWF  12
1F42:  MOVLP  00
1F43:  MOVLB  00
1F44:  CALL   529
1F45:  MOVLP  18
....................       for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1F46:  MOVLB  01
1F47:  CLRF   62
1F48:  MOVF   62,W
1F49:  SUBLW  09
1F4A:  BTFSS  03.0
1F4B:  GOTO   794
....................         if(DTMF_ARRAY[x].Strobe) { 
1F4C:  MOVLW  61
1F4D:  ADDWF  62,W
1F4E:  MOVWF  04
1F4F:  MOVLW  20
1F50:  MOVWF  05
1F51:  BTFSC  03.0
1F52:  INCF   05,F
1F53:  BTFSS  00.4
1F54:  GOTO   791
....................           dtmf=(int)DTMF_ARRAY[x].Key; 
1F55:  MOVLW  61
1F56:  ADDWF  62,W
1F57:  MOVWF  04
1F58:  MOVLW  20
1F59:  MOVWF  05
1F5A:  BTFSC  03.0
1F5B:  INCF   05,F
1F5C:  MOVF   00,W
1F5D:  ANDLW  0F
1F5E:  MOVWF  63
....................           sprintf(tmp,"%d ",dtmf); 
1F5F:  MOVLW  20
1F60:  MOVWF  61
1F61:  MOVLW  94
1F62:  MOVWF  60
1F63:  MOVF   63,W
1F64:  MOVLB  02
1F65:  MOVWF  4F
1F66:  MOVLW  18
1F67:  MOVWF  50
1F68:  MOVLP  08
1F69:  MOVLB  00
1F6A:  CALL   236
1F6B:  MOVLP  18
1F6C:  MOVLW  20
1F6D:  MOVLB  02
1F6E:  MOVWF  55
1F6F:  MOVLP  00
1F70:  MOVLB  00
1F71:  CALL   7F0
1F72:  MOVLP  18
....................           strcat(LCD_str,tmp); 
1F73:  MOVLW  20
1F74:  MOVLB  02
1F75:  MOVWF  2F
1F76:  MOVLW  73
1F77:  MOVWF  2E
1F78:  MOVLW  20
1F79:  MOVWF  31
1F7A:  MOVLW  94
1F7B:  MOVWF  30
1F7C:  MOVLP  10
1F7D:  MOVLB  00
1F7E:  CALL   659
1F7F:  MOVLP  18
....................           printf(" %u",dtmf); 
1F80:  MOVLW  20
1F81:  CLRWDT
1F82:  BTFSS  11.4
1F83:  GOTO   781
1F84:  MOVLB  03
1F85:  MOVWF  1A
1F86:  MOVLB  01
1F87:  MOVF   63,W
1F88:  MOVLB  02
1F89:  MOVWF  55
1F8A:  MOVLW  1B
1F8B:  MOVWF  56
1F8C:  MOVLP  00
1F8D:  MOVLB  00
1F8E:  CALL   775
1F8F:  MOVLP  18
1F90:  MOVLB  01
....................         } 
....................       restart_wdt(); 
1F91:  CLRWDT
....................       } 
1F92:  INCF   62,F
1F93:  GOTO   748
....................       printf("\n\r"); 
1F94:  MOVLW  0A
1F95:  CLRWDT
1F96:  MOVLB  00
1F97:  BTFSC  11.4
1F98:  GOTO   79B
1F99:  MOVLB  01
1F9A:  GOTO   795
1F9B:  MOVLB  03
1F9C:  MOVWF  1A
1F9D:  MOVLW  0D
1F9E:  CLRWDT
1F9F:  MOVLB  00
1FA0:  BTFSC  11.4
1FA1:  GOTO   7A4
1FA2:  MOVLB  03
1FA3:  GOTO   79E
1FA4:  MOVLB  03
1FA5:  MOVWF  1A
....................       DTMF_IN_FLAG=0; 
1FA6:  MOVLB  01
1FA7:  BCF    5A.3
....................       PROMPT_FLAG=1; 
1FA8:  BSF    5A.5
....................       lcd_send(2,LCD_str); // Send DTMF on line 3 
1FA9:  MOVLW  02
1FAA:  MOVLB  02
1FAB:  MOVWF  4F
1FAC:  MOVLW  20
1FAD:  MOVWF  51
1FAE:  MOVLW  73
1FAF:  MOVWF  50
1FB0:  MOVLP  08
1FB1:  MOVLB  00
1FB2:  CALL   1D2
1FB3:  MOVLP  18
....................     restart_wdt(); 
1FB4:  CLRWDT
1FB5:  MOVLB  01
....................     } 
....................     if ( DTMF_FLAG ) { 
1FB6:  BTFSS  5A.2
1FB7:  GOTO   7BD
....................       process_dtmf(); 
1FB8:  MOVLB  00
1FB9:  GOTO   4F4
....................       DTMF_FLAG=0; 
1FBA:  MOVLB  01
1FBB:  BCF    5A.2
....................     restart_wdt(); 
1FBC:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1FBD:  BTFSS  5A.4
1FBE:  GOTO   7C5
....................       clear_dtmf_array(); 
1FBF:  MOVLP  10
1FC0:  MOVLB  00
1FC1:  GOTO   7D8
1FC2:  MOVLP  18
....................       CLEAR_DTMF_FLAG=0; 
1FC3:  MOVLB  01
1FC4:  BCF    5A.4
....................     } 
....................     if ( PROMPT_FLAG ) { 
1FC5:  BTFSS  5A.5
1FC6:  GOTO   7CE
....................       prompt(); 
1FC7:  MOVLP  10
1FC8:  MOVLB  00
1FC9:  CALL   0C2
1FCA:  MOVLP  18
....................       PROMPT_FLAG=0; 
1FCB:  MOVLB  01
1FCC:  BCF    5A.5
....................     restart_wdt(); 
1FCD:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1FCE:  GOTO   610
.................... } // }}} 
....................  
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0BF0:  CLRWDT
*
1FCF:  SLEEP
....................   delay_ms(1000); 
*
0BF1:  MOVLW  04
0BF2:  MOVLB  02
0BF3:  MOVWF  44
0BF4:  MOVLW  FA
0BF5:  MOVWF  4F
0BF6:  MOVLP  00
0BF7:  MOVLB  00
0BF8:  CALL   7C4
0BF9:  MOVLP  08
0BFA:  MOVLB  02
0BFB:  DECFSZ 44,F
0BFC:  GOTO   3F4
....................   if ( ConfirmChar!=0 ) { 
0BFD:  MOVLB  00
0BFE:  MOVF   69,F
0BFF:  BTFSC  03.2
0C00:  GOTO   415
....................     morse(ConfirmChar); 
0C01:  MOVF   69,W
0C02:  MOVLB  02
0C03:  MOVWF  44
0C04:  MOVLB  00
0C05:  CALL   0E9
....................     ConfirmChar=0; 
0C06:  CLRF   69
....................     restart_wdt(); 
0C07:  CLRWDT
....................     delay_ms(500); 
0C08:  MOVLW  02
0C09:  MOVLB  02
0C0A:  MOVWF  44
0C0B:  MOVLW  FA
0C0C:  MOVWF  4F
0C0D:  MOVLP  00
0C0E:  MOVLB  00
0C0F:  CALL   7C4
0C10:  MOVLP  08
0C11:  MOVLB  02
0C12:  DECFSZ 44,F
0C13:  GOTO   40B
0C14:  MOVLB  00
....................   } 
....................   if (TailChar != 0) { 
0C15:  MOVF   68,F
0C16:  BTFSC  03.2
0C17:  GOTO   42C
....................     morse(TailChar); 
0C18:  MOVF   68,W
0C19:  MOVLB  02
0C1A:  MOVWF  44
0C1B:  MOVLB  00
0C1C:  CALL   0E9
....................     TailChar=0; 
0C1D:  CLRF   68
....................     restart_wdt(); 
0C1E:  CLRWDT
....................     delay_ms(500); 
0C1F:  MOVLW  02
0C20:  MOVLB  02
0C21:  MOVWF  44
0C22:  MOVLW  FA
0C23:  MOVWF  4F
0C24:  MOVLP  00
0C25:  MOVLB  00
0C26:  CALL   7C4
0C27:  MOVLP  08
0C28:  MOVLB  02
0C29:  DECFSZ 44,F
0C2A:  GOTO   422
0C2B:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0C2C:  CLRWDT
0C2D:  MOVLB  02
.................... } 
.................... // send_tail }}} 
....................  
.................... int1 in_admin_mode(void) { 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
1027:  MOVLB  01
1028:  BTFSS  5A.6
1029:  GOTO   02C
....................     admin_timer = ADMIN_TIMEOUT; 
102A:  MOVLW  FF
102B:  MOVWF  73
....................   } 
....................   return(AdminMode||rs232_mode); 
102C:  BTFSC  5A.6
102D:  GOTO   032
102E:  BTFSC  5A.7
102F:  GOTO   032
1030:  MOVLW  00
1031:  GOTO   033
1032:  MOVLW  01
1033:  MOVWF  78
.................... } 
1034:  MOVLB  00
1035:  RETURN
.................... void set_admin_mode(int1 enable) { 
....................   AdminMode = (enable!=0); 
*
0D13:  MOVLB  01
0D14:  BCF    5A.6
0D15:  MOVLB  02
0D16:  MOVF   45,F
0D17:  BTFSC  03.2
0D18:  GOTO   51C
0D19:  MOVLB  01
0D1A:  BSF    5A.6
0D1B:  MOVLB  02
....................   if (AdminMode) { 
0D1C:  MOVLB  01
0D1D:  BTFSS  5A.6
0D1E:  GOTO   526
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0D1F:  MOVLW  0A
0D20:  MOVLB  00
0D21:  MOVWF  69
....................     admin_timer = ADMIN_TIMEOUT; 
0D22:  MOVLW  FF
0D23:  MOVWF  73
....................   } else { 
0D24:  GOTO   529
0D25:  MOVLB  01
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0D26:  MOVLW  18
0D27:  MOVLB  00
0D28:  MOVWF  69
....................   }  
.................... } 
0D29:  RETURN
....................  

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
