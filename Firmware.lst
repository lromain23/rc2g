CCS PCM C Compiler, Version 4.140, 64991               05-Jan-24 13:00

               Filename:   C:\Users\m3n2bn\Projects\MBPAB IDE\RC2Ga\52_Buckingham\Firmware.lst

               ROM used:   7983 words (97%)
                           Largest free fragment is 172
               RAM used:   164 (32%) at main() level
                           230 (45%) worst case
               Stack:     10 worst case (8 in main + 2 for interrupts)

*
0000:  MOVLP  18
0001:  GOTO   6AE
0002:  NOP
*
0004:  CLRF   03
0005:  CLRF   0A
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVF   7B,W
0010:  MOVWF  24
0011:  BTFSS  0B.3
0012:  GOTO   015
0013:  BTFSC  0B.0
0014:  GOTO   02B
0015:  BTFSS  0B.5
0016:  GOTO   019
0017:  BTFSC  0B.2
0018:  GOTO   02D
0019:  CLRF   05
001A:  MOVLW  91
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  11.5
001F:  GOTO   02F
0020:  MOVF   20,W
0021:  MOVWF  77
0022:  MOVF   21,W
0023:  MOVWF  78
0024:  MOVF   22,W
0025:  MOVWF  79
0026:  MOVF   23,W
0027:  MOVWF  7A
0028:  MOVF   24,W
0029:  MOVWF  7B
002A:  RETFIE
002B:  MOVLP  00
002C:  GOTO   348
002D:  MOVLP  00
002E:  GOTO   37A
002F:  MOVLP  00
0030:  GOTO   2EB
.................... #include "Firmware.h" 
.................... #include <16F1937.h> 
.................... //////// Standard Header file for the PIC16F1937 device //////////////// 
.................... #device PIC16F1937 
.................... #list 
....................  
....................  
.................... #fuses INTRC_IO 
.................... #fuses NOPROTECT 
.................... #fuses BROWNOUT 
.................... #fuses NOMCLR 
.................... #fuses NOCPD 
.................... #fuses WDT // WDT controlled by sw 
.................... #fuses NOPUT 
.................... #fuses NOFCMEN 
.................... #fuses NOIESO 
.................... #fuses NODEBUG 
.................... #case 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
16C5:  MOVLB  02
16C6:  MOVF   28,W
16C7:  MOVWF  2C
16C8:  MOVF   27,W
16C9:  MOVWF  2B
16CA:  MOVF   2C,W
16CB:  MOVWF  7A
16CC:  MOVF   2B,W
16CD:  MOVWF  04
16CE:  MOVF   7A,W
16CF:  MOVWF  05
16D0:  MOVF   00,F
16D1:  BTFSC  03.2
16D2:  GOTO   6D7
16D3:  INCF   2B,F
16D4:  BTFSC  03.2
16D5:  INCF   2C,F
16D6:  GOTO   6CA
....................    while(*s2 != '\0') 
....................    { 
16D7:  MOVF   2A,W
16D8:  MOVWF  7A
16D9:  MOVF   29,W
16DA:  MOVWF  04
16DB:  MOVF   7A,W
16DC:  MOVWF  05
16DD:  MOVF   00,F
16DE:  BTFSC  03.2
16DF:  GOTO   6F3
....................       *s = *s2; 
16E0:  MOVF   29,W
16E1:  MOVWF  04
16E2:  MOVF   2A,W
16E3:  MOVWF  05
16E4:  MOVF   00,W
16E5:  MOVWF  2F
16E6:  MOVF   2C,W
16E7:  MOVWF  05
16E8:  MOVF   2B,W
16E9:  MOVWF  04
16EA:  MOVF   2F,W
16EB:  MOVWF  00
....................       ++s; 
16EC:  INCF   2B,F
16ED:  BTFSC  03.2
16EE:  INCF   2C,F
....................       ++s2; 
16EF:  INCF   29,F
16F0:  BTFSC  03.2
16F1:  INCF   2A,F
....................    } 
16F2:  GOTO   6D7
....................  
....................    *s = '\0'; 
16F3:  MOVF   2B,W
16F4:  MOVWF  04
16F5:  MOVF   2C,W
16F6:  MOVWF  05
16F7:  CLRF   00
....................    return(s1); 
16F8:  MOVF   27,W
16F9:  MOVWF  78
16FA:  MOVF   28,W
16FB:  MOVWF  79
.................... } 
16FC:  MOVLB  00
16FD:  RETURN
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E03:  MOVF   46,W
0E04:  MOVWF  4A
0E05:  MOVF   45,W
0E06:  MOVWF  49
0E07:  MOVF   4A,W
0E08:  MOVWF  7A
0E09:  MOVF   49,W
0E0A:  MOVWF  04
0E0B:  MOVF   7A,W
0E0C:  MOVWF  05
0E0D:  MOVF   00,F
0E0E:  BTFSC  03.2
0E0F:  GOTO   63C
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0E10:  MOVF   48,W
0E11:  MOVWF  4C
0E12:  MOVF   47,W
0E13:  MOVWF  4B
0E14:  MOVF   4C,W
0E15:  MOVWF  7A
0E16:  MOVF   4B,W
0E17:  MOVWF  04
0E18:  MOVF   7A,W
0E19:  MOVWF  05
0E1A:  MOVF   00,F
0E1B:  BTFSC  03.2
0E1C:  GOTO   638
....................          if (*sc1 == *sc2) 
0E1D:  MOVF   4A,W
0E1E:  MOVWF  7A
0E1F:  MOVF   49,W
0E20:  MOVWF  04
0E21:  MOVF   7A,W
0E22:  MOVWF  05
0E23:  MOVF   00,W
0E24:  MOVWF  4D
0E25:  MOVF   4C,W
0E26:  MOVWF  7A
0E27:  MOVF   4B,W
0E28:  MOVWF  04
0E29:  MOVF   7A,W
0E2A:  MOVWF  05
0E2B:  MOVF   00,W
0E2C:  SUBWF  4D,W
0E2D:  BTFSS  03.2
0E2E:  GOTO   634
....................             return(sc1); 
0E2F:  MOVF   49,W
0E30:  MOVWF  78
0E31:  MOVF   4A,W
0E32:  MOVWF  79
0E33:  GOTO   63F
0E34:  INCF   4B,F
0E35:  BTFSC  03.2
0E36:  INCF   4C,F
0E37:  GOTO   614
0E38:  INCF   49,F
0E39:  BTFSC  03.2
0E3A:  INCF   4A,F
0E3B:  GOTO   607
....................    return(0); 
0E3C:  MOVLW  00
0E3D:  MOVWF  78
0E3E:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0D9C:  MOVF   46,W
0D9D:  MOVWF  4A
0D9E:  MOVF   45,W
0D9F:  MOVWF  49
0DA0:  MOVF   4A,W
0DA1:  MOVWF  7A
0DA2:  MOVF   49,W
0DA3:  MOVWF  04
0DA4:  MOVF   7A,W
0DA5:  MOVWF  05
0DA6:  MOVF   00,F
0DA7:  BTFSC  03.2
0DA8:  GOTO   5DA
....................       for (sc2 = s2; ; sc2++) 
0DA9:  MOVF   48,W
0DAA:  MOVWF  4C
0DAB:  MOVF   47,W
0DAC:  MOVWF  4B
....................     if (*sc2 == '\0') 
0DAD:  MOVF   4C,W
0DAE:  MOVWF  7A
0DAF:  MOVF   4B,W
0DB0:  MOVWF  04
0DB1:  MOVF   7A,W
0DB2:  MOVWF  05
0DB3:  MOVF   00,F
0DB4:  BTFSS  03.2
0DB5:  GOTO   5C0
....................        return(sc1 - s1); 
0DB6:  MOVF   45,W
0DB7:  SUBWF  49,W
0DB8:  MOVWF  77
0DB9:  MOVF   46,W
0DBA:  SUBWFC 4A,W
0DBB:  MOVWF  7A
0DBC:  MOVF   77,W
0DBD:  MOVWF  78
0DBE:  GOTO   5E2
....................          else if (*sc1 == *sc2) 
0DBF:  GOTO   5D2
0DC0:  MOVF   4A,W
0DC1:  MOVWF  7A
0DC2:  MOVF   49,W
0DC3:  MOVWF  04
0DC4:  MOVF   7A,W
0DC5:  MOVWF  05
0DC6:  MOVF   00,W
0DC7:  MOVWF  4D
0DC8:  MOVF   4C,W
0DC9:  MOVWF  7A
0DCA:  MOVF   4B,W
0DCB:  MOVWF  04
0DCC:  MOVF   7A,W
0DCD:  MOVWF  05
0DCE:  MOVF   00,W
0DCF:  SUBWF  4D,W
0DD0:  BTFSC  03.2
....................             break; 
0DD1:  GOTO   5D6
0DD2:  INCF   4B,F
0DD3:  BTFSC  03.2
0DD4:  INCF   4C,F
0DD5:  GOTO   5AD
0DD6:  INCF   49,F
0DD7:  BTFSC  03.2
0DD8:  INCF   4A,F
0DD9:  GOTO   5A0
....................    return(sc1 - s1); 
0DDA:  MOVF   45,W
0DDB:  SUBWF  49,W
0DDC:  MOVWF  77
0DDD:  MOVF   46,W
0DDE:  SUBWFC 4A,W
0DDF:  MOVWF  7A
0DE0:  MOVF   77,W
0DE1:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1EDC:  MOVLB  00
1EDD:  CLRF   26
1EDE:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
*
0D83:  MOVLB  02
0D84:  MOVF   3D,W
0D85:  IORWF  3E,W
0D86:  BTFSC  03.2
0D87:  GOTO   58C
0D88:  MOVF   3E,W
0D89:  MOVWF  7A
0D8A:  MOVF   3D,W
0D8B:  GOTO   591
0D8C:  MOVLB  00
0D8D:  MOVF   27,W
0D8E:  MOVWF  7A
0D8F:  MOVF   26,W
0D90:  MOVLB  02
0D91:  MOVWF  41
0D92:  MOVF   7A,W
0D93:  MOVWF  42
....................    beg += strspn(beg, s2); 
0D94:  MOVF   42,W
0D95:  MOVWF  46
0D96:  MOVF   41,W
0D97:  MOVWF  45
0D98:  MOVF   40,W
0D99:  MOVWF  48
0D9A:  MOVF   3F,W
0D9B:  MOVWF  47
*
0DE2:  MOVF   78,W
0DE3:  ADDWF  41,F
0DE4:  MOVLW  00
0DE5:  ADDWFC 42,F
....................    if (*beg == '\0') 
0DE6:  MOVF   42,W
0DE7:  MOVWF  7A
0DE8:  MOVF   41,W
0DE9:  MOVWF  04
0DEA:  MOVF   7A,W
0DEB:  MOVWF  05
0DEC:  MOVF   00,F
0DED:  BTFSS  03.2
0DEE:  GOTO   5FB
....................    { 
....................       *save = ' '; 
0DEF:  MOVLB  00
0DF0:  MOVF   26,W
0DF1:  MOVWF  04
0DF2:  MOVF   27,W
0DF3:  MOVWF  05
0DF4:  MOVLW  20
0DF5:  MOVWF  00
....................       return(0); 
0DF6:  MOVLW  00
0DF7:  MOVWF  78
0DF8:  MOVWF  79
0DF9:  GOTO   660
0DFA:  MOVLB  02
....................    } 
....................    end = strpbrk(beg, s2); 
0DFB:  MOVF   42,W
0DFC:  MOVWF  46
0DFD:  MOVF   41,W
0DFE:  MOVWF  45
0DFF:  MOVF   40,W
0E00:  MOVWF  48
0E01:  MOVF   3F,W
0E02:  MOVWF  47
*
0E3F:  MOVF   79,W
0E40:  MOVWF  44
0E41:  MOVF   78,W
0E42:  MOVWF  43
....................    if (*end != '\0') 
0E43:  MOVF   44,W
0E44:  MOVWF  7A
0E45:  MOVF   43,W
0E46:  MOVWF  04
0E47:  MOVF   7A,W
0E48:  MOVWF  05
0E49:  MOVF   00,F
0E4A:  BTFSC  03.2
0E4B:  GOTO   654
....................    { 
....................       *end = '\0'; 
0E4C:  MOVF   43,W
0E4D:  MOVWF  04
0E4E:  MOVF   44,W
0E4F:  MOVWF  05
0E50:  CLRF   00
....................       end++; 
0E51:  INCF   43,F
0E52:  BTFSC  03.2
0E53:  INCF   44,F
....................    } 
....................    save = end; 
0E54:  MOVF   44,W
0E55:  MOVLB  00
0E56:  MOVWF  27
0E57:  MOVLB  02
0E58:  MOVF   43,W
0E59:  MOVLB  00
0E5A:  MOVWF  26
....................    return(beg); 
0E5B:  MOVLB  02
0E5C:  MOVF   41,W
0E5D:  MOVWF  78
0E5E:  MOVF   42,W
0E5F:  MOVWF  79
0E60:  MOVLB  00
.................... } 
0E61:  RETURN
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define MCHAR(c) c-'a'+10 
....................  
.................... #define MIN_COUNTER 29 
.................... #define SEC_COUNTER 59 
.................... #define TAIL_CHAR 0 
....................  
.................... #define POT_MAX 63 
....................  
.................... #define RS 0x01 
.................... #define LCD_READ 0x02   
.................... #define LCD_WRITE 0x00   
.................... #define E 0x04 
.................... #define BT 0x08 
.................... #define CHANGE_LINE 0x80 
....................  
.................... #use delay(internal=8M,restart_wdt) 
*
0800:  MOVLW  20
0801:  MOVWF  05
0802:  MOVLW  C8
0803:  MOVWF  04
0804:  MOVF   00,W
0805:  BTFSC  03.2
0806:  GOTO   018
0807:  MOVLW  02
0808:  MOVWF  78
0809:  MOVLW  BF
080A:  MOVWF  77
080B:  CLRWDT
080C:  DECFSZ 77,F
080D:  GOTO   00B
080E:  DECFSZ 78,F
080F:  GOTO   009
0810:  MOVLW  96
0811:  MOVWF  77
0812:  DECFSZ 77,F
0813:  GOTO   012
0814:  GOTO   015
0815:  CLRWDT
0816:  DECFSZ 00,F
0817:  GOTO   007
0818:  RETURN
.................... #use I2C (master,force_hw,I2C1) 
*
06B3:  MOVLB  04
06B4:  BCF    15.7
06B5:  MOVLB  00
06B6:  BCF    11.3
06B7:  MOVLB  02
06B8:  MOVF   4E,W
06B9:  MOVLB  04
06BA:  MOVWF  11
06BB:  MOVLW  02
06BC:  BTFSC  15.7
06BD:  GOTO   6C5
06BE:  MOVLB  00
06BF:  BTFSS  11.3
06C0:  GOTO   6BF
06C1:  MOVLW  00
06C2:  MOVLB  04
06C3:  BTFSC  16.6
06C4:  MOVLW  01
06C5:  MOVWF  78
06C6:  MOVLB  00
06C7:  RETURN
*
0AA0:  MOVLB  04
0AA1:  BCF    15.6
0AA2:  BSF    16.3
0AA3:  BTFSC  16.3
0AA4:  GOTO   2A3
0AA5:  BTFSC  77.0
0AA6:  BCF    16.5
0AA7:  BTFSS  77.0
0AA8:  BSF    16.5
0AA9:  BSF    16.4
0AAA:  BTFSC  16.4
0AAB:  GOTO   2AA
0AAC:  MOVF   11,W
0AAD:  MOVWF  78
.................... #use RS232 (BAUD=9600,UART1,RESTART_WDT) 
*
02E4:  CLRWDT
02E5:  BTFSS  11.4
02E6:  GOTO   2E4
02E7:  MOVLB  03
02E8:  MOVWF  1A
02E9:  MOVLB  00
02EA:  RETURN
.................... #use fast_io (b) 
.................... #use fast_io (c) 
.................... #use fast_io (d) 
.................... #use fast_io (e) 
....................  
.................... //function headers 
.................... char str_to_decimal(char *str); 
.................... void process_dtmf_interrupt(void); 
.................... void init_lcd(void); 
.................... void send_tail(void); 
.................... void morse(char); 
.................... void dit(void); 
.................... void dah(void); 
.................... void prompt(void); 
.................... void increment(int); 
.................... void pot_values_to_lcd(void); 
.................... void init_variables(int1 src); 
.................... void status(void); 
.................... void set_var(void); 
.................... void tokenize_sBuffer(void); 
.................... void store_variables(void); 
.................... void clear_dtmf_array(void); 
.................... void dtmf_send_digit(int); 
.................... void romstrcpy(char *,rom char *); 
.................... void update_aux_in(void); 
.................... void update_aux_out(void); 
.................... void print_dfmf_info(void); 
.................... void do_delay_counters(void); 
.................... int1 my_stricmp(char *, char *); 
....................  
.................... // Variables accessed using linear addressing {{{ 
.................... unsigned int RX_GAIN[4][4]; 
.................... unsigned int AuxIn[3],AuxInSW[3]; 
.................... unsigned int AuxOut[3]; 
.................... unsigned int RXPriority[4]; 
.................... unsigned int RX_PTT[4]; 
.................... unsigned int Morse[6]; 
.................... unsigned int AuxOutOp[3],AuxOutArg[3]; 
.................... unsigned int AuxInOp[3],AuxInArg[3]; 
.................... unsigned int COR_IN; 
.................... unsigned int Enable; 
.................... unsigned int Enable_Mask; 
.................... unsigned int Polarity; 
.................... unsigned int SiteID,TXSiteID; 
.................... unsigned int Tail; 
.................... unsigned int TOT_Min; 
.................... unsigned int TOT_FLAG_Mask; 
.................... unsigned int Link_TOT,LinkDurationTimer; 
.................... unsigned int COR_EMUL; 
.................... unsigned int COR_AUX; 
.................... unsigned int TailChar; 
.................... unsigned int ConfirmChar; 
.................... // Variables accessed using linear addressing }}} 
....................  
.................... // COR variables {{{ 
.................... unsigned int CurrentCorMask; 
.................... unsigned int CurrentCorIndex; 
.................... unsigned int CurrentCorPriority; 
.................... char COR_IN_EFFECTIVE; 
.................... // }}} 
....................  
.................... // RS232 variables / buffers {{{ 
.................... char sBuffer[16]; 
.................... unsigned int sBufferIndex; 
.................... unsigned int1 sBufferFlag; 
.................... // }}} 
....................  
.................... //#define DEBUG_SBUFFER 
.................... #define ESC 0x1B 
....................  
.................... // Commands 
.................... #define LINK_CMD 1 
.................... #define SET_REG 2 
.................... #define GET_REG 3 
.................... #define SAVE_SETTINGS 4 
.................... #define RESTORE_SETTINGS 5 
.................... #define INCREMENT_REG 6 
.................... #define DECREMENT_REG 7 
.................... #define STATUS    8 
.................... #define ADMIN     9 
.................... #define ADMIN_TIMEOUT 255 
.................... char admin_timer; 
.................... // Admin args: 
.................... #define IDLE          0 
.................... #define ENTER_ADMIN   1 
.................... #define REBOOT        2 
.................... #define SEND_MORSE_ID 3 
.................... #define MORSE_SEND 11 
.................... #define I2C_SEND 12 
....................  
.................... // Auxiliary Output Operators 
.................... #define AUX_OUT_IDLE 0 
.................... #define AUX_OUT_FOLLOW_COR 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN 0x02 
.................... // This command operates the same way as AUX_OUT_FOLLOW_COR but 
.................... // it extends the aux output by 1 minute. 
.................... #define AUX_OUT_FOLLOW_COR_DELAY 0x03 
.................... // Follow COR args: 
.................... #define AUX_OUT_FOLLOW_COR1 0x01 
.................... #define AUX_OUT_FOLLOW_COR2 0x02 
.................... #define AUX_OUT_FOLLOW_COR3 0x04 
.................... #define AUX_OUT_FOLLOW_COR4 0x08 
.................... #define AUX_OUT_FOLLOW_COR_INVERT1 0x10 
.................... #define AUX_OUT_FOLLOW_COR_INVERT2 0x20 
.................... #define AUX_OUT_FOLLOW_COR_INVERT3 0x40 
.................... #define AUX_OUT_FOLLOW_COR_INVERT4 0x80 
.................... // Follow AUX_IN args: 
.................... #define AUX_OUT_FOLLOW_AUX_IN0 0x01 
.................... #define AUX_OUT_FOLLOW_AUX_IN0_INV 0x11 
.................... #define AUX_OUT_FOLLOW_AUX_IN1 0x02 
.................... #define AUX_OUT_FOLLOW_AUX_IN1_INV 0x22 
.................... #define AUX_OUT_FOLLOW_AUX_IN2 0x04 
.................... #define AUX_OUT_FOLLOW_AUX_IN2_INV 0x44 
....................  
.................... // Auxiliary Input Operators 
.................... // Set mask bits to 1 to make Enable bit controllable by AuxIn 
.................... // The AUXI_ENABLE# words can be OR'ed to include other enable 
.................... // signals controlled by the same AuxIn. 
.................... // All signals that are not included as the argument will be  
.................... // gated off when the Aux Input is low. 
.................... #define AUXI_ENABLE 0x01 
.................... #define AUXI_ENABLE1 0x01 
.................... #define AUXI_ENABLE2 0x02 
.................... #define AUXI_ENABLE3 0x04 
.................... #define AUXI_ENABLE4 0x08 
....................  
.................... #define AUXI_TAIL_WHEN_LO 0x02 
.................... #define AUXI_TAIL_WHEN_HI 0x03 
.................... #define AUXI_TAIL_CHAR MCHAR('s') 
....................  
.................... #define AUXI_EMULATE_COR 0x04 
.................... #define AUXI_EMULATE_COR1 0x01 
.................... #define AUXI_EMULATE_COR2 0x02 
.................... #define AUXI_EMULATE_COR3 0x04 
.................... #define AUXI_EMULATE_COR4 0x08 
.................... #define AUXI_EMULATE_COR5 0x10 // COR from AUX only for DTMF control (No audio feed-thru) 
.................... #define AUXI_EMULATE_COR_ACTIVE_LO 0x20 
....................  
.................... // Digital TrimPot 
.................... // 
.................... #define TRIMPOT_READ_CMD  0x51 
.................... #define TRIMPOT_WRITE_CMD 0x50 
.................... unsigned int CurrentTrimPot; 
.................... unsigned long rtcc_cnt; 
.................... unsigned long aux_timer; 
.................... unsigned int AuxOutDelayCnt; 
.................... #define AUX_TIMER_1S 31 
.................... #define AUX_TIMER_500ms 16  
.................... #define AUX_TIMER_400ms 13  
.................... #define AUX_TIMER_300ms 10  
.................... #define AUX_TIMER_200ms 6 
.................... #define AUX_TIMER_100ms 3 
.................... #define AUX_TIMER_60ms 2 
.................... #define AUX_TIMER_30ms 1 
.................... #define MorseDitLength 1 
.................... const int MorseLen[4]={AUX_TIMER_30ms,AUX_TIMER_60ms,AUX_TIMER_100ms,AUX_TIMER_200ms}; 
....................  
.................... // DTMF character -- MT8888 maps {{{ 
.................... #define d1 0x01 
.................... #define d2 0x02 
.................... #define d3 0x03 
.................... #define d4 0x04 
.................... #define d5 0x05 
.................... #define d6 0x06 
.................... #define d7 0x07 
.................... #define d8 0x08 
.................... #define d9 0x09 
.................... #define d0 0x0a // 0  (0) 
.................... #define ds 0x0b // 11 (*) 
.................... #define dp 0x0c // 12 (#) 
.................... #define da 0x0d // 13 (A) 
.................... #define db 0x0e // 14 (B) 
.................... #define dc 0x0f // 15 (C) 
.................... #define dd 0x00 // 10 (D) 
.................... // }}} 
....................  
.................... // sDTMF character structure  
.................... // 
.................... typedef struct {  
.................... 			int Key 	: 4; 
.................... 			int Strobe	: 1; 
.................... 			int Last	: 1; 
.................... 			int UNUSED	: 2; 
.................... } sDTMF; 
....................  
.................... #define DTMF_ARRAY_SIZE 10 
.................... sDTMF DTMF_ARRAY[DTMF_ARRAY_SIZE]; 
.................... sDTMF *DTMF_ptr; 
....................  
.................... typedef struct { 
.................... 		int RX0 : 1; 
.................... 		int RX1 : 1; 
.................... 		int RX2 : 1; 
.................... 		int RX3 : 1; 
.................... } sCOR; 
....................  
.................... #define REG_NAME_SIZE 6 
.................... unsigned int command,argument,value; 
.................... #LOCATE command=0x070 
.................... char argument_name[REG_NAME_SIZE]; 
.................... #define LCD_STR_SIZE 21 
.................... char LCD_str[LCD_STR_SIZE]; 
.................... // RegisterPointer is set by the get_var command. 
.................... // It points to the last register that was accessed. 
.................... // It is used by the INCR or DECR commands 
.................... unsigned int  LastRegisterIndex; 
.................... unsigned int  LastRegisterIndexValid; 
....................  
.................... // cMorseChar {{{ 
.................... // Word is read from right to left (LSB to MSB) 
.................... #define MORSE_CHAR_ARRAY_LENGTH 37 
.................... unsigned int rom cMorseChar[] = { 
.................... 	0b10101010, // 0 (dah dah dah dah dah)	0 
.................... 	0b01101010, // 1 (dit dah dah dah dah)	1 
.................... 	0b01011010, // 2 (dit dit dah dah dah)	2 
.................... 	0b01010110, // 3 (dit dit dit dah dah)	3 
.................... 	0b01010101, // 4 (dit dit dit dit dah)	4 
.................... 	0b01010101, // 5 (dit dit dit dit dit)	5 
.................... 	0b10010101, // 6 (dah dit dit dit dit)	6 
.................... 	0b10100101, // 7 (dah dah dit dit dit)	7 
.................... 	0b10101001, // 8 (dah dah dah dit dit)	8 
.................... 	0b10101010, // 9 (dah dah dah dah dit)	9 
.................... 	0b01100000, // a (dit dah)		10 
.................... 	0b10010101, // b (dah dit dit dit)	11 
.................... 	0b10011001, // c (dah dit dah dit)	12 
.................... 	0b10010100, // d (dah dit dit)		13 
.................... 	0b01000000, // e (dit)			14 
.................... 	0b01011001, // f (dit dit dah dit)	15 
.................... 	0b10100100, // g (dah dah dit) 		16 
.................... 	0b01010101, // h (dit dit dit dit)	17 
.................... 	0b01010000, // i (dit dit)		18 
.................... 	0b01101010, // j (dit dah dah dah)	19 
.................... 	0b10011000, // k (dah dit dah)		20 
.................... 	0b01100101, // l (dit dah dit dit)	21 
.................... 	0b10100000, // m (dah dah)		22 
.................... 	0b10010000, // n (dah dit)		23 
.................... 	0b10101000, // o (dah dah dah)		24 
.................... 	0b01101001, // p (dit dah dah dit)	25 
.................... 	0b10100110, // q (dah dah dit dah)	26 
.................... 	0b01100100, // r (dit dah dit)		27 
.................... 	0b01010100, // s (dit dit dit)		28 
.................... 	0b10000000, // t (dah)			29 
.................... 	0b01011000, // u (dit dit dah)		30 
.................... 	0b01010110, // v (dit dit dit dah)	31 
.................... 	0b01101000, // w (dit dah dah)		32 
.................... 	0b10010110, // x (dah dit dit dah)	33 
.................... 	0b10011010, // y (dah dit dah dah)	34 
.................... 	0b10100101, // z (dah dah dit dit)	35 
.................... 	0b00000000  // - (silence)	36 
.................... }; // }}} 
....................  
.................... typedef struct sRegMap_t {  
.................... 	int *	 reg_ptr; 
.................... 	int	 default_value; 
.................... 	int	 non_volatile : 1; 
....................   int  usage : 1; 
.................... }; 
....................  
.................... int dtmf_read(int1 rs); 
.................... void dtmf_write(int data,int1 rs); 
.................... int1 in_admin_mode(void); 
.................... void set_admin_mode(int1 enable); 
.................... void send_morse_id(void); 
....................  
.................... int1       COR_FLAG; 
.................... int1       SECOND_FLAG; 
.................... int1       MINUTE_FLAG; 
.................... int1       THIRTY_MIN_FLAG; 
.................... int1       COR_DROP_FLAG; 
.................... int1       AUX_IN_FLAG; 
.................... int1 	   AUX_OUT_FLAG; 
.................... int        SecondCounter,MinuteCounter; 
.................... unsigned long TOT_SecondCounter; 
.................... int1	     DTMF_FLAG; 
.................... int1	     DTMF_IN_FLAG; 
.................... int1       DTMF_INTERRUPT_FLAG; 
.................... int1	     CLEAR_DTMF_FLAG; 
.................... int1       PROMPT_FLAG; 
.................... int1       AdminMode; 
.................... int1       rs232_mode; 
....................  
.................... // Source is used by init_variables 
.................... // EEPROM -- Initializes variables using values stored in EEPROM 
.................... // DEFAULT -- Initializes variables using values in ROM 
.................... // PROTECTED -- Must be in admin mode to set value 
.................... // PUBLIC    -- Register can be set in any mode 
.................... #define USE_EEPROM_VARS 1 
.................... #define USE_DEFAULT_VARS 0 
.................... #define EEPROM   1 
.................... #define RAM      0 
.................... #define PROTECTED 1 
.................... #define PUBLIC    0 
....................  
.................... #define ENTER_BUTTON   PIN_A7 
.................... #define SELECT_BUTTON   PIN_E3 
.................... #define STATUS_LED_PIN PIN_A6 
.................... // RB 
.................... #define ADJ_POT	 sAN13 
.................... #define DTMF_D0  PIN_D0 
.................... #define DTMF_D1  PIN_D1 
.................... #define DTMF_D2  PIN_D2 
.................... #define DTMF_D3  PIN_D3 
.................... #define DTMF_REB PIN_D4 // PH2 (12) 
.................... #define DTMF_WEB PIN_D5 // RWb (9) 
.................... #define DTMF_RS  PIN_D6 // RS0 (11) 
.................... #define DTMF_CS  PIN_D7 // CSB (10) 
.................... #define DTMF_INT PIN_B4 
.................... #define CONTROL_REG 1 
.................... #define DATA_REG 0 
.................... #define DTMF_IRQ         0x01 
.................... #define DTMF_TX_BUF_EMPTY 0x02 
.................... #define DTMF_BUFFER_FULL 0x04 
.................... // Register A bits 
.................... #define TOUT     0x01 
.................... #define IRQ		 0x04 
.................... #define RSELB	 0x08 
.................... // Register B bits 
.................... #define BURST    0x00 
.................... #define BURST_OFF 0x01 
.................... #define DUAL_TONE 0x00 
.................... #define SINGLE_TONE 0x04 
.................... #define ST_ROW   0x00 
.................... #define ST_COL   0x08 
.................... #define LCD_ENABLE 
....................  
.................... #define AUX_IN0  PIN_B6 
.................... #define AUX_IN1  PIN_B7 
.................... #define AUX_IN2  PIN_C0 
.................... #define AUX_OUT0 PIN_C1 
.................... #define AUX_OUT1 PIN_C5 
.................... #define AUX_OUT2 PIN_E2 
....................  
....................  
.................... #define COR0 PIN_B0 
.................... #define COR1 PIN_B1 
.................... #define COR2 PIN_B2 
.................... #define COR3 PIN_B3 
....................  
.................... #define PTT0 PIN_A4 
.................... #define PTT1 PIN_A5 
.................... #define PTT2 PIN_E0 
.................... #define PTT3 PIN_E1 
....................  
.................... #define RX0_EN PIN_A0  
.................... #define RX1_EN PIN_A1 
.................... #define RX2_EN PIN_A2 
.................... #define RX3_EN PIN_A3 
....................  
.................... #define COR0_MASK 0x01 
.................... #define COR1_MASK 0x02 
.................... #define COR2_MASK 0x04 
.................... #define COR3_MASK 0x08 
.................... #define DTMF_INT_MASK 0x10 
.................... // WPUE must be set to 0 
.................... #bit  WPUEN = 0x095.7 
.................... #byte WPUB  = 0x20D 
.................... #byte IOCBF = 0x396  
....................  
.................... //rom char COR_IN_NAME[]="COR_IN"; 
.................... //rom char POL_NAME[]="POLARITY"; 
.................... //rom char COR0_GAIN_NAME[]="C0GAIN"; 
....................  
.................... //rom char * rom strPtr=COR_IN_NAME; 
....................  
.................... const char RX_PIN[4]={RX0_EN,RX1_EN,RX2_EN,RX3_EN}; 
.................... const char PTT_PIN[4]={PTT0,PTT1,PTT2,PTT3}; 
.................... const int AUX_OUT_PIN[3]={AUX_OUT0,AUX_OUT1,AUX_OUT2}; 
.................... const int AUX_IN_PIN[3] ={AUX_IN0 ,AUX_IN1 ,AUX_IN2}; 
....................  
.................... char const reg_name[][REG_NAME_SIZE]={ 
.................... 	{"EN"},	  // 0 
.................... 	{"POL"},	  // 1 
.................... 	{"R1G1"},	  // 2 
.................... 	{"R1G2"},	  // 3 
.................... 	{"R1G3"},	  // 4 
.................... 	{"R1G4"},	  // 5 
.................... 	{"R2G1"},	  // 6 
.................... 	{"R2G2"},	  // 7 
.................... 	{"R2G3"},	  // 8 
.................... 	{"R2G4"},	  // 9 
.................... 	{"R3G1"},	  // 10 
.................... 	{"R3G2"},	  // 11 
.................... 	{"R3G3"},	  // 12 
.................... 	{"R3G4"},	  // 13 
.................... 	{"R4G1"},	  // 14 
.................... 	{"R4G2"},	  // 15 
.................... 	{"R4G3"},	  // 16 
.................... 	{"R4G4"},	  // 17 
.................... 	{"XI1"},	  // 18 
.................... 	{"XI2"},	  // 19 
.................... 	{"XI3"},	  // 20 
.................... 	{"XO1"},	  // 21 
.................... 	{"XO2"},	  // 22 
.................... 	{"XO3"},	  // 23 
.................... 	{"R1P"},	  // 24 
.................... 	{"R2P"},	  // 25 
.................... 	{"R3P"},	  // 26 
.................... 	{"R4P"},	  // 27 
.................... 	{"R1PTT"},  // 28 
.................... 	{"R2PTT"},  // 29 
.................... 	{"R3PTT"},  // 30 
.................... 	{"R4PTT"},  // 31 
....................     {"SID"},  // 32 
....................     {"TXID"}, // 33 
....................     {"MRS1"}, // 34 
....................     {"MRS2"}, // 35 
....................     {"MRS3"}, // 36 
....................     {"MRS4"}, // 37 
....................     {"MRS5"}, // 38 
....................     {"MRS6"}, // 39 
....................     {"XOO1"}, // 40 
....................     {"XOO2"}, // 41 
....................     {"XOO3"}, // 42 
....................     {"XOA1"}, // 43 
....................     {"XOA2"}, // 44 
....................     {"XOA3"}, // 45 
....................     {"XIO1"}, // 46 
....................     {"XIO2"}, // 47 
....................     {"XIO3"}, // 48 
....................     {"XIA1"}, // 49 
....................     {"XIA2"}, // 50  
....................     {"XIA3"}, // 51 
....................     {"TAIL"}, // 52 
....................     {"TOT"},  // 53 
....................     {"LTO"},  // 54 
....................     {"COR"},  // 55 
....................     {"CPOT"}  // 56 
.................... }; 
....................  
.................... #include "SITE_XX.h" 
....................  
.................... #define SITE_ID_VAL  	52 
.................... #define SITE_GID_VAL 	90 
.................... #define POLARITY_DEF_VAL 0x0F  
.................... #define ENABLE_DEFAULT 0xEF 
.................... #define TOT_MIN 5 
.................... #define LINK_TOT 0 
.................... #define DEFAULT_GAIN 32 
.................... //#define LCD_TYPE_PI 1 
....................  
.................... #define MORSEID0	MCHAR('v') 
.................... #define MORSEID1	MCHAR('e') 
.................... #define MORSEID2	2 
.................... #define MORSEID3	MCHAR('r') 
.................... #define MORSEID4	MCHAR('e') 
.................... #define MORSEID5	MCHAR('h') 
....................  
.................... #define AUXOUTOP0  AUX_OUT_FOLLOW_COR 
.................... #define AUXOUTARG0 AUX_OUT_FOLLOW_COR1 | AUX_OUT_FOLLOW_COR_INVERT1 
.................... #define AUXOUTOP1  0 
.................... #define AUXOUTARG1 0 
.................... #define AUXOUTOP2  AUX_OUT_FOLLOW_COR_DELAY 
.................... #define AUXOUTARG2 AUX_OUT_FOLLOW_COR1 | AUX_OUT_FOLLOW_COR2 | AUX_OUT_FOLLOW_COR3 | AUX_OUT_FOLLOW_COR4 
....................  
.................... // AuxIn1 used by AuxOut 1 
.................... #define AUXINOP0  AUXI_EMULATE_COR 
.................... #define AUXINARG0 AUXI_EMULATE_COR1 | AUXI_EMULATE_COR_ACTIVE_LO 
.................... #define AUXINOP1  AUXI_TAIL_WHEN_HI 
.................... #define AUXINARG1 MCHAR('b') 
.................... #define AUXINOP2  0 
.................... #define AUXINARG2 0 
....................  
.................... #define PO_AUX_OUT0 1 
.................... #define PO_AUX_OUT1 1 
.................... #define PO_AUX_OUT2 1 
....................  
.................... #define RX1_PTT 0x0E 
.................... #define RX2_PTT 0x0D 
.................... #define RX3_PTT 0x0B 
.................... #define RX4_PTT 0x07 
....................  
.................... // Define default variables {{{ 
.................... #ifdef LCD_TYPE_PI 
....................   #define LCD_I2C_ADD 0x27 
.................... #else 
....................   #define LCD_I2C_ADD 0x60 
.................... #endif 
.................... #define LCD_LINE1 0x60 
.................... #define LCD_LINE2 0x62 
.................... #define LCD_LINE3 0x64 
.................... #define LCD_LINE4 0x66 
.................... #ifndef RX1_PTT 
....................   #define RX1_PTT 0x0E 
.................... #endif 
.................... #ifndef RX2_PTT 
....................   #define RX2_PTT 0x0D 
.................... #endif 
.................... #ifndef RX3_PTT 
....................   #define RX3_PTT 0x0B  
.................... #endif 
.................... #ifndef RX4_PTT 
....................   #define RX4_PTT 0x07 
.................... #endif 
.................... #ifndef DEFAULT_GAIN 
....................   #define DEFAULT_GAIN 32 
.................... #endif 
.................... #ifndef POLARITY_DEF_VAL 
....................   #define POLARITY_DEF_VAL 0x0F 
.................... #endif 
.................... #ifndef ENABLE_DEFAULT 
....................   #define ENABLE_DEFAULT 0x0F 
.................... #endif 
.................... struct sRegMap_t const RegMap[]={ 
.................... 	{&Enable        ,ENABLE_DEFAULT  , EEPROM,PUBLIC}, 
.................... 	{&Polarity      ,POLARITY_DEF_VAL, EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[0][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[1][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[2][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][0] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][1] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][2] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&RX_GAIN[3][3] ,DEFAULT_GAIN    , EEPROM,PROTECTED}, 
.................... 	{&AuxIn[0]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[1]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxIn[2]      ,0               , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[0]     ,PO_AUX_OUT0     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[1]     ,PO_AUX_OUT1     , EEPROM,PUBLIC}, 
.................... 	{&AuxOut[2]     ,PO_AUX_OUT2     , EEPROM,PUBLIC}, 
.................... 	{&RXPriority[0] ,4               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[1] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[2] ,6               , EEPROM,PROTECTED}, 
.................... 	{&RXPriority[3] ,2               , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[0]     ,RX1_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[1]     ,RX2_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[2]     ,RX3_PTT         , EEPROM,PROTECTED}, 
.................... 	{&RX_PTT[3]     ,RX4_PTT         , EEPROM,PROTECTED}, 
.................... 	{&SiteID        ,SITE_ID_VAL     , EEPROM,PROTECTED}, 
.................... 	{&TXSiteID      ,0x12            , EEPROM,PROTECTED}, 
....................   {&Morse[0]      ,MORSEID0        , EEPROM,PROTECTED}, 
....................   {&Morse[1]      ,MORSEID1        , EEPROM,PROTECTED}, 
....................   {&Morse[2]      ,MORSEID2        , EEPROM,PROTECTED}, 
....................   {&Morse[3]      ,MORSEID3        , EEPROM,PROTECTED}, 
....................   {&Morse[4]      ,MORSEID4        , EEPROM,PROTECTED}, 
....................   {&Morse[5]      ,MORSEID5        , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[0]   ,AUXOUTOP0       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[1]   ,AUXOUTOP1       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutOp[2]   ,AUXOUTOP2       , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[0]  ,AUXOUTARG0      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[1]  ,AUXOUTARG1      , EEPROM,PROTECTED}, 
.................... 	{&AuxOutArg[2]  ,AUXOUTARG2      , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[0]    ,AUXINOP0        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[1]    ,AUXINOP1        , EEPROM,PROTECTED}, 
.................... 	{&AuxInOp[2]    ,AUXINOP2        , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[0]   ,AUXINARG0       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[1]   ,AUXINARG1       , EEPROM,PROTECTED}, 
.................... 	{&AuxInArg[2]   ,AUXINARG2       , EEPROM,PROTECTED}, 
....................   {&Tail          ,TAIL_CHAR       , EEPROM,PROTECTED}, 
....................   {&TOT_Min       ,TOT_MIN         , EEPROM,PROTECTED}, 
....................   {&Link_TOT      ,LINK_TOT        , EEPROM,PROTECTED}, 
.................... 	{&COR_EMUL      ,0x00            , RAM   ,PUBLIC}, 
.................... 	{&CurrentTrimPot,0x00            , RAM   ,PROTECTED}, 
.................... }; 
....................  
....................  
.................... // AuxInOp/AuxInArg are not initialized correctly. 
.................... // Debug using RS232. 
....................  	 
.................... unsigned int const RegMapNum=sizeof(RegMap)/sizeof(struct sRegMap_t); 
....................  
.................... #INT_RDA 
.................... void rs232_int (void) { // {{{ 
.................... // RS232 serial buffer interrupt handler. 
....................   char c; 
....................   if ( kbhit() ) { 
02EB:  BTFSS  11.5
02EC:  GOTO   342
....................     c = getc(); 
02ED:  CLRWDT
02EE:  BTFSS  11.5
02EF:  GOTO   2ED
02F0:  MOVLB  03
02F1:  MOVF   19,W
02F2:  MOVLB  02
02F3:  MOVWF  53
....................     if ( c == '\b' ) { 
02F4:  MOVF   53,W
02F5:  SUBLW  08
02F6:  BTFSS  03.2
02F7:  GOTO   320
....................       if ( sBufferIndex > 0 ) { 
02F8:  MOVF   73,F
02F9:  BTFSC  03.2
02FA:  GOTO   31A
....................         sBufferIndex--; 
02FB:  DECF   73,F
....................         sBuffer[sBufferIndex]='\0'; 
02FC:  MOVLW  50
02FD:  ADDWF  73,W
02FE:  MOVWF  04
02FF:  MOVLW  20
0300:  MOVWF  05
0301:  BTFSC  03.0
0302:  INCF   05,F
0303:  CLRF   00
....................         putc('\b'); 
0304:  MOVLW  08
0305:  MOVLB  00
0306:  CALL   2E4
....................   // Erase End of Line <ESC>[K 
....................   putc(ESC); 
0307:  MOVLW  1B
0308:  CALL   2E4
....................   printf("[K"); 
0309:  MOVLW  5B
030A:  CLRWDT
030B:  BTFSS  11.4
030C:  GOTO   30A
030D:  MOVLB  03
030E:  MOVWF  1A
030F:  MOVLW  4B
0310:  CLRWDT
0311:  MOVLB  00
0312:  BTFSC  11.4
0313:  GOTO   316
0314:  MOVLB  03
0315:  GOTO   310
0316:  MOVLB  03
0317:  MOVWF  1A
....................       } else { 
0318:  GOTO   31E
0319:  MOVLB  02
....................         putc('\a'); // Send alert. Cannot backspace further 
031A:  MOVLW  07
031B:  MOVLB  00
031C:  CALL   2E4
031D:  MOVLB  03
....................       } 
....................     } else if (sBufferIndex < sizeof(sBuffer)) { 
031E:  GOTO   344
031F:  MOVLB  02
0320:  MOVF   73,W
0321:  SUBLW  0F
0322:  BTFSS  03.0
0323:  GOTO   33F
....................       putc(c); // echo the character 
0324:  MOVF   53,W
0325:  MOVLB  00
0326:  CALL   2E4
....................       sBuffer[sBufferIndex++] = c; 
0327:  MOVF   73,W
0328:  INCF   73,F
0329:  ADDLW  50
032A:  MOVWF  04
032B:  MOVLW  20
032C:  MOVWF  05
032D:  BTFSC  03.0
032E:  INCF   05,F
032F:  MOVLB  02
0330:  MOVF   53,W
0331:  MOVWF  00
....................       if ( c == '\r' || c=='+' || c=='-') { 
0332:  MOVF   53,W
0333:  SUBLW  0D
0334:  BTFSC  03.2
0335:  GOTO   33D
0336:  MOVF   53,W
0337:  SUBLW  2B
0338:  BTFSC  03.2
0339:  GOTO   33D
033A:  MOVF   53,W
033B:  SUBLW  2D
033C:  BTFSC  03.2
....................         sBufferFlag=1; 
033D:  BSF    74.0
....................       } 
....................     } else { 
033E:  GOTO   343
....................       putc('\a'); // Send alert. Avoid buffer overflow 
033F:  MOVLW  07
0340:  MOVLB  00
0341:  CALL   2E4
0342:  MOVLB  02
0343:  MOVLB  03
....................     } 
....................   } 
.................... } // }}} 
0344:  MOVLB  00
0345:  BCF    11.5
0346:  MOVLP  00
0347:  GOTO   020
.................... #INT_RB 
.................... void RB0_INT (void) { // {{{ 
....................   int LAST_COR_IN; 
....................   //if(interrupt_active(INT_RB0|INT_RB1|INT_RB2|INT_RB3)) { 
....................   if(IOCBF&0x0F) { // Check for interrupts on RB[3:0] only 
0348:  MOVLB  07
0349:  MOVF   16,W
034A:  ANDLW  0F
034B:  BTFSC  03.2
034C:  GOTO   36B
....................     LAST_COR_IN=COR_IN; 
034D:  MOVLB  00
034E:  MOVF   5F,W
034F:  MOVLB  02
0350:  MOVWF  53
....................     COR_IN= ((input_b() ^ Polarity)&0x0F) | (COR_EMUL & 0x1F) | (COR_AUX&0x0F); 
0351:  MOVLB  00
0352:  MOVF   0D,W
0353:  XORWF  62,W
0354:  ANDLW  0F
0355:  MOVLB  02
0356:  MOVWF  54
0357:  MOVLB  00
0358:  MOVF   6A,W
0359:  ANDLW  1F
035A:  MOVLB  02
035B:  IORWF  54,F
035C:  MOVLB  00
035D:  MOVF   6B,W
035E:  ANDLW  0F
035F:  MOVLB  02
0360:  IORWF  54,W
0361:  MOVLB  00
0362:  MOVWF  5F
....................     if ( LAST_COR_IN != COR_IN ) { 
0363:  MOVF   5F,W
0364:  MOVLB  02
0365:  SUBWF  53,W
0366:  BTFSS  03.2
....................       COR_FLAG = 1; 
0367:  BSF    74.1
....................     } 
....................     clear_interrupt(INT_RB0|INT_RB1|INT_RB2|INT_RB3); 
0368:  MOVLW  F0
0369:  MOVLB  07
036A:  ANDWF  16,F
....................   } 
....................   if ( interrupt_active(INT_RB4_H2L) ) { 
036B:  BTFSS  0B.0
036C:  GOTO   371
....................     // Read DTMF data first. Then mark it as valid if the DTMF_BUFFER_FULL flag is set. 
....................     DTMF_INTERRUPT_FLAG = 1; 
036D:  MOVLB  01
036E:  BSF    61.2
....................     clear_interrupt(INT_RB4_H2L); 
036F:  MOVLB  07
0370:  BCF    16.4
....................   } 
....................   if(interrupt_active(INT_RB6|INT_RB7)) { 
0371:  BTFSS  0B.0
0372:  GOTO   376
....................     AUX_IN_FLAG=1; 
0373:  BSF    74.6
....................     clear_interrupt(INT_RB6|INT_RB7); 
0374:  MOVLW  3F
0375:  ANDWF  16,F
....................   } 
.................... } // }}} 
0376:  BCF    0B.0
0377:  MOVLP  00
0378:  MOVLB  00
0379:  GOTO   020
.................... #INT_TIMER0 
.................... void int_rtcc(void) { // {{{ 
....................   if ( rtcc_cnt ) { 
037A:  MOVLB  01
037B:  MOVF   30,W
037C:  IORWF  31,W
037D:  BTFSC  03.2
037E:  GOTO   384
....................     rtcc_cnt--; 
037F:  MOVF   30,W
0380:  BTFSC  03.2
0381:  DECF   31,F
0382:  DECF   30,F
....................   } else { 
0383:  GOTO   39D
....................     COR_IN= ((input_b() ^ Polarity)&0x0F) | (COR_EMUL & 0x1F) | (COR_AUX&0x0F); 
0384:  MOVLB  00
0385:  MOVF   0D,W
0386:  XORWF  62,W
0387:  ANDLW  0F
0388:  MOVLB  02
0389:  MOVWF  53
038A:  MOVLB  00
038B:  MOVF   6A,W
038C:  ANDLW  1F
038D:  MOVLB  02
038E:  IORWF  53,F
038F:  MOVLB  00
0390:  MOVF   6B,W
0391:  ANDLW  0F
0392:  MOVLB  02
0393:  IORWF  53,W
0394:  MOVLB  00
0395:  MOVWF  5F
....................     COR_FLAG=1; 
0396:  BSF    74.1
....................     SECOND_FLAG=1; 
0397:  BSF    74.2
....................     AUX_IN_FLAG=1; 
0398:  BSF    74.6
....................     rtcc_cnt=30; 
0399:  MOVLB  01
039A:  CLRF   31
039B:  MOVLW  1E
039C:  MOVWF  30
....................   } 
....................   if (aux_timer ) { 
039D:  MOVF   32,W
039E:  IORWF  33,W
039F:  BTFSC  03.2
03A0:  GOTO   3A5
....................     aux_timer--; 
03A1:  MOVF   32,W
03A2:  BTFSC  03.2
03A3:  DECF   33,F
03A4:  DECF   32,F
....................   } 
.................... } // }}} 
03A5:  BCF    0B.2
03A6:  MOVLP  00
03A7:  MOVLB  00
03A8:  GOTO   020
.................... int1 warn_no_lcd = 1; 
....................  
.................... void lcd_strobe(char data) { // {{{ 
....................   i2c_write(data | E); 
....................   i2c_write(data & ~E); 
.................... } // }}} 
....................  
.................... void lcd_write(char rs, char data) { // {{{ 
....................   char lcd_word_a,lcd_word_b; 
....................   lcd_word_a = LCD_WRITE | BT | (data&0xF0); 
....................   lcd_word_b = LCD_WRITE | BT | ((data<<4)&0xF0); 
....................   if ( rs ) { 
....................     lcd_word_a |= RS; 
....................     lcd_word_b |= RS; 
....................   }  
....................   lcd_strobe(lcd_word_a); 
....................   lcd_strobe(lcd_word_b); 
.................... } // }}} 
....................  
.................... void lcd_send(char line,char * s) { // {{{ 
....................   int lcd_cmd; 
....................   int1 ack; 
....................  
.................... #ifdef LCD_ENABLE 
....................   i2c_start(); 
*
098C:  MOVLB  04
098D:  BSF    16.0
098E:  BTFSC  16.0
098F:  GOTO   18E
....................   #ifdef LCD_TYPE_PI 
....................   ack=i2c_write(LCD_I2C_ADD << 1); 
.................... //  ack=i2c_write(line&0x03); 
.................... // Change line 
....................   switch(line&0x03) { 
....................     case 0x00: lcd_write(0,CHANGE_LINE);break; 
....................     case 0x01: lcd_write(0,CHANGE_LINE+0x40);break; 
....................     case 0x02: lcd_write(0,CHANGE_LINE+0x14);break; 
....................     case 0x03: lcd_write(0,CHANGE_LINE+0x54);break; 
....................   } 
....................   restart_wdt(); 
....................   #else 
....................   lcd_cmd = LCD_I2C_ADD | ((line<<1) & 0x0e); 
0990:  BCF    03.0
0991:  MOVLB  02
0992:  RLF    48,W
0993:  ANDLW  0E
0994:  IORLW  60
0995:  MOVWF  4B
....................   ack=i2c_write(lcd_cmd); 
0996:  MOVF   4B,W
0997:  MOVWF  4E
0998:  MOVLP  00
0999:  MOVLB  00
099A:  CALL   6B3
099B:  MOVLP  08
099C:  MOVF   78,W
099D:  MOVLB  02
099E:  BCF    4C.0
099F:  BTFSC  78.0
09A0:  BSF    4C.0
....................   #endif 
....................   if ( ack!=0 ) { 
09A1:  BTFSS  4C.0
09A2:  GOTO   1C5
....................     if ( warn_no_lcd ) { 
09A3:  MOVLB  01
09A4:  BTFSS  61.7
09A5:  GOTO   1C3
....................       printf("\n\rI2C : No ACK from LCD : %u",ack); 
09A6:  MOVLW  00
09A7:  MOVLB  02
09A8:  BTFSC  4C.0
09A9:  MOVLW  01
09AA:  MOVWF  4D
09AB:  MOVLW  A9
09AC:  MOVLB  03
09AD:  MOVWF  11
09AE:  MOVLW  03
09AF:  MOVWF  12
09B0:  BCF    03.0
09B1:  MOVLW  1A
09B2:  MOVLB  02
09B3:  MOVWF  4E
09B4:  MOVLP  00
09B5:  MOVLB  00
09B6:  CALL   6C8
09B7:  MOVLP  08
09B8:  MOVLB  02
09B9:  MOVF   4D,W
09BA:  MOVWF  4E
09BB:  MOVLW  1B
09BC:  MOVWF  4F
09BD:  MOVLP  00
09BE:  MOVLB  00
09BF:  CALL   73C
09C0:  MOVLP  08
....................       warn_no_lcd = 0; 
09C1:  MOVLB  01
09C2:  BCF    61.7
....................     } 
....................   } else { 
09C3:  GOTO   1C7
09C4:  MOVLB  02
....................     warn_no_lcd = 1; 
09C5:  MOVLB  01
09C6:  BSF    61.7
....................   } 
....................   while(*s) { 
09C7:  MOVLB  02
09C8:  MOVF   4A,W
09C9:  MOVWF  7A
09CA:  MOVF   49,W
09CB:  MOVWF  04
09CC:  MOVF   7A,W
09CD:  MOVWF  05
09CE:  MOVF   00,F
09CF:  BTFSC  03.2
09D0:  GOTO   1E4
.................... #ifdef LCD_TYPE_PI 
....................     if ( *s != '\r' && *s != '\n') { 
....................       lcd_write(1,*s); 
....................     } 
....................     s++; 
.................... #else 
....................    i2c_write(*s++); 
09D1:  MOVF   4A,W
09D2:  MOVWF  7A
09D3:  MOVF   49,W
09D4:  INCF   49,F
09D5:  BTFSC  03.2
09D6:  INCF   4A,F
09D7:  MOVWF  04
09D8:  MOVF   7A,W
09D9:  MOVWF  05
09DA:  MOVF   00,W
09DB:  MOVWF  4D
09DC:  MOVWF  4E
09DD:  MOVLP  00
09DE:  MOVLB  00
09DF:  CALL   6B3
09E0:  MOVLP  08
.................... #endif 
....................   } 
09E1:  MOVLB  01
09E2:  GOTO   1C7
09E3:  MOVLB  02
.................... #ifndef LCD_TYPE_PI 
....................   i2c_write(0); // EOL 
09E4:  CLRF   4E
09E5:  MOVLP  00
09E6:  MOVLB  00
09E7:  CALL   6B3
09E8:  MOVLP  08
.................... #endif 
....................   i2c_stop(); 
09E9:  MOVLB  04
09EA:  BSF    16.2
09EB:  BTFSC  16.2
09EC:  GOTO   1EB
.................... #endif 
.................... } // }}} 
09ED:  MOVLB  00
09EE:  RETURN
....................  
.................... void execute_command(void) { // {{{ 
....................   unsigned int* regPtr; 
....................   int1 init_src; 
....................   int lcd_cmd; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   if ( command ) { 
*
1042:  MOVF   70,F
1043:  BTFSC  03.2
1044:  GOTO   0A6
....................     printf("\n\rProcessing Command:"); 
1045:  MOVLW  B8
1046:  MOVLB  03
1047:  MOVWF  11
1048:  MOVLW  03
1049:  MOVWF  12
104A:  MOVLP  00
104B:  MOVLB  00
104C:  CALL   4D7
104D:  MOVLP  10
....................     printf("\n\r  SiteID  : %u",SiteID); 
104E:  MOVLW  C3
104F:  MOVLB  03
1050:  MOVWF  11
1051:  MOVLW  03
1052:  MOVWF  12
1053:  BCF    03.0
1054:  MOVLW  0E
1055:  MOVLB  02
1056:  MOVWF  4E
1057:  MOVLP  00
1058:  MOVLB  00
1059:  CALL   6C8
105A:  MOVLP  10
105B:  MOVF   63,W
105C:  MOVLB  02
105D:  MOVWF  4E
105E:  MOVLW  1B
105F:  MOVWF  4F
1060:  MOVLP  00
1061:  MOVLB  00
1062:  CALL   73C
1063:  MOVLP  10
....................     printf("\n\r  Command : %u",command); 
1064:  MOVLW  CC
1065:  MOVLB  03
1066:  MOVWF  11
1067:  MOVLW  03
1068:  MOVWF  12
1069:  BCF    03.0
106A:  MOVLW  0E
106B:  MOVLB  02
106C:  MOVWF  4E
106D:  MOVLP  00
106E:  MOVLB  00
106F:  CALL   6C8
1070:  MOVLP  10
1071:  MOVF   70,W
1072:  MOVLB  02
1073:  MOVWF  4E
1074:  MOVLW  1B
1075:  MOVWF  4F
1076:  MOVLP  00
1077:  MOVLB  00
1078:  CALL   73C
1079:  MOVLP  10
....................     printf("\n\r  Argument: %u",argument); 
107A:  MOVLW  D5
107B:  MOVLB  03
107C:  MOVWF  11
107D:  MOVLW  03
107E:  MOVWF  12
107F:  BCF    03.0
1080:  MOVLW  0E
1081:  MOVLB  02
1082:  MOVWF  4E
1083:  MOVLP  00
1084:  MOVLB  00
1085:  CALL   6C8
1086:  MOVLP  10
1087:  MOVF   7D,W
1088:  MOVLB  02
1089:  MOVWF  4E
108A:  MOVLW  1B
108B:  MOVWF  4F
108C:  MOVLP  00
108D:  MOVLB  00
108E:  CALL   73C
108F:  MOVLP  10
....................     printf("\n\r  Value   : %u",value); 
1090:  MOVLW  DE
1091:  MOVLB  03
1092:  MOVWF  11
1093:  MOVLW  03
1094:  MOVWF  12
1095:  BCF    03.0
1096:  MOVLW  0E
1097:  MOVLB  02
1098:  MOVWF  4E
1099:  MOVLP  00
109A:  MOVLB  00
109B:  CALL   6C8
109C:  MOVLP  10
109D:  MOVF   7E,W
109E:  MOVLB  02
109F:  MOVWF  4E
10A0:  MOVLW  1B
10A1:  MOVWF  4F
10A2:  MOVLP  00
10A3:  MOVLB  00
10A4:  CALL   73C
10A5:  MOVLP  10
....................   } 
....................  
....................   switch(command) { 
10A6:  MOVLW  02
10A7:  SUBWF  70,W
10A8:  ADDLW  F5
10A9:  BTFSC  03.0
10AA:  GOTO   4E1
10AB:  ADDLW  0B
10AC:  GOTO   4E2
....................     case SET_REG: 
....................       set_var(); 
....................       break; 
*
1176:  GOTO   4E1
....................     case GET_REG: 
....................       regPtr=RegMap[argument].reg_ptr; 
1177:  RLF    7D,W
1178:  MOVWF  77
1179:  RLF    77,F
117A:  MOVLW  FC
117B:  ANDWF  77,F
117C:  MOVF   77,W
117D:  MOVLB  02
117E:  MOVWF  2A
117F:  INCF   2A,W
1180:  MOVLP  00
1181:  MOVLB  00
1182:  CALL   043
1183:  MOVLP  10
1184:  MOVWF  7A
1185:  MOVLB  02
1186:  MOVF   2A,W
1187:  MOVLP  00
1188:  MOVLB  00
1189:  CALL   043
118A:  MOVLP  10
118B:  MOVLB  01
118C:  MOVWF  6E
118D:  MOVF   7A,W
118E:  MOVWF  6F
....................       LastRegisterIndex = argument; 
118F:  MOVF   7D,W
1190:  MOVWF  5B
....................       LastRegisterIndexValid=1; 
1191:  MOVLW  01
1192:  MOVWF  5C
....................       cPtr = &reg_name + ((unsigned long)argument * REG_NAME_SIZE); 
1193:  MOVLW  01
1194:  MOVWF  7A
1195:  MOVLW  8F
1196:  MOVLB  02
1197:  MOVWF  2A
1198:  MOVF   7A,W
1199:  MOVWF  2B
119A:  CLRF   2D
119B:  MOVF   7D,W
119C:  MOVWF  2C
119D:  MOVF   2D,W
119E:  MOVWF  3C
119F:  MOVF   2C,W
11A0:  MOVWF  3B
11A1:  CLRF   3E
11A2:  MOVLW  06
11A3:  MOVWF  3D
11A4:  MOVLP  08
11A5:  MOVLB  00
11A6:  CALL   6EA
11A7:  MOVLP  10
11A8:  MOVF   78,W
11A9:  MOVLB  02
11AA:  ADDWF  2A,W
11AB:  MOVWF  22
11AC:  MOVF   79,W
11AD:  ADDWFC 2B,W
11AE:  MOVWF  23
....................       romstrcpy(rname,cPtr); 
11AF:  MOVLW  20
11B0:  MOVWF  3A
11B1:  MOVLW  A4
11B2:  MOVWF  39
11B3:  MOVF   23,W
11B4:  MOVWF  3C
11B5:  MOVF   22,W
11B6:  MOVWF  3B
11B7:  MOVLP  08
11B8:  MOVLB  00
11B9:  CALL   701
11BA:  MOVLP  10
....................       sprintf(LCD_str,"[%02u] %s %u\n\r",argument,rname,*regPtr); 
11BB:  MOVLB  01
11BC:  MOVF   6F,W
11BD:  MOVWF  7A
11BE:  MOVF   6E,W
11BF:  MOVWF  04
11C0:  MOVF   6F,W
11C1:  MOVWF  05
11C2:  MOVF   00,W
11C3:  MOVLB  02
11C4:  MOVWF  2A
11C5:  MOVLW  20
11C6:  MOVLB  01
11C7:  MOVWF  63
11C8:  MOVLW  76
11C9:  MOVWF  62
11CA:  MOVLW  5B
11CB:  MOVLB  02
11CC:  MOVWF  4E
11CD:  MOVLP  08
11CE:  MOVLB  00
11CF:  CALL   115
11D0:  MOVLP  10
11D1:  MOVF   7D,W
11D2:  MOVLB  02
11D3:  MOVWF  2B
11D4:  MOVLW  01
11D5:  MOVWF  2C
11D6:  MOVLP  08
11D7:  MOVLB  00
11D8:  CALL   77A
11D9:  MOVLP  10
11DA:  MOVLW  5D
11DB:  MOVLB  02
11DC:  MOVWF  4E
11DD:  MOVLP  08
11DE:  MOVLB  00
11DF:  CALL   115
11E0:  MOVLP  10
11E1:  MOVLW  20
11E2:  MOVLB  02
11E3:  MOVWF  4E
11E4:  MOVLP  08
11E5:  MOVLB  00
11E6:  CALL   115
11E7:  MOVLP  10
11E8:  MOVLW  20
11E9:  MOVWF  05
11EA:  MOVLW  A4
11EB:  MOVWF  04
11EC:  MOVLP  08
11ED:  CALL   177
11EE:  MOVLP  10
11EF:  MOVLW  20
11F0:  MOVLB  02
11F1:  MOVWF  4E
11F2:  MOVLP  08
11F3:  MOVLB  00
11F4:  CALL   115
11F5:  MOVLP  10
11F6:  MOVLB  02
11F7:  MOVF   2A,W
11F8:  MOVWF  2B
11F9:  MOVLW  1B
11FA:  MOVWF  2C
11FB:  MOVLP  08
11FC:  MOVLB  00
11FD:  CALL   77A
11FE:  MOVLP  10
11FF:  MOVLW  0A
1200:  MOVLB  02
1201:  MOVWF  4E
1202:  MOVLP  08
1203:  MOVLB  00
1204:  CALL   115
1205:  MOVLP  10
1206:  MOVLW  0D
1207:  MOVLB  02
1208:  MOVWF  4E
1209:  MOVLP  08
120A:  MOVLB  00
120B:  CALL   115
120C:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
120D:  MOVLW  0A
120E:  CLRWDT
120F:  BTFSS  11.4
1210:  GOTO   20E
1211:  MOVLB  03
1212:  MOVWF  1A
1213:  MOVLW  0D
1214:  CLRWDT
1215:  MOVLB  00
1216:  BTFSC  11.4
1217:  GOTO   21A
1218:  MOVLB  03
1219:  GOTO   214
121A:  MOVLB  03
121B:  MOVWF  1A
121C:  MOVLW  20
121D:  MOVWF  05
121E:  MOVLW  76
121F:  MOVWF  04
1220:  MOVLP  08
1221:  MOVLB  00
1222:  CALL   256
1223:  MOVLP  10
....................       lcd_send(2,LCD_str); 
1224:  MOVLW  02
1225:  MOVLB  02
1226:  MOVWF  48
1227:  MOVLW  20
1228:  MOVWF  4A
1229:  MOVLW  76
122A:  MOVWF  49
122B:  MOVLP  08
122C:  MOVLB  00
122D:  CALL   18C
122E:  MOVLP  10
....................       prompt(); 
122F:  MOVLP  08
1230:  CALL   7BD
1231:  MOVLP  10
....................       break; 
1232:  GOTO   4E1
....................     case SAVE_SETTINGS: 
....................       if ( in_admin_mode() ) { 
1233:  MOVLP  08
1234:  CALL   72A
1235:  MOVLP  10
1236:  MOVF   78,F
1237:  BTFSC  03.2
1238:  GOTO   23C
....................         store_variables(); 
1239:  MOVLP  00
123A:  CALL   5CA
123B:  MOVLP  10
....................       } 
....................       break; 
123C:  GOTO   4E1
....................     case RESTORE_SETTINGS: 
....................       if ( value == USE_EEPROM_VARS ) { 
123D:  DECFSZ 7E,W
123E:  GOTO   243
....................         init_src=USE_EEPROM_VARS; 
123F:  MOVLB  02
1240:  BSF    20.0
....................       } else { 
1241:  GOTO   245
1242:  MOVLB  00
....................         init_src=USE_DEFAULT_VARS; 
1243:  MOVLB  02
1244:  BCF    20.0
....................       } 
....................       if ( in_admin_mode() ) { 
1245:  MOVLP  08
1246:  MOVLB  00
1247:  CALL   72A
1248:  MOVLP  10
1249:  MOVF   78,F
124A:  BTFSC  03.2
124B:  GOTO   256
....................         init_variables(init_src); 
124C:  MOVLW  00
124D:  MOVLB  02
124E:  BTFSC  20.0
124F:  MOVLW  01
1250:  MOVWF  2A
1251:  MOVWF  2B
1252:  MOVLP  00
1253:  MOVLB  00
1254:  CALL   645
1255:  MOVLP  10
....................       } 
....................       break; 
1256:  GOTO   4E1
....................     case INCREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1257:  MOVF   7D,W
1258:  ANDLW  03
1259:  MOVWF  76
....................       increment(value); 
125A:  MOVF   7E,W
125B:  MOVLB  02
125C:  MOVWF  2D
125D:  MOVLP  08
125E:  MOVLB  00
125F:  CALL   739
1260:  MOVLP  10
....................       PROMPT_FLAG=1; 
1261:  MOVLB  01
1262:  BSF    61.4
....................       break; 
1263:  MOVLB  00
1264:  GOTO   4E1
....................     case DECREMENT_REG: 
....................       CurrentTrimPot = argument & 0x03; 
1265:  MOVF   7D,W
1266:  ANDLW  03
1267:  MOVWF  76
....................       increment(-1*value); 
1268:  MOVLW  FF
1269:  MOVLB  02
126A:  MOVWF  41
126B:  MOVF   7E,W
126C:  MOVWF  42
126D:  MOVLP  08
126E:  MOVLB  00
126F:  CALL   662
1270:  MOVLP  10
1271:  MOVF   78,W
1272:  MOVLB  02
1273:  MOVWF  2A
1274:  MOVWF  2D
1275:  MOVLP  08
1276:  MOVLB  00
1277:  CALL   739
1278:  MOVLP  10
....................       PROMPT_FLAG=1; 
1279:  MOVLB  01
127A:  BSF    61.4
....................       break; 
127B:  MOVLB  00
127C:  GOTO   4E1
....................     case STATUS: 
....................       status(); 
....................       break; 
*
145C:  MOVLB  00
145D:  GOTO   4E1
....................     case ADMIN: 
....................       switch(argument) { 
145E:  MOVF   7D,W
145F:  XORLW  02
1460:  BTFSC  03.2
1461:  GOTO   469
1462:  XORLW  03
1463:  BTFSC  03.2
1464:  GOTO   470
1465:  XORLW  02
1466:  BTFSC  03.2
1467:  GOTO   478
1468:  GOTO   47A
....................         case REBOOT: 
....................           if ( in_admin_mode() ) { 
1469:  MOVLP  08
146A:  CALL   72A
146B:  MOVLP  10
146C:  MOVF   78,F
146D:  BTFSS  03.2
....................             reset_cpu(); 
146E:  RESET
....................           } 
....................           break; 
146F:  GOTO   480
....................         case ENTER_ADMIN: 
....................           set_admin_mode(1); 
1470:  MOVLW  01
1471:  MOVLB  02
1472:  MOVWF  3E
1473:  MOVLP  08
1474:  MOVLB  00
1475:  CALL   4A9
1476:  MOVLP  10
....................           break; 
1477:  GOTO   480
....................         case SEND_MORSE_ID: 
....................           send_morse_id(); 
1478:  CALL   000
....................         break; 
1479:  GOTO   480
....................         default: 
....................           set_admin_mode(0); 
147A:  MOVLB  02
147B:  CLRF   3E
147C:  MOVLP  08
147D:  MOVLB  00
147E:  CALL   4A9
147F:  MOVLP  10
....................           break; 
....................       } 
....................       break; 
1480:  GOTO   4E1
....................     case I2C_SEND: 
....................       // I2C special commands 
....................       // 0 - 0b100X - Restart LCD 
....................       // 1 - 0b101X - Clear LCD 
....................       // 2 - 0b110X - Init LCD + Welcome screen 
....................       // 3 - 0b111X - Not implemented 
.................... #ifdef LCD_TYPE_PI 
....................       switch(value) { 
....................         case 0 : init_lcd();break;   
....................         case 1 : lcd_write(0,0x01); 
....................       } 
.................... #else 
....................       lcd_cmd=4+(value&0x03); 
1481:  MOVF   7E,W
1482:  ANDLW  03
1483:  ADDLW  04
1484:  MOVLB  02
1485:  MOVWF  21
....................       sprintf(LCD_str,"I2C(%d) CMD : %d",LCD_I2C_ADD,lcd_cmd); 
1486:  MOVLW  20
1487:  MOVLB  01
1488:  MOVWF  63
1489:  MOVLW  76
148A:  MOVWF  62
148B:  MOVLW  E7
148C:  MOVLB  03
148D:  MOVWF  11
148E:  MOVLW  03
148F:  MOVWF  12
1490:  BCF    03.0
1491:  MOVLW  04
1492:  MOVLB  02
1493:  MOVWF  48
1494:  MOVLP  08
1495:  MOVLB  00
1496:  CALL   124
1497:  MOVLP  10
1498:  MOVLW  60
1499:  MOVLB  02
149A:  MOVWF  48
149B:  MOVLW  18
149C:  MOVWF  49
149D:  MOVLP  08
149E:  MOVLB  00
149F:  CALL   1EF
14A0:  MOVLP  10
14A1:  MOVLW  EA
14A2:  MOVLB  03
14A3:  MOVWF  11
14A4:  MOVLW  03
14A5:  MOVWF  12
14A6:  BCF    03.0
14A7:  MOVLW  08
14A8:  MOVLB  02
14A9:  MOVWF  48
14AA:  MOVLP  08
14AB:  MOVLB  00
14AC:  CALL   124
14AD:  MOVLP  10
14AE:  MOVLB  02
14AF:  MOVF   21,W
14B0:  MOVWF  48
14B1:  MOVLW  18
14B2:  MOVWF  49
14B3:  MOVLP  08
14B4:  MOVLB  00
14B5:  CALL   1EF
14B6:  MOVLP  10
....................       printf("\n\r%s",LCD_str); 
14B7:  MOVLW  0A
14B8:  CLRWDT
14B9:  BTFSS  11.4
14BA:  GOTO   4B8
14BB:  MOVLB  03
14BC:  MOVWF  1A
14BD:  MOVLW  0D
14BE:  CLRWDT
14BF:  MOVLB  00
14C0:  BTFSC  11.4
14C1:  GOTO   4C4
14C2:  MOVLB  03
14C3:  GOTO   4BE
14C4:  MOVLB  03
14C5:  MOVWF  1A
14C6:  MOVLW  20
14C7:  MOVWF  05
14C8:  MOVLW  76
14C9:  MOVWF  04
14CA:  MOVLP  08
14CB:  MOVLB  00
14CC:  CALL   256
14CD:  MOVLP  10
....................       lcd_send(lcd_cmd,LCD_str); 
14CE:  MOVLB  02
14CF:  MOVF   21,W
14D0:  MOVWF  48
14D1:  MOVLW  20
14D2:  MOVWF  4A
14D3:  MOVLW  76
14D4:  MOVWF  49
14D5:  MOVLP  08
14D6:  MOVLB  00
14D7:  CALL   18C
14D8:  MOVLP  10
.................... #endif 
....................       break; 
14D9:  GOTO   4E1
....................     case MORSE_SEND: 
....................       morse(value); 
14DA:  MOVF   7E,W
14DB:  MOVLB  02
14DC:  MOVWF  3D
14DD:  MOVLP  08
14DE:  MOVLB  00
14DF:  CALL   09C
14E0:  MOVLP  10
....................       break; 
....................   } 
.................... } // }}} 
14E1:  RETURN
.................... void process_sBuffer(void) { // {{{ 
....................   unsigned long x; 
....................   rom char * cPtr; 
....................   char rname[REG_NAME_SIZE]; 
....................  
....................   lcd_send(2,sBuffer); 
*
1800:  MOVLW  02
1801:  MOVLB  02
1802:  MOVWF  48
1803:  MOVLW  20
1804:  MOVWF  4A
1805:  MOVLW  50
1806:  MOVWF  49
1807:  MOVLP  08
1808:  MOVLB  00
1809:  CALL   18C
180A:  MOVLP  18
....................   argument = -1; 
180B:  MOVLW  FF
180C:  MOVWF  7D
....................   // tokenize_sBuffer may set argument for some commands 
....................   tokenize_sBuffer(); 
....................  
....................   // Find matching register or argument 
....................   for(x=0;x<RegMapNum;x++) { 
*
1B62:  MOVLB  01
1B63:  CLRF   65
1B64:  CLRF   64
1B65:  MOVF   65,F
1B66:  BTFSS  03.2
1B67:  GOTO   3B1
1B68:  MOVF   64,W
1B69:  SUBLW  38
1B6A:  BTFSS  03.0
1B6B:  GOTO   3B1
....................     cPtr = &reg_name + (x * REG_NAME_SIZE); 
1B6C:  MOVLW  01
1B6D:  MOVWF  7A
1B6E:  MOVLW  8F
1B6F:  MOVWF  6E
1B70:  MOVF   7A,W
1B71:  MOVWF  6F
1B72:  MOVF   65,W
1B73:  MOVLB  02
1B74:  MOVWF  3C
1B75:  MOVLB  01
1B76:  MOVF   64,W
1B77:  MOVLB  02
1B78:  MOVWF  3B
1B79:  CLRF   3E
1B7A:  MOVLW  06
1B7B:  MOVWF  3D
1B7C:  MOVLP  08
1B7D:  MOVLB  00
1B7E:  CALL   6EA
1B7F:  MOVLP  18
1B80:  MOVF   78,W
1B81:  MOVLB  01
1B82:  ADDWF  6E,W
1B83:  MOVWF  66
1B84:  MOVF   79,W
1B85:  ADDWFC 6F,W
1B86:  MOVWF  67
....................     romstrcpy(rname,cPtr); 
1B87:  MOVLW  20
1B88:  MOVLB  02
1B89:  MOVWF  3A
1B8A:  MOVLW  98
1B8B:  MOVWF  39
1B8C:  MOVLB  01
1B8D:  MOVF   67,W
1B8E:  MOVLB  02
1B8F:  MOVWF  3C
1B90:  MOVLB  01
1B91:  MOVF   66,W
1B92:  MOVLB  02
1B93:  MOVWF  3B
1B94:  MOVLP  08
1B95:  MOVLB  00
1B96:  CALL   701
1B97:  MOVLP  18
....................     if(my_stricmp(argument_name,rname)==0) { 
1B98:  MOVLW  20
1B99:  MOVLB  02
1B9A:  MOVWF  3E
1B9B:  MOVLW  70
1B9C:  MOVWF  3D
1B9D:  MOVLW  20
1B9E:  MOVWF  40
1B9F:  MOVLW  98
1BA0:  MOVWF  3F
1BA1:  MOVLP  08
1BA2:  MOVLB  00
1BA3:  CALL   6C2
1BA4:  MOVLP  18
1BA5:  MOVF   78,F
1BA6:  BTFSS  03.2
1BA7:  GOTO   3AC
....................       argument=x; 
1BA8:  MOVLB  01
1BA9:  MOVF   64,W
1BAA:  MOVWF  7D
1BAB:  MOVLB  00
....................     } 
....................   } 
1BAC:  MOVLB  01
1BAD:  INCF   64,F
1BAE:  BTFSC  03.2
1BAF:  INCF   65,F
1BB0:  GOTO   365
....................   // Match "EEPROM" or "RAM" for restore/save functions 
....................   if ( argument == -1 ) { 
1BB1:  MOVF   7D,W
1BB2:  SUBLW  FF
1BB3:  BTFSS  03.2
1BB4:  GOTO   415
....................     // save/restore <eeprom> 
....................     // Convert "argument_name" to value when sending dtmf via RS232 using: 
....................     // d <digit>  
....................     value=str_to_decimal(argument_name); 
1BB5:  MOVLW  20
1BB6:  MOVLB  02
1BB7:  MOVWF  3E
1BB8:  MOVLW  70
1BB9:  MOVWF  3D
1BBA:  MOVLP  08
1BBB:  MOVLB  00
1BBC:  CALL   689
1BBD:  MOVLP  18
1BBE:  MOVF   78,W
1BBF:  MOVWF  7E
....................     strcpy(rname,"eeprom"); 
1BC0:  MOVLB  01
1BC1:  CLRF   6E
1BC2:  CLRF   6F
1BC3:  MOVLW  20
1BC4:  MOVWF  05
1BC5:  MOVLW  98
1BC6:  MOVWF  04
1BC7:  MOVF   6E,W
1BC8:  ADDWF  04,F
1BC9:  MOVLW  00
1BCA:  ADDWFC 05,F
1BCB:  MOVF   6F,W
1BCC:  MOVLP  00
1BCD:  MOVLB  00
1BCE:  CALL   128
1BCF:  MOVLP  18
1BD0:  MOVWF  00
1BD1:  IORLW  00
1BD2:  BTFSC  03.2
1BD3:  GOTO   3D9
1BD4:  MOVLB  01
1BD5:  INCF   6F,F
1BD6:  INCF   6E,F
1BD7:  GOTO   3C3
1BD8:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1BD9:  MOVLW  20
1BDA:  MOVLB  02
1BDB:  MOVWF  3E
1BDC:  MOVLW  70
1BDD:  MOVWF  3D
1BDE:  MOVLW  20
1BDF:  MOVWF  40
1BE0:  MOVLW  98
1BE1:  MOVWF  3F
1BE2:  MOVLP  08
1BE3:  MOVLB  00
1BE4:  CALL   6C2
1BE5:  MOVLP  18
1BE6:  MOVF   78,F
1BE7:  BTFSS  03.2
1BE8:  GOTO   3EB
....................       value=USE_EEPROM_VARS; 
1BE9:  MOVLW  01
1BEA:  MOVWF  7E
....................     } 
....................     // save/restore <default> 
....................     strcpy(rname,"default"); 
1BEB:  MOVLB  01
1BEC:  CLRF   6E
1BED:  CLRF   6F
1BEE:  MOVLW  20
1BEF:  MOVWF  05
1BF0:  MOVLW  98
1BF1:  MOVWF  04
1BF2:  MOVF   6E,W
1BF3:  ADDWF  04,F
1BF4:  MOVLW  00
1BF5:  ADDWFC 05,F
1BF6:  MOVF   6F,W
1BF7:  MOVLP  00
1BF8:  MOVLB  00
1BF9:  CALL   130
1BFA:  MOVLP  18
1BFB:  MOVWF  00
1BFC:  IORLW  00
1BFD:  BTFSC  03.2
1BFE:  GOTO   404
1BFF:  MOVLB  01
1C00:  INCF   6F,F
1C01:  INCF   6E,F
1C02:  GOTO   3EE
1C03:  MOVLB  00
....................     if(my_stricmp(argument_name,rname)==0) { 
1C04:  MOVLW  20
1C05:  MOVLB  02
1C06:  MOVWF  3E
1C07:  MOVLW  70
1C08:  MOVWF  3D
1C09:  MOVLW  20
1C0A:  MOVWF  40
1C0B:  MOVLW  98
1C0C:  MOVWF  3F
1C0D:  MOVLP  08
1C0E:  MOVLB  00
1C0F:  CALL   6C2
1C10:  MOVLP  18
1C11:  MOVF   78,F
1C12:  BTFSC  03.2
....................       value=USE_DEFAULT_VARS; 
1C13:  CLRF   7E
1C14:  MOVLB  01
....................     } 
....................   } 
....................   if ( command == INCREMENT_REG || command == DECREMENT_REG ) { 
1C15:  MOVF   70,W
1C16:  SUBLW  06
1C17:  BTFSC  03.2
1C18:  GOTO   41D
1C19:  MOVF   70,W
1C1A:  SUBLW  07
1C1B:  BTFSS  03.2
1C1C:  GOTO   421
....................     value = 1; 
1C1D:  MOVLW  01
1C1E:  MOVWF  7E
....................     argument = CurrentTrimPot; 
1C1F:  MOVF   76,W
1C20:  MOVWF  7D
....................   } 
....................   rs232_mode = 1; 
1C21:  BSF    61.6
....................   execute_command(); 
1C22:  MOVLP  10
1C23:  MOVLB  00
1C24:  CALL   042
1C25:  MOVLP  18
....................   rs232_mode = 0; 
1C26:  MOVLB  01
1C27:  BCF    61.6
.................... } // }}} 
1C28:  MOVLP  18
1C29:  MOVLB  00
1C2A:  GOTO   6E6 (RETURN)
.................... void clearscr(void) { // {{{ 
.................... // Erase the screen  
....................   putc(ESC); 
*
127D:  MOVLW  1B
127E:  MOVLP  00
127F:  CALL   2E4
1280:  MOVLP  10
....................   printf("[2J"); 
1281:  MOVLW  5B
1282:  CLRWDT
1283:  BTFSS  11.4
1284:  GOTO   282
1285:  MOVLB  03
1286:  MOVWF  1A
1287:  MOVLW  32
1288:  CLRWDT
1289:  MOVLB  00
128A:  BTFSC  11.4
128B:  GOTO   28E
128C:  MOVLB  03
128D:  GOTO   288
128E:  MOVLB  03
128F:  MOVWF  1A
1290:  MOVLW  4A
1291:  CLRWDT
1292:  MOVLB  00
1293:  BTFSC  11.4
1294:  GOTO   297
1295:  MOVLB  03
1296:  GOTO   291
1297:  MOVLB  03
1298:  MOVWF  1A
.................... // Move cursor back to top 
....................   putc(ESC); 
1299:  MOVLW  1B
129A:  MOVLP  00
129B:  MOVLB  00
129C:  CALL   2E4
129D:  MOVLP  10
....................   printf("[0;0H"); 
129E:  MOVLW  F0
129F:  MOVLB  03
12A0:  MOVWF  11
12A1:  MOVLW  03
12A2:  MOVWF  12
12A3:  MOVLP  00
12A4:  MOVLB  00
12A5:  CALL   4D7
12A6:  MOVLP  10
.................... } // }}} 
.................... void set_trimpot(pot,value) { // {{{ 
....................   int tx_value; 
....................   int1 ack; 
....................   tx_value=pot << 6; 
*
078B:  MOVLB  02
078C:  SWAPF  3D,W
078D:  MOVWF  3F
078E:  RLF    3F,F
078F:  RLF    3F,F
0790:  MOVLW  C0
0791:  ANDWF  3F,F
....................   tx_value=tx_value + (value & 0x3F); 
0792:  MOVF   3E,W
0793:  ANDLW  3F
0794:  ADDWF  3F,F
....................   i2c_start(); 
0795:  MOVLB  04
0796:  BSF    16.0
0797:  BTFSC  16.0
0798:  GOTO   797
....................   ack=i2c_write(TRIMPOT_WRITE_CMD); 
0799:  MOVLW  50
079A:  MOVLB  02
079B:  MOVWF  4E
079C:  MOVLB  00
079D:  CALL   6B3
079E:  MOVF   78,W
079F:  MOVLB  02
07A0:  BCF    40.0
07A1:  BTFSC  78.0
07A2:  BSF    40.0
....................   if ( ack != 0) { 
07A3:  BTFSS  40.0
07A4:  GOTO   7BC
....................     printf("\n\rI2C : No ACK : %u",ack); 
07A5:  MOVLW  00
07A6:  BTFSC  40.0
07A7:  MOVLW  01
07A8:  MOVWF  41
07A9:  MOVLW  F3
07AA:  MOVLB  03
07AB:  MOVWF  11
07AC:  MOVLW  03
07AD:  MOVWF  12
07AE:  BCF    03.0
07AF:  MOVLW  11
07B0:  MOVLB  02
07B1:  MOVWF  4E
07B2:  MOVLB  00
07B3:  CALL   6C8
07B4:  MOVLB  02
07B5:  MOVF   41,W
07B6:  MOVWF  4E
07B7:  MOVLW  1B
07B8:  MOVWF  4F
07B9:  MOVLB  00
07BA:  CALL   73C
07BB:  MOVLB  02
....................   } 
....................   i2c_write(tx_value); 
07BC:  MOVF   3F,W
07BD:  MOVWF  4E
07BE:  MOVLB  00
07BF:  CALL   6B3
....................   i2c_stop();   
07C0:  MOVLB  04
07C1:  BSF    16.2
07C2:  BTFSC  16.2
07C3:  GOTO   7C2
....................   printf("\n\rPot(%u)<=%u",pot,value); 
07C4:  MOVLW  FD
07C5:  MOVLB  03
07C6:  MOVWF  11
07C7:  MOVLW  03
07C8:  MOVWF  12
07C9:  BCF    03.0
07CA:  MOVLW  06
07CB:  MOVLB  02
07CC:  MOVWF  4E
07CD:  MOVLB  00
07CE:  CALL   6C8
07CF:  MOVLB  02
07D0:  MOVF   3D,W
07D1:  MOVWF  4E
07D2:  MOVLW  1B
07D3:  MOVWF  4F
07D4:  MOVLB  00
07D5:  CALL   73C
07D6:  MOVLW  29
07D7:  CLRWDT
07D8:  BTFSS  11.4
07D9:  GOTO   7D7
07DA:  MOVLB  03
07DB:  MOVWF  1A
07DC:  MOVLW  3C
07DD:  CLRWDT
07DE:  MOVLB  00
07DF:  BTFSC  11.4
07E0:  GOTO   7E3
07E1:  MOVLB  03
07E2:  GOTO   7DD
07E3:  MOVLB  03
07E4:  MOVWF  1A
07E5:  MOVLW  3D
07E6:  CLRWDT
07E7:  MOVLB  00
07E8:  BTFSC  11.4
07E9:  GOTO   7EC
07EA:  MOVLB  03
07EB:  GOTO   7E6
07EC:  MOVLB  03
07ED:  MOVWF  1A
07EE:  MOVLB  02
07EF:  MOVF   3E,W
07F0:  MOVWF  4E
07F1:  MOVLW  1B
07F2:  MOVWF  4F
07F3:  MOVLB  00
07F4:  CALL   73C
....................  
.................... } // }}} 
07F5:  RETURN
.................... void morse (int c) { // {{{ 
....................   int mc; 
....................   int x; 
....................   int1 do_delay; 
....................  
....................   mc = cMorseChar[c];  
*
089C:  MOVLW  DB
089D:  MOVLB  02
089E:  ADDWF  3D,W
089F:  MOVWF  41
08A0:  MOVLW  1F
08A1:  MOVWF  42
08A2:  BTFSC  03.0
08A3:  INCF   42,F
08A4:  MOVF   42,W
08A5:  MOVLB  03
08A6:  MOVWF  12
08A7:  MOVLB  02
08A8:  MOVF   41,W
08A9:  MOVLB  03
08AA:  MOVWF  11
08AB:  MOVLW  20
08AC:  MOVWF  05
08AD:  MOVLW  BE
08AE:  MOVWF  04
08AF:  MOVLW  01
08B0:  MOVLB  02
08B1:  MOVWF  43
08B2:  MOVLB  00
08B3:  CALL   019
....................    
....................   PROMPT_FLAG=1; 
08B4:  MOVLB  01
08B5:  BSF    61.4
....................   for(x=0;x<4;x++) { 
08B6:  MOVLB  02
08B7:  CLRF   3F
08B8:  MOVF   3F,W
08B9:  SUBLW  03
08BA:  BTFSS  03.0
08BB:  GOTO   0E2
....................     do_delay=1; 
08BC:  BSF    40.0
....................     switch(mc & 0xc0) { // Check two MSB's 
08BD:  MOVF   3E,W
08BE:  ANDLW  C0
08BF:  XORLW  40
08C0:  MOVLB  00
08C1:  BTFSC  03.2
08C2:  GOTO   0C7
08C3:  XORLW  C0
08C4:  BTFSC  03.2
08C5:  GOTO   0C9
08C6:  GOTO   0CB
....................       case(0x40): 
....................         dit(); 
08C7:  CALL   02C
....................         break; 
08C8:  GOTO   0CE
....................       case(0x80): 
....................         dah(); 
08C9:  CALL   064
....................         break; 
08CA:  GOTO   0CE
....................       default: 
....................         do_delay=0; 
08CB:  MOVLB  02
08CC:  BCF    40.0
....................         break; 
08CD:  MOVLB  00
....................     } 
....................     mc = mc << 2; // Shift two MSB's out and continue with next ones 
08CE:  MOVLB  02
08CF:  RLF    3E,F
08D0:  RLF    3E,F
08D1:  MOVLW  FC
08D2:  ANDWF  3E,F
....................     if ( do_delay ) { 
08D3:  BTFSS  40.0
08D4:  GOTO   0E0
....................       aux_timer=MorseLen[(MorseDitLength&0x03)]; 
08D5:  MOVLB  01
08D6:  CLRF   33
08D7:  MOVLW  02
08D8:  MOVWF  32
....................       while(aux_timer) { 
08D9:  MOVF   32,W
08DA:  IORWF  33,W
08DB:  BTFSC  03.2
08DC:  GOTO   0DF
....................         delay_cycles(1); 
08DD:  NOP
....................       } 
08DE:  GOTO   0D9
08DF:  MOVLB  02
....................     } 
....................   } 
08E0:  INCF   3F,F
08E1:  GOTO   0B8
....................   if ( c < 10 ) { // Digits --> add the 5th dit or dah. 
08E2:  MOVF   3D,W
08E3:  SUBLW  09
08E4:  BTFSS  03.0
08E5:  GOTO   0F1
....................     if ( c < 5 ) { 
08E6:  MOVF   3D,W
08E7:  SUBLW  04
08E8:  BTFSS  03.0
08E9:  GOTO   0EE
....................       dah(); 
08EA:  MOVLB  00
08EB:  CALL   064
....................     } 
....................     else { 
08EC:  GOTO   0F0
08ED:  MOVLB  02
....................       dit(); 
08EE:  MOVLB  00
08EF:  CALL   02C
08F0:  MOVLB  02
....................     } 
....................   } 
.................... } // }}} 
08F1:  MOVLB  00
08F2:  RETURN
.................... void update_ptt(int cor) { // {{{ 
....................   char x,pot; 
....................   int pot_val; 
....................   int mask; 
....................   int ptt; 
....................   char COR_s[5]={'0','0','0','0',0}; 
*
0B60:  MOVLW  30
0B61:  MOVLB  02
0B62:  MOVWF  32
0B63:  MOVWF  33
0B64:  MOVWF  34
0B65:  MOVWF  35
0B66:  CLRF   36
....................   char PTT_s[5]={'0','0','0','0',0}; 
0B67:  MOVWF  37
0B68:  MOVWF  38
0B69:  MOVWF  39
0B6A:  MOVWF  3A
0B6B:  CLRF   3B
....................   int1 rx_bit,ptt_bit; 
....................  
....................   CurrentCorIndex=cor; 
0B6C:  MOVF   2C,W
0B6D:  MOVLB  00
0B6E:  MOVWF  6F
....................  
....................   if ( cor ) { 
0B6F:  MOVLB  02
0B70:  MOVF   2C,F
0B71:  BTFSC  03.2
0B72:  GOTO   384
....................     ptt=RX_PTT[cor-1] & (Enable & Enable_Mask); 
0B73:  MOVLW  01
0B74:  SUBWF  2C,W
0B75:  ADDLW  29
0B76:  MOVWF  04
0B77:  MOVLW  20
0B78:  MOVWF  05
0B79:  BTFSC  03.0
0B7A:  INCF   05,F
0B7B:  MOVF   00,W
0B7C:  MOVWF  3D
0B7D:  MOVLB  00
0B7E:  MOVF   60,W
0B7F:  ANDWF  61,W
0B80:  MOVLB  02
0B81:  ANDWF  3D,W
0B82:  MOVWF  31
....................   } else { 
0B83:  GOTO   3C7
....................     ptt=0; 
0B84:  CLRF   31
....................     //COR_EMUL=0; 
....................     if ( COR_DROP_FLAG ) { 
0B85:  BTFSS  74.5
0B86:  GOTO   3C7
....................       COR_DROP_FLAG=0; 
0B87:  BCF    74.5
....................       if ( ConfirmChar || TailChar ) { 
0B88:  MOVLB  00
0B89:  MOVF   6D,F
0B8A:  BTFSS  03.2
0B8B:  GOTO   38F
0B8C:  MOVF   6C,F
0B8D:  BTFSC  03.2
0B8E:  GOTO   3C6
....................         send_tail(); 
....................       } 
....................     } 
....................   } 
....................  
....................   mask=1; 
*
0BC7:  MOVLW  01
0BC8:  MOVWF  30
....................   for(x=0;x<4;x++) { 
0BC9:  CLRF   2D
0BCA:  MOVF   2D,W
0BCB:  SUBLW  03
0BCC:  BTFSS  03.0
0BCD:  GOTO   432
....................     if ( !cor ) { 
0BCE:  MOVF   2C,F
0BCF:  BTFSS  03.2
0BD0:  GOTO   3D4
....................       rx_bit=0; 
0BD1:  BCF    3C.0
....................       ptt_bit=0; 
0BD2:  BCF    3C.1
....................     } else { 
0BD3:  GOTO   3E7
....................       if ( cor == (x+1) ) { 
0BD4:  MOVLW  01
0BD5:  ADDWF  2D,W
0BD6:  SUBWF  2C,W
0BD7:  BTFSS  03.2
0BD8:  GOTO   3DF
....................         rx_bit=1; 
0BD9:  BSF    3C.0
....................         CurrentCorMask=mask; 
0BDA:  MOVF   30,W
0BDB:  MOVLB  00
0BDC:  MOVWF  6E
....................       } else { 
0BDD:  GOTO   3E1
0BDE:  MOVLB  02
....................         rx_bit=0; 
0BDF:  BCF    3C.0
0BE0:  MOVLB  00
....................       } 
....................       ptt_bit=(ptt&mask)!=0; 
0BE1:  MOVLB  02
0BE2:  BCF    3C.1
0BE3:  MOVF   31,W
0BE4:  ANDWF  30,W
0BE5:  BTFSS  03.2
0BE6:  BSF    3C.1
....................     } 
....................     output_bit(RX_PIN[x],rx_bit); 
0BE7:  MOVF   2D,W
0BE8:  MOVLP  00
0BE9:  MOVLB  00
0BEA:  CALL   031
0BEB:  MOVLP  08
0BEC:  MOVLB  02
0BED:  MOVWF  3D
0BEE:  MOVLW  00
0BEF:  BTFSC  3C.0
0BF0:  MOVLW  01
0BF1:  MOVWF  77
0BF2:  MOVF   3D,W
0BF3:  MOVWF  3E
0BF4:  MOVF   77,W
0BF5:  MOVWF  3F
0BF6:  MOVLW  01
0BF7:  MOVWF  41
0BF8:  CLRF   40
0BF9:  MOVLB  00
0BFA:  CALL   0F3
0BFB:  MOVLB  02
0BFC:  MOVF   3D,W
0BFD:  MOVWF  3E
0BFE:  CLRF   3F
0BFF:  CLRF   41
0C00:  MOVLW  80
0C01:  MOVWF  40
0C02:  MOVLB  00
0C03:  CALL   0F3
....................     output_bit(PTT_PIN[x],ptt_bit); 
0C04:  MOVLB  02
0C05:  MOVF   2D,W
0C06:  MOVLP  00
0C07:  MOVLB  00
0C08:  CALL   036
0C09:  MOVLP  08
0C0A:  MOVLB  02
0C0B:  MOVWF  3D
0C0C:  MOVLW  00
0C0D:  BTFSC  3C.1
0C0E:  MOVLW  01
0C0F:  MOVWF  77
0C10:  MOVF   3D,W
0C11:  MOVWF  3E
0C12:  MOVF   77,W
0C13:  MOVWF  3F
0C14:  MOVLW  01
0C15:  MOVWF  41
0C16:  CLRF   40
0C17:  MOVLB  00
0C18:  CALL   0F3
0C19:  MOVLB  02
0C1A:  MOVF   3D,W
0C1B:  MOVWF  3E
0C1C:  CLRF   3F
0C1D:  CLRF   41
0C1E:  MOVLW  80
0C1F:  MOVWF  40
0C20:  MOVLB  00
0C21:  CALL   0F3
....................     if(ptt_bit) { 
0C22:  MOVLB  02
0C23:  BTFSS  3C.1
0C24:  GOTO   42E
....................       PTT_s[x]='1'; 
0C25:  MOVLW  B7
0C26:  ADDWF  2D,W
0C27:  MOVWF  04
0C28:  MOVLW  20
0C29:  MOVWF  05
0C2A:  BTFSC  03.0
0C2B:  INCF   05,F
0C2C:  MOVLW  31
0C2D:  MOVWF  00
....................     } 
....................     mask=mask<<1; 
0C2E:  BCF    03.0
0C2F:  RLF    30,F
....................   }  
0C30:  INCF   2D,F
0C31:  GOTO   3CA
....................   if(!cor) { 
0C32:  MOVF   2C,F
0C33:  BTFSS  03.2
0C34:  GOTO   437
....................     CurrentCorPriority=0; 
0C35:  CLRF   71
....................   } else { 
0C36:  GOTO   465
....................     CurrentCorPriority=RXPriority[cor-1]; 
0C37:  MOVLW  01
0C38:  SUBWF  2C,W
0C39:  ADDLW  25
0C3A:  MOVWF  04
0C3B:  MOVLW  20
0C3C:  MOVWF  05
0C3D:  BTFSC  03.0
0C3E:  INCF   05,F
0C3F:  MOVF   00,W
0C40:  MOVWF  71
....................   // Update TrimPots 
....................     for(pot=0;pot<4;pot++){ 
0C41:  CLRF   2E
0C42:  MOVF   2E,W
0C43:  SUBLW  03
0C44:  BTFSS  03.0
0C45:  GOTO   462
....................       pot_val=RX_GAIN[cor-1][pot]; 
0C46:  MOVLW  01
0C47:  SUBWF  2C,W
0C48:  MOVWF  77
0C49:  RLF    77,F
0C4A:  RLF    77,F
0C4B:  MOVLW  FC
0C4C:  ANDWF  77,F
0C4D:  MOVF   77,W
0C4E:  ADDWF  2E,W
0C4F:  ADDLW  0C
0C50:  MOVWF  04
0C51:  MOVLW  20
0C52:  MOVWF  05
0C53:  BTFSC  03.0
0C54:  INCF   05,F
0C55:  MOVF   00,W
0C56:  MOVWF  2F
....................       set_trimpot(pot,pot_val); 
0C57:  MOVF   2E,W
0C58:  MOVWF  3D
0C59:  MOVF   2F,W
0C5A:  MOVWF  3E
0C5B:  MOVLP  00
0C5C:  MOVLB  00
0C5D:  CALL   78B
0C5E:  MOVLP  08
....................     } 
0C5F:  MOVLB  02
0C60:  INCF   2E,F
0C61:  GOTO   442
....................     PROMPT_FLAG=1; 
0C62:  MOVLB  01
0C63:  BSF    61.4
0C64:  MOVLB  02
....................   } 
....................   if(cor>0) { 
0C65:  MOVF   2C,F
0C66:  BTFSC  03.2
0C67:  GOTO   4A7
....................     COR_s[cor-1]='1'; 
0C68:  MOVLW  01
0C69:  SUBWF  2C,W
0C6A:  ADDLW  B2
0C6B:  MOVWF  04
0C6C:  MOVLW  20
0C6D:  MOVWF  05
0C6E:  BTFSC  03.0
0C6F:  INCF   05,F
0C70:  MOVLW  31
0C71:  MOVWF  00
....................     sprintf(LCD_str,"COR:%s PTT:%s",COR_s,PTT_s); 
0C72:  MOVLW  20
0C73:  MOVLB  01
0C74:  MOVWF  63
0C75:  MOVLW  76
0C76:  MOVWF  62
0C77:  MOVLW  04
0C78:  MOVLB  03
0C79:  MOVWF  11
0C7A:  MOVLW  04
0C7B:  MOVWF  12
0C7C:  BCF    03.0
0C7D:  MOVLW  04
0C7E:  MOVLB  02
0C7F:  MOVWF  48
0C80:  MOVLB  00
0C81:  CALL   124
0C82:  MOVLW  20
0C83:  MOVWF  05
0C84:  MOVLW  B2
0C85:  MOVWF  04
0C86:  CALL   177
0C87:  MOVLW  07
0C88:  MOVLB  03
0C89:  MOVWF  11
0C8A:  MOVLW  04
0C8B:  MOVWF  12
0C8C:  BCF    03.0
0C8D:  MOVLW  05
0C8E:  MOVLB  02
0C8F:  MOVWF  48
0C90:  MOVLB  00
0C91:  CALL   124
0C92:  MOVLW  20
0C93:  MOVWF  05
0C94:  MOVLW  B7
0C95:  MOVWF  04
0C96:  CALL   177
....................     lcd_send(1,LCD_str); // COR/PTT on line 1 
0C97:  MOVLW  01
0C98:  MOVLB  02
0C99:  MOVWF  48
0C9A:  MOVLW  20
0C9B:  MOVWF  4A
0C9C:  MOVLW  76
0C9D:  MOVWF  49
0C9E:  MOVLB  00
0C9F:  CALL   18C
....................     delay_ms(50); 
0CA0:  MOVLW  32
0CA1:  MOVLB  02
0CA2:  MOVWF  48
0CA3:  MOVLB  00
0CA4:  CALL   000
....................     pot_values_to_lcd(); 
0CA5:  CALL   270
0CA6:  MOVLB  02
....................   } 
.................... }// }}} 
0CA7:  MOVLB  00
0CA8:  RETURN
.................... int ValidKey(int index) { // {{{ 
....................   int strobe; 
....................   if(index>=0 && (index <= DTMF_ARRAY_SIZE)) { 
*
1E10:  MOVF   66,W
1E11:  SUBLW  0A
1E12:  BTFSS  03.0
1E13:  GOTO   62E
....................     if(DTMF_ARRAY[index].Strobe && (DTMF_ARRAY[index].Key != dp)) { 
1E14:  MOVLW  64
1E15:  ADDWF  66,W
1E16:  MOVWF  04
1E17:  MOVLW  20
1E18:  MOVWF  05
1E19:  BTFSC  03.0
1E1A:  INCF   05,F
1E1B:  BTFSS  00.4
1E1C:  GOTO   62C
1E1D:  MOVLW  64
1E1E:  ADDWF  66,W
1E1F:  MOVWF  04
1E20:  MOVLW  20
1E21:  MOVWF  05
1E22:  BTFSC  03.0
1E23:  INCF   05,F
1E24:  MOVF   00,W
1E25:  ANDLW  0F
1E26:  SUBLW  0C
1E27:  BTFSC  03.2
1E28:  GOTO   62C
....................       strobe=1; 
1E29:  MOVLW  01
1E2A:  MOVWF  67
....................      } else { 
1E2B:  GOTO   62D
....................       strobe = 0; 
1E2C:  CLRF   67
....................     }  
....................   } else { 
1E2D:  GOTO   62F
....................     strobe=0; 
1E2E:  CLRF   67
....................   } 
....................   return(strobe); 
1E2F:  MOVF   67,W
1E30:  MOVWF  78
.................... } // }}} 
.................... int ValidKeyRange(unsigned int a,unsigned int b) { // {{{ 
....................   int key; 
....................   int x; 
....................   int1 valid; 
....................  
....................   if(b>=a && (a < DTMF_ARRAY_SIZE)) { 
*
1D8F:  MOVLB  01
1D90:  MOVF   66,W
1D91:  SUBWF  67,W
1D92:  BTFSS  03.0
1D93:  GOTO   5B9
1D94:  MOVF   66,W
1D95:  SUBLW  09
1D96:  BTFSS  03.0
1D97:  GOTO   5B9
....................     valid=1; 
1D98:  BSF    6A.0
....................     for(x=a;x<=b;x++) { 
1D99:  MOVF   66,W
1D9A:  MOVWF  69
1D9B:  MOVF   69,W
1D9C:  SUBWF  67,W
1D9D:  BTFSS  03.0
1D9E:  GOTO   5B8
....................       key=(int)DTMF_ARRAY[x].Key; 
1D9F:  MOVLW  64
1DA0:  ADDWF  69,W
1DA1:  MOVWF  04
1DA2:  MOVLW  20
1DA3:  MOVWF  05
1DA4:  BTFSC  03.0
1DA5:  INCF   05,F
1DA6:  MOVF   00,W
1DA7:  ANDLW  0F
1DA8:  MOVWF  68
....................       if(! DTMF_ARRAY[x].Strobe ) { 
1DA9:  MOVLW  64
1DAA:  ADDWF  69,W
1DAB:  MOVWF  04
1DAC:  MOVLW  20
1DAD:  MOVWF  05
1DAE:  BTFSC  03.0
1DAF:  INCF   05,F
1DB0:  BTFSS  00.4
....................         valid=0; 
1DB1:  BCF    6A.0
....................       } 
....................      if(key==dp) { 
1DB2:  MOVF   68,W
1DB3:  SUBLW  0C
1DB4:  BTFSC  03.2
....................         valid=0; 
1DB5:  BCF    6A.0
....................       } 
....................     } 
1DB6:  INCF   69,F
1DB7:  GOTO   59B
....................   } else { 
1DB8:  GOTO   5BA
....................     valid=0; 
1DB9:  BCF    6A.0
....................   } 
....................   return(valid); 
1DBA:  MOVLW  00
1DBB:  BTFSC  6A.0
1DBC:  MOVLW  01
1DBD:  MOVWF  78
.................... } // }}} 
1DBE:  MOVLB  00
1DBF:  RETURN
.................... void process_dtmf(void) { // {{{ 
....................   unsigned site_id; 
....................   unsigned digit; 
....................   // Structure: 
....................   // [SID1][SID0][CMD1][CMD0][ARG1][ARG0][Valx][Valy][Valz] 
....................   //   0     1     2     3     4     5     6     7     8 
....................   // Commands: 
....................   // 01 : Link commands 
....................   // 02 : Set register value 
....................   // 03 : get register value 
....................   // 04 : Save settings to EEPROM 
....................   // 05 : Restore settings from EEPROM 
....................   // 06 : Increment Current Pot 
....................   // 07 : Decrement Current Pot 
....................   // 08 : Status 
....................   // 09 : AdminSettings  
....................   //    :    Args : 0 - Normal mode 
....................   //    :           1 - Enter Admin mode 
....................   //    :           2 - Reboot 
....................   // 10 : -- UNUSED -- 
....................   // 11 : Morse send 
....................   // 12 : Send to I2C 
....................   //  
....................   // Ex: (# = 12) 
....................   // Enter Admin mode       : 52 09 01 # 
....................   // Reboot                 : 52 09 02 # 
....................   // Send Morse ID          : 52 09 03 # 
....................   // Set XO3(22) to 0       : 52 02 22 0 # 
....................   // Set XO3(22) to 1       : 52 02 22 1 # 
....................   // Change to pot 4        : 52 02 55 3 # 
....................   // Increment POT 01 by 3  : 52 06 01 3 # 
....................   // Decrement POT 03 by 4  : 52 07 03 4 # 
....................   // -- User Functions -- 
....................   // Disable AuxOut0        : 51 02 21 0 #  
....................   // Disable AuxOut0 (!Arg) : 51 02 21 #  
....................   // Enable  AuxOut1        : 51 02 22 1 # 
....................   command=0; 
1DC0:  CLRF   70
....................   value=0; 
1DC1:  CLRF   7E
....................   if ( ValidKeyRange(0,3)) { 
1DC2:  MOVLB  01
1DC3:  CLRF   66
1DC4:  MOVLW  03
1DC5:  MOVWF  67
1DC6:  MOVLB  00
1DC7:  CALL   58F
1DC8:  MOVF   78,F
1DC9:  BTFSC  03.2
1DCA:  GOTO   674
....................     site_id = DTMF_ARRAY[0].Key *10 + DTMF_ARRAY[1].Key; 
1DCB:  MOVLB  01
1DCC:  MOVF   34,W
1DCD:  ANDLW  0F
1DCE:  MOVWF  67
1DCF:  MOVLB  02
1DD0:  MOVWF  41
1DD1:  MOVLW  0A
1DD2:  MOVWF  42
1DD3:  MOVLP  08
1DD4:  MOVLB  00
1DD5:  CALL   662
1DD6:  MOVLP  18
1DD7:  MOVF   78,W
1DD8:  MOVLB  01
1DD9:  MOVWF  66
1DDA:  MOVF   35,W
1DDB:  ANDLW  0F
1DDC:  ADDWF  66,W
1DDD:  MOVWF  64
....................     command = DTMF_ARRAY[2].Key * 10 + DTMF_ARRAY[3].Key; 
1DDE:  MOVF   36,W
1DDF:  ANDLW  0F
1DE0:  MOVWF  67
1DE1:  MOVLB  02
1DE2:  MOVWF  41
1DE3:  MOVLW  0A
1DE4:  MOVWF  42
1DE5:  MOVLP  08
1DE6:  MOVLB  00
1DE7:  CALL   662
1DE8:  MOVLP  18
1DE9:  MOVF   78,W
1DEA:  MOVLB  01
1DEB:  MOVWF  66
1DEC:  MOVF   37,W
1DED:  ANDLW  0F
1DEE:  ADDWF  66,W
1DEF:  MOVWF  70
....................     if ( ValidKeyRange(4,5) ) { 
1DF0:  MOVLW  04
1DF1:  MOVWF  66
1DF2:  MOVLW  05
1DF3:  MOVWF  67
1DF4:  MOVLB  00
1DF5:  CALL   58F
1DF6:  MOVF   78,F
1DF7:  BTFSC  03.2
1DF8:  GOTO   64F
....................       // Admin mode {{{ 
....................       argument = DTMF_ARRAY[4].Key * 10 + DTMF_ARRAY[5].Key; 
1DF9:  MOVLB  01
1DFA:  MOVF   38,W
1DFB:  ANDLW  0F
1DFC:  MOVWF  67
1DFD:  MOVLB  02
1DFE:  MOVWF  41
1DFF:  MOVLW  0A
1E00:  MOVWF  42
1E01:  MOVLP  08
1E02:  MOVLB  00
1E03:  CALL   662
1E04:  MOVLP  18
1E05:  MOVF   78,W
1E06:  MOVLB  01
1E07:  MOVWF  66
1E08:  MOVF   39,W
1E09:  ANDLW  0F
1E0A:  ADDWF  66,W
1E0B:  MOVWF  7D
....................       digit=6; 
1E0C:  MOVLW  06
1E0D:  MOVWF  65
....................       while(ValidKey(digit)) { 
1E0E:  MOVF   65,W
1E0F:  MOVWF  66
*
1E31:  MOVF   78,F
1E32:  BTFSC  03.2
1E33:  GOTO   64D
....................        value = value * 10 + DTMF_ARRAY[digit].Key; 
1E34:  MOVF   7E,W
1E35:  MOVLB  02
1E36:  MOVWF  41
1E37:  MOVLW  0A
1E38:  MOVWF  42
1E39:  MOVLP  08
1E3A:  MOVLB  00
1E3B:  CALL   662
1E3C:  MOVLP  18
1E3D:  MOVF   78,W
1E3E:  MOVLB  01
1E3F:  MOVWF  66
1E40:  MOVLW  64
1E41:  ADDWF  65,W
1E42:  MOVWF  04
1E43:  MOVLW  20
1E44:  MOVWF  05
1E45:  BTFSC  03.0
1E46:  INCF   05,F
1E47:  MOVF   00,W
1E48:  ANDLW  0F
1E49:  ADDWF  66,W
1E4A:  MOVWF  7E
....................        digit++; 
1E4B:  INCF   65,F
....................       } 
1E4C:  GOTO   60E
....................       // Admin mode }}} 
....................     } else { 
1E4D:  GOTO   661
1E4E:  MOVLB  00
....................       // User function {{{ 
....................       // Only 4 digits were entered.  
....................       // Use 'command' value as user function. 
....................       switch(command) { 
1E4F:  MOVF   70,W
1E50:  XORLW  0A
1E51:  BTFSC  03.2
1E52:  GOTO   657
1E53:  XORLW  01
1E54:  BTFSC  03.2
1E55:  GOTO   65B
1E56:  GOTO   65E
....................         // Commands 10 (disable link) and 11 (enable link) 
....................         case(10): 
....................           argument = 0; 
1E57:  CLRF   7D
....................           value = 0x0E; 
1E58:  MOVLW  0E
1E59:  MOVWF  7E
....................   	      break; 
1E5A:  GOTO   65E
....................         case(11): 
....................           argument = 0; 
1E5B:  CLRF   7D
....................           value = 0x0F; 
1E5C:  MOVLW  0F
1E5D:  MOVWF  7E
....................    		    break; 
....................       } 
....................       // Override command 
....................       command=SET_REG; 
1E5E:  MOVLW  02
1E5F:  MOVWF  70
1E60:  MOVLB  01
....................       // User function }}} 
....................     } 
....................     // Commands that don't need arguments but need a value: 
....................     switch(command) { 
1E61:  MOVF   70,W
1E62:  XORLW  04
1E63:  MOVLB  00
1E64:  BTFSC  03.2
1E65:  GOTO   669
1E66:  XORLW  01
1E67:  BTFSS  03.2
1E68:  GOTO   66B
....................       case(SAVE_SETTINGS): 
....................       case(RESTORE_SETTINGS):  
....................         value = argument; 
1E69:  MOVF   7D,W
1E6A:  MOVWF  7E
....................         break; 
....................     } 
....................     if ( site_id == SiteID ) { 
1E6B:  MOVF   63,W
1E6C:  MOVLB  01
1E6D:  SUBWF  64,W
1E6E:  BTFSS  03.2
1E6F:  GOTO   675
....................       execute_command(); 
1E70:  MOVLP  10
1E71:  MOVLB  00
1E72:  CALL   042
1E73:  MOVLP  18
1E74:  MOVLB  01
....................     } 
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer {{{ 
....................   // 'b' --> Next pot (DTMF 14) 
....................   // 'c' --> pot down (DTMF 15) 
....................   // 'd' --> pot up   (DTMF 13) 
....................   command=DTMF_ARRAY[0].Key; 
1E75:  MOVF   34,W
1E76:  ANDLW  0F
1E77:  MOVWF  70
....................   if ( AdminMode && ValidKeyRange(0,0) ) { 
1E78:  BTFSS  61.5
1E79:  GOTO   6AA
1E7A:  CLRF   66
1E7B:  CLRF   67
1E7C:  MOVLB  00
1E7D:  CALL   58F
1E7E:  MOVF   78,F
1E7F:  BTFSS  03.2
1E80:  GOTO   683
1E81:  MOVLB  01
1E82:  GOTO   6AA
....................     restart_wdt(); 
1E83:  CLRWDT
....................     switch(command) { 
1E84:  MOVF   70,W
1E85:  XORLW  0E
1E86:  BTFSC  03.2
1E87:  GOTO   68F
1E88:  XORLW  01
1E89:  BTFSC  03.2
1E8A:  GOTO   697
1E8B:  XORLW  05
1E8C:  BTFSC  03.2
1E8D:  GOTO   69F
1E8E:  GOTO   6A6
....................       case(db): // d 14 d 12 
....................         CurrentTrimPot=(CurrentTrimPot+1)&0x03; 
1E8F:  MOVLW  01
1E90:  ADDWF  76,W
1E91:  ANDLW  03
1E92:  MOVWF  76
....................         pot_values_to_lcd(); 
1E93:  MOVLP  08
1E94:  CALL   270
1E95:  MOVLP  18
....................         break; 
1E96:  GOTO   6A6
....................       case(dc): // d 15 d 12  
....................         increment(-1); 
1E97:  MOVLW  FF
1E98:  MOVLB  02
1E99:  MOVWF  2D
1E9A:  MOVLP  08
1E9B:  MOVLB  00
1E9C:  CALL   739
1E9D:  MOVLP  18
....................         break; 
1E9E:  GOTO   6A6
....................       case(d0): // d 10 d 12 
....................         // DTMF (D) is mapped to value 10 (d0) 
....................         increment(1); 
1E9F:  MOVLW  01
1EA0:  MOVLB  02
1EA1:  MOVWF  2D
1EA2:  MOVLP  08
1EA3:  MOVLB  00
1EA4:  CALL   739
1EA5:  MOVLP  18
....................         break; 
....................     } 
....................     in_admin_mode(); 
1EA6:  MOVLP  08
1EA7:  CALL   72A
1EA8:  MOVLP  18
1EA9:  MOVLB  01
....................   } 
....................   // Allow 'b', 'c' and 'd' to turn 'down' and 'up' potentiometer }}} 
....................   CLEAR_DTMF_FLAG=1; 
1EAA:  BSF    61.3
.................... } // }}} 
1EAB:  MOVLP  18
1EAC:  MOVLB  00
1EAD:  GOTO   718 (RETURN)
.................... void process_cor (void) { // {{{ 
....................   int cor_mask; 
....................   int rx_priority; 
....................   int cor_in; 
....................   int do_update_ptt; 
....................   int cor_index; 
....................   int x; 
....................  
....................   cor_mask=1; 
*
15C3:  MOVLW  01
15C4:  MOVLB  01
15C5:  MOVWF  64
....................   do_update_ptt=0; 
15C6:  CLRF   67
....................   // Allow emulated COR[4] for DTMF control (No audio feed-thru) 
....................   cor_in = COR_IN ; 
15C7:  MOVLB  00
15C8:  MOVF   5F,W
15C9:  MOVLB  01
15CA:  MOVWF  66
....................   // Different COR was waiting for the active one to fall. 
....................   if ( CurrentCorPriority && !(cor_in & CurrentCorMask) ) { 
15CB:  MOVF   71,F
15CC:  BTFSC  03.2
15CD:  GOTO   5E7
15CE:  MOVF   66,W
15CF:  MOVLB  00
15D0:  ANDWF  6E,W
15D1:  BTFSC  03.2
15D2:  GOTO   5D5
15D3:  MOVLB  01
15D4:  GOTO   5E7
....................     CurrentCorPriority=0; 
15D5:  CLRF   71
....................     CurrentCorMask=0; 
15D6:  CLRF   6E
....................     do_update_ptt=1; 
15D7:  MOVLW  01
15D8:  MOVLB  01
15D9:  MOVWF  67
....................     if ( (cor_in & Enable & Enable_Mask) == 0x00) { 
15DA:  MOVF   66,W
15DB:  MOVLB  00
15DC:  ANDWF  60,W
15DD:  ANDWF  61,W
15DE:  BTFSS  03.2
15DF:  GOTO   5E6
....................       COR_DROP_FLAG=1; 
15E0:  BSF    74.5
....................       if ( Tail ) { 
15E1:  MOVF   65,F
15E2:  BTFSC  03.2
15E3:  GOTO   5E6
....................         // Tail register has priority over any aux input char 
....................         TailChar=Tail; 
15E4:  MOVF   65,W
15E5:  MOVWF  6C
15E6:  MOVLB  01
....................       } 
....................     } 
....................   } 
....................   cor_index=0; 
15E7:  CLRF   68
....................   for(x=0;x<4;x++) { 
15E8:  CLRF   69
15E9:  MOVF   69,W
15EA:  SUBLW  03
15EB:  BTFSS  03.0
15EC:  GOTO   630
....................     if ( cor_in & cor_mask & (~TOT_FLAG_Mask) ) { 
15ED:  MOVF   66,W
15EE:  ANDWF  64,W
15EF:  MOVWF  6A
15F0:  MOVLB  00
15F1:  MOVF   67,W
15F2:  XORLW  FF
15F3:  MOVLB  01
15F4:  ANDWF  6A,W
15F5:  BTFSC  03.2
15F6:  GOTO   62C
....................       if ( (Enable & Enable_Mask) & cor_mask ) { 
15F7:  MOVLB  00
15F8:  MOVF   60,W
15F9:  ANDWF  61,W
15FA:  MOVLB  01
15FB:  ANDWF  64,W
15FC:  BTFSC  03.2
15FD:  GOTO   608
....................         rx_priority=RXPriority[x]; 
15FE:  MOVLW  25
15FF:  ADDWF  69,W
1600:  MOVWF  04
1601:  MOVLW  20
1602:  MOVWF  05
1603:  BTFSC  03.0
1604:  INCF   05,F
1605:  MOVF   00,W
1606:  MOVWF  65
....................       } else { 
1607:  GOTO   60A
....................         // Radio is not enabled. Only listen for DTMF (if no other radio is enabled). 
....................         rx_priority = 1; // Least priority while still active. 
1608:  MOVLW  01
1609:  MOVWF  65
....................       } 
....................       // New COR is being captured. 
....................       // Initialize TOT timer 
....................       if ( rx_priority > CurrentCorPriority ) { 
160A:  MOVF   65,W
160B:  SUBWF  71,W
160C:  BTFSC  03.0
160D:  GOTO   62C
....................         if ( ! CurrentCorPriority ) { 
160E:  MOVF   71,F
160F:  BTFSS  03.2
1610:  GOTO   613
....................           CurrentCorPriority = rx_priority; 
1611:  MOVF   65,W
1612:  MOVWF  71
....................         } 
....................         cor_index=x+1; 
1613:  MOVLW  01
1614:  ADDWF  69,W
1615:  MOVWF  68
....................         do_update_ptt=1; 
1616:  MOVLW  01
1617:  MOVWF  67
....................         TOT_SecondCounter= 60 * TOT_Min; 
1618:  MOVLW  3C
1619:  MOVLB  02
161A:  MOVWF  41
161B:  MOVLB  00
161C:  MOVF   66,W
161D:  MOVLB  02
161E:  MOVWF  42
161F:  MOVLP  08
1620:  MOVLB  00
1621:  CALL   662
1622:  MOVLP  10
1623:  MOVLB  01
1624:  CLRF   60
1625:  MOVF   78,W
1626:  MOVWF  5F
.................... 	TOT_FLAG_Mask=0; 
1627:  MOVLB  00
1628:  CLRF   67
....................         // COR_IN_EFFECTIVE points to the one that is selected 
....................         COR_IN_EFFECTIVE=cor_mask; 
1629:  MOVLB  01
162A:  MOVF   64,W
162B:  MOVWF  72
....................       } 
....................     } 
....................     cor_mask = cor_mask << 1; 
162C:  BCF    03.0
162D:  RLF    64,F
....................   } 
162E:  INCF   69,F
162F:  GOTO   5E9
....................   if ( do_update_ptt ) { 
1630:  MOVF   67,F
1631:  BTFSC  03.2
1632:  GOTO   63C
....................     update_ptt(cor_index); 
1633:  MOVF   68,W
1634:  MOVLB  02
1635:  MOVWF  2C
1636:  MOVLP  08
1637:  MOVLB  00
1638:  CALL   360
1639:  MOVLP  10
....................     PROMPT_FLAG=1; 
163A:  MOVLB  01
163B:  BSF    61.4
....................   } 
....................   // Clear the DTMF array when all CORs fall 
....................   if ( !cor_in ) { 
163C:  MOVF   66,F
163D:  BTFSS  03.2
163E:  GOTO   644
....................     // --> Don't clear the DTMF if the Aux Input is emulating a COR 
....................     CLEAR_DTMF_FLAG=1; 
163F:  BSF    61.3
....................     COR_IN_EFFECTIVE=0; 
1640:  CLRF   72
....................     TOT_FLAG_Mask=0; 
1641:  MOVLB  00
1642:  CLRF   67
1643:  MOVLB  01
....................   } 
....................   // Refresh Link Time-out timer when COR is received. 
....................   // Any COR value refreshes the link TOT timer. 
....................   if ( Link_TOT != 0 && (cor_in)!=0 ) { 
1644:  MOVLB  00
1645:  MOVF   68,F
1646:  BTFSC  03.2
1647:  GOTO   651
1648:  MOVLB  01
1649:  MOVF   66,F
164A:  BTFSS  03.2
164B:  GOTO   64E
164C:  MOVLB  00
164D:  GOTO   651
....................     LinkDurationTimer = Link_TOT; 
164E:  MOVLB  00
164F:  MOVF   68,W
1650:  MOVWF  69
....................   } 
.................... } // }}} 
1651:  MOVLP  18
1652:  GOTO   6FA (RETURN)
.................... void clear_dtmf_array(void) { // {{{ 
....................   int x; 
....................  
....................   for(x=0;x<sizeof(DTMF_ARRAY);x++) { 
*
17DF:  MOVLB  01
17E0:  CLRF   64
17E1:  MOVF   64,W
17E2:  SUBLW  09
17E3:  BTFSS  03.0
17E4:  GOTO   7EF
....................     DTMF_ARRAY[x]=(sDTMF)0; 
17E5:  MOVLW  64
17E6:  ADDWF  64,W
17E7:  MOVWF  04
17E8:  MOVLW  20
17E9:  MOVWF  05
17EA:  BTFSC  03.0
17EB:  INCF   05,F
17EC:  CLRF   00
....................   } 
17ED:  INCF   64,F
17EE:  GOTO   7E1
....................   DTMF_ptr=&DTMF_ARRAY[0]; 
17EF:  MOVLW  20
17F0:  MOVWF  3F
17F1:  MOVLW  64
17F2:  MOVWF  3E
.................... } // }}} 
17F3:  MOVLP  18
17F4:  MOVLB  00
17F5:  GOTO   720 (RETURN)
.................... void header (void) { // {{{ 
.................... } // }}} 
*
0003:  RETURN
.................... void status (void) { // {{{ 
....................   unsigned long x; 
....................   char y; 
....................   rom char * cPtr; 
....................   unsigned int * regPtr; 
....................   int dtmf_in; 
....................   char aux_in; 
....................   char rname[REG_NAME_SIZE]; 
....................   clearscr(); 
....................   header(); 
*
12A7:  MOVLP  00
12A8:  CALL   003
12A9:  MOVLP  10
....................   dtmf_in=dtmf_read(CONTROL_REG); 
12AA:  MOVLW  01
12AB:  MOVLB  02
12AC:  MOVWF  39
12AD:  MOVLP  00
12AE:  MOVLB  00
12AF:  CALL   69A
12B0:  MOVLP  10
12B1:  MOVF   78,W
12B2:  MOVLB  02
12B3:  MOVWF  31
....................   aux_in = 0; 
12B4:  CLRF   32
....................   for(x=0;x<RegMapNum;x++) { 
12B5:  CLRF   2B
12B6:  CLRF   2A
12B7:  MOVF   2B,F
12B8:  BTFSS  03.2
12B9:  GOTO   3BE
12BA:  MOVF   2A,W
12BB:  SUBLW  38
12BC:  BTFSS  03.0
12BD:  GOTO   3BE
.................... // Bug when X = 0x2B (6). cPtr wraps back to 0x017C!!! 
.................... // reg_name = 0x017A. 
.................... // cPtr is assigned to 0x017C 
....................     cPtr = &reg_name + (x*REG_NAME_SIZE); 
12BE:  MOVLW  01
12BF:  MOVWF  7A
12C0:  MOVLW  8F
12C1:  MOVWF  39
12C2:  MOVF   7A,W
12C3:  MOVWF  3A
12C4:  MOVF   2B,W
12C5:  MOVWF  3C
12C6:  MOVF   2A,W
12C7:  MOVWF  3B
12C8:  CLRF   3E
12C9:  MOVLW  06
12CA:  MOVWF  3D
12CB:  MOVLP  08
12CC:  MOVLB  00
12CD:  CALL   6EA
12CE:  MOVLP  10
12CF:  MOVF   78,W
12D0:  MOVLB  02
12D1:  ADDWF  39,W
12D2:  MOVWF  2D
12D3:  MOVF   79,W
12D4:  ADDWFC 3A,W
12D5:  MOVWF  2E
....................     romstrcpy(rname,cPtr); 
12D6:  MOVLW  20
12D7:  MOVWF  3A
12D8:  MOVLW  B3
12D9:  MOVWF  39
12DA:  MOVF   2E,W
12DB:  MOVWF  3C
12DC:  MOVF   2D,W
12DD:  MOVWF  3B
12DE:  MOVLP  08
12DF:  MOVLB  00
12E0:  CALL   701
12E1:  MOVLP  10
....................   regPtr=RegMap[x].reg_ptr; 
12E2:  MOVLB  02
12E3:  RLF    2A,W
12E4:  MOVWF  39
12E5:  RLF    2B,W
12E6:  MOVWF  3A
12E7:  RLF    39,F
12E8:  RLF    3A,F
12E9:  MOVLW  FC
12EA:  ANDWF  39,F
12EB:  MOVF   3A,W
12EC:  MOVWF  7A
12ED:  MOVF   39,W
12EE:  MOVWF  3B
12EF:  INCF   39,W
12F0:  MOVLP  00
12F1:  MOVLB  00
12F2:  CALL   043
12F3:  MOVLP  10
12F4:  MOVWF  7A
12F5:  MOVLB  02
12F6:  MOVF   3B,W
12F7:  MOVLP  00
12F8:  MOVLB  00
12F9:  CALL   043
12FA:  MOVLP  10
12FB:  MOVLB  02
12FC:  MOVWF  2F
12FD:  MOVF   7A,W
12FE:  MOVWF  30
....................     printf("[%02Lu] %s %u\t",x,rname,*regPtr); 
12FF:  MOVF   30,W
1300:  MOVWF  7A
1301:  MOVF   2F,W
1302:  MOVWF  04
1303:  MOVF   7A,W
1304:  MOVWF  05
1305:  MOVF   00,W
1306:  MOVWF  39
1307:  MOVLW  5B
1308:  CLRWDT
1309:  MOVLB  00
130A:  BTFSC  11.4
130B:  GOTO   30E
130C:  MOVLB  02
130D:  GOTO   308
130E:  MOVLB  03
130F:  MOVWF  1A
1310:  MOVLW  0B
1311:  MOVWF  04
1312:  MOVLB  02
1313:  MOVF   2B,W
1314:  MOVWF  3B
1315:  MOVF   2A,W
1316:  MOVWF  3A
*
1374:  MOVLW  5D
1375:  CLRWDT
1376:  MOVLB  00
1377:  BTFSC  11.4
1378:  GOTO   37B
1379:  MOVLB  02
137A:  GOTO   375
137B:  MOVLB  03
137C:  MOVWF  1A
137D:  MOVLW  20
137E:  CLRWDT
137F:  MOVLB  00
1380:  BTFSC  11.4
1381:  GOTO   384
1382:  MOVLB  03
1383:  GOTO   37E
1384:  MOVLB  03
1385:  MOVWF  1A
1386:  MOVLW  20
1387:  MOVWF  05
1388:  MOVLW  B3
1389:  MOVWF  04
138A:  MOVLP  08
138B:  MOVLB  00
138C:  CALL   256
138D:  MOVLP  10
138E:  MOVLW  20
138F:  CLRWDT
1390:  BTFSS  11.4
1391:  GOTO   38F
1392:  MOVLB  03
1393:  MOVWF  1A
1394:  MOVLB  02
1395:  MOVF   39,W
1396:  MOVWF  4E
1397:  MOVLW  1B
1398:  MOVWF  4F
1399:  MOVLP  00
139A:  MOVLB  00
139B:  CALL   73C
139C:  MOVLP  10
139D:  MOVLW  09
139E:  CLRWDT
139F:  BTFSS  11.4
13A0:  GOTO   39E
13A1:  MOVLB  03
13A2:  MOVWF  1A
....................     if ( x %4 == 3 ) { 
13A3:  MOVLB  02
13A4:  MOVF   2A,W
13A5:  ANDLW  03
13A6:  MOVWF  39
13A7:  CLRF   3A
13A8:  MOVF   39,W
13A9:  SUBLW  03
13AA:  BTFSS  03.2
13AB:  GOTO   3B9
13AC:  MOVF   3A,F
13AD:  BTFSS  03.2
13AE:  GOTO   3B9
....................       putc('\n'); 
13AF:  MOVLW  0A
13B0:  MOVLP  00
13B1:  MOVLB  00
13B2:  CALL   2E4
13B3:  MOVLP  10
....................       putc('\r'); 
13B4:  MOVLW  0D
13B5:  MOVLP  00
13B6:  CALL   2E4
13B7:  MOVLP  10
13B8:  MOVLB  02
....................     } 
....................     restart_wdt(); 
13B9:  CLRWDT
....................   } 
13BA:  INCF   2A,F
13BB:  BTFSC  03.2
13BC:  INCF   2B,F
13BD:  GOTO   2B7
....................   for(y=0;y<3;y++) { 
13BE:  CLRF   2C
13BF:  MOVF   2C,W
13C0:  SUBLW  02
13C1:  BTFSS  03.0
13C2:  GOTO   3D9
....................     if(AuxInSW[y]==1) { 
13C3:  MOVLW  1F
13C4:  ADDWF  2C,W
13C5:  MOVWF  04
13C6:  MOVLW  20
13C7:  MOVWF  05
13C8:  BTFSC  03.0
13C9:  INCF   05,F
13CA:  DECFSZ 00,W
13CB:  GOTO   3D7
....................       aux_in += (1<<y); 
13CC:  MOVLW  01
13CD:  MOVWF  77
13CE:  MOVF   2C,W
13CF:  MOVWF  78
13D0:  BTFSC  03.2
13D1:  GOTO   3D5
13D2:  LSLF   77,F
13D3:  DECFSZ 78,F
13D4:  GOTO   3D2
13D5:  MOVF   77,W
13D6:  ADDWF  32,F
....................     } 
....................   } 
13D7:  INCF   2C,F
13D8:  GOTO   3BF
....................   printf("\n\n\rCOR:%u (Emul:%u); AuxIn:%u TOT:%u",COR_IN,COR_EMUL,aux_in,TOT_FLAG_Mask); 
13D9:  MOVLW  0B
13DA:  MOVLB  03
13DB:  MOVWF  11
13DC:  MOVLW  04
13DD:  MOVWF  12
13DE:  BCF    03.0
13DF:  MOVLW  07
13E0:  MOVLB  02
13E1:  MOVWF  4E
13E2:  MOVLP  00
13E3:  MOVLB  00
13E4:  CALL   6C8
13E5:  MOVLP  10
13E6:  MOVF   5F,W
13E7:  MOVLB  02
13E8:  MOVWF  4E
13E9:  MOVLW  1B
13EA:  MOVWF  4F
13EB:  MOVLP  00
13EC:  MOVLB  00
13ED:  CALL   73C
13EE:  MOVLP  10
13EF:  MOVLW  0F
13F0:  MOVLB  03
13F1:  MOVWF  11
13F2:  MOVLW  04
13F3:  MOVWF  12
13F4:  BSF    03.0
13F5:  MOVLW  07
13F6:  MOVLB  02
13F7:  MOVWF  4E
13F8:  MOVLP  00
13F9:  MOVLB  00
13FA:  CALL   6C8
13FB:  MOVLP  10
13FC:  MOVF   6A,W
13FD:  MOVLB  02
13FE:  MOVWF  4E
13FF:  MOVLW  1B
1400:  MOVWF  4F
1401:  MOVLP  00
1402:  MOVLB  00
1403:  CALL   73C
1404:  MOVLP  10
1405:  MOVLW  14
1406:  MOVLB  03
1407:  MOVWF  11
1408:  MOVLW  04
1409:  MOVWF  12
140A:  BCF    03.0
140B:  MOVLW  09
140C:  MOVLB  02
140D:  MOVWF  4E
140E:  MOVLP  00
140F:  MOVLB  00
1410:  CALL   6C8
1411:  MOVLP  10
1412:  MOVLB  02
1413:  MOVF   32,W
1414:  MOVWF  4E
1415:  MOVLW  1B
1416:  MOVWF  4F
1417:  MOVLP  00
1418:  MOVLB  00
1419:  CALL   73C
141A:  MOVLP  10
141B:  MOVLW  19
141C:  MOVLB  03
141D:  MOVWF  11
141E:  MOVLW  04
141F:  MOVWF  12
1420:  BSF    03.0
1421:  MOVLW  05
1422:  MOVLB  02
1423:  MOVWF  4E
1424:  MOVLP  00
1425:  MOVLB  00
1426:  CALL   6C8
1427:  MOVLP  10
1428:  MOVF   67,W
1429:  MOVLB  02
142A:  MOVWF  4E
142B:  MOVLW  1B
142C:  MOVWF  4F
142D:  MOVLP  00
142E:  MOVLB  00
142F:  CALL   73C
1430:  MOVLP  10
....................   printf("\n\rDTMF Status : %u\n\r",dtmf_in); 
1431:  MOVLW  1E
1432:  MOVLB  03
1433:  MOVWF  11
1434:  MOVLW  04
1435:  MOVWF  12
1436:  BCF    03.0
1437:  MOVLW  10
1438:  MOVLB  02
1439:  MOVWF  4E
143A:  MOVLP  00
143B:  MOVLB  00
143C:  CALL   6C8
143D:  MOVLP  10
143E:  MOVLB  02
143F:  MOVF   31,W
1440:  MOVWF  4E
1441:  MOVLW  1B
1442:  MOVWF  4F
1443:  MOVLP  00
1444:  MOVLB  00
1445:  CALL   73C
1446:  MOVLP  10
1447:  MOVLW  0A
1448:  CLRWDT
1449:  BTFSS  11.4
144A:  GOTO   448
144B:  MOVLB  03
144C:  MOVWF  1A
144D:  MOVLW  0D
144E:  CLRWDT
144F:  MOVLB  00
1450:  BTFSC  11.4
1451:  GOTO   454
1452:  MOVLB  03
1453:  GOTO   44E
1454:  MOVLB  03
1455:  MOVWF  1A
....................   pot_values_to_lcd(); 
1456:  MOVLP  08
1457:  MOVLB  00
1458:  CALL   270
1459:  MOVLP  10
....................   PROMPT_FLAG=1; 
145A:  MOVLB  01
145B:  BSF    61.4
.................... } // }}} 
.................... void pot_values_to_lcd (void) { // {{{ 
....................   char x; 
....................   int8 pot_val; 
....................   int1 ack,ack_in; 
....................   unsigned c[4]={' ',' ',' ',' '}; 
*
0A70:  MOVLW  20
0A71:  MOVLB  02
0A72:  MOVWF  40
0A73:  MOVWF  41
0A74:  MOVWF  42
0A75:  MOVWF  43
....................   unsigned pval[4]={0,0,0,0}; 
0A76:  CLRF   44
0A77:  CLRF   45
0A78:  CLRF   46
0A79:  CLRF   47
....................   delay_ms(40); 
0A7A:  MOVLW  28
0A7B:  MOVWF  48
0A7C:  MOVLB  00
0A7D:  CALL   000
....................   i2c_start(); 
0A7E:  MOVLB  04
0A7F:  BSF    16.0
0A80:  BTFSC  16.0
0A81:  GOTO   280
....................   ack_in=i2c_write(TRIMPOT_READ_CMD); 
0A82:  MOVLW  51
0A83:  MOVLB  02
0A84:  MOVWF  4E
0A85:  MOVLP  00
0A86:  MOVLB  00
0A87:  CALL   6B3
0A88:  MOVLP  08
0A89:  MOVF   78,W
0A8A:  MOVLB  02
0A8B:  BCF    3F.1
0A8C:  BTFSC  78.0
0A8D:  BSF    3F.1
....................   for(x=0;x<4;x++) { 
0A8E:  CLRF   3D
0A8F:  MOVF   3D,W
0A90:  SUBLW  03
0A91:  BTFSS  03.0
0A92:  GOTO   2CC
....................     if(x==3) { 
0A93:  MOVF   3D,W
0A94:  SUBLW  03
0A95:  BTFSS  03.2
0A96:  GOTO   299
....................       ack=0; 
0A97:  BCF    3F.0
....................     } else { 
0A98:  GOTO   29A
....................       ack=1; 
0A99:  BSF    3F.0
....................     } 
....................     pot_val=i2c_read(ack); 
0A9A:  MOVLW  00
0A9B:  BTFSC  3F.0
0A9C:  MOVLW  01
0A9D:  MOVWF  48
0A9E:  MOVF   48,W
0A9F:  MOVWF  77
*
0AAE:  MOVF   78,W
0AAF:  MOVLB  02
0AB0:  MOVWF  3E
....................     pot_val=pot_val&0x3F; 
0AB1:  MOVLW  3F
0AB2:  ANDWF  3E,F
....................     pval[x]=pot_val; 
0AB3:  MOVLW  C4
0AB4:  ADDWF  3D,W
0AB5:  MOVWF  04
0AB6:  MOVLW  20
0AB7:  MOVWF  05
0AB8:  BTFSC  03.0
0AB9:  INCF   05,F
0ABA:  MOVF   3E,W
0ABB:  MOVWF  00
....................     if ( (0x03 & CurrentTrimPot) == x ) { 
0ABC:  MOVF   76,W
0ABD:  ANDLW  03
0ABE:  SUBWF  3D,W
0ABF:  BTFSS  03.2
0AC0:  GOTO   2CA
....................       c[x] = '*'; 
0AC1:  MOVLW  C0
0AC2:  ADDWF  3D,W
0AC3:  MOVWF  04
0AC4:  MOVLW  20
0AC5:  MOVWF  05
0AC6:  BTFSC  03.0
0AC7:  INCF   05,F
0AC8:  MOVLW  2A
0AC9:  MOVWF  00
....................     } 
....................   } 
0ACA:  INCF   3D,F
0ACB:  GOTO   28F
....................   i2c_stop(); 
0ACC:  MOVLB  04
0ACD:  BSF    16.2
0ACE:  BTFSC  16.2
0ACF:  GOTO   2CE
....................   delay_ms(50); 
0AD0:  MOVLW  32
0AD1:  MOVLB  02
0AD2:  MOVWF  48
0AD3:  MOVLB  00
0AD4:  CALL   000
....................   if ( ack_in!=0 ) { 
0AD5:  MOVLB  02
0AD6:  BTFSS  3F.1
0AD7:  GOTO   2F3
....................     printf("\n\rI2C Error : No ACK from TRIMPOTS : %u",ack); 
0AD8:  MOVLW  00
0AD9:  BTFSC  3F.0
0ADA:  MOVLW  01
0ADB:  MOVWF  48
0ADC:  MOVLW  29
0ADD:  MOVLB  03
0ADE:  MOVWF  11
0ADF:  MOVLW  04
0AE0:  MOVWF  12
0AE1:  BCF    03.0
0AE2:  MOVLW  25
0AE3:  MOVLB  02
0AE4:  MOVWF  4E
0AE5:  MOVLP  00
0AE6:  MOVLB  00
0AE7:  CALL   6C8
0AE8:  MOVLP  08
0AE9:  MOVLB  02
0AEA:  MOVF   48,W
0AEB:  MOVWF  4E
0AEC:  MOVLW  1B
0AED:  MOVWF  4F
0AEE:  MOVLP  00
0AEF:  MOVLB  00
0AF0:  CALL   73C
0AF1:  MOVLP  08
0AF2:  MOVLB  02
....................   } 
....................   // 0x7e character is right arrow 
....................   // 0xc7 on LCD displays with standard characters 
....................   sprintf(LCD_str,"POT:%c%d %c%d %c%d %c%d",c[0],pval[0],c[1],pval[1],c[2],pval[2],c[3],pval[3]); 
0AF3:  MOVLW  20
0AF4:  MOVLB  01
0AF5:  MOVWF  63
0AF6:  MOVLW  76
0AF7:  MOVWF  62
0AF8:  MOVLW  3D
0AF9:  MOVLB  03
0AFA:  MOVWF  11
0AFB:  MOVLW  04
0AFC:  MOVWF  12
0AFD:  BCF    03.0
0AFE:  MOVLW  04
0AFF:  MOVLB  02
0B00:  MOVWF  48
0B01:  MOVLB  00
0B02:  CALL   124
0B03:  MOVLB  02
0B04:  MOVF   40,W
0B05:  MOVWF  4E
0B06:  MOVLB  00
0B07:  CALL   115
0B08:  MOVLB  02
0B09:  MOVF   44,W
0B0A:  MOVWF  48
0B0B:  MOVLW  18
0B0C:  MOVWF  49
0B0D:  MOVLB  00
0B0E:  CALL   1EF
0B0F:  MOVLW  20
0B10:  MOVLB  02
0B11:  MOVWF  4E
0B12:  MOVLB  00
0B13:  CALL   115
0B14:  MOVLB  02
0B15:  MOVF   41,W
0B16:  MOVWF  4E
0B17:  MOVLB  00
0B18:  CALL   115
0B19:  MOVLB  02
0B1A:  MOVF   45,W
0B1B:  MOVWF  48
0B1C:  MOVLW  18
0B1D:  MOVWF  49
0B1E:  MOVLB  00
0B1F:  CALL   1EF
0B20:  MOVLW  20
0B21:  MOVLB  02
0B22:  MOVWF  4E
0B23:  MOVLB  00
0B24:  CALL   115
0B25:  MOVLB  02
0B26:  MOVF   42,W
0B27:  MOVWF  4E
0B28:  MOVLB  00
0B29:  CALL   115
0B2A:  MOVLB  02
0B2B:  MOVF   46,W
0B2C:  MOVWF  48
0B2D:  MOVLW  18
0B2E:  MOVWF  49
0B2F:  MOVLB  00
0B30:  CALL   1EF
0B31:  MOVLW  20
0B32:  MOVLB  02
0B33:  MOVWF  4E
0B34:  MOVLB  00
0B35:  CALL   115
0B36:  MOVLB  02
0B37:  MOVF   43,W
0B38:  MOVWF  4E
0B39:  MOVLB  00
0B3A:  CALL   115
0B3B:  MOVLB  02
0B3C:  MOVF   47,W
0B3D:  MOVWF  48
0B3E:  MOVLW  18
0B3F:  MOVWF  49
0B40:  MOVLB  00
0B41:  CALL   1EF
....................   lcd_send(0,LCD_str); // COR/PTT on line 0 
0B42:  MOVLB  02
0B43:  CLRF   48
0B44:  MOVLW  20
0B45:  MOVWF  4A
0B46:  MOVLW  76
0B47:  MOVWF  49
0B48:  MOVLB  00
0B49:  CALL   18C
....................   printf("\n\r%s",LCD_str); 
0B4A:  MOVLW  0A
0B4B:  CLRWDT
0B4C:  BTFSS  11.4
0B4D:  GOTO   34B
0B4E:  MOVLB  03
0B4F:  MOVWF  1A
0B50:  MOVLW  0D
0B51:  CLRWDT
0B52:  MOVLB  00
0B53:  BTFSC  11.4
0B54:  GOTO   357
0B55:  MOVLB  03
0B56:  GOTO   351
0B57:  MOVLB  03
0B58:  MOVWF  1A
0B59:  MOVLW  20
0B5A:  MOVWF  05
0B5B:  MOVLW  76
0B5C:  MOVWF  04
0B5D:  MOVLB  00
0B5E:  CALL   256
....................  
.................... } // }}} 
0B5F:  RETURN
.................... void prompt(void) { // {{{ 
....................   if ( AdminMode ) { 
*
0FBD:  MOVLB  01
0FBE:  BTFSS  61.5
0FBF:  GOTO   7CB
....................     printf("\n\n\rADMIN> "); 
0FC0:  MOVLW  49
0FC1:  MOVLB  03
0FC2:  MOVWF  11
0FC3:  MOVLW  04
0FC4:  MOVWF  12
0FC5:  MOVLP  00
0FC6:  MOVLB  00
0FC7:  CALL   4D7
0FC8:  MOVLP  08
....................   } else { 
0FC9:  GOTO   7D4
0FCA:  MOVLB  01
....................     printf("\n\n\rCOMMAND> "); 
0FCB:  MOVLW  4F
0FCC:  MOVLB  03
0FCD:  MOVWF  11
0FCE:  MOVLW  04
0FCF:  MOVWF  12
0FD0:  MOVLP  00
0FD1:  MOVLB  00
0FD2:  CALL   4D7
0FD3:  MOVLP  08
....................   } 
.................... } // }}} 
0FD4:  RETURN
.................... void clear_sBuffer(void) { // {{{ 
.................... // This function initializes the RS232 serial 
.................... // buffer, index and flag. 
....................   unsigned x,char_num; 
....................   char_num = sizeof(sBuffer)/sizeof(char); 
*
04BD:  MOVLW  10
04BE:  MOVLB  01
04BF:  MOVWF  65
....................   for (x=0;x<char_num;x++) { 
04C0:  CLRF   64
04C1:  MOVF   65,W
04C2:  SUBWF  64,W
04C3:  BTFSC  03.0
04C4:  GOTO   4CF
....................     sBuffer[x]='\0'; 
04C5:  MOVLW  50
04C6:  ADDWF  64,W
04C7:  MOVWF  04
04C8:  MOVLW  20
04C9:  MOVWF  05
04CA:  BTFSC  03.0
04CB:  INCF   05,F
04CC:  CLRF   00
....................   } 
04CD:  INCF   64,F
04CE:  GOTO   4C1
....................   sBufferIndex=0; 
04CF:  CLRF   73
....................   sBufferFlag=0;   
04D0:  BCF    74.0
....................   argument=-1; 
04D1:  MOVLW  FF
04D2:  MOVWF  7D
....................   argument_name[0]='\0'; 
04D3:  CLRF   40
....................   command=0; 
04D4:  CLRF   70
.................... } // }}} 
04D5:  MOVLB  00
04D6:  RETURN
.................... void dtmf_write(int data,int1 rs) { // {{{ 
....................   int1 dbit; 
.................... // Write Data Bits {{{ 
....................   set_tris_d(0x00); 
*
065A:  MOVLW  00
065B:  MOVLB  01
065C:  MOVWF  0F
....................   dbit=((data&0x0F)&0x01)!=0; 
065D:  MOVLB  02
065E:  BCF    43.0
065F:  MOVF   41,W
0660:  ANDLW  0F
0661:  ANDLW  01
0662:  BTFSS  03.2
0663:  BSF    43.0
....................   output_bit(DTMF_D0,dbit); 
0664:  BTFSC  43.0
0665:  GOTO   668
0666:  BCF    0F.0
0667:  GOTO   669
0668:  BSF    0F.0
....................   dbit=((data&0x0F)&0x02)!=0; 
0669:  BCF    43.0
066A:  MOVF   41,W
066B:  ANDLW  0F
066C:  ANDLW  02
066D:  BTFSS  03.2
066E:  BSF    43.0
....................   output_bit(DTMF_D1,dbit); 
066F:  BTFSC  43.0
0670:  GOTO   673
0671:  BCF    0F.1
0672:  GOTO   674
0673:  BSF    0F.1
....................   dbit=((data&0x0F)&0x04)!=0; 
0674:  BCF    43.0
0675:  MOVF   41,W
0676:  ANDLW  0F
0677:  ANDLW  04
0678:  BTFSS  03.2
0679:  BSF    43.0
....................   output_bit(DTMF_D2,dbit); 
067A:  BTFSC  43.0
067B:  GOTO   67E
067C:  BCF    0F.2
067D:  GOTO   67F
067E:  BSF    0F.2
....................   dbit=((data&0x0F)&0x08)!=0; 
067F:  BCF    43.0
0680:  MOVF   41,W
0681:  ANDLW  0F
0682:  ANDLW  08
0683:  BTFSS  03.2
0684:  BSF    43.0
....................   output_bit(DTMF_D3,dbit); 
0685:  BTFSC  43.0
0686:  GOTO   689
0687:  BCF    0F.3
0688:  GOTO   68A
0689:  BSF    0F.3
.................... // }}} 
....................   output_bit(DTMF_RS,rs); 
068A:  MOVF   42,F
068B:  BTFSS  03.2
068C:  GOTO   68F
068D:  BCF    0F.6
068E:  GOTO   690
068F:  BSF    0F.6
....................   delay_cycles(2); 
0690:  GOTO   691
....................   output_bit(DTMF_WEB,0); 
0691:  BCF    0F.5
....................   delay_cycles(2); 
0692:  GOTO   693
....................   output_bit(DTMF_WEB,1);   
0693:  BSF    0F.5
....................   //output_bit(DTMF_RS,DATA_REG); 
....................   delay_cycles(2); 
0694:  GOTO   695
....................   set_tris_d(0x0F); 
0695:  MOVLW  0F
0696:  MOVLB  01
0697:  MOVWF  0F
.................... } // }}} 
0698:  MOVLB  00
0699:  RETURN
.................... int dtmf_read(int rs) { // {{{ 
....................   int value; 
....................   set_tris_d(0x0F); 
069A:  MOVLW  0F
069B:  MOVLB  01
069C:  MOVWF  0F
....................   output_bit(DTMF_RS,rs); 
069D:  MOVLB  02
069E:  MOVF   39,F
069F:  BTFSS  03.2
06A0:  GOTO   6A3
06A1:  BCF    0F.6
06A2:  GOTO   6A4
06A3:  BSF    0F.6
....................   delay_cycles(1); 
06A4:  NOP
....................   output_bit(DTMF_REB,0); 
06A5:  BCF    0F.4
....................   delay_cycles(1); 
06A6:  NOP
....................   value=input_d(); 
06A7:  MOVLB  00
06A8:  MOVF   0F,W
06A9:  MOVLB  02
06AA:  MOVWF  3A
....................   value&=0x0F; 
06AB:  MOVLW  0F
06AC:  ANDWF  3A,F
....................   output_bit(DTMF_REB,1); 
06AD:  BSF    0F.4
....................   //output_bit(DTMF_RS,DATA_REG);   
....................   delay_cycles(1); 
06AE:  NOP
....................   return(value); 
06AF:  MOVF   3A,W
06B0:  MOVWF  78
.................... } // }}} 
06B1:  MOVLB  00
06B2:  RETURN
.................... void init_dtmf(void) { // {{{ 
....................     output_bit(DTMF_REB,1); 
*
0CFE:  MOVLB  02
0CFF:  BSF    0F.4
....................     output_bit(DTMF_WEB,1); 
0D00:  BSF    0F.5
....................     output_bit(DTMF_RS ,DATA_REG); 
0D01:  BCF    0F.6
....................     dtmf_write(0,CONTROL_REG); 
0D02:  CLRF   41
0D03:  MOVLW  01
0D04:  MOVWF  42
0D05:  MOVLP  00
0D06:  MOVLB  00
0D07:  CALL   65A
0D08:  MOVLP  08
....................     dtmf_write(0,CONTROL_REG); 
0D09:  MOVLB  02
0D0A:  CLRF   41
0D0B:  MOVLW  01
0D0C:  MOVWF  42
0D0D:  MOVLP  00
0D0E:  MOVLB  00
0D0F:  CALL   65A
0D10:  MOVLP  08
....................     //dtmf_write(8,CONTROL_REG); 
.................... //  dtmf_write(TOUT|IRQ|RSELB,CONTROL_REG); // Enable TOUT and IRQ 
....................     dtmf_write(IRQ|RSELB,CONTROL_REG); // Enable IRQ then write to register B 
0D11:  MOVLW  0C
0D12:  MOVLB  02
0D13:  MOVWF  41
0D14:  MOVLW  01
0D15:  MOVWF  42
0D16:  MOVLP  00
0D17:  MOVLB  00
0D18:  CALL   65A
0D19:  MOVLP  08
....................     dtmf_write(BURST_OFF,CONTROL_REG); 
0D1A:  MOVLW  01
0D1B:  MOVLB  02
0D1C:  MOVWF  41
0D1D:  MOVWF  42
0D1E:  MOVLP  00
0D1F:  MOVLB  00
0D20:  CALL   65A
0D21:  MOVLP  08
....................     dtmf_read(CONTROL_REG); 
0D22:  MOVLW  01
0D23:  MOVLB  02
0D24:  MOVWF  39
0D25:  MOVLP  00
0D26:  MOVLB  00
0D27:  CALL   69A
0D28:  MOVLP  08
.................... } // }}} 
.................... void dtmf_send_digit(int digit) { // {{{ 
....................   dtmf_write(digit,DATA_REG); 
*
19EC:  MOVF   3E,W
19ED:  MOVWF  41
19EE:  CLRF   42
19EF:  MOVLP  00
19F0:  MOVLB  00
19F1:  CALL   65A
19F2:  MOVLP  18
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
19F3:  MOVLW  0C
19F4:  MOVLB  02
19F5:  MOVWF  41
19F6:  MOVLW  01
19F7:  MOVWF  42
19F8:  MOVLP  00
19F9:  MOVLB  00
19FA:  CALL   65A
19FB:  MOVLP  18
....................   dtmf_write(BURST_OFF|DUAL_TONE,CONTROL_REG); // Enable DTMF 
19FC:  MOVLW  01
19FD:  MOVLB  02
19FE:  MOVWF  41
19FF:  MOVWF  42
1A00:  MOVLP  00
1A01:  MOVLB  00
1A02:  CALL   65A
1A03:  MOVLP  18
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
1A04:  MOVLW  05
1A05:  MOVLB  02
1A06:  MOVWF  41
1A07:  MOVLW  01
1A08:  MOVWF  42
1A09:  MOVLP  00
1A0A:  MOVLB  00
1A0B:  CALL   65A
1A0C:  MOVLP  18
....................   aux_timer=AUX_TIMER_500ms; 
1A0D:  MOVLB  01
1A0E:  CLRF   33
1A0F:  MOVLW  10
1A10:  MOVWF  32
....................   while(aux_timer) { 
1A11:  MOVF   32,W
1A12:  IORWF  33,W
1A13:  BTFSC  03.2
1A14:  GOTO   217
....................     delay_cycles(1); 
1A15:  NOP
....................   } 
1A16:  GOTO   211
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
1A17:  MOVLW  04
1A18:  MOVLB  02
1A19:  MOVWF  41
1A1A:  MOVLW  01
1A1B:  MOVWF  42
1A1C:  MOVLP  00
1A1D:  MOVLB  00
1A1E:  CALL   65A
1A1F:  MOVLP  18
.................... } // }}} 
.................... void dit (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
*
082C:  MOVLW  01
082D:  MOVLB  02
082E:  MOVWF  41
082F:  CLRF   42
0830:  MOVLP  00
0831:  MOVLB  00
0832:  CALL   65A
0833:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
0834:  MOVLW  0C
0835:  MOVLB  02
0836:  MOVWF  41
0837:  MOVLW  01
0838:  MOVWF  42
0839:  MOVLP  00
083A:  MOVLB  00
083B:  CALL   65A
083C:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
083D:  MOVLW  05
083E:  MOVLB  02
083F:  MOVWF  41
0840:  MOVLW  01
0841:  MOVWF  42
0842:  MOVLP  00
0843:  MOVLB  00
0844:  CALL   65A
0845:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
0846:  MOVLW  05
0847:  MOVLB  02
0848:  MOVWF  41
0849:  MOVLW  01
084A:  MOVWF  42
084B:  MOVLP  00
084C:  MOVLB  00
084D:  CALL   65A
084E:  MOVLP  08
....................   aux_timer=MorseLen[(MorseDitLength&0x03)]; 
084F:  MOVLB  01
0850:  CLRF   33
0851:  MOVLW  02
0852:  MOVWF  32
....................   while(aux_timer) { 
0853:  MOVF   32,W
0854:  IORWF  33,W
0855:  BTFSC  03.2
0856:  GOTO   059
....................     delay_cycles(1); 
0857:  NOP
....................   } 
0858:  GOTO   053
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0859:  MOVLW  04
085A:  MOVLB  02
085B:  MOVWF  41
085C:  MOVLW  01
085D:  MOVWF  42
085E:  MOVLP  00
085F:  MOVLB  00
0860:  CALL   65A
0861:  MOVLP  08
....................   restart_wdt(); 
0862:  CLRWDT
.................... } // }}} 
0863:  RETURN
.................... void dah (void) { // {{{ 
....................   dtmf_write(1,DATA_REG); 
0864:  MOVLW  01
0865:  MOVLB  02
0866:  MOVWF  41
0867:  CLRF   42
0868:  MOVLP  00
0869:  MOVLB  00
086A:  CALL   65A
086B:  MOVLP  08
....................   dtmf_write(IRQ|RSELB,CONTROL_REG); // Switch to DTMF mode 
086C:  MOVLW  0C
086D:  MOVLB  02
086E:  MOVWF  41
086F:  MOVLW  01
0870:  MOVWF  42
0871:  MOVLP  00
0872:  MOVLB  00
0873:  CALL   65A
0874:  MOVLP  08
....................   dtmf_write(BURST_OFF|SINGLE_TONE,CONTROL_REG); // Enable DTMF 
0875:  MOVLW  05
0876:  MOVLB  02
0877:  MOVWF  41
0878:  MOVLW  01
0879:  MOVWF  42
087A:  MOVLP  00
087B:  MOVLB  00
087C:  CALL   65A
087D:  MOVLP  08
....................   dtmf_write(TOUT|IRQ,CONTROL_REG); // Enable Tones 
087E:  MOVLW  05
087F:  MOVLB  02
0880:  MOVWF  41
0881:  MOVLW  01
0882:  MOVWF  42
0883:  MOVLP  00
0884:  MOVLB  00
0885:  CALL   65A
0886:  MOVLP  08
....................   aux_timer=3*MorseLen[(MorseDitLength&0x03)]; 
0887:  MOVLB  01
0888:  CLRF   33
0889:  MOVLW  06
088A:  MOVWF  32
....................   while(aux_timer) { 
088B:  MOVF   32,W
088C:  IORWF  33,W
088D:  BTFSC  03.2
088E:  GOTO   091
....................     delay_cycles(1); 
088F:  NOP
....................   } 
0890:  GOTO   08B
....................   dtmf_write(IRQ,CONTROL_REG); // Disable tones 
0891:  MOVLW  04
0892:  MOVLB  02
0893:  MOVWF  41
0894:  MOVLW  01
0895:  MOVWF  42
0896:  MOVLP  00
0897:  MOVLB  00
0898:  CALL   65A
0899:  MOVLP  08
....................   restart_wdt(); 
089A:  CLRWDT
.................... } // }}} 
089B:  RETURN
.................... void update_checksum (int *cksum,int value) { // {{{ 
....................   const int seed = 0x09; 
....................   int tmp; 
....................  
....................   tmp=*cksum; 
*
052C:  MOVLB  02
052D:  MOVF   36,W
052E:  MOVWF  04
052F:  MOVF   37,W
0530:  MOVWF  05
0531:  MOVF   00,W
0532:  MOVWF  39
....................   if ( tmp > 127 ) { 
0533:  MOVF   39,W
0534:  SUBLW  7F
0535:  BTFSS  03.0
....................     tmp++; 
0536:  INCF   39,F
....................   } 
....................   tmp = ((tmp << 1)^seed)+value; 
0537:  BCF    03.0
0538:  RLF    39,W
0539:  XORLW  09
053A:  ADDWF  38,W
053B:  MOVWF  39
....................   *cksum=tmp; 
053C:  MOVF   36,W
053D:  MOVWF  04
053E:  MOVF   37,W
053F:  MOVWF  05
0540:  MOVF   39,W
0541:  MOVWF  00
.................... } // }}} 
0542:  MOVLB  00
0543:  RETURN
.................... void print_dtmf_info(void) { // {{{ 
....................   unsigned int x; 
....................   char dtmf; 
....................   char tmp[5]; 
....................   strcpy(LCD_str,"DTMF:"); 
*
1750:  MOVLB  01
1751:  CLRF   6B
1752:  CLRF   6C
1753:  MOVLW  20
1754:  MOVWF  05
1755:  MOVLW  76
1756:  MOVWF  04
1757:  MOVF   6B,W
1758:  ADDWF  04,F
1759:  MOVLW  00
175A:  ADDWFC 05,F
175B:  MOVF   6C,W
175C:  MOVLP  00
175D:  MOVLB  00
175E:  CALL   139
175F:  MOVLP  10
1760:  MOVWF  00
1761:  IORLW  00
1762:  BTFSC  03.2
1763:  GOTO   769
1764:  MOVLB  01
1765:  INCF   6C,F
1766:  INCF   6B,F
1767:  GOTO   753
1768:  MOVLB  00
....................   printf("\n\rDTMF="); 
1769:  MOVLW  56
176A:  MOVLB  03
176B:  MOVWF  11
176C:  MOVLW  04
176D:  MOVWF  12
176E:  MOVLP  00
176F:  MOVLB  00
1770:  CALL   4D7
1771:  MOVLP  10
....................   for(x=0;x<DTMF_ARRAY_SIZE;x++) { 
1772:  MOVLB  01
1773:  CLRF   64
1774:  MOVF   64,W
1775:  SUBLW  09
1776:  BTFSS  03.0
1777:  GOTO   7BE
....................     if(DTMF_ARRAY[x].Strobe) { 
1778:  MOVLW  64
1779:  ADDWF  64,W
177A:  MOVWF  04
177B:  MOVLW  20
177C:  MOVWF  05
177D:  BTFSC  03.0
177E:  INCF   05,F
177F:  BTFSS  00.4
1780:  GOTO   7BB
....................       dtmf=(int)DTMF_ARRAY[x].Key; 
1781:  MOVLW  64
1782:  ADDWF  64,W
1783:  MOVWF  04
1784:  MOVLW  20
1785:  MOVWF  05
1786:  BTFSC  03.0
1787:  INCF   05,F
1788:  MOVF   00,W
1789:  ANDLW  0F
178A:  MOVWF  65
....................       sprintf(tmp,"%d ",dtmf); 
178B:  MOVLW  20
178C:  MOVWF  63
178D:  MOVLW  96
178E:  MOVWF  62
178F:  MOVF   65,W
1790:  MOVLB  02
1791:  MOVWF  48
1792:  MOVLW  18
1793:  MOVWF  49
1794:  MOVLP  08
1795:  MOVLB  00
1796:  CALL   1EF
1797:  MOVLP  10
1798:  MOVLW  20
1799:  MOVLB  02
179A:  MOVWF  4E
179B:  MOVLP  08
179C:  MOVLB  00
179D:  CALL   115
179E:  MOVLP  10
....................       strcat(LCD_str,tmp); 
179F:  MOVLW  20
17A0:  MOVLB  02
17A1:  MOVWF  28
17A2:  MOVLW  76
17A3:  MOVWF  27
17A4:  MOVLW  20
17A5:  MOVWF  2A
17A6:  MOVLW  96
17A7:  MOVWF  29
17A8:  MOVLB  00
17A9:  CALL   6C5
....................       printf(" %u",dtmf); 
17AA:  MOVLW  20
17AB:  CLRWDT
17AC:  BTFSS  11.4
17AD:  GOTO   7AB
17AE:  MOVLB  03
17AF:  MOVWF  1A
17B0:  MOVLB  01
17B1:  MOVF   65,W
17B2:  MOVLB  02
17B3:  MOVWF  4E
17B4:  MOVLW  1B
17B5:  MOVWF  4F
17B6:  MOVLP  00
17B7:  MOVLB  00
17B8:  CALL   73C
17B9:  MOVLP  10
17BA:  MOVLB  01
....................     } 
....................   restart_wdt(); 
17BB:  CLRWDT
....................   } 
17BC:  INCF   64,F
17BD:  GOTO   774
....................   printf("\n\r"); 
17BE:  MOVLW  0A
17BF:  CLRWDT
17C0:  MOVLB  00
17C1:  BTFSC  11.4
17C2:  GOTO   7C5
17C3:  MOVLB  01
17C4:  GOTO   7BF
17C5:  MOVLB  03
17C6:  MOVWF  1A
17C7:  MOVLW  0D
17C8:  CLRWDT
17C9:  MOVLB  00
17CA:  BTFSC  11.4
17CB:  GOTO   7CE
17CC:  MOVLB  03
17CD:  GOTO   7C8
17CE:  MOVLB  03
17CF:  MOVWF  1A
....................   PROMPT_FLAG=1; 
17D0:  MOVLB  01
17D1:  BSF    61.4
....................   lcd_send(2,LCD_str); // Send DTMF on line 3 
17D2:  MOVLW  02
17D3:  MOVLB  02
17D4:  MOVWF  48
17D5:  MOVLW  20
17D6:  MOVWF  4A
17D7:  MOVLW  76
17D8:  MOVWF  49
17D9:  MOVLP  08
17DA:  MOVLB  00
17DB:  CALL   18C
17DC:  MOVLP  10
.................... } // }}} 
17DD:  MOVLP  18
17DE:  GOTO   710 (RETURN)
.................... int _init_variables (int1 source) { // {{{ 
....................   int x; 
....................   int *regPtr; 
....................   int cksum; 
....................   int eeprom_index; 
....................   int default_value; 
....................   int retVal; 
....................   int eeprom_val; 
....................  
....................   cksum=1; 
*
0544:  MOVLW  01
0545:  MOVLB  02
0546:  MOVWF  30
....................   eeprom_index=0; 
0547:  CLRF   31
....................   retVal = 1; 
0548:  MOVWF  33
....................   if ( source == USE_EEPROM_VARS ) { 
0549:  DECFSZ 2C,W
054A:  GOTO   554
....................     printf("\n\rInit RAM <= EEPROM"); 
054B:  MOVLW  5A
054C:  MOVLB  03
054D:  MOVWF  11
054E:  MOVLW  04
054F:  MOVWF  12
0550:  MOVLB  00
0551:  CALL   4D7
....................   } else { 
0552:  GOTO   55B
0553:  MOVLB  02
....................     printf("\n\rInit RAM <= HW Defaults"); 
0554:  MOVLW  65
0555:  MOVLB  03
0556:  MOVWF  11
0557:  MOVLW  04
0558:  MOVWF  12
0559:  MOVLB  00
055A:  CALL   4D7
....................   } 
....................   for(x=0;x<RegMapNum;x++) { 
055B:  MOVLB  02
055C:  CLRF   2D
055D:  MOVF   2D,W
055E:  SUBLW  38
055F:  BTFSS  03.0
0560:  GOTO   5BA
....................     regPtr=RegMap[x].reg_ptr; 
0561:  RLF    2D,W
0562:  MOVWF  77
0563:  RLF    77,F
0564:  MOVLW  FC
0565:  ANDWF  77,F
0566:  MOVF   77,W
0567:  MOVWF  35
0568:  INCF   35,W
0569:  MOVLB  00
056A:  CALL   043
056B:  MOVWF  7A
056C:  MOVLB  02
056D:  MOVF   35,W
056E:  MOVLB  00
056F:  CALL   043
0570:  MOVLB  02
0571:  MOVWF  2E
0572:  MOVF   7A,W
0573:  MOVWF  2F
....................     if ( source == USE_EEPROM_VARS && RegMap[x].non_volatile ) { 
0574:  DECFSZ 2C,W
0575:  GOTO   5A6
0576:  RLF    2D,W
0577:  MOVWF  77
0578:  RLF    77,F
0579:  MOVLW  FC
057A:  ANDWF  77,F
057B:  MOVF   77,W
057C:  ADDLW  03
057D:  MOVLB  00
057E:  CALL   043
057F:  MOVWF  78
0580:  BTFSC  78.0
0581:  GOTO   584
0582:  MOVLB  02
0583:  GOTO   5A6
....................       eeprom_val=read_eeprom(eeprom_index); 
0584:  MOVLB  02
0585:  MOVF   31,W
0586:  MOVLB  03
0587:  MOVWF  11
0588:  BCF    15.7
0589:  BSF    15.0
058A:  MOVF   13,W
058B:  MOVLB  02
058C:  MOVWF  34
....................       *regPtr=eeprom_val; 
058D:  MOVF   2E,W
058E:  MOVWF  04
058F:  MOVF   2F,W
0590:  MOVWF  05
0591:  MOVF   34,W
0592:  MOVWF  00
....................       update_checksum(&cksum,*regPtr);     
0593:  MOVF   2F,W
0594:  MOVWF  7A
0595:  MOVF   2E,W
0596:  MOVWF  04
0597:  MOVF   2F,W
0598:  MOVWF  05
0599:  MOVF   00,W
059A:  MOVWF  35
059B:  MOVLW  20
059C:  MOVWF  37
059D:  MOVLW  B0
059E:  MOVWF  36
059F:  MOVF   35,W
05A0:  MOVWF  38
05A1:  MOVLB  00
05A2:  CALL   52C
....................       eeprom_index++; 
05A3:  MOVLB  02
05A4:  INCF   31,F
....................     } else { 
05A5:  GOTO   5B8
....................       default_value=(int8)RegMap[x].default_value; 
05A6:  RLF    2D,W
05A7:  MOVWF  77
05A8:  RLF    77,F
05A9:  MOVLW  FC
05AA:  ANDWF  77,F
05AB:  MOVF   77,W
05AC:  ADDLW  02
05AD:  MOVLB  00
05AE:  CALL   043
05AF:  MOVWF  78
05B0:  MOVLB  02
05B1:  MOVWF  32
....................       *regPtr=default_value; 
05B2:  MOVF   2E,W
05B3:  MOVWF  04
05B4:  MOVF   2F,W
05B5:  MOVWF  05
05B6:  MOVF   32,W
05B7:  MOVWF  00
....................     } 
....................   } 
05B8:  INCF   2D,F
05B9:  GOTO   55D
....................   if ( source == USE_EEPROM_VARS ) { 
05BA:  DECFSZ 2C,W
05BB:  GOTO   5C6
....................     if ( read_eeprom(eeprom_index) != cksum ) { 
05BC:  MOVF   31,W
05BD:  MOVLB  03
05BE:  MOVWF  11
05BF:  BCF    15.7
05C0:  BSF    15.0
05C1:  MOVF   13,W
05C2:  MOVLB  02
05C3:  SUBWF  30,W
05C4:  BTFSS  03.2
....................        retVal = 0 ; // Error : Checksum does not match when initializing variables from EEPROM 
05C5:  CLRF   33
....................     } 
....................   } 
....................   return (retVal); 
05C6:  MOVF   33,W
05C7:  MOVWF  78
.................... } // }}} 
05C8:  MOVLB  00
05C9:  RETURN
.................... void store_variables(void) { // {{{ 
.................... // Save RAM variables in EEPROM 
....................   int x; 
....................   int eeprom_index; 
....................   int *regPtr; 
....................   int cksum; 
....................   int8 value; 
....................  
....................   cksum=1; 
05CA:  MOVLW  01
05CB:  MOVLB  02
05CC:  MOVWF  30
....................  
....................   eeprom_index=0; 
05CD:  CLRF   2D
....................   for(x=0;x<RegMapNum;x++) { 
05CE:  CLRF   2C
05CF:  MOVF   2C,W
05D0:  SUBLW  38
05D1:  BTFSS  03.0
05D2:  GOTO   628
....................     regPtr=RegMap[x].reg_ptr; 
05D3:  RLF    2C,W
05D4:  MOVWF  77
05D5:  RLF    77,F
05D6:  MOVLW  FC
05D7:  ANDWF  77,F
05D8:  MOVF   77,W
05D9:  MOVWF  32
05DA:  INCF   32,W
05DB:  MOVLB  00
05DC:  CALL   043
05DD:  MOVWF  7A
05DE:  MOVLB  02
05DF:  MOVF   32,W
05E0:  MOVLB  00
05E1:  CALL   043
05E2:  MOVLB  02
05E3:  MOVWF  2E
05E4:  MOVF   7A,W
05E5:  MOVWF  2F
....................     if ( RegMap[x].non_volatile ) { 
05E6:  RLF    2C,W
05E7:  MOVWF  77
05E8:  RLF    77,F
05E9:  MOVLW  FC
05EA:  ANDWF  77,F
05EB:  MOVF   77,W
05EC:  ADDLW  03
05ED:  MOVLB  00
05EE:  CALL   043
05EF:  MOVWF  78
05F0:  BTFSS  78.0
05F1:  GOTO   625
....................      value=*regPtr; 
05F2:  MOVLB  02
05F3:  MOVF   2E,W
05F4:  MOVWF  04
05F5:  MOVF   2F,W
05F6:  MOVWF  05
05F7:  MOVF   00,W
05F8:  MOVWF  31
....................      if ( read_eeprom(eeprom_index) != value ) { 
05F9:  MOVF   2D,W
05FA:  MOVLB  03
05FB:  MOVWF  11
05FC:  BCF    15.7
05FD:  BSF    15.0
05FE:  MOVF   13,W
05FF:  MOVLB  02
0600:  SUBWF  31,W
0601:  BTFSC  03.2
0602:  GOTO   61A
....................        write_eeprom(eeprom_index,value); 
0603:  MOVF   0B,W
0604:  MOVWF  77
0605:  BCF    0B.7
0606:  MOVF   2D,W
0607:  MOVLB  03
0608:  MOVWF  11
0609:  MOVLB  02
060A:  MOVF   31,W
060B:  MOVLB  03
060C:  MOVWF  13
060D:  BCF    15.7
060E:  BSF    15.2
060F:  MOVLW  55
0610:  MOVWF  16
0611:  MOVLW  AA
0612:  MOVWF  16
0613:  BSF    15.1
0614:  BTFSC  15.1
0615:  GOTO   614
0616:  BCF    15.2
0617:  MOVF   77,W
0618:  IORWF  0B,F
0619:  MOVLB  02
....................      } 
....................      update_checksum(&cksum,value); 
061A:  MOVLW  20
061B:  MOVWF  37
061C:  MOVLW  B0
061D:  MOVWF  36
061E:  MOVF   31,W
061F:  MOVWF  38
0620:  MOVLB  00
0621:  CALL   52C
....................      eeprom_index++; 
0622:  MOVLB  02
0623:  INCF   2D,F
0624:  MOVLB  00
....................     } 
....................   } 
0625:  MOVLB  02
0626:  INCF   2C,F
0627:  GOTO   5CF
....................   write_eeprom(eeprom_index,cksum); 
0628:  MOVF   0B,W
0629:  MOVWF  77
062A:  BCF    0B.7
062B:  MOVF   2D,W
062C:  MOVLB  03
062D:  MOVWF  11
062E:  MOVLB  02
062F:  MOVF   30,W
0630:  MOVLB  03
0631:  MOVWF  13
0632:  BCF    15.7
0633:  BSF    15.2
0634:  MOVLW  55
0635:  MOVWF  16
0636:  MOVLW  AA
0637:  MOVWF  16
0638:  BSF    15.1
0639:  BTFSC  15.1
063A:  GOTO   639
063B:  BCF    15.2
063C:  MOVF   77,W
063D:  IORWF  0B,F
....................   printf("\n\rSaving RAM configuration in EEPROM."); 
063E:  MOVLW  72
063F:  MOVWF  11
0640:  MOVLW  04
0641:  MOVWF  12
0642:  MOVLB  00
0643:  CALL   4D7
.................... } // }}} 
0644:  RETURN
.................... void init_variables (int1 source) { // {{{ 
....................     // Attempt initialization from EEPROM and verify checksum. 
....................     // If checksum does not match, use default variables. 
....................     if ( !_init_variables(source) ) { 
0645:  MOVLB  02
0646:  MOVF   2B,W
0647:  MOVWF  2C
0648:  MOVLB  00
0649:  CALL   544
064A:  MOVF   78,F
064B:  BTFSS  03.2
064C:  GOTO   659
....................       printf("\n\r  Checksum mismatch. Restoring default values."); 
064D:  MOVLW  85
064E:  MOVLB  03
064F:  MOVWF  11
0650:  MOVLW  04
0651:  MOVWF  12
0652:  MOVLB  00
0653:  CALL   4D7
....................         _init_variables(USE_DEFAULT_VARS); 
0654:  MOVLB  02
0655:  CLRF   2C
0656:  MOVLB  00
0657:  CALL   544
....................     store_variables(); 
0658:  CALL   5CA
....................     } 
.................... } // }}} 
0659:  RETURN
.................... void init_trimpot(void) {//{{{ 
....................   set_trimpot(0,0); 
*
0D3D:  MOVLB  02
0D3E:  CLRF   3D
0D3F:  CLRF   3E
0D40:  MOVLP  00
0D41:  MOVLB  00
0D42:  CALL   78B
0D43:  MOVLP  08
....................   set_trimpot(1,0); 
0D44:  MOVLW  01
0D45:  MOVLB  02
0D46:  MOVWF  3D
0D47:  CLRF   3E
0D48:  MOVLP  00
0D49:  MOVLB  00
0D4A:  CALL   78B
0D4B:  MOVLP  08
....................   set_trimpot(2,0); 
0D4C:  MOVLW  02
0D4D:  MOVLB  02
0D4E:  MOVWF  3D
0D4F:  CLRF   3E
0D50:  MOVLP  00
0D51:  MOVLB  00
0D52:  CALL   78B
0D53:  MOVLP  08
....................   set_trimpot(3,0); 
0D54:  MOVLW  03
0D55:  MOVLB  02
0D56:  MOVWF  3D
0D57:  CLRF   3E
0D58:  MOVLP  00
0D59:  MOVLB  00
0D5A:  CALL   78B
0D5B:  MOVLP  08
.................... } // }}} 
.................... void initialize (void) { // {{{ 
.................... // This function performs all initializations upon 
.................... // power-up 
....................   clear_sBuffer(); 
*
0CC0:  MOVLP  00
0CC1:  CALL   4BD
0CC2:  MOVLP  08
....................   setup_comparator(NC_NC_NC_NC);  
0CC3:  MOVLB  02
0CC4:  CLRF   12
0CC5:  CLRF   11
0CC6:  CLRF   14
0CC7:  CLRF   13
....................   setup_wdt(WDT_2S); 
0CC8:  MOVLW  17
0CC9:  MOVLB  01
0CCA:  MOVWF  17
....................   COR_IN=0; 
0CCB:  MOVLB  00
0CCC:  CLRF   5F
....................   COR_EMUL=0; 
0CCD:  CLRF   6A
....................   COR_AUX=0; 
0CCE:  CLRF   6B
....................   COR_DROP_FLAG=0; 
0CCF:  BCF    74.5
....................   DTMF_IN_FLAG=0; 
0CD0:  MOVLB  01
0CD1:  BCF    61.1
....................   DTMF_INTERRUPT_FLAG=0; 
0CD2:  BCF    61.2
....................   TOT_FLAG_Mask=0; 
0CD3:  MOVLB  00
0CD4:  CLRF   67
....................   AuxOutDelayCnt=0; 
0CD5:  CLRF   7C
....................   LastRegisterIndexValid=0; 
0CD6:  MOVLB  01
0CD7:  CLRF   5C
....................   LastRegisterIndex=0; 
0CD8:  CLRF   5B
....................   CurrentCorMask=0; 
0CD9:  MOVLB  00
0CDA:  CLRF   6E
....................   CurrentCorPriority=0; 
0CDB:  CLRF   71
....................   CurrentCorIndex=0; 
0CDC:  CLRF   6F
....................   CurrentTrimPot=0; 
0CDD:  CLRF   76
....................   setup_adc(NO_ANALOGS); 
0CDE:  MOVLB  01
0CDF:  BCF    1D.0
....................   set_tris_b(0xFF); 
0CE0:  MOVLW  FF
0CE1:  TRIS   6
....................   set_tris_d(0x00); 
0CE2:  MOVLW  00
0CE3:  MOVWF  0F
....................   set_tris_e(0xF8); 
0CE4:  BCF    10.0
0CE5:  BCF    10.1
0CE6:  BCF    10.2
0CE7:  BSF    10.3
....................   enable_interrupts(INT_RDA); 
0CE8:  BSF    11.5
....................   enable_interrupts(INT_RB0|INT_RB1|INT_RB2|INT_RB3|INT_RB6|INT_RB7); 
0CE9:  BSF    0B.3
0CEA:  MOVLW  CF
0CEB:  MOVLB  07
0CEC:  IORWF  14,F
0CED:  IORWF  15,F
....................   enable_interrupts(INT_RB4_H2L); 
0CEE:  BSF    0B.3
0CEF:  BSF    15.4
0CF0:  BCF    14.4
....................   enable_interrupts(GLOBAL); 
0CF1:  MOVLW  C0
0CF2:  IORWF  0B,F
....................   output_bit(DTMF_CS ,0); 
0CF3:  MOVLB  02
0CF4:  BCF    0F.7
....................   output_bit(DTMF_WEB,1); 
0CF5:  BSF    0F.5
....................   output_bit(DTMF_REB,1); 
0CF6:  BSF    0F.4
....................   output_bit(DTMF_RS ,0); 
0CF7:  BCF    0F.6
....................   //clearscr(); 
....................   init_variables(USE_EEPROM_VARS); 
0CF8:  MOVLW  01
0CF9:  MOVWF  2B
0CFA:  MOVLP  00
0CFB:  MOVLB  00
0CFC:  CALL   645
0CFD:  MOVLP  08
....................   init_dtmf(); 
....................   CLEAR_DTMF_FLAG=1; 
*
0D29:  MOVLB  01
0D2A:  BSF    61.3
....................   Enable_Mask = 0x0F; 
0D2B:  MOVLW  0F
0D2C:  MOVLB  00
0D2D:  MOVWF  61
....................   // Port B Pullups {{{ 
....................   // AuxIn pins : B6, B7, C0 
....................   // Port_x_pullups requires a bit value corresponding to each 
....................   // bit. 
....................   // AuxIn 1:0: Pins B6&B7 
....................   // COR 3:0: Pins B3:B0 
....................   // DTMF interrupt : PIN_B4 (No pull-up required) 
....................   // PIN_B5 : Adjust trmipot. Nu pull-up required 
....................   // port_b_pullups(0b11000000 | (Polarity & 0x0F)); 
....................   WPUB = 0b11000000 | ( Polarity & 0x0F); 
0D2E:  MOVF   62,W
0D2F:  ANDLW  0F
0D30:  IORLW  C0
0D31:  MOVLB  04
0D32:  MOVWF  0D
....................   // Set WPUEN (bar) bit on OPTION_REG 
....................   // Master Weak pull-up enable 
....................   WPUEN = 0; 
0D33:  MOVLB  01
0D34:  BCF    15.7
....................   // }}} 
....................   header(); 
0D35:  MOVLP  00
0D36:  MOVLB  00
0D37:  CALL   003
0D38:  MOVLP  08
....................   // C7 : UART RX 
....................   // C6 : UART TX 
....................   // C5 : Aux1 Out 
....................   // C4 : I2C SDA 
....................   // C3 : I2C SCL 
....................   // C2 : PWM Out 
....................   // C1 : Aux0 Out 
....................   // C0 : Aux2 In 
....................   // TRIS_C = 0x5D; 
....................   set_tris_c(0b10011101); 
0D39:  MOVLW  9D
0D3A:  TRIS   7
....................   // Pin A7 --> ENTER button 
....................   set_tris_a(0b10000000); 
0D3B:  MOVLW  80
0D3C:  TRIS   5
....................   init_trimpot(); 
....................   // Initialize RTC 
....................   rtcc_cnt=30; 
*
0D5C:  MOVLB  01
0D5D:  CLRF   31
0D5E:  MOVLW  1E
0D5F:  MOVWF  30
....................   setup_timer_0(T0_INTERNAL|T0_DIV_256); 
0D60:  MOVF   15,W
0D61:  ANDLW  C0
0D62:  IORLW  07
0D63:  MOVWF  15
....................   enable_interrupts(INT_TIMER0); 
0D64:  BSF    0B.5
....................   update_ptt(0); 
0D65:  MOVLB  02
0D66:  CLRF   2C
0D67:  MOVLB  00
0D68:  CALL   360
....................   MinuteCounter=MIN_COUNTER; 
0D69:  MOVLW  1D
0D6A:  MOVLB  01
0D6B:  MOVWF  5E
....................   SecondCounter=SEC_COUNTER; 
0D6C:  MOVLW  3B
0D6D:  MOVWF  5D
....................   THIRTY_MIN_FLAG=0; 
0D6E:  BCF    74.4
....................   MINUTE_FLAG=0; 
0D6F:  BCF    74.3
....................   PROMPT_FLAG=1; 
0D70:  BSF    61.4
....................   TailChar=Tail; 
0D71:  MOVLB  00
0D72:  MOVF   65,W
0D73:  MOVWF  6C
....................   ConfirmChar=0; 
0D74:  CLRF   6D
....................   //AuxOut[0] = PO_AUX_OUT0; 
....................   //AuxOut[1] = PO_AUX_OUT1; 
....................   //AuxOut[2] = PO_AUX_OUT2; 
....................   AuxInSW[0] = 0; 
0D75:  CLRF   3F
....................   AuxInSW[1] = 0; 
0D76:  CLRF   40
....................   AuxInSW[2] = 0; 
0D77:  CLRF   41
....................   AUX_IN_FLAG = 0; 
0D78:  BCF    74.6
....................   COR_IN_EFFECTIVE=0; 
0D79:  CLRF   72
....................   set_admin_mode(0); 
0D7A:  MOVLB  02
0D7B:  CLRF   3E
0D7C:  MOVLB  00
0D7D:  CALL   4A9
....................   rs232_mode=0; 
0D7E:  MOVLB  01
0D7F:  BCF    61.6
.................... #ifdef LCD_TYPE_PI 
....................   init_lcd(); 
.................... #endif 
.................... } // }}} 
0D80:  MOVLP  18
0D81:  MOVLB  00
0D82:  GOTO   6E1 (RETURN)
.................... void tokenize_sBuffer() { // {{{ 
*
180D:  MOVLB  02
180E:  BCF    26.0
....................   char verb[8]; 
....................   int1 do_get_var=0; 
....................   char *sptr; 
....................   char match_tok[8],match_val[4],smatch_reg[8]; 
....................  
....................   // Get verb {{{ 
....................   strcpy(match_tok," ,;\r"); 
180F:  CLRF   3D
1810:  CLRF   3E
1811:  MOVLW  20
1812:  MOVWF  05
1813:  MOVLW  A9
1814:  MOVWF  04
1815:  MOVF   3D,W
1816:  ADDWF  04,F
1817:  MOVLW  00
1818:  ADDWFC 05,F
1819:  MOVF   3E,W
181A:  MOVLP  00
181B:  MOVLB  00
181C:  CALL   140
181D:  MOVLP  18
181E:  MOVWF  00
181F:  IORLW  00
1820:  BTFSC  03.2
1821:  GOTO   027
1822:  MOVLB  02
1823:  INCF   3E,F
1824:  INCF   3D,F
1825:  GOTO   011
1826:  MOVLB  00
....................   sptr=strtok(sBuffer,match_tok); 
1827:  MOVLW  20
1828:  MOVLB  02
1829:  MOVWF  3E
182A:  MOVLW  50
182B:  MOVWF  3D
182C:  MOVLW  20
182D:  MOVWF  40
182E:  MOVLW  A9
182F:  MOVWF  3F
1830:  MOVLP  08
1831:  MOVLB  00
1832:  CALL   583
1833:  MOVLP  18
1834:  MOVF   79,W
1835:  MOVLB  02
1836:  MOVWF  28
1837:  MOVF   78,W
1838:  MOVWF  27
....................   if (sptr!=0) {; 
1839:  MOVF   27,F
183A:  BTFSS  03.2
183B:  GOTO   03F
183C:  MOVF   28,F
183D:  BTFSC  03.2
183E:  GOTO   059
....................     strcpy(verb,sptr); 
183F:  MOVF   28,W
1840:  MOVWF  40
1841:  MOVF   27,W
1842:  MOVWF  3F
1843:  MOVLW  20
1844:  MOVWF  3E
1845:  MOVLW  9E
1846:  MOVWF  3D
1847:  MOVF   40,W
1848:  MOVWF  05
1849:  MOVF   3F,W
184A:  MOVWF  04
184B:  MOVF   00,W
184C:  MOVWF  41
184D:  MOVF   3E,W
184E:  MOVWF  05
184F:  MOVF   3D,W
1850:  MOVWF  04
1851:  MOVF   41,W
1852:  MOVWF  00
1853:  MOVF   00,F
1854:  BTFSC  03.2
1855:  GOTO   059
1856:  INCF   3D,F
1857:  INCF   3F,F
1858:  GOTO   047
....................   }   
....................   // }}}   
....................   // Get argument {{{ 
....................   sptr=strtok(0,match_tok); 
1859:  CLRF   3E
185A:  CLRF   3D
185B:  MOVLW  20
185C:  MOVWF  40
185D:  MOVLW  A9
185E:  MOVWF  3F
185F:  MOVLP  08
1860:  MOVLB  00
1861:  CALL   583
1862:  MOVLP  18
1863:  MOVF   79,W
1864:  MOVLB  02
1865:  MOVWF  28
1866:  MOVF   78,W
1867:  MOVWF  27
....................   if (sptr!=0) {; 
1868:  MOVF   27,F
1869:  BTFSS  03.2
186A:  GOTO   06E
186B:  MOVF   28,F
186C:  BTFSC  03.2
186D:  GOTO   088
....................     strcpy(argument_name,sptr); 
186E:  MOVF   28,W
186F:  MOVWF  40
1870:  MOVF   27,W
1871:  MOVWF  3F
1872:  MOVLW  20
1873:  MOVWF  3E
1874:  MOVLW  70
1875:  MOVWF  3D
1876:  MOVF   40,W
1877:  MOVWF  05
1878:  MOVF   3F,W
1879:  MOVWF  04
187A:  MOVF   00,W
187B:  MOVWF  41
187C:  MOVF   3E,W
187D:  MOVWF  05
187E:  MOVF   3D,W
187F:  MOVWF  04
1880:  MOVF   41,W
1881:  MOVWF  00
1882:  MOVF   00,F
1883:  BTFSC  03.2
1884:  GOTO   088
1885:  INCF   3D,F
1886:  INCF   3F,F
1887:  GOTO   076
....................   }   
....................   // }}} 
....................   // Get value {{{ 
....................   sptr=strtok(0,match_tok); 
1888:  CLRF   3E
1889:  CLRF   3D
188A:  MOVLW  20
188B:  MOVWF  40
188C:  MOVLW  A9
188D:  MOVWF  3F
188E:  MOVLP  08
188F:  MOVLB  00
1890:  CALL   583
1891:  MOVLP  18
1892:  MOVF   79,W
1893:  MOVLB  02
1894:  MOVWF  28
1895:  MOVF   78,W
1896:  MOVWF  27
....................   if (sptr!=0) {; 
1897:  MOVF   27,F
1898:  BTFSS  03.2
1899:  GOTO   09D
189A:  MOVF   28,F
189B:  BTFSC  03.2
189C:  GOTO   0C3
....................     strcpy(match_val,sptr); 
189D:  MOVF   28,W
189E:  MOVWF  40
189F:  MOVF   27,W
18A0:  MOVWF  3F
18A1:  MOVLW  20
18A2:  MOVWF  3E
18A3:  MOVLW  B1
18A4:  MOVWF  3D
18A5:  MOVF   40,W
18A6:  MOVWF  05
18A7:  MOVF   3F,W
18A8:  MOVWF  04
18A9:  MOVF   00,W
18AA:  MOVWF  41
18AB:  MOVF   3E,W
18AC:  MOVWF  05
18AD:  MOVF   3D,W
18AE:  MOVWF  04
18AF:  MOVF   41,W
18B0:  MOVWF  00
18B1:  MOVF   00,F
18B2:  BTFSC  03.2
18B3:  GOTO   0B7
18B4:  INCF   3D,F
18B5:  INCF   3F,F
18B6:  GOTO   0A5
....................     value = str_to_decimal(match_val); 
18B7:  MOVLW  20
18B8:  MOVWF  3E
18B9:  MOVLW  B1
18BA:  MOVWF  3D
18BB:  MOVLP  08
18BC:  MOVLB  00
18BD:  CALL   689
18BE:  MOVLP  18
18BF:  MOVF   78,W
18C0:  MOVWF  7E
....................   } else { 
18C1:  GOTO   0C6
18C2:  MOVLB  02
....................     value = 0; 
18C3:  CLRF   7E
....................     do_get_var = 1; 
18C4:  BSF    26.0
18C5:  MOVLB  00
....................   }   
....................   // }}} 
....................   // Check for "SET" command {{{ 
....................   strcpy(smatch_reg,"set");   
18C6:  MOVLB  02
18C7:  CLRF   3D
18C8:  CLRF   3E
18C9:  MOVLW  20
18CA:  MOVWF  05
18CB:  MOVLW  B5
18CC:  MOVWF  04
18CD:  MOVF   3D,W
18CE:  ADDWF  04,F
18CF:  MOVLW  00
18D0:  ADDWFC 05,F
18D1:  MOVF   3E,W
18D2:  MOVLP  00
18D3:  MOVLB  00
18D4:  CALL   146
18D5:  MOVLP  18
18D6:  MOVWF  00
18D7:  IORLW  00
18D8:  BTFSC  03.2
18D9:  GOTO   0DF
18DA:  MOVLB  02
18DB:  INCF   3E,F
18DC:  INCF   3D,F
18DD:  GOTO   0C9
18DE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
18DF:  MOVLW  20
18E0:  MOVLB  02
18E1:  MOVWF  3E
18E2:  MOVLW  B5
18E3:  MOVWF  3D
18E4:  MOVLW  20
18E5:  MOVWF  40
18E6:  MOVLW  9E
18E7:  MOVWF  3F
18E8:  MOVLP  08
18E9:  MOVLB  00
18EA:  CALL   6C2
18EB:  MOVLP  18
18EC:  MOVF   78,F
18ED:  BTFSS  03.2
18EE:  GOTO   0F8
....................     if ( do_get_var ) { 
18EF:  MOVLB  02
18F0:  BTFSS  26.0
18F1:  GOTO   0F5
....................       command=GET_REG; 
18F2:  MOVLW  03
18F3:  MOVWF  70
....................     } else { 
18F4:  GOTO   0F7
....................       command=SET_REG; 
18F5:  MOVLW  02
18F6:  MOVWF  70
18F7:  MOVLB  00
....................     } 
....................   } // }}} 
....................   // Check for "SAVE" command {{{ 
....................   strcpy(smatch_reg,"SAVE");   
18F8:  MOVLB  02
18F9:  CLRF   3D
18FA:  CLRF   3E
18FB:  MOVLW  20
18FC:  MOVWF  05
18FD:  MOVLW  B5
18FE:  MOVWF  04
18FF:  MOVF   3D,W
1900:  ADDWF  04,F
1901:  MOVLW  00
1902:  ADDWFC 05,F
1903:  MOVF   3E,W
1904:  MOVLP  00
1905:  MOVLB  00
1906:  CALL   14B
1907:  MOVLP  18
1908:  MOVWF  00
1909:  IORLW  00
190A:  BTFSC  03.2
190B:  GOTO   111
190C:  MOVLB  02
190D:  INCF   3E,F
190E:  INCF   3D,F
190F:  GOTO   0FB
1910:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1911:  MOVLW  20
1912:  MOVLB  02
1913:  MOVWF  3E
1914:  MOVLW  B5
1915:  MOVWF  3D
1916:  MOVLW  20
1917:  MOVWF  40
1918:  MOVLW  9E
1919:  MOVWF  3F
191A:  MOVLP  08
191B:  MOVLB  00
191C:  CALL   6C2
191D:  MOVLP  18
191E:  MOVF   78,F
191F:  BTFSS  03.2
1920:  GOTO   123
....................       command=SAVE_SETTINGS; 
1921:  MOVLW  04
1922:  MOVWF  70
....................   } // }}} 
....................   // Check for "RESTORE" command {{{ 
....................   strcpy(smatch_reg,"RESTORE");   
1923:  MOVLB  02
1924:  CLRF   3D
1925:  CLRF   3E
1926:  MOVLW  20
1927:  MOVWF  05
1928:  MOVLW  B5
1929:  MOVWF  04
192A:  MOVF   3D,W
192B:  ADDWF  04,F
192C:  MOVLW  00
192D:  ADDWFC 05,F
192E:  MOVF   3E,W
192F:  MOVLP  00
1930:  MOVLB  00
1931:  CALL   151
1932:  MOVLP  18
1933:  MOVWF  00
1934:  IORLW  00
1935:  BTFSC  03.2
1936:  GOTO   13C
1937:  MOVLB  02
1938:  INCF   3E,F
1939:  INCF   3D,F
193A:  GOTO   126
193B:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
193C:  MOVLW  20
193D:  MOVLB  02
193E:  MOVWF  3E
193F:  MOVLW  B5
1940:  MOVWF  3D
1941:  MOVLW  20
1942:  MOVWF  40
1943:  MOVLW  9E
1944:  MOVWF  3F
1945:  MOVLP  08
1946:  MOVLB  00
1947:  CALL   6C2
1948:  MOVLP  18
1949:  MOVF   78,F
194A:  BTFSS  03.2
194B:  GOTO   14E
....................       command=RESTORE_SETTINGS; 
194C:  MOVLW  05
194D:  MOVWF  70
....................   } // }}} 
....................   // Check for "STATUS" command {{{ 
....................   strcpy(smatch_reg,"status");   
194E:  MOVLB  02
194F:  CLRF   3D
1950:  CLRF   3E
1951:  MOVLW  20
1952:  MOVWF  05
1953:  MOVLW  B5
1954:  MOVWF  04
1955:  MOVF   3D,W
1956:  ADDWF  04,F
1957:  MOVLW  00
1958:  ADDWFC 05,F
1959:  MOVF   3E,W
195A:  MOVLP  00
195B:  MOVLB  00
195C:  CALL   15A
195D:  MOVLP  18
195E:  MOVWF  00
195F:  IORLW  00
1960:  BTFSC  03.2
1961:  GOTO   167
1962:  MOVLB  02
1963:  INCF   3E,F
1964:  INCF   3D,F
1965:  GOTO   151
1966:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1967:  MOVLW  20
1968:  MOVLB  02
1969:  MOVWF  3E
196A:  MOVLW  B5
196B:  MOVWF  3D
196C:  MOVLW  20
196D:  MOVWF  40
196E:  MOVLW  9E
196F:  MOVWF  3F
1970:  MOVLP  08
1971:  MOVLB  00
1972:  CALL   6C2
1973:  MOVLP  18
1974:  MOVF   78,F
1975:  BTFSS  03.2
1976:  GOTO   179
....................     command=STATUS; 
1977:  MOVLW  08
1978:  MOVWF  70
....................   } // }}} 
....................   // Check for "reboot" command {{{ 
....................   strcpy(smatch_reg,"reboot");   
1979:  MOVLB  02
197A:  CLRF   3D
197B:  CLRF   3E
197C:  MOVLW  20
197D:  MOVWF  05
197E:  MOVLW  B5
197F:  MOVWF  04
1980:  MOVF   3D,W
1981:  ADDWF  04,F
1982:  MOVLW  00
1983:  ADDWFC 05,F
1984:  MOVF   3E,W
1985:  MOVLP  00
1986:  MOVLB  00
1987:  CALL   162
1988:  MOVLP  18
1989:  MOVWF  00
198A:  IORLW  00
198B:  BTFSC  03.2
198C:  GOTO   192
198D:  MOVLB  02
198E:  INCF   3E,F
198F:  INCF   3D,F
1990:  GOTO   17C
1991:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1992:  MOVLW  20
1993:  MOVLB  02
1994:  MOVWF  3E
1995:  MOVLW  B5
1996:  MOVWF  3D
1997:  MOVLW  20
1998:  MOVWF  40
1999:  MOVLW  9E
199A:  MOVWF  3F
199B:  MOVLP  08
199C:  MOVLB  00
199D:  CALL   6C2
199E:  MOVLP  18
199F:  MOVF   78,F
19A0:  BTFSS  03.2
19A1:  GOTO   1A6
....................     command=ADMIN; 
19A2:  MOVLW  09
19A3:  MOVWF  70
....................     argument=REBOOT; 
19A4:  MOVLW  02
19A5:  MOVWF  7D
....................   } // }}} 
....................   // Check for "dtmf" command {{{ 
....................   strcpy(smatch_reg,"d");   
19A6:  MOVLB  02
19A7:  CLRF   3D
19A8:  CLRF   3E
19A9:  MOVLW  20
19AA:  MOVWF  05
19AB:  MOVLW  B5
19AC:  MOVWF  04
19AD:  MOVF   3D,W
19AE:  ADDWF  04,F
19AF:  MOVLW  00
19B0:  ADDWFC 05,F
19B1:  MOVF   3E,W
19B2:  MOVLP  00
19B3:  MOVLB  00
19B4:  CALL   16A
19B5:  MOVLP  18
19B6:  MOVWF  00
19B7:  IORLW  00
19B8:  BTFSC  03.2
19B9:  GOTO   1BF
19BA:  MOVLB  02
19BB:  INCF   3E,F
19BC:  INCF   3D,F
19BD:  GOTO   1A9
19BE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
19BF:  MOVLW  20
19C0:  MOVLB  02
19C1:  MOVWF  3E
19C2:  MOVLW  B5
19C3:  MOVWF  3D
19C4:  MOVLW  20
19C5:  MOVWF  40
19C6:  MOVLW  9E
19C7:  MOVWF  3F
19C8:  MOVLP  08
19C9:  MOVLB  00
19CA:  CALL   6C2
19CB:  MOVLP  18
19CC:  MOVF   78,F
19CD:  BTFSS  03.2
19CE:  GOTO   220
....................     //command=DTMF_SEND; 
....................     command=0; 
19CF:  CLRF   70
....................     value = str_to_decimal(argument_name); 
19D0:  MOVLW  20
19D1:  MOVLB  02
19D2:  MOVWF  3E
19D3:  MOVLW  70
19D4:  MOVWF  3D
19D5:  MOVLP  08
19D6:  MOVLB  00
19D7:  CALL   689
19D8:  MOVLP  18
19D9:  MOVF   78,W
19DA:  MOVWF  7E
....................     if ( value == d0 ) { 
19DB:  MOVF   7E,W
19DC:  SUBLW  0A
19DD:  BTFSS  03.2
19DE:  GOTO   1E1
....................       value = dd; 
19DF:  CLRF   7E
....................     } else if (value == dd) { 
19E0:  GOTO   1E6
19E1:  MOVF   7E,F
19E2:  BTFSS  03.2
19E3:  GOTO   1E6
....................       value = d0; 
19E4:  MOVLW  0A
19E5:  MOVWF  7E
....................     } 
....................     dtmf_send_digit(value&0x0F); 
19E6:  MOVF   7E,W
19E7:  ANDLW  0F
19E8:  MOVLB  02
19E9:  MOVWF  3D
19EA:  MOVF   3D,W
19EB:  MOVWF  3E
....................   } // }}} 
....................   // Check for "i2c" command {{{ 
....................   strcpy(smatch_reg,"i2c");   
*
1A20:  MOVLB  02
1A21:  CLRF   3D
1A22:  CLRF   3E
1A23:  MOVLW  20
1A24:  MOVWF  05
1A25:  MOVLW  B5
1A26:  MOVWF  04
1A27:  MOVF   3D,W
1A28:  ADDWF  04,F
1A29:  MOVLW  00
1A2A:  ADDWFC 05,F
1A2B:  MOVF   3E,W
1A2C:  MOVLP  00
1A2D:  MOVLB  00
1A2E:  CALL   16D
1A2F:  MOVLP  18
1A30:  MOVWF  00
1A31:  IORLW  00
1A32:  BTFSC  03.2
1A33:  GOTO   239
1A34:  MOVLB  02
1A35:  INCF   3E,F
1A36:  INCF   3D,F
1A37:  GOTO   223
1A38:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A39:  MOVLW  20
1A3A:  MOVLB  02
1A3B:  MOVWF  3E
1A3C:  MOVLW  B5
1A3D:  MOVWF  3D
1A3E:  MOVLW  20
1A3F:  MOVWF  40
1A40:  MOVLW  9E
1A41:  MOVWF  3F
1A42:  MOVLP  08
1A43:  MOVLB  00
1A44:  CALL   6C2
1A45:  MOVLP  18
1A46:  MOVF   78,F
1A47:  BTFSS  03.2
1A48:  GOTO   24B
....................     command=I2C_SEND; 
1A49:  MOVLW  0C
1A4A:  MOVWF  70
....................   } // }}} 
....................   // Check for "morse" command {{{ 
....................   // morse [0..35] --> send 0-9 or a-z in morse 
....................   // morse[36]     --> Silence 
....................   // morse <value> 37 --> send site ID 
....................   strcpy(smatch_reg,"morse");   
1A4B:  MOVLB  02
1A4C:  CLRF   3D
1A4D:  CLRF   3E
1A4E:  MOVLW  20
1A4F:  MOVWF  05
1A50:  MOVLW  B5
1A51:  MOVWF  04
1A52:  MOVF   3D,W
1A53:  ADDWF  04,F
1A54:  MOVLW  00
1A55:  ADDWFC 05,F
1A56:  MOVF   3E,W
1A57:  MOVLP  00
1A58:  MOVLB  00
1A59:  CALL   172
1A5A:  MOVLP  18
1A5B:  MOVWF  00
1A5C:  IORLW  00
1A5D:  BTFSC  03.2
1A5E:  GOTO   264
1A5F:  MOVLB  02
1A60:  INCF   3E,F
1A61:  INCF   3D,F
1A62:  GOTO   24E
1A63:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1A64:  MOVLW  20
1A65:  MOVLB  02
1A66:  MOVWF  3E
1A67:  MOVLW  B5
1A68:  MOVWF  3D
1A69:  MOVLW  20
1A6A:  MOVWF  40
1A6B:  MOVLW  9E
1A6C:  MOVWF  3F
1A6D:  MOVLP  08
1A6E:  MOVLB  00
1A6F:  CALL   6C2
1A70:  MOVLP  18
1A71:  MOVF   78,F
1A72:  BTFSS  03.2
1A73:  GOTO   28B
....................     value = str_to_decimal(argument_name); 
1A74:  MOVLW  20
1A75:  MOVLB  02
1A76:  MOVWF  3E
1A77:  MOVLW  70
1A78:  MOVWF  3D
1A79:  MOVLP  08
1A7A:  MOVLB  00
1A7B:  CALL   689
1A7C:  MOVLP  18
1A7D:  MOVF   78,W
1A7E:  MOVWF  7E
....................     if ( value < MORSE_CHAR_ARRAY_LENGTH ) { 
1A7F:  MOVF   7E,W
1A80:  SUBLW  24
1A81:  BTFSS  03.0
1A82:  GOTO   287
....................       argument = 0; 
1A83:  CLRF   7D
....................       command  = MORSE_SEND; 
1A84:  MOVLW  0B
1A85:  MOVWF  70
....................     } else { 
1A86:  GOTO   28B
....................       command  = ADMIN; 
1A87:  MOVLW  09
1A88:  MOVWF  70
....................       argument = SEND_MORSE_ID; 
1A89:  MOVLW  03
1A8A:  MOVWF  7D
....................     } 
....................   } // }}} 
....................   // Check for "+ (INCR)" command {{{ 
....................   strcpy(smatch_reg,"+");   
1A8B:  MOVLB  02
1A8C:  CLRF   3D
1A8D:  CLRF   3E
1A8E:  MOVLW  20
1A8F:  MOVWF  05
1A90:  MOVLW  B5
1A91:  MOVWF  04
1A92:  MOVF   3D,W
1A93:  ADDWF  04,F
1A94:  MOVLW  00
1A95:  ADDWFC 05,F
1A96:  MOVF   3E,W
1A97:  MOVLP  00
1A98:  MOVLB  00
1A99:  CALL   179
1A9A:  MOVLP  18
1A9B:  MOVWF  00
1A9C:  IORLW  00
1A9D:  BTFSC  03.2
1A9E:  GOTO   2A4
1A9F:  MOVLB  02
1AA0:  INCF   3E,F
1AA1:  INCF   3D,F
1AA2:  GOTO   28E
1AA3:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AA4:  MOVLW  20
1AA5:  MOVLB  02
1AA6:  MOVWF  3E
1AA7:  MOVLW  B5
1AA8:  MOVWF  3D
1AA9:  MOVLW  20
1AAA:  MOVWF  40
1AAB:  MOVLW  9E
1AAC:  MOVWF  3F
1AAD:  MOVLP  08
1AAE:  MOVLB  00
1AAF:  CALL   6C2
1AB0:  MOVLP  18
1AB1:  MOVF   78,F
1AB2:  BTFSS  03.2
1AB3:  GOTO   2B6
....................     command=INCREMENT_REG; 
1AB4:  MOVLW  06
1AB5:  MOVWF  70
....................   } // }}} 
....................   // Check for "- (DECR)" command {{{ 
....................   strcpy(smatch_reg,"-");   
1AB6:  MOVLB  02
1AB7:  CLRF   3D
1AB8:  CLRF   3E
1AB9:  MOVLW  20
1ABA:  MOVWF  05
1ABB:  MOVLW  B5
1ABC:  MOVWF  04
1ABD:  MOVF   3D,W
1ABE:  ADDWF  04,F
1ABF:  MOVLW  00
1AC0:  ADDWFC 05,F
1AC1:  MOVF   3E,W
1AC2:  MOVLP  00
1AC3:  MOVLB  00
1AC4:  CALL   17C
1AC5:  MOVLP  18
1AC6:  MOVWF  00
1AC7:  IORLW  00
1AC8:  BTFSC  03.2
1AC9:  GOTO   2CF
1ACA:  MOVLB  02
1ACB:  INCF   3E,F
1ACC:  INCF   3D,F
1ACD:  GOTO   2B9
1ACE:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1ACF:  MOVLW  20
1AD0:  MOVLB  02
1AD1:  MOVWF  3E
1AD2:  MOVLW  B5
1AD3:  MOVWF  3D
1AD4:  MOVLW  20
1AD5:  MOVWF  40
1AD6:  MOVLW  9E
1AD7:  MOVWF  3F
1AD8:  MOVLP  08
1AD9:  MOVLB  00
1ADA:  CALL   6C2
1ADB:  MOVLP  18
1ADC:  MOVF   78,F
1ADD:  BTFSS  03.2
1ADE:  GOTO   2E1
....................     command=DECREMENT_REG; 
1ADF:  MOVLW  07
1AE0:  MOVWF  70
....................   } // }}} 
....................   // Check for "n (Next CPOT)" command {{{ 
....................   strcpy(smatch_reg,"n");   
1AE1:  MOVLB  02
1AE2:  CLRF   3D
1AE3:  CLRF   3E
1AE4:  MOVLW  20
1AE5:  MOVWF  05
1AE6:  MOVLW  B5
1AE7:  MOVWF  04
1AE8:  MOVF   3D,W
1AE9:  ADDWF  04,F
1AEA:  MOVLW  00
1AEB:  ADDWFC 05,F
1AEC:  MOVF   3E,W
1AED:  MOVLP  00
1AEE:  MOVLB  00
1AEF:  CALL   17F
1AF0:  MOVLP  18
1AF1:  MOVWF  00
1AF2:  IORLW  00
1AF3:  BTFSC  03.2
1AF4:  GOTO   2FA
1AF5:  MOVLB  02
1AF6:  INCF   3E,F
1AF7:  INCF   3D,F
1AF8:  GOTO   2E4
1AF9:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1AFA:  MOVLW  20
1AFB:  MOVLB  02
1AFC:  MOVWF  3E
1AFD:  MOVLW  B5
1AFE:  MOVWF  3D
1AFF:  MOVLW  20
1B00:  MOVWF  40
1B01:  MOVLW  9E
1B02:  MOVWF  3F
1B03:  MOVLP  08
1B04:  MOVLB  00
1B05:  CALL   6C2
1B06:  MOVLP  18
1B07:  MOVF   78,F
1B08:  BTFSS  03.2
1B09:  GOTO   329
....................     command=SET_REG; 
1B0A:  MOVLW  02
1B0B:  MOVWF  70
....................     value = (CurrentTrimPot + 1)&0x03; 
1B0C:  MOVLW  01
1B0D:  ADDWF  76,W
1B0E:  ANDLW  03
1B0F:  MOVWF  7E
....................     strcpy(argument_name,"CPOT"); 
1B10:  MOVLB  02
1B11:  CLRF   3D
1B12:  CLRF   3E
1B13:  MOVLW  20
1B14:  MOVWF  05
1B15:  MOVLW  70
1B16:  MOVWF  04
1B17:  MOVF   3D,W
1B18:  ADDWF  04,F
1B19:  MOVLW  00
1B1A:  ADDWFC 05,F
1B1B:  MOVF   3E,W
1B1C:  MOVLP  00
1B1D:  MOVLB  00
1B1E:  CALL   182
1B1F:  MOVLP  18
1B20:  MOVWF  00
1B21:  IORLW  00
1B22:  BTFSC  03.2
1B23:  GOTO   329
1B24:  MOVLB  02
1B25:  INCF   3E,F
1B26:  INCF   3D,F
1B27:  GOTO   313
1B28:  MOVLB  00
....................   } // }}} 
....................   // AdminMode toggle Check for "admin" command {{{ 
....................   strcpy(smatch_reg,"admin");   
1B29:  MOVLB  02
1B2A:  CLRF   3D
1B2B:  CLRF   3E
1B2C:  MOVLW  20
1B2D:  MOVWF  05
1B2E:  MOVLW  B5
1B2F:  MOVWF  04
1B30:  MOVF   3D,W
1B31:  ADDWF  04,F
1B32:  MOVLW  00
1B33:  ADDWFC 05,F
1B34:  MOVF   3E,W
1B35:  MOVLP  00
1B36:  MOVLB  00
1B37:  CALL   188
1B38:  MOVLP  18
1B39:  MOVWF  00
1B3A:  IORLW  00
1B3B:  BTFSC  03.2
1B3C:  GOTO   342
1B3D:  MOVLB  02
1B3E:  INCF   3E,F
1B3F:  INCF   3D,F
1B40:  GOTO   32C
1B41:  MOVLB  00
....................   if ( my_stricmp(smatch_reg,verb) == 0 ) { 
1B42:  MOVLW  20
1B43:  MOVLB  02
1B44:  MOVWF  3E
1B45:  MOVLW  B5
1B46:  MOVWF  3D
1B47:  MOVLW  20
1B48:  MOVWF  40
1B49:  MOVLW  9E
1B4A:  MOVWF  3F
1B4B:  MOVLP  08
1B4C:  MOVLB  00
1B4D:  CALL   6C2
1B4E:  MOVLP  18
1B4F:  MOVF   78,F
1B50:  BTFSS  03.2
1B51:  GOTO   362
....................     AdminMode = ~AdminMode; 
1B52:  MOVLW  20
1B53:  MOVLB  01
1B54:  XORWF  61,F
....................     set_admin_mode(AdminMode); 
1B55:  MOVLW  00
1B56:  BTFSC  61.5
1B57:  MOVLW  01
1B58:  MOVLB  02
1B59:  MOVWF  3D
1B5A:  MOVWF  3E
1B5B:  MOVLP  08
1B5C:  MOVLB  00
1B5D:  CALL   4A9
1B5E:  MOVLP  18
....................     PROMPT_FLAG = 1; 
1B5F:  MOVLB  01
1B60:  BSF    61.4
1B61:  MOVLB  00
....................   } // }}} 
.................... } // }}} 
.................... void set_var (void) { // {{{ 
....................   // This function sets the specified register if a value is specified. 
....................   // Otherwise it displays it. 
....................   int *pObj; 
....................   int lVar; 
....................   if ( value == -1 ) { 
*
10AD:  MOVF   7E,W
10AE:  SUBLW  FF
10AF:  BTFSS  03.2
10B0:  GOTO   0D7
....................     printf ("\n\r%s %u",argument,value); 
10B1:  MOVLW  0A
10B2:  CLRWDT
10B3:  BTFSS  11.4
10B4:  GOTO   0B2
10B5:  MOVLB  03
10B6:  MOVWF  1A
10B7:  MOVLW  0D
10B8:  CLRWDT
10B9:  MOVLB  00
10BA:  BTFSC  11.4
10BB:  GOTO   0BE
10BC:  MOVLB  03
10BD:  GOTO   0B8
10BE:  MOVLB  03
10BF:  MOVWF  1A
10C0:  CLRF   05
10C1:  MOVF   7D,W
10C2:  MOVWF  04
10C3:  MOVLP  08
10C4:  MOVLB  00
10C5:  CALL   256
10C6:  MOVLP  10
10C7:  MOVLW  20
10C8:  CLRWDT
10C9:  BTFSS  11.4
10CA:  GOTO   0C8
10CB:  MOVLB  03
10CC:  MOVWF  1A
10CD:  MOVF   7E,W
10CE:  MOVLB  02
10CF:  MOVWF  4E
10D0:  MOVLW  1B
10D1:  MOVWF  4F
10D2:  MOVLP  00
10D3:  MOVLB  00
10D4:  CALL   73C
10D5:  MOVLP  10
....................   } else { 
10D6:  GOTO   176
....................     pObj=RegMap[argument].reg_ptr; 
10D7:  RLF    7D,W
10D8:  MOVWF  77
10D9:  RLF    77,F
10DA:  MOVLW  FC
10DB:  ANDWF  77,F
10DC:  MOVF   77,W
10DD:  MOVLB  02
10DE:  MOVWF  2D
10DF:  INCF   2D,W
10E0:  MOVLP  00
10E1:  MOVLB  00
10E2:  CALL   043
10E3:  MOVLP  10
10E4:  MOVWF  7A
10E5:  MOVLB  02
10E6:  MOVF   2D,W
10E7:  MOVLP  00
10E8:  MOVLB  00
10E9:  CALL   043
10EA:  MOVLP  10
10EB:  MOVLB  02
10EC:  MOVWF  2A
10ED:  MOVF   7A,W
10EE:  MOVWF  2B
....................     // Consider allowing some registers to be updated outside AdminMode. 
....................     // Example : AuxOut registers, Enable 
....................     if ( in_admin_mode() || (RegMap[argument].usage==PUBLIC) ) { 
10EF:  MOVLP  08
10F0:  MOVLB  00
10F1:  CALL   72A
10F2:  MOVLP  10
10F3:  MOVF   78,F
10F4:  BTFSS  03.2
10F5:  GOTO   103
10F6:  RLF    7D,W
10F7:  MOVWF  77
10F8:  RLF    77,F
10F9:  MOVLW  FC
10FA:  ANDWF  77,F
10FB:  MOVF   77,W
10FC:  ADDLW  03
10FD:  MOVLP  00
10FE:  CALL   043
10FF:  MOVLP  10
1100:  MOVWF  78
1101:  BTFSC  78.1
1102:  GOTO   10B
....................       *pObj=value; 
1103:  MOVLB  02
1104:  MOVF   2A,W
1105:  MOVWF  04
1106:  MOVF   2B,W
1107:  MOVWF  05
1108:  MOVF   7E,W
1109:  MOVWF  00
110A:  MOVLB  00
....................     } 
....................     lVar = *pObj; 
110B:  MOVLB  02
110C:  MOVF   2A,W
110D:  MOVWF  04
110E:  MOVF   2B,W
110F:  MOVWF  05
1110:  MOVF   00,W
1111:  MOVWF  2C
....................     LastRegisterIndex = argument; 
1112:  MOVF   7D,W
1113:  MOVLB  01
1114:  MOVWF  5B
....................     LastRegisterIndexValid=1; 
1115:  MOVLW  01
1116:  MOVWF  5C
....................     printf ("\n\rSetting %s(%u) to %u",argument_name,argument,lVar); 
1117:  MOVLW  9E
1118:  MOVLB  03
1119:  MOVWF  11
111A:  MOVLW  04
111B:  MOVWF  12
111C:  BCF    03.0
111D:  MOVLW  0A
111E:  MOVLB  02
111F:  MOVWF  4E
1120:  MOVLP  00
1121:  MOVLB  00
1122:  CALL   6C8
1123:  MOVLP  10
1124:  MOVLW  20
1125:  MOVWF  05
1126:  MOVLW  70
1127:  MOVWF  04
1128:  MOVLP  08
1129:  CALL   256
112A:  MOVLP  10
112B:  MOVLW  28
112C:  CLRWDT
112D:  BTFSS  11.4
112E:  GOTO   12C
112F:  MOVLB  03
1130:  MOVWF  1A
1131:  MOVF   7D,W
1132:  MOVLB  02
1133:  MOVWF  4E
1134:  MOVLW  1B
1135:  MOVWF  4F
1136:  MOVLP  00
1137:  MOVLB  00
1138:  CALL   73C
1139:  MOVLP  10
113A:  MOVLW  A5
113B:  MOVLB  03
113C:  MOVWF  11
113D:  MOVLW  04
113E:  MOVWF  12
113F:  BSF    03.0
1140:  MOVLW  05
1141:  MOVLB  02
1142:  MOVWF  4E
1143:  MOVLP  00
1144:  MOVLB  00
1145:  CALL   6C8
1146:  MOVLP  10
1147:  MOVLB  02
1148:  MOVF   2C,W
1149:  MOVWF  4E
114A:  MOVLW  1B
114B:  MOVWF  4F
114C:  MOVLP  00
114D:  MOVLB  00
114E:  CALL   73C
114F:  MOVLP  10
....................     if ( (pObj >= &RX_GAIN[0][0] && pObj <= &RX_GAIN[3][3]) || pObj == &CurrentTrimPot ) { 
1150:  MOVLB  02
1151:  MOVF   2B,W
1152:  SUBLW  1F
1153:  BTFSC  03.0
1154:  GOTO   166
1155:  XORLW  FF
1156:  BTFSS  03.2
1157:  GOTO   15C
1158:  MOVF   2A,W
1159:  SUBLW  0B
115A:  BTFSC  03.0
115B:  GOTO   166
115C:  MOVF   2B,W
115D:  SUBLW  20
115E:  BTFSS  03.0
115F:  GOTO   166
1160:  BTFSS  03.2
1161:  GOTO   16D
1162:  MOVF   2A,W
1163:  SUBLW  1B
1164:  BTFSC  03.0
1165:  GOTO   16D
1166:  MOVF   2A,W
1167:  SUBLW  76
1168:  BTFSS  03.2
1169:  GOTO   173
116A:  MOVF   2B,F
116B:  BTFSS  03.2
116C:  GOTO   173
....................       increment(0); // Increment is done in this function. Only update trim pot. 
116D:  CLRF   2D
116E:  MOVLP  08
116F:  MOVLB  00
1170:  CALL   739
1171:  MOVLP  10
1172:  MOVLB  02
....................     } 
....................     PROMPT_FLAG=1; 
1173:  MOVLB  01
1174:  BSF    61.4
1175:  MOVLB  00
....................   } 
.................... } // }}} 
.................... void increment(int incr) { // {{{ 
....................   int8 *pot_ptr; 
....................   int8 value; 
....................   char CPotPtr; 
....................   CPotPtr=CurrentTrimPot & 0x03; 
*
0F39:  MOVF   76,W
0F3A:  ANDLW  03
0F3B:  MOVLB  02
0F3C:  MOVWF  31
....................   if ( CurrentCorIndex ) { 
0F3D:  MOVLB  00
0F3E:  MOVF   6F,F
0F3F:  BTFSC  03.2
0F40:  GOTO   778
....................     pot_ptr=&RX_GAIN[CurrentCorIndex-1][CPotPtr]; 
0F41:  MOVLW  01
0F42:  SUBWF  6F,W
0F43:  MOVWF  77
0F44:  RLF    77,F
0F45:  RLF    77,F
0F46:  MOVLW  FC
0F47:  ANDWF  77,F
0F48:  MOVF   77,W
0F49:  MOVLB  02
0F4A:  ADDWF  31,W
0F4B:  ADDLW  0C
0F4C:  MOVWF  78
0F4D:  MOVLW  20
0F4E:  MOVWF  7A
0F4F:  BTFSC  03.0
0F50:  INCF   7A,F
0F51:  MOVF   78,W
0F52:  MOVWF  2E
0F53:  MOVF   7A,W
0F54:  MOVWF  2F
....................     value = *pot_ptr; 
0F55:  MOVF   2E,W
0F56:  MOVWF  04
0F57:  MOVF   2F,W
0F58:  MOVWF  05
0F59:  MOVF   00,W
0F5A:  MOVWF  30
....................     // Do not exceed 63 during increment or 0 during decrement 
....................     *pot_ptr = value + incr; 
0F5B:  MOVF   2E,W
0F5C:  MOVWF  04
0F5D:  MOVF   2F,W
0F5E:  MOVWF  05
0F5F:  MOVF   2D,W
0F60:  ADDWF  30,W
0F61:  MOVWF  00
....................     if ( in_admin_mode() ) { 
0F62:  MOVLB  00
0F63:  CALL   72A
0F64:  MOVF   78,F
0F65:  BTFSC  03.2
0F66:  GOTO   778
....................       set_trimpot(CPotPtr,*pot_ptr); 
0F67:  MOVLB  02
0F68:  MOVF   2F,W
0F69:  MOVWF  7A
0F6A:  MOVF   2E,W
0F6B:  MOVWF  04
0F6C:  MOVF   2F,W
0F6D:  MOVWF  05
0F6E:  MOVF   00,W
0F6F:  MOVWF  32
0F70:  MOVF   31,W
0F71:  MOVWF  3D
0F72:  MOVF   32,W
0F73:  MOVWF  3E
0F74:  MOVLP  00
0F75:  MOVLB  00
0F76:  CALL   78B
0F77:  MOVLP  08
....................     } 
....................   } 
....................   pot_values_to_lcd(); 
0F78:  CALL   270
.................... } // }}} 
0F79:  RETURN
.................... void romstrcpy(char *dest,rom char *src) { // {{{ 
*
0F01:  MOVLB  02
0F02:  CLRF   3D
....................   int c=0; 
....................   while(c<REG_NAME_SIZE) { 
0F03:  MOVF   3D,W
0F04:  SUBLW  05
0F05:  BTFSS  03.0
0F06:  GOTO   728
....................     dest[c]=src[c]; 
0F07:  MOVF   3D,W
0F08:  ADDWF  39,W
0F09:  MOVWF  78
0F0A:  MOVLW  00
0F0B:  ADDWFC 3A,W
0F0C:  MOVWF  7A
0F0D:  MOVF   78,W
0F0E:  MOVWF  3E
0F0F:  MOVF   7A,W
0F10:  MOVWF  3F
0F11:  MOVF   3D,W
0F12:  ADDWF  3B,W
0F13:  MOVWF  78
0F14:  MOVLW  00
0F15:  ADDWFC 3C,W
0F16:  MOVWF  7A
0F17:  MOVF   78,W
0F18:  MOVLB  03
0F19:  MOVWF  11
0F1A:  MOVF   7A,W
0F1B:  MOVWF  12
0F1C:  MOVLB  02
0F1D:  MOVF   3F,W
0F1E:  MOVWF  05
0F1F:  MOVF   3E,W
0F20:  MOVWF  04
0F21:  MOVLW  01
0F22:  MOVWF  43
0F23:  MOVLB  00
0F24:  CALL   019
....................   c++; 
0F25:  MOVLB  02
0F26:  INCF   3D,F
....................   } 
0F27:  GOTO   703
.................... } // }}} 
0F28:  MOVLB  00
0F29:  RETURN
.................... void ExecAuxOutOp(int op,int arg,int ID) { // {{{ 
....................   char larg,uarg; // Lower and upper nibbles 
....................   larg = arg & 0x0F; 
*
1C66:  MOVF   28,W
1C67:  ANDLW  0F
1C68:  MOVWF  2A
....................   uarg = (arg & 0xF0) >> 4; 
1C69:  MOVF   28,W
1C6A:  ANDLW  F0
1C6B:  MOVWF  77
1C6C:  SWAPF  77,W
1C6D:  MOVWF  2B
1C6E:  MOVLW  0F
1C6F:  ANDWF  2B,F
....................   switch(op) { 
1C70:  MOVF   27,W
1C71:  XORLW  01
1C72:  MOVLB  00
1C73:  BTFSC  03.2
1C74:  GOTO   47C
1C75:  XORLW  03
1C76:  BTFSC  03.2
1C77:  GOTO   48F
1C78:  XORLW  01
1C79:  BTFSC  03.2
1C7A:  GOTO   4A9
1C7B:  GOTO   4C6
....................     case AUX_OUT_FOLLOW_COR:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       AuxOut[ID] = ((COR_IN_EFFECTIVE ^ uarg) & larg) != 0; 
1C7C:  MOVLW  22
1C7D:  MOVLB  02
1C7E:  ADDWF  29,W
1C7F:  MOVWF  04
1C80:  MOVLW  20
1C81:  MOVWF  05
1C82:  BTFSC  03.0
1C83:  INCF   05,F
1C84:  MOVF   72,W
1C85:  XORWF  2B,W
1C86:  ANDWF  2A,W
1C87:  BTFSS  03.2
1C88:  GOTO   48B
1C89:  MOVLW  00
1C8A:  GOTO   48C
1C8B:  MOVLW  01
1C8C:  MOVWF  00
....................     break; 
1C8D:  MOVLB  00
1C8E:  GOTO   4C6
....................     case AUX_OUT_FOLLOW_AUX_IN: 
....................       // Lower argument (larg) enables the comparison (bitwise enable) 
....................       // Upper argument (uarg) inverts the output (bitwise invert selection) 
....................       AuxOut[ID] = ((AuxInSW & larg) ^ uarg)!=0; 
1C8F:  MOVLW  22
1C90:  MOVLB  02
1C91:  ADDWF  29,W
1C92:  MOVWF  04
1C93:  MOVLW  20
1C94:  MOVWF  05
1C95:  BTFSC  03.0
1C96:  INCF   05,F
1C97:  MOVF   2A,W
1C98:  ANDLW  1F
1C99:  MOVWF  2F
1C9A:  MOVF   7A,W
1C9B:  MOVWF  30
1C9C:  MOVF   2B,W
1C9D:  XORWF  2F,F
1C9E:  BTFSS  03.2
1C9F:  GOTO   4A5
1CA0:  MOVF   30,F
1CA1:  BTFSS  03.2
1CA2:  GOTO   4A5
1CA3:  MOVLW  00
1CA4:  GOTO   4A6
1CA5:  MOVLW  01
1CA6:  MOVWF  00
....................     break; 
1CA7:  MOVLB  00
1CA8:  GOTO   4C6
....................     case AUX_OUT_FOLLOW_COR_DELAY:  
....................       // Invert AuxIn value if argument 1 is set 
....................       // Check what is the effective COR_IN. Many COR_INs can be applied but  
....................       // Only one is really effective and used to drive PTTs 
....................       int1 cor_active = ((COR_IN_EFFECTIVE ^ uarg) & larg) != 0; 
....................       int1 pin_value; 
1CA9:  MOVLB  02
1CAA:  BCF    2C.0
1CAB:  MOVF   72,W
1CAC:  XORWF  2B,W
1CAD:  ANDWF  2A,W
1CAE:  BTFSS  03.2
1CAF:  BSF    2C.0
....................       if ( cor_active ) { 
1CB0:  BTFSS  2C.0
1CB1:  GOTO   4B6
....................         pin_value = 1; 
1CB2:  BSF    2C.1
....................         AuxOutDelayCnt = 60; 
1CB3:  MOVLW  3C
1CB4:  MOVWF  7C
....................       } else { 
1CB5:  GOTO   4BA
....................         pin_value = (AuxOutDelayCnt != 0); 
1CB6:  BCF    2C.1
1CB7:  MOVF   7C,F
1CB8:  BTFSS  03.2
1CB9:  BSF    2C.1
....................       } 
....................       AuxOut[ID] = pin_value; 
1CBA:  MOVLW  22
1CBB:  ADDWF  29,W
1CBC:  MOVWF  04
1CBD:  MOVLW  20
1CBE:  MOVWF  05
1CBF:  BTFSC  03.0
1CC0:  INCF   05,F
1CC1:  MOVLW  00
1CC2:  BTFSC  2C.1
1CC3:  MOVLW  01
1CC4:  MOVWF  00
....................     break; 
1CC5:  MOVLB  00
....................   } 
.................... } // }}} 
.................... char str_to_decimal(char *str) { // {{{ 
*
0E89:  MOVLB  02
0E8A:  CLRF   3F
0E8B:  CLRF   40
....................   // Convert string to unsigned integer 
....................   int x=0; 
....................   char value=0; 
....................   while(str[x]!=0 && str[x] >= '0' && str[x] <= '9') { 
0E8C:  MOVF   3F,W
0E8D:  ADDWF  3D,W
0E8E:  MOVWF  04
0E8F:  MOVLW  00
0E90:  ADDWFC 3E,W
0E91:  MOVWF  05
0E92:  MOVF   00,F
0E93:  BTFSC  03.2
0E94:  GOTO   6BE
0E95:  MOVF   3F,W
0E96:  ADDWF  3D,W
0E97:  MOVWF  04
0E98:  MOVLW  00
0E99:  ADDWFC 3E,W
0E9A:  MOVWF  05
0E9B:  MOVF   00,W
0E9C:  SUBLW  2F
0E9D:  BTFSC  03.0
0E9E:  GOTO   6BE
0E9F:  MOVF   3F,W
0EA0:  ADDWF  3D,W
0EA1:  MOVWF  04
0EA2:  MOVLW  00
0EA3:  ADDWFC 3E,W
0EA4:  MOVWF  05
0EA5:  MOVF   00,W
0EA6:  SUBLW  39
0EA7:  BTFSS  03.0
0EA8:  GOTO   6BE
....................     value = (value * 10) + (str[x]-'0'); 
0EA9:  MOVF   40,W
0EAA:  MOVWF  41
0EAB:  MOVLW  0A
0EAC:  MOVWF  42
0EAD:  MOVLB  00
0EAE:  CALL   662
0EAF:  MOVF   78,W
0EB0:  MOVLB  02
0EB1:  MOVWF  41
0EB2:  MOVF   3F,W
0EB3:  ADDWF  3D,W
0EB4:  MOVWF  04
0EB5:  MOVLW  00
0EB6:  ADDWFC 3E,W
0EB7:  MOVWF  05
0EB8:  MOVLW  30
0EB9:  SUBWF  00,W
0EBA:  ADDWF  41,W
0EBB:  MOVWF  40
....................     x++; 
0EBC:  INCF   3F,F
....................   } 
0EBD:  GOTO   68C
....................   return(value); 
0EBE:  MOVF   40,W
0EBF:  MOVWF  78
.................... } // }}} 
0EC0:  MOVLB  00
0EC1:  RETURN
.................... void ExecAuxInOp(int op,int arg,int ID) { // {{{ 
....................   int1 in_bit; 
....................   int1 tmp_bit; 
....................   in_bit = AuxInSW[ID]!=0; 
*
1653:  MOVLB  02
1654:  BCF    2A.0
1655:  MOVLW  1F
1656:  ADDWF  29,W
1657:  MOVWF  04
1658:  MOVLW  20
1659:  MOVWF  05
165A:  BTFSC  03.0
165B:  INCF   05,F
165C:  MOVF   00,F
165D:  BTFSS  03.2
165E:  BSF    2A.0
....................   char larg,uarg; // Lower and upper nibbles 
....................   // Include arg[4] for COR4 emulation 
....................   larg = arg & 0x1F; 
165F:  MOVF   28,W
1660:  ANDLW  1F
1661:  MOVWF  2B
....................   uarg = (arg & 0xF0) >> 4; 
1662:  MOVF   28,W
1663:  ANDLW  F0
1664:  MOVWF  77
1665:  SWAPF  77,W
1666:  MOVWF  2C
1667:  MOVLW  0F
1668:  ANDWF  2C,F
....................   switch(op) { 
1669:  MOVLW  01
166A:  SUBWF  27,W
166B:  ADDLW  FC
166C:  BTFSC  03.0
166D:  GOTO   6BA
166E:  ADDLW  04
166F:  MOVLB  00
1670:  GOTO   6BD
.................... // Must add a method to reset the Enable_Mask to 0x0F when 
.................... // the operator is not AUXI_ENABLE 
....................     case AUXI_ENABLE:  
....................       if (in_bit) { // Enable 
1671:  MOVLB  02
1672:  BTFSS  2A.0
1673:  GOTO   679
....................         Enable_Mask &= arg; 
1674:  MOVF   28,W
1675:  MOVLB  00
1676:  ANDWF  61,F
....................       } else { // AuxIn is not enabled 
1677:  GOTO   67E
1678:  MOVLB  02
....................         Enable_Mask |= (~arg & 0x0F); 
1679:  MOVF   28,W
167A:  XORLW  FF
167B:  ANDLW  0F
167C:  MOVLB  00
167D:  IORWF  61,F
....................       } 
....................       break; 
167E:  MOVLB  02
167F:  GOTO   6BA
....................     case AUXI_TAIL_WHEN_HI: 
....................       if ( in_bit ) { 
1680:  MOVLB  02
1681:  BTFSS  2A.0
1682:  GOTO   689
....................         COR_DROP_FLAG=1; 
1683:  BSF    74.5
....................         TailChar=arg; 
1684:  MOVF   28,W
1685:  MOVLB  00
1686:  MOVWF  6C
....................       } else { 
1687:  GOTO   68B
1688:  MOVLB  02
....................         TailChar=0; 
1689:  MOVLB  00
168A:  CLRF   6C
....................       } 
....................     break; 
168B:  MOVLB  02
168C:  GOTO   6BA
....................     case AUXI_TAIL_WHEN_LO: 
....................       if ( in_bit==0 ) { 
168D:  MOVLB  02
168E:  BTFSC  2A.0
168F:  GOTO   696
....................         COR_DROP_FLAG=1; 
1690:  BSF    74.5
....................         TailChar=arg; 
1691:  MOVF   28,W
1692:  MOVLB  00
1693:  MOVWF  6C
....................       } else { 
1694:  GOTO   698
1695:  MOVLB  02
....................         TailChar=0; 
1696:  MOVLB  00
1697:  CLRF   6C
....................       } 
....................     break; 
1698:  MOVLB  02
1699:  GOTO   6BA
....................     case AUXI_EMULATE_COR: 
....................       int1 active_low = (arg & AUXI_EMULATE_COR_ACTIVE_LO) != 0; 
169A:  MOVLB  02
169B:  BCF    2A.2
169C:  MOVF   28,W
169D:  ANDLW  20
169E:  BTFSS  03.2
169F:  BSF    2A.2
....................       tmp_bit = (active_low ^ in_bit); 
16A0:  MOVLW  00
16A1:  BTFSC  2A.2
16A2:  MOVLW  01
16A3:  MOVWF  2E
16A4:  MOVLW  00
16A5:  BTFSC  2A.0
16A6:  MOVLW  01
16A7:  XORWF  2E,W
16A8:  MOVWF  78
16A9:  BCF    2A.1
16AA:  BTFSC  78.0
16AB:  BSF    2A.1
....................       if ( tmp_bit ) { 
16AC:  BTFSS  2A.1
16AD:  GOTO   6B3
....................         COR_AUX |= larg; 
16AE:  MOVF   2B,W
16AF:  MOVLB  00
16B0:  IORWF  6B,F
....................       } else { 
16B1:  GOTO   6B7
16B2:  MOVLB  02
....................         COR_AUX &= ~larg; 
16B3:  MOVF   2B,W
16B4:  XORLW  FF
16B5:  MOVLB  00
16B6:  ANDWF  6B,F
....................       } 
....................     break; 
16B7:  MOVLB  02
16B8:  GOTO   6BA
16B9:  MOVLB  02
....................   } 
.................... } // }}} 
16BA:  MOVLP  18
16BB:  MOVLB  00
16BC:  GOTO   538 (RETURN)
.................... void update_aux_in(void) { // {{{ 
....................   int x; 
....................   for(x=0;x<3;x++) { 
*
14F1:  MOVLB  01
14F2:  CLRF   64
14F3:  MOVF   64,W
14F4:  SUBLW  02
14F5:  BTFSS  03.0
14F6:  GOTO   536
....................     // AuxIn is enabled via RS232 only for test/emulation purpose 
....................     AuxInSW[x] = ((input(AUX_IN_PIN[x])!=0 )|| (AuxIn[x]!=0)); 
14F7:  MOVLW  1F
14F8:  ADDWF  64,W
14F9:  MOVWF  65
14FA:  MOVLW  20
14FB:  MOVWF  66
14FC:  BTFSC  03.0
14FD:  INCF   66,F
14FE:  MOVF   64,W
14FF:  MOVLP  00
1500:  MOVLB  00
1501:  CALL   03F
1502:  MOVLP  10
1503:  MOVLB  01
1504:  MOVWF  67
1505:  MOVLB  02
1506:  MOVWF  3E
1507:  MOVLW  01
1508:  MOVWF  3F
1509:  CLRF   41
150A:  MOVLW  80
150B:  MOVWF  40
150C:  MOVLP  08
150D:  MOVLB  00
150E:  CALL   0F3
150F:  MOVLP  10
1510:  MOVLB  01
1511:  MOVF   67,W
1512:  MOVWF  68
1513:  CLRF   6A
1514:  CLRF   69
1515:  MOVLP  08
1516:  MOVLB  00
1517:  GOTO   7D5
1518:  MOVLP  10
1519:  BTFSC  78.0
151A:  GOTO   52B
151B:  MOVLW  1C
151C:  MOVLB  01
151D:  ADDWF  64,W
151E:  MOVWF  04
151F:  MOVLW  20
1520:  MOVWF  05
1521:  BTFSC  03.0
1522:  INCF   05,F
1523:  MOVF   00,F
1524:  BTFSC  03.2
1525:  GOTO   528
1526:  MOVLB  00
1527:  GOTO   52B
1528:  MOVLW  00
1529:  GOTO   52D
152A:  MOVLB  00
152B:  MOVLW  01
152C:  MOVLB  01
152D:  MOVWF  68
152E:  MOVF   66,W
152F:  MOVWF  05
1530:  MOVF   65,W
1531:  MOVWF  04
1532:  MOVF   68,W
1533:  MOVWF  00
....................   } 
1534:  INCF   64,F
1535:  GOTO   4F3
.................... } // }}} 
1536:  MOVLP  18
1537:  MOVLB  00
1538:  GOTO   6EF (RETURN)
.................... void update_aux_out(void) { // {{{ 
....................   char x; 
....................   char AuxOp; 
....................   char AuxArg; 
....................   char AuxIn_s[4]={'0','0','0',0}; 
*
1C2B:  MOVLW  30
1C2C:  MOVLB  01
1C2D:  MOVWF  67
1C2E:  MOVWF  68
1C2F:  MOVWF  69
1C30:  CLRF   6A
....................   char AuxOut_s[4]={'0','0','0',0}; 
1C31:  MOVWF  6B
1C32:  MOVWF  6C
1C33:  MOVWF  6D
1C34:  CLRF   6E
....................   char ADM[]=" ADMIN"; 
1C35:  MOVLW  20
1C36:  MOVWF  6F
1C37:  MOVLW  41
1C38:  MOVLB  02
1C39:  MOVWF  20
1C3A:  MOVLW  44
1C3B:  MOVWF  21
1C3C:  MOVLW  4D
1C3D:  MOVWF  22
1C3E:  MOVLW  49
1C3F:  MOVWF  23
1C40:  MOVLW  4E
1C41:  MOVWF  24
1C42:  CLRF   25
....................   int1 out_bit; 
....................  
....................   for(x=0;x<3;x++) { 
1C43:  MOVLB  01
1C44:  CLRF   64
1C45:  MOVF   64,W
1C46:  SUBLW  02
1C47:  BTFSS  03.0
1C48:  GOTO   53C
....................     AuxOp = AuxOutOp[x]; 
1C49:  MOVLW  33
1C4A:  ADDWF  64,W
1C4B:  MOVWF  04
1C4C:  MOVLW  20
1C4D:  MOVWF  05
1C4E:  BTFSC  03.0
1C4F:  INCF   05,F
1C50:  MOVF   00,W
1C51:  MOVWF  65
....................     AuxArg = AuxOutArg[x]; 
1C52:  MOVLW  36
1C53:  ADDWF  64,W
1C54:  MOVWF  04
1C55:  MOVLW  20
1C56:  MOVWF  05
1C57:  BTFSC  03.0
1C58:  INCF   05,F
1C59:  MOVF   00,W
1C5A:  MOVWF  66
....................     ExecAuxOutOp(AuxOp,AuxArg,x); // This updates AuxOut global reg. 
1C5B:  MOVF   65,W
1C5C:  MOVLB  02
1C5D:  MOVWF  27
1C5E:  MOVLB  01
1C5F:  MOVF   66,W
1C60:  MOVLB  02
1C61:  MOVWF  28
1C62:  MOVLB  01
1C63:  MOVF   64,W
1C64:  MOVLB  02
1C65:  MOVWF  29
....................     out_bit = (AuxOut[x])==0; 
*
1CC6:  MOVLB  02
1CC7:  BCF    26.0
1CC8:  MOVLW  22
1CC9:  MOVLB  01
1CCA:  ADDWF  64,W
1CCB:  MOVWF  04
1CCC:  MOVLW  20
1CCD:  MOVWF  05
1CCE:  BTFSC  03.0
1CCF:  INCF   05,F
1CD0:  MOVF   00,F
1CD1:  BTFSS  03.2
1CD2:  GOTO   4D6
1CD3:  MOVLB  02
1CD4:  BSF    26.0
1CD5:  MOVLB  01
....................     output_bit(AUX_OUT_PIN[x],out_bit); 
1CD6:  MOVF   64,W
1CD7:  MOVLP  00
1CD8:  MOVLB  00
1CD9:  CALL   03B
1CDA:  MOVLP  18
1CDB:  MOVLB  02
1CDC:  MOVWF  27
1CDD:  MOVLW  00
1CDE:  BTFSC  26.0
1CDF:  MOVLW  01
1CE0:  MOVWF  77
1CE1:  MOVF   27,W
1CE2:  MOVWF  3E
1CE3:  MOVF   77,W
1CE4:  MOVWF  3F
1CE5:  MOVLW  01
1CE6:  MOVWF  41
1CE7:  CLRF   40
1CE8:  MOVLP  08
1CE9:  MOVLB  00
1CEA:  CALL   0F3
1CEB:  MOVLP  18
1CEC:  MOVLB  02
1CED:  MOVF   27,W
1CEE:  MOVWF  3E
1CEF:  CLRF   3F
1CF0:  CLRF   41
1CF1:  MOVLW  80
1CF2:  MOVWF  40
1CF3:  MOVLP  08
1CF4:  MOVLB  00
1CF5:  CALL   0F3
1CF6:  MOVLP  18
....................     if(out_bit==0) { 
1CF7:  MOVLB  02
1CF8:  BTFSC  26.0
1CF9:  GOTO   505
....................       AuxOut_s[x]='1'; 
1CFA:  MOVLW  9B
1CFB:  MOVLB  01
1CFC:  ADDWF  64,W
1CFD:  MOVWF  04
1CFE:  MOVLW  20
1CFF:  MOVWF  05
1D00:  BTFSC  03.0
1D01:  INCF   05,F
1D02:  MOVLW  31
1D03:  MOVWF  00
1D04:  MOVLB  02
....................     } 
....................     // Execute aux inputs {{{ 
....................     AuxOp = AuxInOp[x]; 
1D05:  MOVLW  39
1D06:  MOVLB  01
1D07:  ADDWF  64,W
1D08:  MOVWF  04
1D09:  MOVLW  20
1D0A:  MOVWF  05
1D0B:  BTFSC  03.0
1D0C:  INCF   05,F
1D0D:  MOVF   00,W
1D0E:  MOVWF  65
....................     AuxArg = AuxInArg[x]; 
1D0F:  MOVLW  3C
1D10:  ADDWF  64,W
1D11:  MOVWF  04
1D12:  MOVLW  20
1D13:  MOVWF  05
1D14:  BTFSC  03.0
1D15:  INCF   05,F
1D16:  MOVF   00,W
1D17:  MOVWF  66
....................     if(AuxInSW[x]==1) { 
1D18:  MOVLW  1F
1D19:  ADDWF  64,W
1D1A:  MOVWF  04
1D1B:  MOVLW  20
1D1C:  MOVWF  05
1D1D:  BTFSC  03.0
1D1E:  INCF   05,F
1D1F:  DECFSZ 00,W
1D20:  GOTO   52A
....................       AuxIn_s[x]='1'; 
1D21:  MOVLW  97
1D22:  ADDWF  64,W
1D23:  MOVWF  04
1D24:  MOVLW  20
1D25:  MOVWF  05
1D26:  BTFSC  03.0
1D27:  INCF   05,F
1D28:  MOVLW  31
1D29:  MOVWF  00
....................     } 
....................     ExecAuxInOp(AuxOp,AuxArg,x); 
1D2A:  MOVF   65,W
1D2B:  MOVLB  02
1D2C:  MOVWF  27
1D2D:  MOVLB  01
1D2E:  MOVF   66,W
1D2F:  MOVLB  02
1D30:  MOVWF  28
1D31:  MOVLB  01
1D32:  MOVF   64,W
1D33:  MOVLB  02
1D34:  MOVWF  29
1D35:  MOVLP  10
1D36:  MOVLB  00
1D37:  GOTO   653
1D38:  MOVLP  18
....................     // }}} 
....................   } 
1D39:  MOVLB  01
1D3A:  INCF   64,F
1D3B:  GOTO   445
....................   sprintf(LCD_str,"I:%s O:%s",AuxIn_s,AuxOut_s); 
1D3C:  MOVLW  20
1D3D:  MOVWF  63
1D3E:  MOVLW  76
1D3F:  MOVWF  62
1D40:  MOVLW  49
1D41:  MOVLB  02
1D42:  MOVWF  4E
1D43:  MOVLP  08
1D44:  MOVLB  00
1D45:  CALL   115
1D46:  MOVLP  18
1D47:  MOVLW  3A
1D48:  MOVLB  02
1D49:  MOVWF  4E
1D4A:  MOVLP  08
1D4B:  MOVLB  00
1D4C:  CALL   115
1D4D:  MOVLP  18
1D4E:  MOVLW  20
1D4F:  MOVWF  05
1D50:  MOVLW  97
1D51:  MOVWF  04
1D52:  MOVLP  08
1D53:  CALL   177
1D54:  MOVLP  18
1D55:  MOVLW  20
1D56:  MOVLB  02
1D57:  MOVWF  4E
1D58:  MOVLP  08
1D59:  MOVLB  00
1D5A:  CALL   115
1D5B:  MOVLP  18
1D5C:  MOVLW  4F
1D5D:  MOVLB  02
1D5E:  MOVWF  4E
1D5F:  MOVLP  08
1D60:  MOVLB  00
1D61:  CALL   115
1D62:  MOVLP  18
1D63:  MOVLW  3A
1D64:  MOVLB  02
1D65:  MOVWF  4E
1D66:  MOVLP  08
1D67:  MOVLB  00
1D68:  CALL   115
1D69:  MOVLP  18
1D6A:  MOVLW  20
1D6B:  MOVWF  05
1D6C:  MOVLW  9B
1D6D:  MOVWF  04
1D6E:  MOVLP  08
1D6F:  CALL   177
1D70:  MOVLP  18
....................   if ( AdminMode ) { 
1D71:  MOVLB  01
1D72:  BTFSS  61.5
1D73:  GOTO   582
....................     strcat(LCD_str,ADM); 
1D74:  MOVLW  20
1D75:  MOVLB  02
1D76:  MOVWF  28
1D77:  MOVLW  76
1D78:  MOVWF  27
1D79:  MOVLW  20
1D7A:  MOVWF  2A
1D7B:  MOVLW  9F
1D7C:  MOVWF  29
1D7D:  MOVLP  10
1D7E:  MOVLB  00
1D7F:  CALL   6C5
1D80:  MOVLP  18
1D81:  MOVLB  01
....................   } 
....................   lcd_send(3,LCD_str); 
1D82:  MOVLW  03
1D83:  MOVLB  02
1D84:  MOVWF  48
1D85:  MOVLW  20
1D86:  MOVWF  4A
1D87:  MOVLW  76
1D88:  MOVWF  49
1D89:  MOVLP  08
1D8A:  MOVLB  00
1D8B:  CALL   18C
1D8C:  MOVLP  18
.................... } // }}} 
1D8D:  MOVLP  18
1D8E:  GOTO   701 (RETURN)
.................... void send_morse_id (void) { // {{{ 
....................   int x; 
....................   int mchar; 
....................   // Send morse as if it was received from COR(1) -- Link radio 
....................   update_ptt(1);  
*
1000:  MOVLW  01
1001:  MOVLB  02
1002:  MOVWF  2C
1003:  MOVLP  08
1004:  MOVLB  00
1005:  CALL   360
1006:  MOVLP  10
....................   delay_ms(1000); 
1007:  MOVLW  04
1008:  MOVLB  02
1009:  MOVWF  2C
100A:  MOVLW  FA
100B:  MOVWF  48
100C:  MOVLP  08
100D:  MOVLB  00
100E:  CALL   000
100F:  MOVLP  10
1010:  MOVLB  02
1011:  DECFSZ 2C,F
1012:  GOTO   00A
....................   for(x=0;x<6;x++) { 
1013:  CLRF   2A
1014:  MOVF   2A,W
1015:  SUBLW  05
1016:  BTFSS  03.0
1017:  GOTO   034
....................     mchar=Morse[x]; 
1018:  MOVLW  2D
1019:  ADDWF  2A,W
101A:  MOVWF  04
101B:  MOVLW  20
101C:  MOVWF  05
101D:  BTFSC  03.0
101E:  INCF   05,F
101F:  MOVF   00,W
1020:  MOVWF  2B
....................     morse(mchar); 
1021:  MOVF   2B,W
1022:  MOVWF  3D
1023:  MOVLP  08
1024:  MOVLB  00
1025:  CALL   09C
1026:  MOVLP  10
....................     // Delay 3 "dits" between letters 
....................     aux_timer= 3 * MorseLen[(MorseDitLength&0x03)]; 
1027:  MOVLB  01
1028:  CLRF   33
1029:  MOVLW  06
102A:  MOVWF  32
....................     while(aux_timer) { 
102B:  MOVF   32,W
102C:  IORWF  33,W
102D:  BTFSC  03.2
102E:  GOTO   031
....................       delay_cycles(1); 
102F:  NOP
....................     } 
1030:  GOTO   02B
....................   } 
1031:  MOVLB  02
1032:  INCF   2A,F
1033:  GOTO   014
....................   delay_ms(1000); 
1034:  MOVLW  04
1035:  MOVWF  2C
1036:  MOVLW  FA
1037:  MOVWF  48
1038:  MOVLP  08
1039:  MOVLB  00
103A:  CALL   000
103B:  MOVLP  10
103C:  MOVLB  02
103D:  DECFSZ 2C,F
103E:  GOTO   036
....................   COR_FLAG=1; 
103F:  BSF    74.1
.................... } // }}} 
1040:  MOVLB  00
1041:  RETURN
.................... void main (void) { // {{{ 
*
1EAE:  CLRF   05
1EAF:  CLRF   04
1EB0:  MOVLW  1F
1EB1:  ANDWF  03,F
1EB2:  MOVLW  72
1EB3:  MOVLB  01
1EB4:  MOVWF  19
1EB5:  BSF    0E.3
1EB6:  BSF    0E.4
1EB7:  MOVLB  04
1EB8:  BCF    17.0
1EB9:  BCF    17.1
1EBA:  BCF    17.3
1EBB:  MOVLW  13
1EBC:  MOVWF  12
1EBD:  MOVLW  28
1EBE:  MOVWF  15
1EBF:  BSF    14.7
1EC0:  BCF    14.6
1EC1:  MOVLW  0C
1EC2:  MOVLB  03
1EC3:  MOVWF  1B
1EC4:  MOVLW  A2
1EC5:  MOVWF  1E
1EC6:  MOVLW  90
1EC7:  MOVWF  1D
1EC8:  MOVLB  01
1EC9:  BSF    61.7
1ECA:  CLRF   63
1ECB:  CLRF   62
1ECC:  MOVLB  0F
1ECD:  CLRF   11
1ECE:  CLRF   12
1ECF:  CLRF   18
1ED0:  CLRF   19
1ED1:  CLRF   1A
1ED2:  MOVLB  03
1ED3:  CLRF   0C
1ED4:  CLRF   0D
1ED5:  CLRF   0F
1ED6:  CLRF   10
1ED7:  MOVLB  02
1ED8:  CLRF   12
1ED9:  CLRF   11
1EDA:  CLRF   14
1EDB:  CLRF   13
....................   initialize(); 
*
1EDF:  MOVLP  08
1EE0:  GOTO   4C0
1EE1:  MOVLP  18
.................... #ignore_warnings 203 
....................   while(1) { // {{{ 
.................... #ignore_warnings none 
....................     restart_wdt(); 
1EE2:  CLRWDT
....................     // Process RS232 Serial Buffer Flag {{{ 
....................     // The sBufferFlag is set when a "\r" or "+" or "-" is received. 
....................     if ( sBufferFlag ) { 
1EE3:  BTFSS  74.0
1EE4:  GOTO   6EA
....................       process_sBuffer(); 
1EE5:  GOTO   000
....................       clear_sBuffer(); 
1EE6:  MOVLP  00
1EE7:  CALL   4BD
1EE8:  MOVLP  18
....................       sBufferFlag=0; 
1EE9:  BCF    74.0
....................     } 
....................     // Process RS232 Serial Buffer Flag }}}  
....................   restart_wdt(); 
1EEA:  CLRWDT
....................     if ( AUX_IN_FLAG ) { 
1EEB:  BTFSS  74.6
1EEC:  GOTO   6F2
....................       update_aux_in(); 
1EED:  MOVLP  10
1EEE:  GOTO   4F1
1EEF:  MOVLP  18
....................       AUX_IN_FLAG=0; 
1EF0:  BCF    74.6
....................       AUX_OUT_FLAG=1; 
1EF1:  BSF    74.7
....................     } 
....................     do_delay_counters(); 
1EF2:  MOVLP  10
1EF3:  GOTO   539
1EF4:  MOVLP  18
....................     restart_wdt(); 
1EF5:  CLRWDT
....................     if ( COR_FLAG ) { 
1EF6:  BTFSS  74.1
1EF7:  GOTO   6FE
....................       process_cor(); 
1EF8:  MOVLP  10
1EF9:  GOTO   5C3
1EFA:  MOVLP  18
....................       // Call update_aux_out to instantly update AuxOut  
....................       // values when one of them is following a COR. 
....................       AUX_OUT_FLAG=1; 
1EFB:  BSF    74.7
....................       COR_FLAG=0; 
1EFC:  BCF    74.1
....................       restart_wdt(); 
1EFD:  CLRWDT
....................     } 
....................     if ( AUX_OUT_FLAG ) { 
1EFE:  BTFSS  74.7
1EFF:  GOTO   702
....................       update_aux_out();  
1F00:  GOTO   42B
....................       AUX_OUT_FLAG=0; 
1F01:  BCF    74.7
....................     } 
....................     if ( DTMF_INTERRUPT_FLAG ) { 
1F02:  MOVLB  01
1F03:  BTFSS  61.2
1F04:  GOTO   70B
....................       // Extract data from DTMF device 
....................       process_dtmf_interrupt(); 
1F05:  MOVLP  10
1F06:  MOVLB  00
1F07:  GOTO   6FE
1F08:  MOVLP  18
....................       DTMF_INTERRUPT_FLAG=0; 
1F09:  MOVLB  01
1F0A:  BCF    61.2
....................     } 
....................     if ( DTMF_IN_FLAG ) { 
1F0B:  BTFSS  61.1
1F0C:  GOTO   714
....................       print_dtmf_info(); 
1F0D:  MOVLP  10
1F0E:  MOVLB  00
1F0F:  GOTO   750
1F10:  MOVLP  18
....................       DTMF_IN_FLAG=0; 
1F11:  MOVLB  01
1F12:  BCF    61.1
....................       restart_wdt(); 
1F13:  CLRWDT
....................     } 
....................     if ( DTMF_FLAG ) { 
1F14:  BTFSS  61.0
1F15:  GOTO   71B
....................       process_dtmf(); 
1F16:  MOVLB  00
1F17:  GOTO   5C0
....................       DTMF_FLAG=0; 
1F18:  MOVLB  01
1F19:  BCF    61.0
....................     restart_wdt(); 
1F1A:  CLRWDT
....................     } 
....................     if ( CLEAR_DTMF_FLAG ) { 
1F1B:  BTFSS  61.3
1F1C:  GOTO   723
....................       clear_dtmf_array(); 
1F1D:  MOVLP  10
1F1E:  MOVLB  00
1F1F:  GOTO   7DF
1F20:  MOVLP  18
....................       CLEAR_DTMF_FLAG=0; 
1F21:  MOVLB  01
1F22:  BCF    61.3
....................     } 
....................     if ( PROMPT_FLAG ) { 
1F23:  BTFSS  61.4
1F24:  GOTO   72C
....................       prompt(); 
1F25:  MOVLP  08
1F26:  MOVLB  00
1F27:  CALL   7BD
1F28:  MOVLP  18
....................       PROMPT_FLAG=0; 
1F29:  MOVLB  01
1F2A:  BCF    61.4
....................     restart_wdt(); 
1F2B:  CLRWDT
....................     } 
....................   } // End of while(1) main loop }}} 
1F2C:  MOVLB  00
1F2D:  GOTO   6E2
.................... } // }}} 
.................... // send_tail {{{ 
.................... void send_tail(void) { 
....................   restart_wdt(); 
*
0B8F:  CLRWDT
*
1F2E:  SLEEP
....................   delay_ms(1000); 
*
0B90:  MOVLW  04
0B91:  MOVLB  02
0B92:  MOVWF  3D
0B93:  MOVLW  FA
0B94:  MOVWF  48
0B95:  MOVLB  00
0B96:  CALL   000
0B97:  MOVLB  02
0B98:  DECFSZ 3D,F
0B99:  GOTO   393
....................   if ( ConfirmChar!=0 ) { 
0B9A:  MOVLB  00
0B9B:  MOVF   6D,F
0B9C:  BTFSC  03.2
0B9D:  GOTO   3B0
....................     morse(ConfirmChar); 
0B9E:  MOVF   6D,W
0B9F:  MOVLB  02
0BA0:  MOVWF  3D
0BA1:  MOVLB  00
0BA2:  CALL   09C
....................     ConfirmChar=0; 
0BA3:  CLRF   6D
....................     restart_wdt(); 
0BA4:  CLRWDT
....................     delay_ms(500); 
0BA5:  MOVLW  02
0BA6:  MOVLB  02
0BA7:  MOVWF  3D
0BA8:  MOVLW  FA
0BA9:  MOVWF  48
0BAA:  MOVLB  00
0BAB:  CALL   000
0BAC:  MOVLB  02
0BAD:  DECFSZ 3D,F
0BAE:  GOTO   3A8
0BAF:  MOVLB  00
....................   } 
....................   if (TailChar != 0) { 
0BB0:  MOVF   6C,F
0BB1:  BTFSC  03.2
0BB2:  GOTO   3C5
....................     morse(TailChar); 
0BB3:  MOVF   6C,W
0BB4:  MOVLB  02
0BB5:  MOVWF  3D
0BB6:  MOVLB  00
0BB7:  CALL   09C
....................     TailChar=0; 
0BB8:  CLRF   6C
....................     restart_wdt(); 
0BB9:  CLRWDT
....................     delay_ms(500); 
0BBA:  MOVLW  02
0BBB:  MOVLB  02
0BBC:  MOVWF  3D
0BBD:  MOVLW  FA
0BBE:  MOVWF  48
0BBF:  MOVLB  00
0BC0:  CALL   000
0BC1:  MOVLB  02
0BC2:  DECFSZ 3D,F
0BC3:  GOTO   3BD
0BC4:  MOVLB  00
....................   } 
....................   restart_wdt(); 
0BC5:  CLRWDT
0BC6:  MOVLB  02
.................... } 
.................... // send_tail }}} 
.................... int1 in_admin_mode(void) { // {{{ 
....................   // Refresh timer 
....................   if (AdminMode) { 
*
0F2A:  MOVLB  01
0F2B:  BTFSS  61.5
0F2C:  GOTO   72F
....................     admin_timer = ADMIN_TIMEOUT; 
0F2D:  MOVLW  FF
0F2E:  MOVWF  75
....................   } 
....................   return(AdminMode||rs232_mode); 
0F2F:  BTFSC  61.5
0F30:  GOTO   735
0F31:  BTFSC  61.6
0F32:  GOTO   735
0F33:  MOVLW  00
0F34:  GOTO   736
0F35:  MOVLW  01
0F36:  MOVWF  78
.................... } // }}} 
0F37:  MOVLB  00
0F38:  RETURN
.................... void set_admin_mode(int1 enable) { // {{{ 
....................   AdminMode = (enable!=0); 
*
0CA9:  MOVLB  01
0CAA:  BCF    61.5
0CAB:  MOVLB  02
0CAC:  MOVF   3E,F
0CAD:  BTFSC  03.2
0CAE:  GOTO   4B2
0CAF:  MOVLB  01
0CB0:  BSF    61.5
0CB1:  MOVLB  02
....................   if (AdminMode) { 
0CB2:  MOVLB  01
0CB3:  BTFSS  61.5
0CB4:  GOTO   4BC
....................     // Enter Admin mode 
....................     ConfirmChar = MCHAR('a'); 
0CB5:  MOVLW  0A
0CB6:  MOVLB  00
0CB7:  MOVWF  6D
....................     admin_timer = ADMIN_TIMEOUT; 
0CB8:  MOVLW  FF
0CB9:  MOVWF  75
....................   } else { 
0CBA:  GOTO   4BF
0CBB:  MOVLB  01
....................     // Exit / out of admin mode 
....................     ConfirmChar = MCHAR('o'); 
0CBC:  MOVLW  18
0CBD:  MOVLB  00
0CBE:  MOVWF  6D
....................   }  
.................... } // }}} 
0CBF:  RETURN
.................... // string matchnig function with case insensitive match. 
.................... int1 my_stricmp(char *s1,char *s2) { // {{{ 
*
0EC2:  MOVLB  02
0EC3:  CLRF   41
....................   unsigned int x=0; 
....................   const char AMASK=0xDF; 
....................   while((AMASK&s1[x])==(AMASK&s2[x])) { 
0EC4:  MOVF   41,W
0EC5:  ADDWF  3D,W
0EC6:  MOVWF  04
0EC7:  MOVLW  00
0EC8:  ADDWFC 3E,W
0EC9:  MOVWF  05
0ECA:  MOVF   00,W
0ECB:  ANDLW  DF
0ECC:  MOVWF  42
0ECD:  MOVF   41,W
0ECE:  ADDWF  3F,W
0ECF:  MOVWF  04
0ED0:  MOVLW  00
0ED1:  ADDWFC 40,W
0ED2:  MOVWF  05
0ED3:  MOVF   00,W
0ED4:  ANDLW  DF
0ED5:  SUBWF  42,W
0ED6:  BTFSS  03.2
0ED7:  GOTO   6E6
....................     if(s1[x]==0) { 
0ED8:  MOVF   41,W
0ED9:  ADDWF  3D,W
0EDA:  MOVWF  04
0EDB:  MOVLW  00
0EDC:  ADDWFC 3E,W
0EDD:  MOVWF  05
0EDE:  MOVF   00,F
0EDF:  BTFSS  03.2
0EE0:  GOTO   6E4
....................       return 0; 
0EE1:  MOVLW  00
0EE2:  MOVWF  78
0EE3:  GOTO   6E8
....................     } 
....................     x++; 
0EE4:  INCF   41,F
....................   } 
0EE5:  GOTO   6C4
....................   // Strings don't match. Return 1. 
....................   return 1; 
0EE6:  MOVLW  01
0EE7:  MOVWF  78
.................... } // }}} 
0EE8:  MOVLB  00
0EE9:  RETURN
.................... // Fetches data from MC8888 device upon interrupt 
.................... void process_dtmf_interrupt(void) { // {{{ 
....................   int value,dtmf_status; 
....................   dtmf_status = dtmf_read(CONTROL_REG); 
*
16FE:  MOVLW  01
16FF:  MOVLB  02
1700:  MOVWF  39
1701:  MOVLP  00
1702:  MOVLB  00
1703:  CALL   69A
1704:  MOVLP  10
1705:  MOVF   78,W
1706:  MOVLB  01
1707:  MOVWF  65
....................   if ( dtmf_status & DTMF_BUFFER_FULL) { 
1708:  BTFSS  65.2
1709:  GOTO   74D
....................     value=dtmf_read(DATA_REG); 
170A:  MOVLB  02
170B:  CLRF   39
170C:  MOVLP  00
170D:  MOVLB  00
170E:  CALL   69A
170F:  MOVLP  10
1710:  MOVF   78,W
1711:  MOVLB  01
1712:  MOVWF  64
....................     DTMF_IN_FLAG=1; 
1713:  BSF    61.1
....................     if ( value == dd ) { 
1714:  MOVF   64,F
1715:  BTFSS  03.2
1716:  GOTO   71A
....................       value=d0; 
1717:  MOVLW  0A
1718:  MOVWF  64
....................     } else if ( value == d0 ) { 
1719:  GOTO   71E
171A:  MOVF   64,W
171B:  SUBLW  0A
171C:  BTFSC  03.2
....................       value=dd; 
171D:  CLRF   64
....................     } 
....................     if ( value == ds ) { 
171E:  MOVF   64,W
171F:  SUBLW  0B
1720:  BTFSC  03.2
....................       CLEAR_DTMF_FLAG=1; 
1721:  BSF    61.3
....................     } 
....................     // Check for '#' 
....................     if ( value == dp ) { 
1722:  MOVF   64,W
1723:  SUBLW  0C
1724:  BTFSS  03.2
1725:  GOTO   72E
....................       DTMF_FLAG = 1; 
1726:  BSF    61.0
....................       DTMF_ptr->Last=1; 
1727:  MOVF   3E,W
1728:  MOVWF  04
1729:  MOVF   3F,W
172A:  MOVWF  05
172B:  ADDFSR 00,FSR0
172C:  BSF    00.5
....................     } else { 
172D:  GOTO   74D
....................       if ( DTMF_ptr <= &DTMF_ARRAY[DTMF_ARRAY_SIZE-1] ) { 
172E:  MOVF   3F,W
172F:  SUBLW  20
1730:  BTFSS  03.0
1731:  GOTO   74D
1732:  BTFSS  03.2
1733:  GOTO   738
1734:  MOVF   3E,W
1735:  SUBLW  6D
1736:  BTFSS  03.0
1737:  GOTO   74D
....................         DTMF_ptr->Key=value; 
1738:  MOVF   3E,W
1739:  MOVWF  04
173A:  MOVF   3F,W
173B:  MOVWF  05
173C:  ADDFSR 00,FSR0
173D:  MOVF   64,W
173E:  ANDLW  0F
173F:  MOVWF  77
1740:  MOVLW  F0
1741:  ANDWF  00,W
1742:  IORWF  77,W
1743:  MOVWF  00
....................         DTMF_ptr->Strobe=1; 
1744:  MOVF   3E,W
1745:  MOVWF  04
1746:  MOVF   3F,W
1747:  MOVWF  05
1748:  ADDFSR 00,FSR0
1749:  BSF    00.4
....................         DTMF_ptr++; 
174A:  INCF   3E,F
174B:  BTFSC  03.2
174C:  INCF   3F,F
....................       } 
....................     } 
....................   } 
.................... } // }}} 
174D:  MOVLP  18
174E:  MOVLB  00
174F:  GOTO   708 (RETURN)
.................... void init_lcd(void) { // {{{ 
.................... #define INIT 0x18 
.................... #define MODE_SET 0x1C 
.................... #define ENABLE 0x04 
....................   i2c_start(); 
....................   i2c_write(LCD_I2C_ADD<<1); 
....................   // Function set 
....................   // Initialize in 8-bit mode first for 3 clock cycles 
....................   lcd_strobe(0x30);lcd_strobe(0x30);lcd_strobe(0x30); 
....................   // Init 4-bit interface mode 
....................   lcd_strobe(0x20); 
....................   lcd_write(0,0x2C); 
....................   // Display On/Off, Cursor off 
....................   lcd_write(0,0x0C); 
....................   // Display clear 
....................   lcd_write(0,0x01); 
....................   // Entry mode set 
....................   lcd_write(0,0x04); 
....................   i2c_stop(); 
.................... } // }}} 
.................... void do_delay_counters(void) { 
....................   // Second Flag {{{ 
....................   if ( SECOND_FLAG ) { 
*
1539:  BTFSS  74.2
153A:  GOTO   58A
....................     AUX_OUT_FLAG=1; 
153B:  BSF    74.7
....................     // Time Out PTT {{{ 
....................     if ( TOT_SecondCounter || TOT_Min == 0) { 
153C:  MOVLB  01
153D:  MOVF   5F,W
153E:  IORWF  60,W
153F:  BTFSS  03.2
1540:  GOTO   546
1541:  MOVLB  00
1542:  MOVF   66,F
1543:  BTFSS  03.2
1544:  GOTO   562
1545:  MOVLB  01
....................       TOT_SecondCounter--; 
1546:  MOVF   5F,W
1547:  BTFSC  03.2
1548:  DECF   60,F
1549:  DECF   5F,F
....................       if ( TOT_Min && !TOT_SecondCounter ) { 
154A:  MOVLB  00
154B:  MOVF   66,F
154C:  BTFSC  03.2
154D:  GOTO   561
154E:  MOVLB  01
154F:  MOVF   5F,W
1550:  IORWF  60,W
1551:  BTFSC  03.2
1552:  GOTO   555
1553:  MOVLB  00
1554:  GOTO   561
....................         printf("\n\r# PTT Timeout!\n"); 
1555:  MOVLW  AA
1556:  MOVLB  03
1557:  MOVWF  11
1558:  MOVLW  04
1559:  MOVWF  12
155A:  MOVLP  00
155B:  MOVLB  00
155C:  CALL   4D7
155D:  MOVLP  10
....................         PROMPT_FLAG=1; 
155E:  MOVLB  01
155F:  BSF    61.4
1560:  MOVLB  00
....................       } 
....................     } else if ( COR_IN_EFFECTIVE != 0x00 ) { 
1561:  GOTO   56D
1562:  MOVF   72,F
1563:  BTFSC  03.2
1564:  GOTO   56D
....................       TOT_FLAG_Mask=COR_IN_EFFECTIVE; 
1565:  MOVF   72,W
1566:  MOVWF  67
....................       update_ptt(0); 
1567:  MOVLB  02
1568:  CLRF   2C
1569:  MOVLP  08
156A:  MOVLB  00
156B:  CALL   360
156C:  MOVLP  10
....................     } 
....................     // }}} 
....................     // AuxOutDelayCnt {{{ 
....................     if ( AuxOutDelayCnt ) { 
156D:  MOVF   7C,F
156E:  BTFSS  03.2
....................       AuxOutDelayCnt--; 
156F:  DECF   7C,F
....................     } 
....................     // }}} 
....................     // Admin mode timeout {{{ 
....................     if ( admin_timer ) { 
1570:  MOVF   75,F
1571:  BTFSC  03.2
1572:  GOTO   575
....................       admin_timer--; 
1573:  DECF   75,F
....................     } else { 
1574:  GOTO   57E
....................       // Exit admin mode. 
....................       if ( AdminMode ) { 
1575:  MOVLB  01
1576:  BTFSS  61.5
1577:  GOTO   57F
....................         set_admin_mode(0); 
1578:  MOVLB  02
1579:  CLRF   3E
157A:  MOVLP  08
157B:  MOVLB  00
157C:  CALL   4A9
157D:  MOVLP  10
157E:  MOVLB  01
....................       } 
....................     } 
....................     // }}} 
....................     restart_wdt(); 
157F:  CLRWDT
....................     if ( SecondCounter ) { 
1580:  MOVF   5D,F
1581:  BTFSC  03.2
1582:  GOTO   585
....................       SecondCounter--; 
1583:  DECF   5D,F
....................     } else { 
1584:  GOTO   588
....................       SecondCounter=SEC_COUNTER; 
1585:  MOVLW  3B
1586:  MOVWF  5D
....................       MINUTE_FLAG = 1; 
1587:  BSF    74.3
....................     } 
....................     SECOND_FLAG=0; 
1588:  BCF    74.2
1589:  MOVLB  00
....................   } 
....................   // Second Flag }}} 
....................   // Minute flag {{{ 
....................   if ( MINUTE_FLAG ) { 
158A:  BTFSS  74.3
158B:  GOTO   5A9
....................     if ( MinuteCounter ) { 
158C:  MOVLB  01
158D:  MOVF   5E,F
158E:  BTFSC  03.2
158F:  GOTO   592
....................       MinuteCounter--; 
1590:  DECF   5E,F
....................     } else { 
1591:  GOTO   595
....................       THIRTY_MIN_FLAG=1; 
1592:  BSF    74.4
....................       MinuteCounter = MIN_COUNTER; 
1593:  MOVLW  1D
1594:  MOVWF  5E
....................     } 
....................     MINUTE_FLAG = 0; 
1595:  BCF    74.3
....................     // Link timeout timer {{{ 
....................     if ( Link_TOT != 0 ) { 
1596:  MOVLB  00
1597:  MOVF   68,F
1598:  BTFSC  03.2
1599:  GOTO   5A9
....................       if ( LinkDurationTimer ) { 
159A:  MOVF   69,F
159B:  BTFSC  03.2
159C:  GOTO   59F
....................         LinkDurationTimer--; 
159D:  DECF   69,F
....................       } else { 
159E:  GOTO   5A9
....................         // Disable Link 
....................         printf("\n\r# Link Timeout!\n"); 
159F:  MOVLW  B3
15A0:  MOVLB  03
15A1:  MOVWF  11
15A2:  MOVLW  04
15A3:  MOVWF  12
15A4:  MOVLP  00
15A5:  MOVLB  00
15A6:  CALL   4D7
15A7:  MOVLP  10
....................         Enable&=0xFE; 
15A8:  BCF    60.0
....................       } 
....................     } 
....................     // Link timeout timer }}} 
....................   } 
....................   // Minute flag }}} 
....................   if ( THIRTY_MIN_FLAG ) { // {{{ 
15A9:  BTFSS  74.4
15AA:  GOTO   5C1
....................     if ( (TXSiteID&0x03) !=0 ) { 
15AB:  MOVF   64,W
15AC:  ANDLW  03
15AD:  BTFSC  03.2
15AE:  GOTO   5C0
....................       // Transmit Site ID every 30 mins when: 
....................       // TXSiteID = <EnableMask[3:0]>,{x,x,M,E} 
....................       // E = Transmit every 30 mins 
....................       // M = Transmit only if EnableMask is off 
....................       if ( (TXSiteID & 0x01)!=0 || ((TXSiteID & 0x02)!=0 && (((TXSiteID >> 4) & 0x0F) & Enable)==0) ) { 
15AF:  MOVF   64,W
15B0:  ANDLW  01
15B1:  BTFSS  03.2
15B2:  GOTO   5BF
15B3:  MOVF   64,W
15B4:  ANDLW  02
15B5:  BTFSC  03.2
15B6:  GOTO   5C0
15B7:  SWAPF  64,W
15B8:  MOVWF  77
15B9:  MOVLW  0F
15BA:  ANDWF  77,F
15BB:  MOVF   77,W
15BC:  ANDLW  0F
15BD:  ANDWF  60,W
15BE:  BTFSC  03.2
....................         send_morse_id(); 
15BF:  CALL   000
....................       } 
....................     } 
....................     THIRTY_MIN_FLAG=0; 
15C0:  BCF    74.4
....................   } // }}} 
.................... } 
15C1:  MOVLP  18
15C2:  GOTO   6F4 (RETURN)
....................  

Configuration Fuses:
   Word  1: 0FBC   INTRC_IO WDT NOPUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT NOIESO NOFCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP

ROM data:
001FDB: 34AA 346A 345A 3456 3455 3455 3495 34A5 
001FE3: 34A9 34AA 3460 3495 3499 3494 3440 3459 
001FEB: 34A4 3455 3450 346A 3498 3465 34A0 3490 
001FF3: 34A8 3469 34A6 3464 3454 3480 3458 3456 
001FFB: 3468 3496 349A 34A5 3400 
